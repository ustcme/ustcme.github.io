{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sakura • All posts by \"hyperstreamline\" tag",
    "description": "一个专注于技术和思考分享的博客",
    "home_page_url": "https://sakurame.eu.org",
    "items": [
        {
            "id": "https://sakurame.eu.org/2023/08/17/basic-theory/Methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3D-seismic-images/",
            "url": "https://sakurame.eu.org/2023/08/17/basic-theory/Methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3D-seismic-images/",
            "title": "Methods_to_compute_fault_images_extract_fault_surfaces_and_estimate_fault_throws_from_3D_seismic_images",
            "date_published": "2023-08-17T15:28:18.000Z",
            "content_html": "<h1 id=\"methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3d-seismic-images\"><a class=\"anchor\" href=\"#methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3d-seismic-images\">#</a> Methods to compute fault images, extract fault surfaces, and estimate fault throws from 3D seismic images</h1>\n<p>从三维地震图像中计算断层图像、提取断层面和估算断层投影的方法</p>\n<h2 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> ABSTRACT</h2>\n<p>Fault interpretation enhances our understanding of complex geologic structures and stratigraphy apparent in 3D seismic images. Common steps in this interpretation include image processing to highlight faults, the construction of fault surfaces, and estimation of fault throws. Although all three of these steps have been automated to some extent by others, fault interpretation today typically requires significant manual effort, suggesting that further improvements in automatic methods are feasible and worthwhile. I first used an efficient algorithm to compute images of fault likelihoods, strikes, and dips from a 3D seismic image. From these three fault images, I then automatically extracted fault surfaces as meshes of quadrilaterals that coincide with ridges of fault likelihood. A quadrilateral mesh is a simple data structure alongside which one can easily gather samples of the 3D seismic image. I automatically estimated fault throws by minimizing differences in values of samples gathered from opposite sides of a fault, while constraining the variation of throw within a fault surface. I tested the fidelity of estimated fault throws by using them to undo faulting. After unfaulting, reflectors in 3D seismic images were more continuous than those in the original 3D seismic image. In one example, this unfaulting test supported the observation that some extracted fault surfaces have unusual conical shapes.</p>\n<p>断层解释可加深我们对三维地震图像中明显的复杂地质结构和地层的理解。这种解释的常见步骤包括图像处理以突出断层、构建断层面和估算断层投影。虽然这三个步骤都已在一定程度上实现了自动化，但如今的断层解释通常需要大量的人工操作，这表明进一步改进自动方法是可行的，也是值得的。我首先使用一种高效算法，从三维地震图像中计算出断层似然、走向和倾角图像。然后，我从这三幅断层图像中自动提取出断层面，作为与断层似然脊重合的四边形网格。四边形网格是一种简单的数据结构，可以轻松地收集三维地震图像的样本。我通过最小化从断层两侧采集的样本值之间的差异来自动估算断层投影，同时限制断层面内投影的变化。我利用估算出的断层抛掷度来消除断层，从而测试了断层抛掷度的准确性。解除断层后，三维地震图像中的反射体比原始三维地震图像中的反射体更加连续。在一个例子中，这种解断层测试证实了一些提取的断层面具有不寻常的圆锥形。</p>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> INTRODUCTION</h2>\n<p>Fault surfaces are an important aspect of subsurface geology that we can derive from seismic images. Fault displacements are important as well because they enable correlation across faults of subsurface properties.</p>\n<p>断层面是我们可以从地震图像中得出的地下地质的一个重要方面。断层位移也很重要，因为它可以跨断层关联地下属性。</p>\n<p>In the context of exploration geophysics, fault throw, relative displacement up or down along the dip of a fault, is usually more significant than displacement along the strike of a fault. Moreover, fault throw vectors are usually more perpendicular to geologic layers, and therefore easier to estimate, than are strike-slip displacements.</p>\n<p>在勘探地球物理方面，断层落差，即沿断层倾角向上或向下的相对位移，通常比沿断层走向的位移更为重要。此外，断层落差矢量通常更垂直于地质层，因此比走向滑动位移更容易估算。</p>\n<p>Figure 1 illustrates the definition of fault throw as a vector component of displacement that is perpendicular to the strike of a fault surface. The orientation of that surface is described by a fault strike angle $\\varphi $ and fault dip angle $\\theta $, where the latter is here measured from vertical. Typically, fault orientation and fault throw vary within a fault surface.</p>\n<p>图 1 说明了断层落差的定义，即垂直于断层面走向的位移矢量分量。断层面的走向由断层走向角 $\\varphi $ 和断层倾角 $\\theta $ 描述，其中断层倾角 $\\theta $ 是指从垂直方向测量的倾角。通常情况下，断层走向和断层倾角在一个断层面内各不相同。</p>\n<p>Figure 2 shows examples of curviplanar fault surfaces and corresponding fault throws computed automatically from a 3D seismic image using new methods proposed in this paper. Because fault throws are vectors, they are difficult to visualize in displays of numerous faults. Therefore, while estimating all three components of fault throw vectors, I display in color only the vertical components. Because the vertical axis of the seismic image is time (not depth), vertical components of fault throw are here measured in milliseconds. Note that fault throws are nonnegative, which indicates that the faults shown here are normal faults.</p>\n<p>图 2 显示了利用本文提出的新方法从三维地震图像中自动计算出的曲线断层面和相应的断层倾向的示例。由于断层落差是矢量，在显示众多断层时很难直观地显示出来。因此，在估算断层落差向量的所有三个分量时，我只用彩色显示垂直分量。由于地震图像的纵轴是时间（而不是深度），因此这里的断层落差垂直分量以毫秒为单位。请注意，断层落差是非负值，这表明此处显示的断层是正常断层。</p>\n<p>As Luo and Hale (2012) describe, we can use estimated fault throw vectors to undo faulting. Figure 3 displays in color vertical components of fault throws on slices of a 3D seismic image, before and after this unfaulting process. Although only vertical components of fault throw are displayed, the unfaulting process uses all three components of fault throw vectors. After unfaulting, seismic reflections are more continuous across faults, suggesting that estimated fault throws are generally consistent with true fault displacements.</p>\n<p>正如 Luo 和 Hale（2012 年）所述，我们可以利用估算的断层落差矢量来消除断层。图 3 用彩色图片显示了三维地震图像切片上断层落差垂直分量，以及该解除断层过程之前和之后的情况。虽然只显示了断层落差的垂直分量，但解错过程使用了断层落差向量的所有三个分量。解断层后，地震反射在断层上更加连续，这表明估算的断层落差量与真实的断层位移基本一致。</p>\n<p>Fault surfaces and fault throws like those displayed in Figures 2 and 3 may be computed by numerous automatic or semiautomatic methods used today in the interpretation of 3D seismic images. Therefore, before describing the new methods proposed in this paper, I briefly review methods developed by others.</p>\n<p>断层面和断层落差如图 2 和图 3 所示，可以通过当今在 3D 地震图像解释中使用的许多自动或半自动方法来计算。因此，在描述本文提出的新方法之前，我简要回顾了其他人开发的方法。</p>\n<p><img data-src=\"https://ptpimg.me/4x0rd4.jpg\" alt=\"\" /></p>\n<p>Figure 1. Fault throw is a vector representing one component of displacement of the hanging-wall side of a fault surface relative to the footwall side of the same surface. More generally, fault throw varies within a fault surface, which need not be planar; but fault throw remains everywhere perpendicular to fault strike. The other component, not shown here, corresponds to horizontal displacement in the strike direction.</p>\n<p>图 1. 断层落差是表示断层面上盘侧相对于同一面下盘侧位移的一个分量的矢量。更一般地，断层落差在断层面内变化，断层面不必是平面的；但断层位移仍然保持在垂直于断层走向的各处。此处未示出的另一分量对应于冲击方向上的水平位移。</p>\n<p><img data-src=\"https://ptpimg.me/2f466t.jpg\" alt=\"\" /></p>\n<p>Figure 2. Fault surfaces and fault throws (a) computed automatically from a 3D seismic image. The close-up view (b) of the fault in the white rectangle in (a) shows the quadrilateral mesh used to represent each of the fault surfaces. Each quadrilateral intersects exactly one edge of the 4 ms × 25 m × 25 m image-sampling grid.</p>\n<p>图 2. 根据三维地震图像自动计算出的断层面和断层落差（a）。（a）中白色矩形中断层的特写视图（B）显示了用于表示每个断层表面的四边形网格。每个四边形正好与 4 ms × 25 m × 25 m 图像采样网格的一条边相交。</p>\n<h3 id=\"fault-images\"><a class=\"anchor\" href=\"#fault-images\">#</a> Fault images</h3>\n<p>断层图像</p>\n<p>Several methods for highlighting faults, that is, for computing 3D images of faults from 3D seismic images, are commonly used today. Some compute a measure of the continuity of seismic reflections, such as semblance (Marfurt et al, 1998) or other forms of coherence (Marfurt et al, 1999). Others compute a measure of discontinuity, such as variance (Randen et al, 2001; Van Bemmel and Pepper, 2011), entropy (Cohen et al, 2006), or gradient magnitude (Aqrawi and Boe, 2011). All of these methods are based on the observation that faults may exist where continuity in seismic reflections is low or, equivalently, where discontinuity is high.</p>\n<p>目前常用的几种方法用于突出显示断层，即用于从 3D 地震图像计算断层的 3D 图像。一些计算地震反射连续性的度量，例如相似性（Marfurt 等人，1998）或其他形式的相干性（Marfurt 等人，1999）。其他人计算不连续性的度量，例如方差（Randen 等人，2001; 货车 Bemmel 和 Pepper，2011）、熵（Cohen 等人，2006）或梯度幅度（Aqrawi 和 Boe，2011）。<strong>所有这些方法都是基于这样的观察，即在地震反射连续性低的地方，或者等效地，在不连续性高的地方，可能存在断层。</strong></p>\n<p>However, in small regions within 3D seismic images, continuity may be low for reasons unrelated to faults. Stratigraphic features such as buried channels are well highlighted in seismic images by low continuity. Low continuity is also caused by incoherent noise that is stronger than weak seismic reflections. Even where a fault is present, seismic events may appear to be highly continuous where fault throws are approximately equal to the dominant period (or wavelength) of those events. Event continuity alone is insufficient to distinguish faults.</p>\n<p>然而，在 3D 地震图像内的小区域中，由于与断层无关的原因，连续性可能较低。地层特征，如埋藏河道，由于低连续性，在地震图像中被很好地突出。低连续性也是由强于弱地震反射的非相干噪声引起的。即使在存在断层的地方，地震事件也可能表现为高度连续的，其中断层断距近似等于那些事件的主周期（或波长）。事件连续性本身不足以区分断层。</p>\n<p>For these reasons, Gersztenkorn and Marfurt (1999) suggest that any measure of continuity or discontinuity should include some form of averaging within vertical windows that are longer when detecting faults than when detecting stratigraphic features. In effect, these averaging windows smooth together small regions of low continuity that are vertically aligned along faults with significant vertical extent. More recently, Aqrawi and Boe (2011) note that such vertical smoothing of image gradient magnitudes is desirable when highlighting faults.</p>\n<p>由于这些原因，Gersztenkorn 和 Marfurt（1999 年）建议，任何连续性或不连续性的测量方法都应包括某种形式的垂直窗口平均，在探测断层时，垂直窗口比探测地层特征时更长。实际上，这些平均窗口将沿断层垂直排列的连续性较低的小区域平滑地整合在一起，而断层的垂直范围很大。最近，Aqrawi 和 Boe（2011 年）指出，在突出断层时，最好对图像梯度大小进行这种垂直平滑处理。</p>\n<p>However, faults are seldom vertical. When averaging any seismic attribute used to highlight faults, we should alter the orientation of this averaging to coincide with the strikes and dips of the faults. Neff et al (2000) and Cohen et al (2006) do this in their computation of fault images, as they scan over a range of fault orientations for each sample in a 3D seismic image. The computational cost of such scans can be high when, for each 3D image sample point and for each possible fault orientation, one must process many samples (over 1300 in the example of Cohen et al, 2006) within some neighborhood of the sample point.</p>\n<p>然而，断层很少是垂直的。<strong>在对用于突出断层的任何地震属性进行平均时，我们应改变平均的方向，使其与断层的走向和倾角相吻合</strong>。Neff 等人（2000 年）和 Cohen 等人（2006 年）在计算断层图像时就是这样做的，他们对三维地震图像中的每个样本进行了一系列断层方向扫描。这种扫描的计算成本很高，因为对于每个三维图像样本点和每个可能的断层走向，都必须处理样本点附近的许多样本（以 Cohen 等人 2006 年的研究为例，处理了 1300 多个样本）。</p>\n<p>One way to reduce this cost is to perform a sequence of scans within 2D image slices. For example, Crawford and Medwedeff (1999) scan over a range of fault azimuths using samples within small neighborhoods of each sample in horizontal 2D slices of a 3D seismic image. Dorn et al (2012) describe a similar sequence of scans, first over fault azimuths in horizontal 2D image slices and then over fault dips, using for each 3D image sample the azimuth estimated in the first scan. A potential disadvantage of such methods is that fault azimuths may not be well resolved in single horizontal 2D slices of a 3D seismic image.</p>\n<p>降低成本的一种方法是在二维图像切片内执行一系列扫描。例如，Crawford 和 Medwedeff（1999 年）使用三维地震图像水平二维切片中每个样本的小邻域内的样本对一系列断层方位角进行扫描。Dorn 等人（2012 年）描述了类似的扫描序列，首先扫描水平二维图像切片中的断层方位角，然后扫描断层倾角，每个三维图像样本都使用第一次扫描中估计的方位角。这种方法的一个潜在缺点是，断层方位角可能无法在三维地震图像的单个水平二维切片中得到很好的分辨。</p>\n<h3 id=\"fault-surfaces\"><a class=\"anchor\" href=\"#fault-surfaces\">#</a> Fault surfaces</h3>\n<p>断层面</p>\n<p>To extract fault surfaces such as those shown in Figure 2 from 3D images of faults requires additional processing, which again has been performed in various ways.</p>\n<p>要从断层的三维图像中提取图 2 所示的断层面，还需要进行额外的处理，而处理的方式也多种多样。</p>\n<p>For example, Pedersen et al (2002, 2003) and Pedersen (2007, 2011) develop the method of ant tracking to merge together small regions of low continuity in 3D fault images into larger fault surfaces.</p>\n<p>例如，Pedersen 等人（2002 年、2003 年）和 Pedersen（2007 年、2011 年）开发了蚂蚁追踪方法，将三维断层图像中连续性较低的小区域合并成较大的断层面。</p>\n<p>Gibson et al (2005) propose a multistage method of constructing larger fault surfaces by merging smaller ones, beginning with small surfaces that correspond to “local discontinuities” in 3D seismic images. Other methods for growing large fault surfaces from small initial surfaces are also proposed by Admasu et al (2006), Kadlec et al (2008), and Kadlec (2011). In such methods, seismic interpreters can specify seed points from which to begin growing fault surfaces.</p>\n<p>Gibson 等人（2005 年）提出了一种通过合并较小断层面来构建较大断层面的多阶段方法，该方法从与三维地震图像中的 &quot;局部不连续性&quot; 相对应的小断层面开始。<strong>Admasu 等人（2006 年）、Kadlec 等人（2008 年）和 Kadlec（2011 年）也提出了其他从小型初始表面生成大型断层表面的方法。在这些方法中，地震解释人员可以指定种子点，从种子点开始生长断层面。</strong></p>\n<p>In a more general context, Schultz et al (2010) describe a direct method for extracting so-called crease surfaces from 3D images without seed points. In one example, they extract surfaces corresponding to ridges in a 3D image of fractional anisotropy, which is computed from 3D diffusion-tensor magnetic resonance images of the human brain. Their method of extracting surfaces works well for 3D images with ridges that are well defined and continuous.</p>\n<p><strong>Schultz 等人（2010 年）在更广泛的背景下描述了一种从三维图像中提取所谓折痕表面的直接方法，无需种子点。在一个例子中，他们提取了与分数各向异性三维图像中脊线相对应的表面，分数各向异性是通过人脑的三维扩散张量磁共振图像计算得出的。他们提取曲面的方法对于脊线清晰且连续的三维图像效果很好。</strong></p>\n<h3 id=\"fault-throws\"><a class=\"anchor\" href=\"#fault-throws\">#</a> Fault throws</h3>\n<p>断层断距</p>\n<p>Methods for computing fault surfaces lead naturally to the problem of estimating relative displacements of geologic layers alongside such surfaces. Solutions to this problem are not trivial, in part because of the sinusoidal character of seismic waveforms alongside faults, which can cause coincidental horizontal alignment of seismic events across faults even where fault throws are significant. Another difficulty is that fault throws typically vary within the spatial extent of any fault surface. Nevertheless, several authors have described solutions to the problem of estimating fault throws.</p>\n<p>计算断层面的方法自然会引出估算断层面旁地质层相对位移的问题。要解决这个问题并非易事，部分原因是断层旁的地震波形具有正弦特征，即使断层断距很大，也会造成地震事件在断层上的巧合水平排列。另一个困难是，断层断距通常在任何断层面的空间范围内各不相同。尽管如此，一些学者已经介绍了估计断层断距的解决方案。</p>\n<p>For example, Aurnhammer and Tönnies (2005) demonstrate the use of local crosscorrelations computed in rectangular windows and a genetic algorithm with geologic and geometric constraints to match horizons extracted from both sides of faults in 2D seismic images. Liang et al (2010) also use local crosscorrelations to estimate fault throws, while simultaneously scanning over fault dips to determine the locations and orientations of faults in 2D seismic images.</p>\n<p>例如，Aurnhammer 和 Tönnies（2005 年）展示了如何利用矩形窗口计算的局部交叉相关性以及带有地质和几何约束的遗传算法来匹配二维地震图像中断层两侧提取的地层。Liang 等人（2010 年）也使用局部交叉相关来估计断层投影，同时扫描断层倾角，以确定二维地震图像中断层的位置和方向。</p>\n<p>Admasu (2008) addresses the problem of estimating fault throws from 3D images through a Bayesian matching of seismic horizons extracted alongside faults in vertical 2D image slices, with the matching for one 2D slice used as a guide for the matching in adjacent slices. This method requires that fault surfaces are approximately orthogonal to the 2D image slices used to compute the fault throws.</p>\n<p>Admasu （2008 年）通过对垂直二维图像切片中断层旁提取的地震地层进行贝叶斯匹配，解决了从三维图像中估计断层走向的问题，并将一个二维切片的匹配结果作为相邻切片匹配的指导。这种方法要求断层面与用于计算断层走向的二维图像切片近似正交。</p>\n<p>In a 3D solution to the problem, Borgos et al (2003) correlate seismic horizons across faults by clustering into classes local extrema in various attributes computed from 3D seismic images. Carrillat et al (2004) and Skov et al (2004) show examples of analyzing fault displacements computed using this method. In another 3D solution, Bates et al (2009) demonstrate a “geomodel time differential analysis method” for computing fault throws after automatic horizon tracking.</p>\n<p>在该问题的三维解决方案中，Borgos 等人（2003 年）通过将从三维地震图像中计算出的各种属性的局部极值聚类，将各断层的地震层位关联起来。Carrillat 等人（2004 年）和 Skov 等人（2004 年）展示了使用这种方法计算断层位移的分析实例。在另一种三维解决方案中，Bates 等人（2009 年）展示了一种 &quot;地质模型时差分析方法&quot;，用于计算自动地平线跟踪后的断层投影。</p>\n<p><img data-src=\"https://ptpimg.me/qlrpmg.jpg\" alt=\"\" /></p>\n<p>Figure 3. Fault surfaces and fault throws for a 3D seismic image before (a) and after (b) unfaulting. In all image slices, reflectors are more continuous after unfaulting.</p>\n<p>图 3. 三维地震图像中断层面和断层投影在解断层前（a）和解断层后（b）的对比。在所有图像切片中，解断层后的反射体更加连续。</p>\n<p>performed for each fault orientation. In other words, I improve computational efficiency by eliminating the large factor equal to the number of samples in the windows that Cohen et al (2006) describe.</p>\n<p>对每个故障方位进行计算。换句话说，我消除了 Cohen 等人（2006 年）所描述的与窗口中样本数量相等的大系数，从而提高了计算效率。</p>\n<p>I then use the resulting 3D images of fault likelihoods, dips and strikes to extract fault surfaces using a method that is similar to that of Schultz et al (2010). The fault surfaces shown in Figures 2 and 3 are ridges in 3D images of fault likelihood, and are represented by meshes of quadrilaterals.</p>\n<p>然后，我利用生成的断层似然、倾角和走向三维图像，采用与 Schultz 等人（2010 年）类似的方法提取断层面。图 2 和图 3 所示的断层面是断层似然三维图像中的山脊，由四边形网格表示。</p>\n<p>Finally, I compute fault throws from differences in values of samples extracted from 3D seismic images alongside fault surfaces. The algorithm I use to compute fault throws is derived from a classic dynamic programming solution (Sakoe and Chiba, 1978) to a problem in speech recognition. Today, that solution is often called dynamic time warping and is here extended to find a spatial warping that best aligns samples of 3D seismic images alongside faults, as illustrated in Figure 3.</p>\n<p>最后，我根据从断层面旁的三维地震图像中提取的样本值的差异计算断层投影。我用来计算断层投影的算法源自语音识别问题的经典动态编程解决方案（Sakoe 和 Chiba，1978 年）。如今，该解决方案通常被称为动态时间扭曲，并在此得到扩展，以找到一种空间扭曲方法，最好地对齐断层旁的三维地震图像样本，如图 3 所示。</p>\n<h2 id=\"fault-images-2\"><a class=\"anchor\" href=\"#fault-images-2\">#</a> FAULT IMAGES</h2>\n<p>断层图像</p>\n<p>Whereas seismic horizons appear in 3D seismic images as coherent events, a fault appears less prominently as a curviplanar surface across which seismic events are discontinuous, yet correlated, with some displacement, from one side of the fault to the other. Therefore, a useful first step in extracting fault surfaces and estimating fault throws is to first compute images in which faults are most prominent.</p>\n<p>地震层在三维地震图像中表现为连贯的地震事件，而断层在三维地震图像中则表现为不太明显的曲线表面，地震事件在该表面上是不连续的，但从断层的一侧到另一侧有一定的位移关联。因此，<strong>提取断层面和估计断层投影的第一步是首先计算断层最突出的图像</strong>。</p>\n<h3 id=\"fault-oriented-semblance\"><a class=\"anchor\" href=\"#fault-oriented-semblance\">#</a> Fault-oriented semblance</h3>\n<p>断层导向形似</p>\n<p>The method I use for this first step is based on semblance (Taner and Koehler, 1969), and is therefore similar to methods that Marfurt et al (1998) propose. Like Marfurt et al (1999), I compute semblances from small numbers (3 in 2D, 3 × 3 ¼ 9 in 3D) of adjacent seismic traces, after aligning those traces so that any coherent reflections are horizontal.</p>\n<p>我在第一步中使用的方法是基于相似度（Taner 和 Koehler，1969 年），因此与 Marfurt 等人（1998 年）提出的方法类似。与 Marfurt 等人（1999 年）一样，我从少量（二维为 3 个，三维为 3 × 3 ¼ 9 个）相邻地震道中计算相似度，然后将这些地震道对齐，使任何相干反射都是水平的。</p>\n<p><img data-src=\"https://ptpimg.me/n9r2fc.jpg\" alt=\"\" /></p>\n<p>Figure 4. A 2D seismic image after logarithmic gain (a), with estimated reflection slopes (b) displayed in translucent colors.</p>\n<p>图 4. 对数增益后的二维地震图像（a），用半透明颜色显示估计反射斜率（b）。</p>\n<p>That alignment requires prior estimates of reflection slopes, like those displayed in Figure 4b. I computed these slopes from structure tensors (e.g., van Vliet and Verbeek, 1995; Weickert, 1999) for the seismic image displayed in Figure 4a. The logarithmic gain applied to that image has merely increased the relative amplitudes of weaker reflections.</p>\n<p>这种排列需要事先估计反射斜率，<strong>如图 4b 所示。我通过结构张量（如 van Vliet 和 Verbeek，1995 年；Weickert，1999 年）计算了图 4a 中显示的地震图像的反射斜率</strong>。应用于该图像的对数增益只是增加了较弱反射的相对振幅。</p>\n<p>Given estimates of reflection slopes, we might define structureoriented semblance as</p>\n<p>考虑到反射斜率的估计值，我们可以将面向结构的相似性定义为</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>s</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mfrac><msubsup><mrow><mo fence=\"true\">⟨</mo><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow><mo fence=\"true\">⟩</mo></mrow><mi>S</mi><mn>2</mn></msubsup><msub><mrow><mo fence=\"true\">⟨</mo><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><msup><mi>e</mi><mn>2</mn></msup></mrow><mo fence=\"true\">⟩</mo></mrow><mi>S</mi></msub></mfrac><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">semblance = { { \\left\\langle {image} \\right\\rangle _S^2 } \\over { { { \\left\\langle {imag{e^2}} \\right\\rangle } _S } } },(1)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">se</span><span class=\"mord mathnormal\">mb</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">ce</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.6294em;vertical-align:-0.9857em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6437em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7401em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.6897em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9857em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where, for each semblance value, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>S</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> denotes a structure-oriented averaging of whatever is inside the brackets, 3 (2D) or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>3</mn><mo>=</mo><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">3*3 = 9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span> (3D) image sample values. However, semblance ratios computed in this way will vary wildly where the numerators and denominators are small.</p>\n<p>其中，对于每个相似度值，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>S</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> 表示面向结构的平均值，即括号内的 3 个（二维）或 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>∗</mo><mn>3</mn><mo>=</mo><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">3*3 = 9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span> 个（三维）图像样本值。不过，如果分子和分母较小，用这种方法计算出的形貌比会有很大差异。</p>\n<p>This instability is one reason that we typically perform an additional smoothing of numerators and denominators before computing semblance ratios:</p>\n<p>这种不稳定性是我们通常在计算形似比之前对分子和分母进行额外平滑处理的原因之一：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>s</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mfrac><msub><mrow><mo fence=\"true\">⟨</mo><msubsup><mrow><mo fence=\"true\">⟨</mo><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow><mo fence=\"true\">⟩</mo></mrow><mi>S</mi><mn>2</mn></msubsup><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub><msub><mrow><mo fence=\"true\">⟨</mo><msub><mrow><mo fence=\"true\">⟨</mo><mrow><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><msup><mi>e</mi><mn>2</mn></msup></mrow><mo fence=\"true\">⟩</mo></mrow><mi>S</mi></msub><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mfrac><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">semblance = { { { { \\left\\langle { \\left\\langle {image} \\right\\rangle _S^2 } \\right\\rangle } _f } } \\over { { { \\left\\langle { { { \\left\\langle {imag{e^2} } \\right\\rangle } _S } } \\right\\rangle } _f } } } ,(2)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">se</span><span class=\"mord mathnormal\">mb</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">ce</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.5473em;vertical-align:-1.1715em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.3758em;\"><span style=\"top:-2.464em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7401em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1367em;\"><span style=\"top:-2.3506em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4855em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.38em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-4.3758em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⟨</span></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size2\">⟩</span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:-0.2136em;\"><span style=\"top:-2.0003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8358em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1715em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where the subscript <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> implies that this additional smoothing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> should be fault oriented.</p>\n<p>其中，下标 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 意味着额外的平滑 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> 应面向断层。</p>\n<p>A second reason is that discontinuities in seismic reflections corresponding to faults are most significant for strong reflections that may be widely separated. The additional fault-oriented smoothing in equation 2 links together these localized discontinuities, where semblance numerators can be much smaller than semblance denominators.</p>\n<p>第二个原因是，与断层相对应的地震反射的不连续性对于可能相距甚远的强反射最为明显。等式 2 中附加的面向断层的平滑处理将这些局部不连续性联系在一起，在这种情况下，共轭分子可能比共轭分母小得多。</p>\n<p>It is for this second reason that Gersztenkorn and Marfurt (1999) recommend the use of long vertical smoothing windows when highlighting structural features, such as faults, and short windows when highlighting stratigraphic features such as channels. In proposing a different gradient-based measure of discontinuity, Aqrawi and Boe (2011) likewise use a vertical smoothing of that measure for the same reason.</p>\n<p>正是出于第二个原因，Gersztenkorn 和 Marfurt（1999 年）建议在突出断层等结构特征时使用长垂直平滑窗口，而在突出通道等地层特征时使用短窗口。出于同样的原因，Aqrawi 和 Boe（2011 年）在提出另一种基于梯度的不连续性测量方法时，同样使用了垂直平滑法。</p>\n<p>Figure 5a shows semblances computed using a highly efficient two-sided-exponential filter to implement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> in equation 2 with vertical smoothing. The impulse response of this recursive filter is infinitely long, decays smoothly to zero, and in this example approximates a Gaussian filter with half-width <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\sigma  = 20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">20</span></span></span></span> samples. Significantly, the computational cost of the filter is independent of this half-width.</p>\n<p>图 5a 显示了使用高效的双面指数滤波器计算出的相似度，以实现方程 2 中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> 的垂直平滑。这种递归滤波器的脉冲响应无限长，平滑衰减为零，在本例中近似于半宽度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\sigma  = 20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">20</span></span></span></span> 样本的高斯滤波器。值得注意的是，滤波器的计算成本与半宽度无关。</p>\n<p>This vertical smoothing of semblance numerators and denominators accounts for the vertical extent of features with low semblance apparent in Figure 5a. To highlight these features, I define an attribute fault likelihood <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> by</p>\n<p>这种对相似度分子和分母的垂直平滑处理解释了图 5a 中明显的低相似度特征的垂直范围。为了突出这些特征，我通过以下方法定义了属性断层可能性 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo>≡</mo><mn>1</mn><mo>−</mo><mi>s</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>c</mi><msup><mi>e</mi><mn>8</mn></msup><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f \\equiv 1 - semblanc{e^8},(3)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">se</span><span class=\"mord mathnormal\">mb</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">c</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The choice of power eight is somewhat arbitrary; it increases the contrast between samples with low and high fault likelihoods, as shown in Figure 5b, where lower likelihoods <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>&lt;</mo><mn>0.5</mn></mrow><annotation encoding=\"application/x-tex\">f &lt; 0.5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.5</span></span></span></span> are transparent, to enhance visibility of unfaulted seismic reflectors.</p>\n<p>幂 8 的选择有些随意；它增加了低断层似然和高断层似然样本之间的对比度，如图 5b 所示，低似然 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>&lt;</mo><mn>0.5</mn></mrow><annotation encoding=\"application/x-tex\">f &lt; 0.5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.5</span></span></span></span> 是透明的，以提高无断层地震反射体的可见度。</p>\n<p>Although features in the semblance and fault likelihood images shown in Figure 5 have significant vertical extent, these features are not well aligned with faults because those faults are not vertical. To improve the fault likelihood attribute <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, we should instead smooth semblance numerators and denominators along the faults. Our problem is that we have not yet determined fault locations or orientations.</p>\n<p>虽然图 5 所示的胜似度和断层似然图像中的地物具有明显的垂直范围，但这些地物与断层并不十分吻合，因为这些断层并不垂直。为了改进断层似然属性 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>，我们应该沿断层平滑相似度分子和分母。我们的问题在于，我们尚未确定断层的位置或方向。</p>\n<h3 id=\"scanning-for-fault-orientations\"><a class=\"anchor\" href=\"#scanning-for-fault-orientations\">#</a> Scanning for fault orientations</h3>\n<p>扫描断层方向</p>\n<p>This sort of problem is common in seismic data processing, for example, when we must perform normal moveout corrections without knowing normal moveout velocities. A common solution is to perform a scan for multiple velocities to find the velocities that maximize some (often semblance-based) measure of alignment. Here, I scan over negative and positive fault dip angles $\\theta $ (where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\theta  = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> corresponds to vertical faults) to find those dips that maximize fault likelihoods <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>.</p>\n<p>这种问题在地震数据处理中很常见，例如，当我们必须在不知道正常移动速度的情况下进行正常移动校正时。常见的解决方法是对多个速度进行扫描，找出能最大限度地提高某种（通常是基于形似的）排列度的速度。在这里，我扫描了负断层倾角 $\\theta $ 和正断层倾角 $\\theta $（其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\theta  = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 对应于垂直断层），以找到能使断层可能性 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 最大化的倾角。</p>\n<p>Figure 6 illustrates the results of nonvertical smoothing for two different fault dips $\\theta $ in this scan. These examples demonstrate that fault likelihoods tend to be largest when smoothing of semblance numerators and denominators is performed along the faults, which are not vertical.</p>\n<p>图 6 展示了本次扫描中两个不同断层倾角 $\\theta $ 的非垂直平滑结果。这些示例表明，当沿非垂直的断层对共轭分子和分母进行平滑处理时，断层可能性往往最大。</p>\n<p>To perform this nonvertical smoothing efficiently for each fault dip $\\theta $, I shear semblance numerator and denominator images horizontally to make faults with that dip appear to be vertical, apply the fast vertical smoothing filter described above, and unshear the smoothed images before computing their ratio. Horizontal shearing (and unshearing) of images requires a simple horizontal shift of each row of image pixels, where the amount of shift varies linearly with row index. After shearing, faults with some nonvertical (nonzero) dip $\\theta $ will appear to be vertical, so that we may apply the recursive smoothing filter to each column of pixels in the sheared image, independently, before unshearing.</p>\n<p>为了对每个断层倾角 $\\theta $ 有效地进行这种非垂直平滑处理，我对分子和分母图像进行水平剪切，使该倾角的断层看起来是垂直的，然后应用上述快速垂直平滑滤波器，并在计算它们的比率之前对平滑后的图像进行解剪切。图像的水平剪切（和解除剪切）需要对每行图像像素进行简单的水平移动，移动量随行索引线性变化。剪切后，具有一定非垂直（非零）倾角 $\\theta $ 的断层将显示为垂直，因此我们可以在取消剪切前，对剪切图像中的每列像素独立应用递归平滑滤波器。</p>\n<p>Recall that the computational cost of the recursive smoothing filter does not depend on the extent of smoothing, which is controlled by the half-width parameter $\\sigma $. This recursive filter and the shearing and unshearing for nonvertical faults are largely responsible for reducing the computational cost of the scan over fault dips, relative to alternative scans as Neff et al (2000) and Cohen et al (2006) describe.</p>\n<p>回顾一下，递归平滑滤波器的计算成本并不取决于平滑的程度，平滑程度由半宽度参数 $\\sigma $ 控制。与 Neff 等人（2000 年）和 Cohen 等人（2006 年）描述的其他扫描方法相比，这种递归滤波器以及对非垂直断层的剪切和非剪切在很大程度上降低了断层倾角扫描的计算成本。</p>\n<p>An alternative to the sequence of rotation, horizontal smoothing, shearing, vertical smoothing, and unshearing described above is to implement the fault-oriented smoothing filter <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> with a 3D fast Fourier transform (FFT). However, my implementation of such an FFT-based smoothing filter is about three times slower than the scanning process used here. Rotation and shearing are common operations in image processing that can all be performed with computational cost less than that for FFTs.</p>\n<p>除了上述旋转、水平平滑、剪切、垂直平滑和取消剪切的顺序外，另一种方法是使用三维快速傅立叶变换（FFT）来实现断层导向平滑滤波器 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> 。然而，我所实现的这种基于 FFT 的平滑滤波器要比这里使用的扫描过程慢三倍左右。旋转和剪切是图像处理中的常见操作，这些操作的计算成本都低于 FFT。</p>\n<p>Computational cost is also a factor in my choice of the semblance attribute, which requires smoothing of only the two (numerator and denominator) images in equation 2. Alternatives such as the normalized correlation coefficient (Rodgers and Nicewander, 1988) or the eigenstructure-based coherence that Gersztenkorn and Marfurt (1999) describe would require fault-oriented smoothing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> of more than two images for each fault strike and dip in the scan.</p>\n<p>计算成本也是我选择 &quot;形似&quot; 属性的一个因素，因为它只需要对等式 2 中的两个（分子和分母）图像进行平滑处理。如果采用归一化相关系数（Rodgers 和 Nicewander，1988 年）或 Gersztenkorn 和 Marfurt（1999 年）描述的基于特征结构的一致性等替代方法，则需要对扫描中每个断层走向和倾角的两幅以上图像进行面向断层的平滑 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span></span> 处理。</p>\n<p><img data-src=\"https://ptpimg.me/ma7yq5.jpg\" alt=\"\" /></p>\n<p>Figure 5. Semblances (a) and fault likelihoods (b) computed using vertical smoothing of semblance numerators and denominators.</p>\n<p>图 5. 使用垂直平滑符号分子和分母计算出的符号（a）和断层可能性（b）。</p>\n<p><img data-src=\"https://ptpimg.me/49a6jw.jpg\" alt=\"\" /></p>\n<p>Figure 6. Fault likelihoods computed for two different fault dips $\\theta $, one positive (a) and the other negative (b), in a scan used to estimate fault dips. The positive dip is consistent with many of the major faults. The negative dip is consistent with antithetic faults.</p>\n<p>图 6. 在用于估算断层倾角的扫描中，针对两个不同断层倾角 $\\theta $ 计算的断层似然，一个为正倾角（a），另一个为负倾角（b）。正倾角与许多主要断层一致。负倾角与反断层一致。</p>\n<h3 id=\"ridges-of-fault-likelihood\"><a class=\"anchor\" href=\"#ridges-of-fault-likelihood\">#</a> Ridges of fault likelihood</h3>\n<p>断层可能性曲线</p>\n<p>The purpose of the scan over fault strikes and dips is to find, for each image sample, the angles $\\phi $ and $\\theta $ that maximize fault likelihood <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. I begin with a fault likelihood image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. Then, for each orientation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo separator=\"true\">,</mo><mi>θ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\phi ,\\theta )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mclose\">)</span></span></span></span> in the scan, where the fault likelihood <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo separator=\"true\">,</mo><mi>θ</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{f_{(\\phi ,\\theta )}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0496em;vertical-align:-0.3552em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">ϕ</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span></span></span></span></span> exceeds the maximum likelihood stored in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> , I update <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and also save the corresponding strike $\\phi $ and dip $\\theta $. When complete, the results of this scan are images of maximum fault likelihoods and corresponding fault strikes and dips.</p>\n<p>对断层走向和倾角进行扫描的目的是为每个图像样本找到能使断层似然 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> 最大化的角度 $\\phi $ 和 $\\theta $。然后，对于扫描中的每个方位 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo separator=\"true\">,</mo><mi>θ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\phi ,\\theta )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mclose\">)</span></span></span></span>，如果断层似然 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo separator=\"true\">,</mo><mi>θ</mi><mo stretchy=\"false\">)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{f_{(\\phi ,\\theta )}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0496em;vertical-align:-0.3552em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">ϕ</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span></span></span></span></span> 超过了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 中存储的最大似然，则更新 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 并保存相应的走向 $\\phi $ 和倾角 $\\theta $。</p>\n<p>Figure 7a shows fault likelihoods <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> computed in this way with a scan over fault dips for the 2D seismic image. Ridges of high fault likelihood generally coincide with faults apparent in the seismic image. These ridges can be extracted by scanning each row of the fault likelihood image, preserving only local maxima, and setting fault likelihoods elsewhere to zero. In effect, this process thins the fault likelihood image, reducing the number of image samples at which a fault might be considered to exist.</p>\n<p>图 7a 显示了用这种方法计算出的断层似然 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>，并扫描了二维地震图像的断层倾角。高断层似然脊一般与地震图像中明显的断层重合。通过扫描断层似然图像的每一行，只保留局部最大值，并将其他地方的断层似然设置为零，就可以提取出这些脊。实际上，这一过程可以减薄断层似然图像，减少可能存在断层的图像样本数量。</p>\n<p>Figure 7b shows ridges extracted from the fault image of Figure 7a. Parts of some ridges, especially those with lower fault likelihoods, may not coincide with faults. At this stage, I do not suppress these parts, although one might easily remove some of them by thresholding fault likelihoods.</p>\n<p>图 7b 显示了从图 7a 的断层图像中提取的脊线。一些脊的部分区域，尤其是断层似然值较低的区域，可能与断层不重合。在此阶段，我并没有抑制这些部分，尽管我们可以通过阈值断层似然值轻松去除其中一些。</p>\n<p>The seismic image displayed in Figure 7b is the result of structure-oriented filtering applied to the image shown in Figure 7a. This filtering is similar to that of Fehmers and Höcker (2003), but it is here constrained to not smooth across the thin ridges of fault likelihood. When estimating fault throws as described below, I use this filtering to attenuate noise and smooth coherent reflections toward, but not across, faults, much as human interpreters do visually.</p>\n<p>图 7b 显示的地震图像是对图 7a 显示的图像进行结构导向滤波的结果。<strong>这种滤波类似于 Fehmers 和 Höcker（2003 年）的滤波，但在此受限于不对断层似然的细脊进行平滑</strong>。如下文所述，在估算断层投影时，我使用这种滤波方法来减弱噪声，并平滑相干反射，使其朝向断层，而不是穿过断层，这与人类解释者的视觉效果非常相似。</p>\n<p><img data-src=\"https://ptpimg.me/2xk8kl.jpg\" alt=\"\" /></p>\n<p>Figure 7. Fault likelihoods computed by scanning over fault dips θ, (a) before and (b) after thinning. To facilitate estimation of fault throws, the seismic image in (b) has been smoothed along structures, but not across faults.</p>\n<p>图 7. 通过扫描断层倾角 θ 计算出的断层似然，(a) 在减薄之前，(b) 在减薄之后。为便于估算断层倾角，(b) 中的地震图像沿结构进行了平滑处理，但未跨越断层。</p>\n<h2 id=\"fault-surfaces-2\"><a class=\"anchor\" href=\"#fault-surfaces-2\">#</a> FAULT SURFACES</h2>\n<p>断层表面</p>\n<p>We can easily imagine how to extract fault curves from 2D fault images like those shown in Figure 7. For example, we might somehow link together samples with nonzero fault likelihood in the thinned image of Figure 7b. We could then use samples of the seismic image on the left and right sides of the extracted fault curves to estimate fault throws.</p>\n<p>我们可以轻松想象如何从图 7 所示的二维断层图像中提取断层曲线。例如，我们可以用某种方法将图 7b 稀释图像中断层可能性不为零的样本连接在一起。然后，我们就可以使用提取的断层曲线左右两侧的地震图像样本来估计断层投影。</p>\n<p>It is more difficult to construct fault surfaces like those shown in Figures 2 and 3 from 3D fault images. One problem is how to best represent a fault surface, which need not be aligned with any axis of the sampling grid for the 3D seismic image. Many fault surfaces cannot be projected onto a plane, and they cannot be well represented by a single-valued function of coordinates within such a plane (e.g., Walsh et al, 1999).</p>\n<p>根据三维断层图像构建图 2 和图 3 所示的断层面较为困难。其中一个问题是如何最好地表示断层面，因为断层面不必与三维地震图像采样网格的任何轴线对齐。许多断层面无法投影到一个平面上，也无法用一个平面内坐标的单值函数很好地表示（如 Walsh 等人，1999 年）。</p>\n<p>Also, the resolution with which we sample fault surfaces will be important when we compute fault throws. In that computation, we must be able to efficiently iterate upward and downward along fault curves of constant strike as we analyze seismic image samples alongside fault surfaces. We must also be able to efficiently traverse horizontally along fault traces for which time (or depth) is constant.</p>\n<p>此外，在计算断层断距时，断层面采样的分辨率也很重要。在计算时，我们必须能够在分析断层面旁的地震图像样本时，沿着走向恒定的断层曲线有效地向上和向下遍历。我们还必须能够沿着时间（或深度）恒定的断层轨迹进行有效的水平遍历。</p>\n<p>For these reasons, I represent fault surfaces with unstructured meshes of quadrilaterals (quads) like those shown in Figure 2b.</p>\n<p>因此，我采用图 2b 所示的四边形（quads）非结构网格来表示断层面。</p>\n<p><img data-src=\"https://ptpimg.me/5765n5.jpg\" alt=\"\" /></p>\n<p>Figure 8. Four adjacent quadrilaterals in a fault surface share a node that lies within one cell of the 3D sampling grid of a fault image. Spatial coordinates of the quad node are averages of the coordinates of intersections of the fault surface and edges of the image sampling grid. Quads are linked to quad neighbors where two edges in any of the six faces of a cell are intersected by a fault, and this example shows four such links.</p>\n<p>图 8. 断层面上相邻的四个四边形共享一个节点，该节点位于断层图像三维采样网格的一个单元内。四边形节点的空间坐标是断层面与图像采样网格边缘交点坐标的平均值。当一个单元的六个面中有两条边与断层相交时，四边形节点就会与四边形相邻节点链接，本示例显示了四个这样的链接。</p>\n<h3 id=\"extracting-quads-from-fault-images\"><a class=\"anchor\" href=\"#extracting-quads-from-fault-images\">#</a> Extracting quads from fault images</h3>\n<p>从断层图像中提取四边形</p>\n<p>My first step in constructing quad meshes is to extract a set of quads, not yet connected, from the 3D image of fault likelihoods. That 3D image is analogous to the 2D image of fault likelihoods shown in Figure 7a.</p>\n<p>构建四边形网格的第一步是从断层可能性的三维图像中提取一组尚未连接的四边形。该三维图像类似于图 7a 所示的断层可能性二维图像。</p>\n<p>As shown in Figure 8, each quad in a fault surface intersects exactly one edge of the 3D sampling grid of a fault image. I find these fault-edge intersections using a method similar to the one that Schultz et al (2010) develop. Specifically, I assume that fault surfaces are ridges in 3D images of fault likelihoods, analogous to the fault curves apparent in the 2D images shown in Figure 7.</p>\n<p>如图 8 所示，断层面上的每个四边形正好与断层图像三维采样网格的一条边缘相交。我使用与 Schultz 等人（2010 年）开发的方法类似的方法找到这些断层边缘交点。具体来说，我假设断层面是断层似然三维图像中的山脊，类似于图 7 所示二维图像中明显的断层曲线。</p>\n<p>Recall that curves apparent in Figure 7b are merely collections of pixels corresponding to local maxima within each row of pixels in the image of fault likelihoods shown in Figure 7a. If we walk up or down along a fault in Figure 7a, the fault likelihood may increase or decrease. If we instead walk horizontally across a fault in Figure 7, the fault likelihood will first increase, then decrease, as we cross a ridge of fault likelihood. Faults are most likely to exist at maxima, where horizontal derivatives of fault likelihood are zero.</p>\n<p>回想一下，图 7b 中明显的曲线只是像素的集合，与图 7a 所示断层可能性图像中每一行像素的局部最大值相对应。如果我们沿着图 7a 中的断层向上或向下走，断层可能性可能会增加或减少。如果我们横向穿过图 7 中的断层，当我们穿过断层似然脊时，断层似然将先增后减。断层最有可能存在于最大值处，此时断层可能性的水平导数为零。</p>\n<p>A more precise location of ridges of fault likelihood can be obtained by first computing derivatives of fault likelihood in directions perpendicular to faults and then interpolating with subpixel precision the locations at maxima where these derivatives are zero. For each image sample, the perpendicular direction can be computed from the image of fault dips $\\theta $ obtained in the scan to maximize fault likelihoods.</p>\n<p>首先计算与断层垂直方向上的断层似然导数，然后以亚像素精度内插这些导数为零的最大值位置，就能获得更精确的断层似然脊位置。对于每个图像样本，可根据扫描中获得的断层倾角 $\\theta $ 图像计算垂直方向，以最大限度地提高断层似然。</p>\n<p>For 3D images, ridges of fault likelihood intersect edges of cells in the 3D sampling grid (see Figure 8), and can be found by considering all such edges, one at a time. Each edge is defined by two adjacent samples in the 3D image of fault likelihood. For each of those two image samples, we have estimates of fault likelihood <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> , strike $\\phi $, and dip $\\theta $. These attributes enable us to compute derivatives of fault likelihood in directions perpendicular to faults, and from those directional derivatives we can determine whether or not a ridge (a local maximum) of fault likelihood intersects the edge of the seismic sampling grid between the two adjacent samples.</p>\n<p>对于三维图像，断层可能性脊与三维采样网格中的单元边缘相交（见图 8），可以通过每次考虑所有这些边缘来找到断层可能性脊。每条边缘由断层可能性三维图像中两个相邻的样本定义。对于这两个图像样本中的每一个，我们都有断层似然 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> 、走向 $\\phi $ 和倾角 $\\theta $ 的估计值。这些属性使我们能够计算断层似然在垂直于断层的方向上的导数，根据这些方向导数，我们可以确定断层似然的脊线（局部最大值）是否与两个相邻样本之间的地震采样网格边缘相交。</p>\n<p>As Schultz et al (2010) describe, those same derivatives also enable us to interpolate the location between samples of the fault-edge intersection (where the directional derivative is zero), if one exists. The spatial coordinates of a quad node located within any cell of the sampling grid are the average of coordinates computed for all faultedge intersections in that cell. This interpolation and averaging yields quads that coincide (with subvoxel precision) with ridges in the 3D image of fault likelihoods.</p>\n<p>正如 Schultz 等人（2010 年）所描述的，如果存在断层边缘交点（方向导数为零），这些导数还能使我们对样本之间的位置进行插值。位于采样网格任一单元内的四边形节点的空间坐标是该单元内所有断层边缘交点坐标的平均值。这种内插法和平均法得到的四边形（以亚体素精度）与断层似然三维图像中的脊相吻合。</p>\n<p>By analyzing all edges in the 3D sampling grid in this way, I extract quads that intersect edges where faults may exist. Most quads will share nodes with adjacent quads, and when displayed may appear to be parts of large fault surfaces. However, at this point in the process of fault surface extraction, quads have not yet been linked together to form a surface mesh. We have only a collection of quads, what is sometimes called “quad soup.”</p>\n<p>通过这种方法分析三维采样网格中的所有边缘，我提取出与可能存在断层的边缘相交的四边形。大多数四边形将与相邻四边形共享节点，显示出来时可能会显示为大型断层面的一部分。然而，在断层面提取过程的这一阶段，还没有将四边形连接在一起形成表面网格。我们只有一个四边形集合，有时被称为 &quot;四边形汤&quot;。</p>\n<h3 id=\"linking-quads\"><a class=\"anchor\" href=\"#linking-quads\">#</a> Linking quads</h3>\n<p>连接四边形</p>\n<p>The next step in extracting fault surfaces is to link quads together to form a mesh. Each quad in such a mesh will be linked to no more than four quad neighbors, quads that share an edge between two of their nodes. A simple method to find such links is to again loop over all cells in the image sampling grid, like the cell shown in Figure 8. Each cell has six faces, and each face has four edges. For each face, we look for edges that are intersected by faults, edges for which we have already constructed quads. If fault-edge intersections occur for two edges in the face, we link the two quads constructed for those two edges. In Figure 8, each quad would be linked in this way to exactly two neighbors.</p>\n<p>提取断层面的下一步是将四边形连接起来形成网格。<strong>这种网格中的每个四边形将与不多于四个四边形邻居相连，即在两个节点之间共享一条边的四边形。查找此类链接的简单方法是再次循环图像采样网格中的所有单元</strong>，如图 8 所示的单元。每个单元格有六个面，每个面有四条边。<strong>对于每个面，我们都要寻找与断层相交的边，我们已经为这些边构建了四边形</strong>。<strong>如果面中的两条边出现断层相交，我们就会将为这两条边构建的两个四边形连接起来</strong>。在图 8 中，每个四边形都会以这种方式链接到两个相邻的四边形。</p>\n<p>If fault-edge intersections occur for more than two edges in a single face of the image sampling grid cell, I link none of the corresponding quads that intersect those edges. This choice implies that two fault surfaces extracted in this way cannot intersect precisely, although they may be separated by only one grid sample.</p>\n<p><strong>如果在图像采样网格单元的一个面上有两条以上的断层边缘相交，则我不会链接与这些边缘相交的相应四边形。这种选择意味着以这种方式提取的两个断层面不能精确相交，尽管它们之间可能只有一个网格样本的距离。</strong></p>\n<p>After all links between quads and their neighbors have been found, I apply several filters to remove links that are inconsistent with geologically feasible fault surfaces. For example, I unlink two quads if either of them has no other neighbors or has only one neighbor on the opposite side. Such quads tend to appear as fins or bridges between two nearby fault surfaces, and by unlinking them I ensure that fault surfaces are nowhere too skinny, with a width or height of only one quad.</p>\n<p><strong>在找到四边形及其邻近地区之间的所有联系之后，我会使用几个过滤器来删除与地质上可行的断层面不一致的联系</strong>。例如，如果两个四边形中的任何一个没有其他邻居，或者只有一个邻居在对面，我就会取消它们之间的链接。这样的四边形往往会在两个邻近的断层面之间形成鳍状或桥状，通过解除链接，我可以确保断层面不会过于狭窄，宽度或高度只有一个四边形。</p>\n<p>Another filter unlinks two quads if the dihedral angle between them (computed from their normal vectors) is less than 90°. This filter ensures that the orientation of a fault surface does not vary too rapidly from one quad to the next.</p>\n<p>如果两个四边形之间的二面角（根据它们的法线向量计算得出）小于 90°，则另一个过滤器会将它们解除链接。该过滤器可确保断层面的方向不会从一个四边形到另一个四边形变化过快。</p>\n<p>Let the orientation of a quad be defined by its normal vector, which points toward a viewer that sees the four quad nodes labeled in counterclockwise order. From the opposite side, those same nodes would appear to be labeled in clockwise order. We can then define the back and front sides of a quad such that the quad normal vector points toward a viewer looking at the front side.</p>\n<p>让一个四边形的方向由其法线向量来定义，法线向量指向观察者，而观察者看到的是按逆时针顺序标注的四个四边形节点。从反面看，这些节点似乎是按顺时针顺序标注的。这样，我们就可以定义一个四边形的前后两面，使四边形的法向量指向观看正面的观众。</p>\n<p>At this stage in the process of fault surface extraction, the orientations of quad neighbors may be inconsistent. That is, when linking quads, the normal vectors of a quad and its quad neighbors may point in opposite directions.</p>\n<p>在断层面提取过程的这一阶段，相邻四边形的方向可能不一致。也就是说，在连接四边形时，四边形及其相邻四边形的法向量可能指向相反的方向。</p>\n<h3 id=\"constructing-oriented-fault-surfaces\"><a class=\"anchor\" href=\"#constructing-oriented-fault-surfaces\">#</a> Constructing oriented fault surfaces</h3>\n<p>构建定向断层面</p>\n<p>After extracting quads and linking them to neighbors, the final step in extracting fault surfaces is to find collections of quads that are linked either directly as neighbors or recursively as neighbors of neighbors. These collections form quad meshes that represent fault surfaces.</p>\n<p><strong>在提取四边形并将它们与相邻的四边形连接起来之后，提取断层面的最后一步是找到直接作为相邻四边形或递归作为相邻四边形的相邻四边形的集合。这些集合形成代表断层面的四边形网格。</strong></p>\n<p>I assume that these fault surfaces are orientable, that they have topologically distinct front and back sides, unlike the surfaces extracted from medical images by Schultz et al (2010). In other words, I assume that fault normal vectors can be chosen consistently for every quad in the surface, so that the front side of every quad coincides with the front side of the surface. Therefore, when recursively collecting quads to form fault surfaces, I flip the orientations of quads as necessary to be consistent with their neighbors.</p>\n<p>与舒尔茨等人（2010 年）从医学图像中提取的表面不同，我假定这些断层表面是可定向的，它们具有拓扑学上不同的正面和背面。<strong>换句话说，我假设可以为曲面中的每个四边形选择一致的断层法向量，这样每个四边形的正面都与曲面的正面重合</strong>。因此，<strong>在递归收集四边形以形成断层面时，我会根据需要翻转四边形的方向，使其与相邻的四边形保持一致</strong>。</p>\n<p>In the extraction of surfaces shown in Figure 3 I found 1922 surfaces, and all of them were orientable. However, some surfaces were quite small; this figure displays only the 20 largest fault surfaces, those with at least 2000 quads.</p>\n<p>在提取图 3 所示的表面时，我发现了 1922 个表面，而且所有表面都是可定向的。不过，有些表面很小；本图只显示了 20 个最大的断层表面，即至少有 2000 个四边形的表面。</p>\n<p>This selection of faults based on their size is just one example of the sort of filtering that is possible after constructing fault surfaces. We could also filter these surfaces based on their average strikes or dips (Pedersen et al, 2003; Pedersen, 2007, 2011), their fault likelihoods, or any combination of statistics derived from attributes computed for the quads that comprise the surfaces.</p>\n<p>这种根据断层大小选择断层的方法只是在构建断层面后进行筛选的一个例子。我们还可以根据这些断层面的平均走向或倾角（Pedersen 等人，2003 年；Pedersen，2007 年，2011 年）、断层可能性，或根据构成断层面的四边形属性计算得出的统计数据组合，对断层面进行筛选。</p>\n<h2 id=\"fault-throws-2\"><a class=\"anchor\" href=\"#fault-throws-2\">#</a> FAULT THROWS</h2>\n<p>断层断距</p>\n<p>Conceptually, the problem of estimating fault throws from 3D seismic images is a simple one. We must correlate seismic reflections on one side of the fault with those on the other side and compute vector displacements between corresponding reflections. In practice, this problem is difficult for several reasons.</p>\n<p>从概念上讲，根据三维地震图像估算断层投影是一个简单的问题。我们必须将断层一侧的地震反射与另一侧的地震反射关联起来，并计算相应反射之间的矢量位移。实际上，由于以下几个原因，这个问题很难解决。</p>\n<h3 id=\"difficulties-in-estimating-fault-throws\"><a class=\"anchor\" href=\"#difficulties-in-estimating-fault-throws\">#</a> Difficulties in estimating fault throws</h3>\n<p>估算断层点的困难</p>\n<p>One difficulty is that fault throws vary within a fault surface and within any local windows that we might use to correlate seismic reflections on opposite sides of the fault. To ease this difficulty, Aurnhammer and Tönnies (2005) use several geologic and geometric constraints in a genetic algorithm to estimate fault displacements. Still, inconsistency remains in estimating fault throw by crosscorrelation of windows of image samples in which that throw may vary significantly. This first difficulty is exacerbated by the fact that crosscorrelation windows must be at least as long as the longest fault throw vector to be estimated.</p>\n<p><strong>其中一个困难是，断层断距量在断层面内以及我们可能用来关联断层两侧地震反射的任何局部窗口内都是不同的。为了缓解这一困难，Aurnhammer 和 Tönnies（2005 年）在遗传算法中使用了多个地质和几何约束条件来估算断层位移</strong>。尽管如此，通过图像样本窗口的交叉相关性来估算断层位移仍然存在不一致性，而在这些窗口中，断层位移可能会有很大的变化。由于交叉相关窗口必须至少与要估算的最长断层断距向量一样长，这就加剧了第一个困难。</p>\n<p>A second difficulty is related to the fact that we can best estimate fault throws from strong seismic reflections with high signalto-noise ratios, but these reflections may be far apart, with weaker and noisier reflections in between. Constraints (e.g., Aurnhammer and Tönnies, 2005) are therefore needed to ensure continuity of fault throws estimated between strong reflections.</p>\n<p>第二个困难与以下事实有关：我们可以从信噪比高的强地震反射中估算出最佳的断层走向，但这些反射可能相距甚远，中间的反射更弱、更噪。<strong>因此需要一些约束条件（如 Aurnhammer 和 Tönnies，2005 年）来确保强反射之间所估算的断层走向的连续性。</strong></p>\n<p>A third difficulty lies in constraining fault throws to vary smoothly in dip and strike directions within a fault surface. Imposing this constraint is difficult partly because fault surfaces often cannot be projected onto a plane (e.g., Walsh et al, 1999). This means that we cannot estimate fault throws from 3D seismic images by crosscorrelation of one 2D image extracted from the footwall side of a fault surface with another 2D image extracted from the hanging-wall side.</p>\n<p>第三个难点在于如何限制断层断距在断层面内的倾角和走向方向上的平滑变化。施加这种约束之所以困难，部分原因是断层面通常无法投影到一个平面上（如 Walsh 等人，1999 年）。这意味着，我们无法通过从断层面底壁一侧提取的二维图像与从悬壁一侧提取的二维图像的交叉相关来估计三维地震图像中的断层走向。</p>\n<h3 id=\"dynamic-warping\"><a class=\"anchor\" href=\"#dynamic-warping\">#</a> Dynamic warping</h3>\n<p>动态翘曲</p>\n<p>I address the difficulties summarized above with an extension of a classic method for estimating relative shifts between two acoustic signals in the problem of speech recognition (Sakoe and Chiba, 1978). This method is today widely known as dynamic time warping. For the problem of estimating fault throws, the most important aspect of this method is that it estimates time-varying (dynamic) shifts between two sampled functions of time, without any local correlation windows. Instead, dynamic time warping finds shifts that minimize alignment errors, squared differences between sample values computed for different shifts, while strictly constraining the rate at which those shifts can vary with time.</p>\n<p>为了解决上述难题，我对语音识别问题中估算两个声音信号之间相对位移的经典方法进行了扩展（Sakoe 和 Chiba，1978 年）。这种方法如今被广泛称为<strong>动态时间扭曲法</strong>。对于估计故障点的问题来说，<strong>这种方法最重要的一点是，它可以估计两个时间采样函数之间的时变（动态）偏移，而不需要任何局部相关窗口</strong>。相反，动态时间扭曲法可以找到最大限度减少对齐误差的偏移量，即不同偏移量计算的样本值之间的平方差，同时严格限制这些偏移量随时间变化的速率。</p>\n<p>Hale (2013) describes an extension of the dynamic time warping solution to the problem of dynamic image warping, in which we seek to constrain estimates of relative shifts between two images to vary smoothly in all directions. The extension is an alternating sequence of vertical (top-down, bottom-up) and horizontal (leftright, right-left) smoothings of alignment errors, followed by the classic dynamic time warping algorithm. The vertical and horizontal smoothings are nonlinear but computationally efficient.</p>\n<p>Hale (2013) 描述了动态时间扭曲解决方案在动态图像扭曲问题上的扩展，其中我们试图限制两幅图像之间相对移动的估计值在所有方向上的平滑变化。该扩展是对配准误差进行垂直（自上而下、自下而上）和水平（左右、左右）平滑的交替序列，然后采用经典的动态时间扭曲算法。垂直和水平平滑是非线性的，但计算效率很高。</p>\n<p>As mentioned above, we often cannot reduce the problem of estimating fault throws to that of finding an optimal warping between footwall and hanging-wall images. We can, however, adapt the image warping solution to the problem of estimating fault throws, by extending this solution to quad meshes like that displayed in Figure 2b.</p>\n<p>如上所述，我们通常无法将估计断层走向的问题简化为在岩脚和悬壁图像之间寻找最佳翘曲的问题。不过，我们可以将图像扭曲解决方案扩展到图 2b 所示的四边形网格，使其适用于估计断层走向的问题。</p>\n<p>These quad meshes provide the links necessary to iterate upward and downward along fault curves of constant strike and to thereby compute alignment errors from seismic image sample values located on opposite sides of a fault surface. Quad links also enable us to smooth those alignment errors vertically and horizontally, just as we would in dynamic image warping, where such links are implied by a uniform sampling grid.</p>\n<p>这些四边形网格提供了沿着恒定走向的断层曲线向上和向下迭代所需的链接，从而计算出位于断层面两侧的地震图像样本值的配准误差。四边形链接还能使我们在垂直和水平方向上平滑对齐误差，就像我们在动态图像扭曲中一样，在动态图像扭曲中，这种链接是由均匀采样网格暗示的。</p>\n<p>In this way, I estimate vertical components of throw vectors from the footwall side to the hanging-wall side of a fault. The vertical components of throw shown in Figures 2 and 3 are smooth because of the constraints imposed in dynamic warping. They are nonnegative because the faults in this example are normal faults. For each quad, the vertical component of throw tells us how far upward or downward along a fault curve we must iterate within the quad mesh to determine the horizontal inline and crossline components (not shown) of the throw vector.</p>\n<p>通过这种方法，我估算出了从断层底壁侧到悬壁侧的抛掷矢量的垂直分量。图 2 和图 3 所示的抛掷垂直分量是平滑的，这是因为在动态扭曲过程中施加了限制。它们是非负的，因为本例中的断层是正常断层。对于每个四边形，抛掷垂直分量可以告诉我们必须在四边形网格内沿着断层曲线向上或向下移动多远，以确定抛掷矢量的水平内线和横线分量（未显示）。</p>\n<p>In summary, the dynamic warping process proposed here computes fault throws that minimize the sum of squared differences between image sample values on opposite sides of a fault, while constraining those fault throws to vary smoothly within the fault surface.</p>\n<p>总之，本文提出的动态扭曲过程可以计算出断层抛掷点，使断层两侧图像样本值的平方差之和最小，同时限制这些断层抛掷点在断层面内平滑变化。</p>\n<p><img data-src=\"https://ptpimg.me/t2j3e0.jpg\" alt=\"\" /></p>\n<p>Figure 9. Fault surfaces and fault throws for a 3D seismic image (a) before and (b) after unfaulting. The shape for many of these faults is roughly conical, and the two vertical sections intersect near the symmetry axis of one of these conical faults.</p>\n<p>图 9. 三维地震图像中的断层面和断层走向（a）在解除断层之前，（b）在解除断层之后。其中许多断层的形状大致呈圆锥形，两个垂直剖面在其中一个圆锥形断层的对称轴附近相交。</p>\n<h3 id=\"unfaulted-images\"><a class=\"anchor\" href=\"#unfaulted-images\">#</a> Unfaulted images</h3>\n<p>无断层图像</p>\n<p>A good test of the fidelity of estimated fault throws is to use them to undo faulting apparent in the seismic images from which they were derived. Luo and Hale (2012) describe this unfaulting process in detail. Here, I use this process only to illustrate the accuracy of fault surfaces and fault throws computed using the methods proposed in this paper.</p>\n<p>对估算的断层断距量的保真度进行测试的一个好方法是使用它们来消除地震图像中明显的断层。Luo 和 Hale（2012 年）详细描述了这一消除断层的过程。在此，我仅使用这一过程来说明使用本文提出的方法计算出的断层面和断层断距量的准确性。</p>\n<p>Figure 3 provides one example in which fault surfaces have roughly planar shapes. Faulting and unfaulting are most apparent in the inline sections because faults with large throws have strike vectors that are approximately aligned with the orthogonal crossline direction. Throws for these faults vary smoothly while generally increasing with depth.</p>\n<p>图 3 举例说明了断层面的大致平面形状。断层和非断层在内联剖面图中最为明显，因为具有较大走向的断层的走向矢量与正交横断面方向大致对齐。这些断层的走向变化平缓，一般随深度增加。</p>\n<p>Visual comparison of the continuity of reflections before and after unfaulting suggests that estimated fault throw vectors are generally accurate. One location where estimated fault throw appears to be incorrect (for unknown reasons) is located at about 1.7 s and 4.5 km in the crossline section.</p>\n<p>对解除断层前后反射连续性的目测比较表明，估计的断层断距矢量总体上是准确的。有一处估计的断层断距似乎不正确（原因不明），位于横断面上大约 1.7 秒和 4.5 千米处。</p>\n<p>Figures 9 and 10 show faults extracted from the same seismic image for a shallower portion of the subsurface with a more chaotic structure. Many of the faults extracted from this portion have roughly conical shapes, in which the apex of each cone lies above its base. In Figure 9, the two vertical image slices intersect near the symmetry axis of one of these conical fault surfaces.</p>\n<p>图 9 和图 10 显示了从同一地震图像中提取的断层，该断层位于地下较浅的部分，结构较为混乱。从这部分提取的许多断层具有大致的圆锥形，其中每个圆锥的顶点都位于其底部之上。在图 9 中，两个垂直图像切片在其中一个锥形断层面的对称轴附近相交。</p>\n<p>These conical shapes became apparent to me only after extracting fault surfaces, partly because I had never before seen faults with such shapes, and so I did not recognize their appearance in horizontal and vertical slices of the 3D seismic image. This experience highlighted an important benefit in using an automated process to extract information from 3D seismic images. The process used here cannot exclude such shapes merely because they are unexpected.</p>\n<p>我是在提取断层面后才发现这些圆锥形的，部分原因是我以前从未见过这种形状的断层，因此在三维地震图像的水平和垂直切片中无法识别它们的外观。这次经历突出了使用自动程序从三维地震图像中提取信息的一个重要好处。这里使用的程序不能仅仅因为这些形状出乎意料而将其排除在外。</p>\n<p>After recognizing the conical shapes of these faults, they are easily seen in 3D seismic images, even without the color overlays shown in Figures 9 and 10. In vertical sections, conical faults appear to be hyperbolic because a vertical slice (conic section) of a cone is a hyperbola. When interactively moving a vertical image slice through the 3D image, one can clearly see these hyperbolic discontinuities rising and falling as the image slice moves through the faults.</p>\n<p>识别出这些断层的圆锥形后，即使没有图 9 和图 10 所示的彩色叠加，也很容易在三维地震图像中看到它们。在垂直切面上，圆锥形断层似乎是双曲线，因为圆锥的垂直切面（圆锥切面）是双曲线。在三维图像中交互移动垂直图像切片时，可以清楚地看到这些双曲线不连续性随着图像切片在断层中的移动而上升和下降。</p>\n<p>Moreover, even in this relatively chaotic part of the seismic image, reflections are more continuous in the unfaulted image than in the original image. Some discontinuities that remain may be due to using only the 30 largest fault surfaces, those with at least 2000 quads.</p>\n<p>此外，即使在地震图像中相对混乱的部分，未断层图像中的反射也比原始图像中的更连续。残留的一些不连续性可能是由于只使用了 30 个最大的断层面，即至少有 2000 个四边形的断层面。</p>\n<p>Vertical exaggeration in all of these figures makes faults appear to be more vertical than they really are; an approximate time-to-depth conversion (with 1 s equivalent to 1 km) suggests that the dips of most faults are roughly 45° from vertical.</p>\n<p>所有这些图中的垂直夸张都使断层看起来比实际更垂直；时间与深度的近似换算（1 秒相当于 1 千米）表明，大多数断层的倾角与垂直方向大致成 45°。</p>\n<p>All of the seismic images shown in this paper are subsets of a 3D seismic image made publicly available by dGB Earth Sciences (1987). I therefore encourage others to study similar subsets, to look for conical faults apparent as circular arcs in horizontal slices and hyperbolic curves in vertical sections, before assuming that these faults have polygonal or other shapes that may be more familiar.</p>\n<p>本文显示的所有地震图像都是 dGB 地球科学公司（1987 年）公开提供的三维地震图像的子集。因此，我鼓励其他人研究类似的子集，在水平切片中寻找圆锥形断层，在垂直切片中寻找双曲线，然后再假设这些断层具有多边形或其他可能更熟悉的形状。</p>\n<p><img data-src=\"https://ptpimg.me/awexy1.jpg\" alt=\"\" /></p>\n<p>Figure 10. Different image slices for the same fault surfaces and fault throws displayed in Figure 9, (a) before and (b) after unfaulting. Conical faults here appear as fragments of hyperbolas in vertical seismic sections.</p>\n<p>图 10. 图 9 中显示的同一断层面和断层断距的不同图像切片，(a) 在未发生断层之前，(b) 在未发生断层之后。这里的锥形断层在垂直地震剖面上表现为双曲线的碎片。</p>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> CONCLUSION</h2>\n<p>The methods proposed in this paper comprise a three-step process to (1) compute fault images of likelihood, strike, and dip (2) extract fault surfaces, and (3) estimate fault throws. I once hoped to bypass the first two steps, to directly compute fault throws everywhere and then let faults be defined by locations where fault throws are significant. However, I have been unable to find an implementation of this conceptually simpler one-step process that is computationally feasible for 3D seismic images.</p>\n<p>本文提出的方法包括三个步骤：(1) 计算似然、走向和倾角的断层图像；(2) 提取断层面；(3) 估计断层断距。我曾经希望绕过前两个步骤，直接计算各地的断层断距，然后让断层由断层断距显著的位置来定义。然而，我一直无法找到这种概念上更简单的一步法的实现方法，而且在三维地震图像的计算上也不可行。</p>\n<p>It is significant that the scan in the first step yields images of fault strikes and dips for which the fault likelihood is maximized. These estimates of fault orientations are especially useful in the second step used to extract fault surfaces from ridges in fault likelihood.</p>\n<p>重要的是，第一步中的扫描会产生断层走向和倾角的图像，而这些图像的断层可能性是最大的。这些断层方向的估计值在第二步中特别有用，可用于从断层似然的脊中提取断层面。</p>\n<p>I chose the quad-mesh representation for fault surfaces in part to facilitate the third step of estimating fault throws. Because throw vectors connect samples on one side of a fault to those on the other side, it is especially convenient that quads in the fault surface lie between two adjacent samples of the seismic image at the same time or depth. In addition, the quad mesh also provides up-down and left-right connectivity needed to implement the dynamic warping algorithm used to estimate vertical throws.</p>\n<p>我选择用四边形网格表示断层面，部分原因是为了方便第三步估算断层断距。由于断距矢量将断层一侧的样本与断层另一侧的样本连接起来，因此断层面上的四边形位于同一时间或同一深度的两个相邻地震图像样本之间特别方便。此外，四边形网格还提供了上下和左右的连通性，以实现用于估算垂直抛掷的动态扭曲算法。</p>\n<p>Most of the computation time in this three-step process is spent in the first step, which currently requires a scan over all possible fault orientations. I improve the computational efficiency of this scan by using fast recursive smoothing filters within each potential fault plane, but further improvements may be worthwhile. My implementation of this scan for about 500 different fault orientations requires less than 2 h to process a 3D image of 10003 samples on a modern workstation.</p>\n<p>这个三步流程中的大部分计算时间都花在第一步，目前需要对所有可能的断层方向进行扫描。我在每个潜在断层面内使用了快速递归平滑滤波器，从而提高了这一扫描的计算效率，但仍有进一步改进的价值。我对大约 500 个不同断层方向进行扫描，在现代工作站上处理 10003 个样本的三维图像只需不到 2 小时。</p>\n<p>Perhaps the biggest current limitation in this process is in its handling of intersecting faults. As discussed above, to simplify the extraction of fault surfaces and estimation of fault throws, I do not yet permit two fault surfaces to intersect precisely, requiring instead that they be separated by at least one sample of the seismic image sampling grid. Further work is required to extend these two steps to properly account for fault intersections.</p>\n<p>目前这一过程最大的局限性可能在于对相交断层的处理。如上所述，为了简化断层面的提取和断层投影的估算，我还不允许两个断层面精确相交，而是要求它们之间至少有一个地震图像采样网格样本相隔。还需要进一步的工作来扩展这两个步骤，以适当考虑断层交汇。</p>\n",
            "tags": [
                "Hyperstreamline"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/08/16/basic-theory/Detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features/",
            "url": "https://sakurame.eu.org/2023/08/16/basic-theory/Detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features/",
            "title": "Detecting_faults_and_channels_while_enhancing_seismic_structural_and_stratigraphic_features",
            "date_published": "2023-08-16T04:55:19.000Z",
            "content_html": "<h1 id=\"detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features\"><a class=\"anchor\" href=\"#detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features\">#</a> Detecting faults and channels while enhancing seismic structural and stratigraphic features</h1>\n<p>探测断层和通道，增强地震构造和地层特征</p>\n<h2 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> Abstract</h2>\n<p>A 3D seismic image contains structural and stratigraphic features such as reflections, faults, and channels. When smoothing such an image, we want to enhance all of these features so that they are easier to interpret. Most smoothing methods aim to enhance reflections but may blur faults and channels in the image. A few methods smooth seismic reflections while preserving faults and channel boundaries. However, it has not well-discussed to smooth simultaneously along the seismic reflections and channels, which are linear features apparent within dipping reflections. In addition, to interpret faults and channels, extra steps are required to compute attributes or mappings of faults and channels from a seismic image. Such fault and channel attributes are often sensitive to noise because they are typically computed as discontinuities of seismic reflections. In this paper, we have developed methods to simultaneously enhance seismic reflections, faults, and channels while obtaining mappings of the faults and channels. In these methods, we first estimate the orientations of the reflections, faults, and channels directly in a seismic image. We then use the estimated orientations to control the smoothing directions in an efficient iterative diffusion scheme to smooth a seismic image along the reflections and channels. In this iterative scheme, we also efficiently compute mappings of faults and channels, which are used to control smoothing extents in the diffusion to stop smoothing across them. This diffusion scheme iteratively smooths a seismic image along reflections and channels while updating the mappings of faults and channels. By doing this, we will finally obtain an enhanced seismic image (with enhanced reflections and channels and sharpened faults) and cleaned mappings of faults and channels (discontinuities related to noise are cleaned up). We have examined the methods using 2D and 3D real seismic images.</p>\n<p>三维地震图像包含反射、断层和道等构造和地层特征。在对此类图像进行平滑处理时，我们希望增强所有这些特征，使其更易于解释。大多数平滑方法旨在增强反射，但可能会模糊图像中的断层和道。少数方法在平滑地震反射的同时保留断层和道的边界。然而，沿地震反射和道同时平滑的方法尚未得到充分讨论，而地震反射和道是倾斜反射中明显的线性特征。此外，要解释断层和道，还需要额外的步骤，从地震图像中计算断层和道的属性或映射。这些断层和道属性通常对噪声很敏感，因为它们通常是作为地震反射的不连续性计算出来的。在本文中，我们开发了同时增强地震反射、断层和道的方法，同时获得断层和道的映射。在这些方法中，我们首先直接在地震图像中估计反射、断层和道的方向。然后，我们利用估算出的方向来控制高效迭代扩散方案中的平滑方向，以沿着反射和道平滑地震图像。在这一迭代方案中，我们还能有效计算断层和道的映射，用于控制扩散中的平滑范围，以停止沿断层和道的平滑。</p>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>Seismic interpretation often includes extracting structural and stratigraphic features such as horizons, faults, and channels from a seismic image (Wu and Hale, 2016b). The seismic horizons can be directly extracted from a seismic image by following reflections, which are dominant linear (2D) or planar (3D) features in the seismic image (Wu and Hale, 2015). The seismic faults and channels are recognized as the lateral discontinuities of reflections in a seismic image (Gersztenkorn and Marfurt, 1999; Chopra and Marfurt, 2007). In a 3D seismic image, channels are also spatially apparent as linear features that are aligned within dipping reflections (Wu, 2017). To extract seismic faults and channels, we often need to compute an extra attribute image from a seismic image so that the faults and channels are the most prominent features in the attribute image (Wu and Hale, 2016a; Wu, 2017).</p>\n<p>地震解释通常包括从地震图像中提取地层、断层和道等构造和地层特征（Wu 和 Hale，2016b）。<strong>地震地层可通过跟踪反射从地震图像中直接提取</strong>，反射是地震图像中主要的线性（二维）或平面（三维）特征（Wu 和 Hale，2015 年）。<strong>地震断层和道被认为是地震图像中反射的横向不连续性</strong>（Gersztenkorn 和 Marfurt，1999 年；Chopra 和 Marfurt，2007 年）。<strong>在三维地震图像中，道在空间上也是明显的线性特征，这些线性特征在倾斜反射中排列</strong>（Wu，2017）。为了提取地震断层和道，我们通常需要从地震图像中计算额外的属性图像，以便断层和道成为属性图像中最突出的特征（Wu 和 Hale，2016a；Wu，2017）。</p>\n<p>In practice, such structural and stratigraphic features may not be obvious to track in a seismic image because of noise or limitations in seismic imaging methods.</p>\n<p>在实践中，由于噪音或地震成像方法的限制，在地震图像中可能无法明显追踪到此类结构和地层特征。</p>\n<p>Therefore, a helpful step before seismic interpretation is to first enhance the structural and stratigraphic features in the seismic image so that the reflections are more continuous in areas away from faults and channels, the reflection discontinuities near faults and channels are more obvious, and the channels are spatially more continuous along dipping horizons or reflections. Some methods (e.g., Bakker et al, 1999; Fehmers and Höcker, 2003; Lavialle et al, 2007; Hale, 2009, 2011; Liu et al, 2010) have been proposed to enhance seismic reflections while preserving reflection discontinuities near faults and channel boundaries. To enhance the linear or planar reflections, most authors (Fehmers and Höcker, 2003; Lavialle et al, 2007; Hale, 2009) construct structure-oriented filters to smooth a seismic image along reflections by using anisotropic diffusion (Weickert, 1997, 1999). Some other authors construct structureoriented filters using the steered Kuwahara filter (Bakker et al, 1999; AlBinHassan et al, 2006), plane-wave prediction (Liu et al, 2010), and steered bilateral filter (Hale, 2011). To preserve reflection discontinuities near faults, all the methods require computing some fault image to stop the smoothing at the faults. To preserve computational efficiency, some authors (Bakker et al, 1999; Hale, 2009) do not update the fault image during the smoothing. However, such a fault image is often sensitive to noise, some other authors (Fehmers and Höcker, 2003; Lavialle et al, 2007; Liu et al, 2010; Hale, 2011) therefore prefer to iteratively update the fault image to obtain a more accurate detection of faults and to better preserve faults during the smoothing.</p>\n<p>因此，<strong>地震解释前的一个有用步骤是首先增强地震图像中的构造和地层特征，使远离断层和道的区域反射更加连续，断层和道附近的反射不连续性更加明显，道沿倾斜地层或反射在空间上更加连续</strong>。一些方法（如 Bakker 等人，1999 年；Fehmers 和 Höcker，2003 年；Lavialle 等人，2007 年；Hale，2009 年，2011 年；Liu 等人，2010 年）被提出来增强地震反射，同时保留断层和道边界附近的反射不连续性。为了增强线性或平面反射，大多数学者（Fehmers 和 Höcker，2003 年；Lavialle 等人，2007 年；Hale，2009 年）构建了面向结构的滤波器，利用各向异性扩散（Weickert，1997 年，1999 年）来平滑沿反射方向的地震图像。还有一些学者利用转向 Kuwahara 滤波器（Bakker 等人，1999 年；AlBinHassan 等人，2006 年）、平面波预测（Liu 等人，2010 年）和转向双边滤波器（Hale，2011 年）构建了面向结构的滤波器。为了保留断层附近的反射不连续性，所有方法都需要计算一些断层图像，以停止断层处的平滑处理。为了保持计算效率，一些作者（Bakker 等人，1999 年；Hale，2009 年）在平滑过程中不更新断层图像。然而，这样的断层图像往往对噪声很敏感。</p>\n<p>Although structure-oriented smoothing methods have been proposed to enhance seismic reflections while preserving faults and channel boundaries, it is not discussed to simultaneously enhance or smooth along seismic stratigraphic features such as channels. In addition, the efficiency of the previous structure-oriented smoothing methods can be further improved. In this paper, we discuss fast cyclic explicit diffusion methods to simultaneously enhance reflections, faults, and channels in a seismic image while computing enhanced images of faults and channels. In the methods, we first estimate the orientations of reflections, faults, and channels from a seismic image. We also compute fault and channel mappings from the seismic image and apply fault- and channel-oriented smoothing to enhance the fault and channel features in these mappings. We then use the orientations of reflections and channels to control the smoothing directions in an iterative diffusion scheme to smooth along reflections and channels in the seismic image. The fault and channel mappings are used to control the smoothing extents in the diffusion scheme so that the smoothing is performed along reflections and channels but not across faults and channels. In the diffusion scheme, we iteratively update the fault and channel mappings together with the seismic image. The finally updated fault and channel images will display enhanced faults and channels, whereas the finally updated seismic image will display enhanced reflections, channels, and sharpen discontinuities near faults and channel boundaries. To accelerate the diffusion, we use the fast explicit diffusion (FED) method proposed by Grewenig et al (2010) and Weickert et al (2016), which requires fewer iterations than the conventional explicit diffusions schemes. We demonstrate the proposed methods using 2D and 3D examples with many faults and channels.</p>\n<p>虽然已经提出了面向结构的平滑方法，在增强地震反射的同时保留断层和道的边界，但并没有讨论同时增强或平滑道等地震地层特征。此外，以往面向结构的平滑方法的效率还可以进一步提高。本文讨论了<strong>快速循环显式扩散方法</strong>，用于<strong>同时增强地震图像中的反射、断层和道，同时计算断层和道的增强图像</strong>。在这些方法中，我们首先从地震图像中估计反射、断层和道的方向。我们还根据地震图像计算断层和道映射，并应用面向断层和道的平滑处理来增强这些映射中的断层和道特征。然后，我们利用反射和道的方向来控制迭代扩散方案中的平滑方向，以沿着地震图像中的反射和道进行平滑。断层和道映射用于控制扩散方案中的平滑范围，使平滑沿着反射和道进行，而不跨越断层和道。在扩散方案中，我们连同地震图像一起迭代更新断层和道映射。最终更新的断层和道图像将显示增强的断层和道，而最终更新的地震图像将显示增强的反射和反射道。</p>\n<h2 id=\"structural-and-stratigraphic-orientations\"><a class=\"anchor\" href=\"#structural-and-stratigraphic-orientations\">#</a> Structural and stratigraphic orientations</h2>\n<p>结构和地层走向</p>\n<p>Several methods, such as the structure tensor (Van Vliet and Verbeek, 1995; Weickert, 1997; Fehmers and Höcker, 2003), coherence scanning (Marfurt, 2006), plane-wave destruction (Fomel, 2002), and dynamic image warping (Arias, 2016), have been proposed to estimate seismic reflection orientations or slopes. However, the latter three methods are not applicable to estimate orientations of seismic stratigraphic features such as channels that are generally aligned within dipping reflections. In this paper, we use the structure tensor method to estimate orientations of structural features (reflections) and stratigraphic features (channels).</p>\n<p>有几种方法，如结构张量（Van Vliet 和 Verbeek，1995 年；Weickert，1997 年；Fehmers 和 Höcker，2003 年）、相干扫描（Marfurt，2006 年）、平面波破坏（Fomel，2002 年）和动态图像扭曲（Arias，2016 年），已被提出用于估计地震反射方向或斜度。然而，后三种方法并不适用于估算地震地层特征的方向，例如通常在倾斜反射中排列的道。在本文中，<strong>我们使用结构张量法来估计结构特征（反射）和地层特征（道）的方向</strong>。</p>\n<h2 id=\"structure-tensors\"><a class=\"anchor\" href=\"#structure-tensors\">#</a> Structure tensors</h2>\n<p>结构张量</p>\n<p>A structure tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> at each seismic image sample can be constructed as a smoothed outer product of image gradient $g:T = \\left\\langle <ruby>g{g<rp>(</rp><rt>T</rt><rp>)</rp></ruby>} \\right\\rangle $ , where $\\left\\langle  \\cdot  \\right\\rangle $ denotes the smoothing for each element of the outer product or structure tensor. This smoothing, often implemented as a Gaussian filter, helps to construct structure tensors with stable estimations of seismic structural and stratigraphic orientations.</p>\n<p>每个地震图像样本的结构张量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 都可以构建为图像梯度 $g:T = \\left\\langle <ruby>g{g<rp>(</rp><rt>T</rt><rp>)</rp></ruby>} \\right\\rangle $ 的平滑外积，其中 $\\left\\langle  \\cdot  \\right\\rangle $ 表示外积或结构张量每个元素的平滑化。这种<strong>平滑处理通常采用高斯滤波器，有助于构建结构张量，对地震结构和地层方向进行稳定估计</strong>。</p>\n<p>For each image sample in a 2D image, a structure tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a 2 × 2 symmetric positive-semidefinite matrix</p>\n<p>对于二维图像中的每个图像样本，结构张量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 是一个 2 × 2 对称正半无限矩阵</p>\nT = \\left\\langle { g {g^T} } \\right\\rangle  = \\left[ {\\matrix { \n   { \\left\\langle { {g_1} {g_1} } \\right\\rangle } & { \\left\\langle { {g_1} {g_2} } \\right\\rangle }  \\cr \n   { \\left \\langle { { g_1 } { g_2 } } \\right \\rangle } & { \\left \\langle { { g_2} {g_2} } \\right \\rangle }  \\cr \n} } \\right] (1)\n\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>=</mo><mrow><mo fence=\"true\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub></mrow><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">g = \\left[ { {g_1} {g_2} } \\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span> represent the 2D image gradients with first derivatives computed in the vertical <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({g_1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> and horizontal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({g_2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> directions and $\\left\\langle  \\cdot  \\right\\rangle $ denotes the smoothing of whatever is inside the angle brackets. As shown by Fehmers and Höcker (2003), the seismic reflection orientation at each image sample can be estimated from the eigendecomposition of the structure tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> at that sample</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>=</mo><mrow><mo fence=\"true\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub></mrow><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">g = \\left[ { {g_1} {g_2} } \\right]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">[</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">]</span></span></span></span></span> 表示在垂直 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">( {g_1} )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 和水平 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">( {g_2} )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 方向计算一阶导数的二维图像梯度，$\\left\\langle  \\cdot  \\right\\rangle $ 表示角括弧内的平滑化。正如 Fehmers 和 Höcker（2003 年）所指出的，每个图像样本的地震反射方位可通过该样本的结构张量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 的极值分解估算得出</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>λ</mi><mi>u</mi></msub><mi>u</mi><msup><mi>u</mi><mi>T</mi></msup><msub><mi>λ</mi><mi>v</mi></msub><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T = {\\lambda _u}u{u^T} {\\lambda _v}v{v^T} (2)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1413em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> are the eigenvalues corresponding to eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>. If we label the eigenvalues <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub><mo>≥</mo><msub><mi>λ</mi><mi>v</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u} \\ge {\\lambda _v} \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, then the corresponding eigenvectors u will be perpendicular to locally linear features (seismic reflections) in an image and the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> will be parallel to such features. Figure 1a shows a 2D seismic image, and the cyan segments in Figure 1b represent the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> that are aligned with the seismic reflections in the image. Although we display the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> only at some image samples in Figure 1b, we actually compute eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> for all image samples from the eigendecomposition of 2D structure tensors.</p>\n<p>如果我们标注特征值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub><mo>≥</mo><msub><mi>λ</mi><mi>v</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u} \\ge {\\lambda _v} \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，那么相应的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 将垂直于图像中的局部线性特征 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>（地震反射），而特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 将平行于这些特征 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 。图 1a 显示的是一幅二维地震图像，图 1b 中的青色线段表示与图像中的地震反射相一致的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>。虽然图 1b 中仅显示了部分图像样本的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>，但实际上我们通过二维结构张量的特征分解计算出了所有图像样本的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>。</p>\n<p><img data-src=\"https://ptpimg.me/wnyop2.jpg\" alt=\"\" /></p>\n<p>Figure 1. (a) A 2D seismic image is displayed with the (b) eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> (the cyan segments) of structure tensors.</p>\n<p>图 1：（a）二维地震图像与（b）结构张量的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>（青色部分）。</p>\n<p>For each sample in a 3D image, a structure tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a 3 × 3 symmetric positive-semidefinite matrix</p>\n<p>对于三维图像中的每个样本，结构张量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 是一个 3 × 3 对称正半无限矩阵</p>\nT = \\left\\langle { g { g^T } } \\right\\rangle  = \\left[ {\\matrix{\n   {\\left\\langle { {g_1} {g_1} } \\right\\rangle } & {\\left\\langle { {g_1} {g_2} } \\right\\rangle } & {\\left\\langle { {g_1} {g_3} } \\right\\rangle }  \\cr \n   {\\left\\langle { {g_1} {g_2} } \\right\\rangle } & {\\left\\langle { {g_2} {g_2} } \\right\\rangle } & {\\left\\langle { {g_2} {g_3} } \\right\\rangle }  \\cr \n   {\\left\\langle { {g_1} {g_3} } \\right\\rangle } & {\\left\\langle { {g_2} {g_3} } \\right\\rangle } & {\\left\\langle { {g_3} {g_3} } \\right\\rangle }  \\cr \n} } \\right],(3)\n\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mo stretchy=\"false\">!</mo><mo>−</mo><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>g</mi><mtext>￼</mtext><mn>0</mn><mo>−</mo><mo>−</mo><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\"></annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">￼0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mo stretchy=\"false\">!</mo><mo>−</mo><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>g</mi><mtext>￼</mtext><mn>1</mn><mo>−</mo><mo>−</mo><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\"></annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">￼1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo><mo stretchy=\"false\">!</mo><mo>−</mo><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>g</mi><mtext>￼</mtext><mn>2</mn><mo>−</mo><mo>−</mo><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\"></annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">￼2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span> are the three components of an image gradient vector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> computed at a 3D image sample. The eigendecomposition of such a 3D structure tensor is as follows:</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{ {g_1} }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{ {g_2} }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">{ {g_3} }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></span> 是在三维图像样本上计算的图像梯度向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> 的三个分量。这种三维结构张量的特征分解如下：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>λ</mi><mi>u</mi></msub><mi>u</mi><msup><mi>u</mi><mi>T</mi></msup><mo>+</mo><msub><mi>λ</mi><mi>v</mi></msub><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><msub><mi>λ</mi><mi>w</mi></msub><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">T = {\\lambda _u}u{u^T} + {\\lambda _v}v{v^T} + {\\lambda _w}w{w^T}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0413em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">u</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0413em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0413em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>w</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _w}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> are the eigenvalues corresponding to orthogonal eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>, respectively. If we label the eigenvalues <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub><mo>≥</mo><msub><mi>λ</mi><mi>v</mi></msub><mo>≥</mo><msub><mi>λ</mi><mi>w</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u} \\ge {\\lambda _v} \\ge {\\lambda _w} \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, then the corresponding eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> will be parallel to directions in which the image features vary most significantly, whereas the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> will be parallel to directions in which the image features vary the least significantly. In a 3D seismic image, the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> are locally perpendicular to seismic reflections, whereas the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are locally parallel to seismic stratigraphic features (channels) that are aligned within the reflections (Hale, 2009). The eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> are orthogonal to seismic reflections and stratigraphic features. Figure 2 displays the three eigenvectors on a stratigraphic surface that can be extracted from a 3D seismic image by following seismic reflections. As shown in Figure 2, the eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> is normal to the surface, whereas eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> lie within a local plane of the surface and are laterally perpendicular and parallel to the channel, respectively.</p>\n<p>** 其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>v</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>w</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\lambda _w}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 分别是与正交特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 相对应的特征值。如果我们标注特征值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>λ</mi><mi>u</mi></msub><mo>≥</mo><msub><mi>λ</mi><mi>v</mi></msub><mo>≥</mo><msub><mi>λ</mi><mi>w</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">{\\lambda _u} \\ge {\\lambda _v} \\ge {\\lambda _w} \\ge 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>，那么相应的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 将平行于图像特征变化最明显的方向，而特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 将平行于图像特征变化最不明显的方向。在三维地震图像中，特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 在局部垂直于地震反射，而特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 在局部平行于反射内排列的地震地层特征（道）（Hale，2009 年）。特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与地震反射和地层特征正交。图 2 显示了地层面上的三个特征向量，可通过跟踪地震反射从三维地震图像中提取。** 如图 2 所示，特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 是地层面的法线，而特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 则位于地层面的局部平面内，分别在横向上垂直于通道和平行于通道。</p>\n<p>With the eigenvectors derived from 2D or 3D structure tensors, we are able to design anisotropic filters that smooth along seismic structural and stratigraphic features. In this paper, we construct such a structureand stratigraphy-oriented smoothing filter with anisotropic diffusion (e.g., Weickert, 1997, 1999; Ma and Plonka, 2007; Plonka and Ma, 2008). Such anisotropic diffusion filters are based on a physical heat diffusion process, but the diffusion is steered by a tensor field that may be constructed from the eigenvectors of structure tensors. Some authors (Fehmers and Höcker, 2003; Hale, 2009) have applied such anisotropic diffusion filters to enhance seismic reflections while preserving faults. However, these anisotropic diffusion filters may blur seismic stratigraphic features such as channels by smoothing along seismic reflections. Moreover, the fault images used to preserve faults in these methods can be further enhanced by applying approximate fault-oriented smoothing to the images. Figure 3a shows a smoothed image computed by applying the structure-oriented smoothing method, proposed by Hale (2009), to the original seismic image in Figure 1. We observe that this method works pretty well to enhance the seismic reflections but also remove the reflection discontinuities related to faults as shown in the smoothed image (Figure 3a) and the input-output difference image (Figure 3b). To preserve the faults within the smoothed image, a fault attribute image such as coherence is required as an extra input for the method as discussed by Hale (2009). In addition, although this method requires only 0.086 s to compute this 2D smoothed image by using an eight-core computer, the computational efficiency can still be significantly improved.</p>\n<p>利用从二维或三维结构张量得出的特征向量，我们能够设计出各向异性滤波器，以平滑地震结构和地层特征。在本文中，<strong>我们利用各向异性扩散（如 Weickert, 1997, 1999; Ma and Plonka, 2007; Plonka and Ma, 2008）构建了这样一种面向结构和地层的平滑滤波器</strong>。<strong>这种各向异性扩散滤波器基于物理热扩散过程，但扩散是由张量场引导的，张量场可由结构张量的特征向量构建</strong>。一些学者（Fehmers 和 Höcker，2003 年；Hale，2009 年）已经应用这种各向异性扩散滤波器来增强地震反射，同时保留断层。然而，这些各向异性扩散滤波器可能会通过平滑地震反射来模糊地震地层特征，如地震道。此外，这些方法中用于保留断层的断层图像可以通过对图像进行近似断层导向平滑处理来进一步增强。图 3a 显示了对图 1 中的原始地震图像应用 Hale（2009 年）提出的面向结构的平滑方法计算出的平滑图像。从平滑图像（图 3a）和输入输出差分图像（图 3b）中可以看出，<strong>这种方法不仅能很好地增强地震反射，还能消除与断层有关的反射不连续性</strong>。<strong>为了在平滑图像中保留断层，需要使用断层属性图像，如相干性图像</strong>。</p>\n<p>In this paper, we will discuss anisotropic diffusion filters to simultaneously enhance reflections, faults, and channels in a seismic image and at the same time compute enhanced mappings of faults and channels. We solve the anisotropic diffusion using the FED method proposed by Grewenig et al (2010) and Weickert et al (2016), which is significantly more efficient than the previous structure-oriented filters (Fehmers and Höcker, 2003; Hale, 2009) used in seismic image smoothing.</p>\n<p>本文将讨论各向异性扩散滤波器，以同时增强地震图像中的反射、断层和道，并同时计算断层和道的增强映射。<strong>我们使用 Grewenig 等人（2010 年）和 Weickert 等人（2016 年）提出的 FED 方法解决各向异性扩散问题</strong>。该方法比之前用于地震图像平滑的结构导向滤波器（Fehmers 和 Höcker，2003 年；Hale，2009 年）效率更高。</p>\n<h2 id=\"fast-explicit-diffusion\"><a class=\"anchor\" href=\"#fast-explicit-diffusion\">#</a> Fast explicit diffusion</h2>\n<p>快速显式扩散</p>\n<p>The anisotropic diffusion can be implemented explicitly using an iterative scheme (Weickert, 1999; Fehmers and Höcker, 2003) or implicitly by solving a large linear system (Hale, 2009). In this paper, we use the FED method (Grewenig et al, 2010; Weickert et al, 2016) to more efficiently solve the anisotropic diffusion filters. Then, we will explain the FED method using a simple 1D homogeneous diffusion problem.</p>\n<p>各向异性扩散可以通过迭代方案显式实现（Weickert，1999 年；Fehmers 和 Höcker，2003 年），也可以通过求解大型线性系统隐式实现（Hale，2009 年）。在本文中，我们使用 FED 方法（Grewenig 等人，2010 年；Weickert 等人，2016 年）更高效地求解各向异性扩散滤波器。然后，我们将用一个简单的一维均质扩散问题来解释 FED 方法。</p>\n<p><img data-src=\"https://ptpimg.me/eyp6ra.jpg\" alt=\"\" /></p>\n<p>Figure 2. Eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> of a 3D structure tensor are displayed on a stratigraphic surface with a channel. The vector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> is orthogonal to the surface and the channel. The vectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> lie within the local plane of the surface and are laterally perpendicular and parallel to the channel, respectively.</p>\n<p>图 2. 三维结构张量的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 显示在带有通道的地层表面上。向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与地表和通道正交。矢量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 位于地层表面的局部平面内，分别与通道横向垂直和平行。</p>\n<p><img data-src=\"https://ptpimg.me/7i2qme.jpg\" alt=\"\" /></p>\n<p>Figure 3. (a) Smoothed image computed by Hale’s method (computational time: 0.086 s). (b) Input-output difference.</p>\n<p>图 3. (a) 用 Hale 方法计算的平滑图像（计算时间：0.086 秒）。(b) 输入输出差值。</p>\n<h2 id=\"1d-linear-diffusion\"><a class=\"anchor\" href=\"#1d-linear-diffusion\">#</a> 1D linear diffusion</h2>\n<p>一维线性扩散</p>\n<p>A 1D homogeneous diffusion of a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x;t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> can be expressed as</p>\n<p>函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x;t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> 的一维均匀扩散可表示为</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">∂</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi mathvariant=\"normal\">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mi mathvariant=\"normal\">∂</mi><mrow><mi mathvariant=\"normal\">∂</mi><mi>x</mi></mrow></mfrac><mfrac><mrow><mi mathvariant=\"normal\">∂</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi mathvariant=\"normal\">∂</mi><mi>x</mi></mrow></mfrac><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mn>5</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{ {\\partial g(x;t) } \\over {\\partial t}} = {\\partial  \\over {\\partial x} } { {\\partial g(x;t)} \\over {\\partial x} }.(5)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\">5</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> denote the spatial mesh size and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>τ</mi><mo>&gt;</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau (\\tau  &gt; 0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> denote the time step size, and then the discretization of the above equation at a spatial-time-grid point <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({x_i};{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>:</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">{x_i}: = (i - (1/2))h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/2</span><span class=\"mclose\">))</span><span class=\"mord mathnormal\">h</span></span></span></span> and t${t_k}: = k\\tau $ can be formulated as</p>\n<p>设 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span> 表示空间网格大小，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo stretchy=\"false\">(</mo><mi>τ</mi><mo>&gt;</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tau (\\tau  &gt; 0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> 表示时间步长，则上述方程在时空网格点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({x_i};{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 处的离散化公式为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>:</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">{x_i}: = (i - (1/2))h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/2</span><span class=\"mclose\">))</span><span class=\"mord mathnormal\">h</span></span></span></span> 和 ${t_k}: = k\\tau $</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">;</mo><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><mi>τ</mi><mi mathvariant=\"normal\">Δ</mi><mo stretchy=\"false\">)</mo><mi>g</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>6</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g( {x_i} ;{t_{k + 1} } ) = (I + \\tau \\Delta )g( {x_i};{t_k}),(6)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mord\">Δ</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is the identity operator and $\\Delta $ represents the discrete second derivative operator.</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> 是同一算子，$\\Delta $ 代表离散二阶导数算子。</p>\n<p>Iteratively solving the above diffusion equation 6 with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{g_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is equivalent in applying a Gaussian smoothing filter to the discretized sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{g_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> (Weickert, 1997; Grewenig et al, 2010). This diffusion process with stop time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">{t_k} = {\\sigma ^2}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span></span></span></span> yields the comparable smoothing extent of a Gaussian smoothing filter with the half-width $\\sigma $ (Weickert, 1998). Because the stability restriction for the time step size is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo>≤</mo><msup><mi>h</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\tau  \\le {h^2}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span></span></span></span>, a diffusion filter requires at least <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">{\\sigma ^2}/{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> steps to produce the smoothing extent of $\\sigma $.</p>\n<p>用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{g_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 迭代求解上述扩散方程 6 相当于对离散序列 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{g_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 应用高斯平滑滤波器（Weickert，1997 年；Grewenig 等人，2010 年）。该扩散过程的停止时间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">{t_k} = {\\sigma ^2}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span></span></span></span> 与半宽度为 $\\sigma $ 的高斯平滑滤波器的平滑程度相当（Weickert，1998 年）。由于时间步长的稳定性限制为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo>≤</mo><msup><mi>h</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\tau  \\le {h^2}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span></span></span></span>，因此扩散滤波器至少需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">{\\sigma ^2}/{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 步才能产生 $\\sigma $ 的平滑范围。</p>\n<p>To improve the efficiency of the diffusion filter, some authors propose to compute semi-implicit (Drblkov and Mikula, 2008) or implicit numerical (Hale, 2009) solutions of the diffusion equation 5 with several large time steps or a single step. However, these semi-implicit and implicit schemes are often more difficult to implement than the explicit scheme (equation 6) and need to solve large linear systems (Grewenig et al, 2010). In this paper, we use the FED method, proposed by Grewenig et al (2010) and Weickert et al (2016), to solve the explicit diffusion (equation 6) with fewer time steps than a conventional explicit method.</p>\n<p>为了提高扩散滤波器的效率，一些学者提出用几个大的时间步或单步计算扩散方程 5 的半隐式（Drblkov 和 Mikula，2008 年）或隐式数值解（Hale，2009 年）。然而，这些半隐式和隐式方案往往比显式方案（方程 6）更难实现，而且需要求解大型线性系统（Grewenig et al, 2010）。在本文中，<strong>我们使用 Grewenig 等人（2010 年）和 Weickert 等人（2016 年）提出的 FED 方法，以比传统显式方法更少的时间步数求解显式扩散（方程 6）</strong>。</p>\n<h2 id=\"cyclic-scheme\"><a class=\"anchor\" href=\"#cyclic-scheme\">#</a> Cyclic scheme</h2>\n<p>循环计划</p>\n<p>The FED method can be considered as a variant of super time stepping schemes that use a set of different time step sizes for the explicit diffusion. As discussed by Grewenig et al (2010), the FED method is based on two aspects: (1) A Gaussian filter can be approximated by several iterated box filters, and (2) a discrete box filter is equivalent to a cycle of several explicit diffusion steps with varying time step sizes. Therefore, the FED method approximates a diffusion filter with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> iterated cycles of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> explicit diffusion steps with varying time step sizes.</p>\n<p>FED 方法可视为超时间步长方案的一种变体，它使用一组不同的时间步长来进行显式扩散。正如 Grewenig 等人（2010 年）所论述的，FED 方法基于两个方面：（1）高斯滤波器可以用多个迭代盒式滤波器来近似；（2）离散盒式滤波器等同于多个显式扩散步长的循环，其时间步长各不相同。因此，FED 方法用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 个不同时间步长 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 显式扩散步的迭代循环来近似扩散滤波器。</p>\n<p>As discussed by Grewenig et al (2010) and Weickert et al (2016), three (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>) iterated box filters can yield good approximation of a Gaussian filter. In addition, a box filter $B_<ruby>2n + 1}<rp>(</rp><rt>h{g_i</rt><rp>)</rp></ruby> = \\sum\\nolimits_<ruby>k =  - n}<rp>(</rp><rt>n {(1/(2n + 1)){g_k</rt><rp>)</rp></ruby>} $ is equivalent to a cycle of n explicit diffusions steps: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>B</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>h</mi></msubsup><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>I</mi></mrow></msubsup><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><msub><mi>τ</mi><mi>i</mi></msub><mi mathvariant=\"normal\">Δ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">B_{2n + 1}^h = \\prod _{i = 0}^{n - I} (I + {\\tau _i}\\Delta )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1555em;vertical-align:-0.3064em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-2.4519em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3064em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2809em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord\">Δ</span><span class=\"mclose\">)</span></span></span></span> with the varying time step sizes</p>\n<p>正如 Grewenig 等人（2010 年）和 Weickert 等人（2016 年）所讨论的，三个（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> ）迭代盒式滤波器可以很好地近似高斯滤波器。此外，盒式滤波器 $B_<ruby>2n + 1}<rp>(</rp><rt>h{g_i</rt><rp>)</rp></ruby> = \\sum\\nolimits_<ruby>k =  - n}<rp>(</rp><rt>n {(1/(2n + 1)){g_k</rt><rp>)</rp></ruby>} $ 相当于 n 个显式扩散步骤的循环： B<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>B</mi><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mi>h</mi></msubsup><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>I</mi></mrow></msubsup><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><msub><mi>τ</mi><mi>i</mi></msub><mi mathvariant=\"normal\">Δ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">B_{2n + 1}^h = \\prod _{i = 0}^{n - I}(I + {\\tau _i}\\Delta )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1555em;vertical-align:-0.3064em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-2.4519em;margin-left:-0.0502em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3064em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2809em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord\">Δ</span><span class=\"mclose\">)</span></span></span></span> ，时间步长不同</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>τ</mi><mi>i</mi></msub><mo>=</mo><mfrac><msup><mi>h</mi><mn>2</mn></msup><mrow><mn>4</mn><msup><mi>cos</mi><mo>⁡</mo><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi>π</mi><mfrac><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mn>4</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mo stretchy=\"false\">)</mo></mrow></mfrac><mo stretchy=\"false\">(</mo><mn>7</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\tau _i} = { { {h^2} } \\over { 4 { {\\cos } ^2} (\\pi { { 2i + 1} \\over {4n + 2} } ) } } (7)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.6401em;vertical-align:-1.149em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.4911em;\"><span style=\"top:-2.2543em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mop\">cos</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7401em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8557em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4033em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mclose\">)</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.149em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">7</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>and the corresponding stopping diffusion time</p>\n<p>以及相应的停止扩散时间</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>τ</mi><mi>i</mi></msub><mo>=</mo><mfrac><msup><mi>h</mi><mn>2</mn></msup><mn>6</mn></mfrac><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{t_n} = \\sum\\limits_ {i = 0} ^ {n - 1} { {\\tau _i} }  = { { { h^2} } \\over 6} ( {n^2} + n)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.0788em;vertical-align:-1.2777em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8011em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2777em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1771em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.4911em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">6</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>To explain how this cyclic scheme improves the efficiency of a diffusion filter, let us consider approximating a Gaussian filter with half-width <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>72</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">{\\sigma ^2} = 72{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">72</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>, which corresponds to a diffusion time of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>36</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">T = (1/2){\\sigma ^2} = 36{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/2</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">36</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>. The conventional explicit scheme requires at least 72 diffusion steps with a constant time step size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo>=</mo><msup><mi>h</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\tau  = {h^2}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span></span></span></span>. Using the cyclic scheme with three cycles (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>), we need to implement each cycle of explicit diffusion with a diffusion time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mi>T</mi><mo>=</mo><mn>12</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(1/3)T = 12{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/3</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">12</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>. According to equation 8, the diffusion time in each cycle is given by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>h</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>6</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({h^2}/6)({n^2} + n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/6</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>. This means that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">n = 8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> diffusion steps are required to reach the time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">12{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">12</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> in each cycle. Therefore, the cyclic scheme with three cycles requires only <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>⋅</mo><mn>8</mn><mo>=</mo><mn>24</mn></mrow><annotation encoding=\"application/x-tex\">3 \\cdot 8 = 24</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">24</span></span></span></span> explicit diffusion steps to approximate the Gaussian filter <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>72</mn><msup><mi>h</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({\\sigma ^2} = 72{h^2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\">72</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, compared with at least 72 steps for a conventional explicit scheme, which significantly improves the efficiency of the explicit diffusion.</p>\n<p>为了解释这种循环方案如何提高扩散滤波器的效率，让我们考虑近似半宽为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>72</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">{\\sigma ^2} = 72{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">72</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 的高斯滤波器，它对应的扩散时间为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">)</mo><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>36</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">T = (1/2){\\sigma ^2} = 36{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/2</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">36</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>。传统的显式方案至少需要 72 个扩散步骤，时间步长为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi><mo>=</mo><msup><mi>h</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\tau  = {h^2}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span></span></span></span>。使用三个周期的循环方案（<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>），我们需要在扩散时间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mi>T</mi><mo>=</mo><mn>12</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(1/3)T = 12{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1/3</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">12</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 的条件下实现每个周期的显式扩散。根据公式 8，每个周期的扩散时间为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>h</mi><mn>2</mn></msup><mi mathvariant=\"normal\">/</mi><mn>6</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({h^2}/6)({n^2} + n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/6</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。这意味着在每个循环中需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">n = 8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span> 个扩散步骤才能达到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>12</mn><msup><mi>h</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">12{h^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">12</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 的时间。因此，三个周期的循环方案只需要 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>⋅</mo><mn>8</mn><mo>=</mo><mn>24</mn></mrow><annotation encoding=\"application/x-tex\">3 \\cdot 8 = 24</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">24</span></span></span></span> 个显式扩散步骤就可以近似高斯滤波器<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>72</mn><msup><mi>h</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({\\sigma ^2} = 72{h^2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\">72</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">h</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> ，而传统的显式方案至少需要 72 个步骤，这大大提高了显式扩散的效率。</p>\n<p>Although the FED method is derived from the 1D linear homogeneous diffusion filter (equation 5), it is actually a general paradigm that is applicable to multidimensional, nonlinear, and anisotropic diffusion filters (Grewenig et al, 2010). Then, we will discuss how to use this efficient FED method in 2D and 3D nonlinear and anisotropic diffusion to simultaneously enhance seismic reflections, faults, and channels.</p>\n<p><strong>虽然 FED 方法源于一维线性均质扩散滤波器（方程 5），但它实际上是一种适用于多维、非线性和各向异性扩散滤波器的通用范式（Grewenig 等人，2010 年）</strong>。然后，我们将讨论如何在二维和三维非线性及各向异性扩散中使用这种高效的 FED 方法，以同时增强地震反射、断层和道。</p>\n<h2 id=\"enhancing-seismic-reflections-faults-and-channels\"><a class=\"anchor\" href=\"#enhancing-seismic-reflections-faults-and-channels\">#</a> Enhancing seismic reflections, faults, and channels</h2>\n<p>增强地震反射、断层和通道</p>\n<p>Using a diffusion filter to enhance anisotropic (linear in two dimensions and planar in three dimensions) reflections in a seismic image, we expect the diffusion to be anisotropic and aligned in directions along the seismic reflections. As discussed by Fehmers and Höcker (2003) and Hale (2009), such anisotropic diffusion can be designed by steering the diffusion with a diffusion tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>:</p>\n<p>使用扩散滤波器增强地震图像中的各向异性（二维为线性，三维为平面）反射时，我们希望扩散是各向异性的，并沿着地震反射的方向排列。正如 Fehmers 和 Höcker（2003 年）以及 Hale（2009 年）所讨论的，这种各向异性扩散可通过用扩散张量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 引导扩散来设计：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">∂</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi mathvariant=\"normal\">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi mathvariant=\"normal\">∇</mi><mo>⋅</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>9</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{ {\\partial g(x;t) } \\over {\\partial t} } = \\nabla  \\cdot D(x)\\nabla g(x;t),(9)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">∇</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">9</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> represents the 2D or 3D spatial coordinates, $\\nabla $ is the gradient operator, and the diffusion tensor field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> can be constructed from eigenvectors of seismic structure tensors.</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 代表二维或三维空间坐标，$\\nabla $ 是梯度算子，<strong>扩散张量场 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 可由地震结构张量的特征向量构建</strong>。</p>\n<h2 id=\"diffusion-with-reflection-enhancement\"><a class=\"anchor\" href=\"#diffusion-with-reflection-enhancement\">#</a> Diffusion with reflection enhancement</h2>\n<p>反射增强扩散</p>\n<p>As discussed previously in this paper, the eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> corresponding to the maximum eigenvalue of a structure tensor (equations 2 and 4) is perpendicular to seismic reflections, whereas the other eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and w are aligned with seismic reflections. Therefore, to enhance seismic reflections, we should smooth the seismic image in directions of v in two dimensions or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> in three dimensions, but we avoid smoothing in the direction along <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>. To steer the diffusion in directions along <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and w for seismic reflection enhancing, we can construct the diffusion tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> as</p>\n<p>正如本文前面所讨论的，与结构张量（等式 2 和 4）最大特征值相对应的特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与地震反射垂直，而其他特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 w 则与地震反射对齐。因此，为了增强地震反射，我们应该在二维的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 或三维的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 方向上平滑地震图像，但要避免扩散张量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 沿 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 方向上的平滑。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>μ</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mi>μ</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>10</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x) = {\\mu _v} (x) v(x) {v^T} (x) + {\\mu _w} (x) w (x) {w^T} (x),(10)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1413em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1413em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">10</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where the weights <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>μ</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le {\\mu _v}(x) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>μ</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le {\\mu _w}(x) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> are used to design a diffusion filter with spatially variant smoothing extents. In most cases, we can set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>μ</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{\\mu _v}(x) = {\\mu _w}(x) = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, which yields a spatially invariant and isotropic smoothing extent in the directions along vectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>. In 2D cases, a diffusion tensor field for reflection enhancing can be constructed with only the eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>:</p>\n<p>其中权值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>μ</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le {\\mu _v}(x) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>μ</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le {\\mu _w}(x) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 用于设计具有空间变化平滑范围的扩散滤波器。在大多数情况下，我们可以设置 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>μ</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{\\mu _v}(x) = {\\mu _w}(x) = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>，这样就可以在沿 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 方向上得到空间不变特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 的各向同性平滑范围：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>μ</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>11</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x) = {\\mu _v}(x)v(x){v^T}(x),(11)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1413em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">11</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>The multidimensional and anisotropic diffusion (equation 9) can also be solved explicitly in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> diffusion steps:</p>\n<p>多维和各向异性扩散（方程 9）也可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 个扩散步骤中明确求解：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">;</mo><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><mi>τ</mi><mi mathvariant=\"normal\">∇</mi><mo>⋅</mo><mi>D</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mo stretchy=\"false\">)</mo><mi>g</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>12</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g( {x_i};{t_{k + 1} } ) = (I + \\tau \\nabla  \\cdot D ( {x_i} ) \\nabla ) g ( {x_i};{t_k} ) ) ,(12)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"mord\">∇</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">))</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">12</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>with an initial image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x;{t_0}) = g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and a constant time step size $\\tau $. To speed up the diffusion process, we can also use the FED method with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> cycles of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> explicit diffusion steps. In all examples in this paper, we use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> for the number of FED cycles. We use equation 8 to compute the smallest number of steps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> in one cycle such that the stopping time t<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub><mo>≈</mo><mi>T</mi><mi mathvariant=\"normal\">/</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">{t_n} \\approx T/M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> . For step <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> in each cycle, we compute the time step size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\tau _i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> using equation 7. The FED method for anisotropic diffusion with reflection enhancing can be described as in the following pseudocodes in Algorithm 1.</p>\n<p>具有初始图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x;{t_0}) = g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和恒定时间步长 $\\tau $ 。为了加快扩散过程，我们还可以使用具有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 个周期的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个显式扩散步骤的 FED 方法。在本文的所有例子中，我们使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> 来表示 FED 周期的数量。我们使用公式 8 来计算一个周期中的最小步数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> ，使得停止时间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub><mo>≈</mo><mi>T</mi><mi mathvariant=\"normal\">/</mi><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">{t_n} \\approx T/M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 。对于每个周期中的步骤 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> ，我们使用公式 7 来计算时间步长 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\tau _i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1132em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 。用于具有反射增强的各向异性扩散的 FED 方法可以描述为算法 1 中的以下伪代码。</p>\n<p>Figure 4 shows a 2D example of using anisotropic diffusion to enhance seismic reflections. In this example, we set the stopping time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">T = 32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">32</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>, which yields 24 explicit diffusion steps to compute the smoothed seismic image shown in Figure 4a. With an eight-core computer, computing the smoothed image in Figure 4a takes only 0.037 s compared to 0.086 s in computing the smoothed image in Figure 3a by using the structureoriented smoothing method (Hale, 2009). In this example, we construct the diffusion tensor field as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>r</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{D_r}(x) = v(x){v^T}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, which yields an anisotropic diffusion with a constant smoothing extent along seismic reflections. We observe that the seismic reflections in the smoothed image (Figure 4a) are cleaner and more continuous compared to the input seismic image (Figure 1a). Most of the noise in the original seismic image (Figure 1a) is removed as shown in the input-output difference image (Figure 4b). However, the faults, recognized as lateral discontinuities in the seismic image, are also smoothed out because of the constant-extent smoothing along seismic reflections.</p>\n<p>图 4 显示了使用各向异性扩散增强地震反射的二维示例。在这个例子中，我们设置了停止时间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">T = 32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">32</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>，这样就有 24 个显式扩散步骤来计算图 4a 所示的平滑地震图像。使用八核计算机计算图 4a 中的平滑图像仅需 0.037 秒，而使用面向结构的平滑方法计算图 3a 中的平滑图像则需 0.086 秒（Hale，2009 年）。在本例中，我们将扩散张量场构建为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>r</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{D_r}(x) = v(x){v^T}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> ，从而得到沿地震反射方向具有恒定平滑范围的各向异性扩散。我们观察到，与输入地震图像（图 1a）相比，平滑后图像（图 4a）中的地震反射更清晰、更连续。如输入输出差分图像（图 4b）所示，原始地震图像（图 1a）中的大部分噪声被去除。然而，由于沿地震反射进行了恒定延伸平滑处理，在地震图像中被识别为横向不连续的断层也被平滑掉了。</p>\n<h2 id=\"diffusion-with-reflection-and-fault-enhancement\"><a class=\"anchor\" href=\"#diffusion-with-reflection-and-fault-enhancement\">#</a> Diffusion with reflection and fault enhancement</h2>\n<p>带有反射和断层增强的扩散</p>\n<p>To preserve reflection discontinuities at faults, we should stop the anisotropic diffusion near the faults. This means that we need to construct anisotropic diffusion with spatially variant smoothing extents, which can be designed using diffusion tensors with spatially variant weights as shown in equations 10 and 11. Such spatially variant diffusion is similar to the problem of diffusion with edge preserving (e.g., Alvarez et al, 1992; Weickert, 1997, 2001; Fehmers and Höcker, 2003; Hale, 2009). Hale (2009) first computes an image of faults or edges and then uses the image to stop diffusion across the faults. In this method, the fault image is not updated and therefore the diffusion is linear. Most methods (Alvarez et al, 1992; Weickert, 1997, 2001; Fehmers and Höcker, 2003) construct nonlinear diffusion for preserving edges, which keeps updating the edge image while iteratively performing the diffusion process. Linear diffusion without updating the edge image is often more efficient. Nonlinear diffusion is less efficient, but it can gradually update the edge image during the diffusion process. In this paper, we apply nonlinear diffusion to iteratively update the image of seismic faults while smoothing seismic reflections. We also apply approximate fault-oriented smoothing to the fault image to enhance the fault features. This iteratively updated and enhanced fault image is used to preserve discontinuities corresponding to faults in the smoothed seismic image, and it also provides a good detection of faults.</p>\n<p><strong>为了保留断层处的反射不连续性，我们应该在断层附近停止各向异性扩散。这意味着我们需要构建各向异性扩散的空间变化平滑扩展，可以使用具有空间变化权重的扩散张量来设计</strong>，如等式 10 和 11 所示。这种空间变化扩散类似于边缘保留扩散问题（例如，Alvarez 等人，1992 年；Weickert，1997 年，2001 年；Fehmers 和 Höcker，2003 年；Hale，2009 年）。Hale (2009) 首先计算出断层或边缘的图像，然后使用该图像来阻止跨断层的扩散。在这种方法中，断层图像不会更新，因此扩散是线性的。大多数方法（Alvarez 等人，1992 年；Weickert，1997 年，2001 年；Fehmers 和 Höcker，2003 年）为保留边缘构建了非线性扩散，在迭代执行扩散过程的同时不断更新边缘图像。<strong>不更新边缘图像的线性扩散通常效率更高。非线性扩散的效率较低，但它可以在扩散过程中逐步更新边缘图像</strong>。<strong>在本文中，我们应用非线性扩散来迭代更新地震断层图像，同时平滑地震反射。我们还对断层图像进行了近似断层导向平滑处理，以增强断层特征</strong>。<strong>这种迭代更新和增强的断层图像可用于保留平滑地震图像中与断层相对应的不连续性，同时还可用于识别断层</strong>。</p>\n<p><img data-src=\"https://ptpimg.me/pgxt7s.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://ptpimg.me/18890v.jpg\" alt=\"\" /></p>\n<p>Figure 4. (a) Smoothed image computed by the proposed fast anisotropic diffusion with reflection enhancing (computational time: 0.037 s). (b) Input-output difference.</p>\n<p>图 4. (a) 利用拟议的快速各向异性扩散和反射增强计算出的平滑图像（计算时间：0.037 秒）。(b) 输入输出差值。</p>\n<p>To detect edges in an image, Weickert (2001) uses a scalar-valued diffusivity function defined as</p>\n<p>为了检测图像中的边缘，Weickert（2001 年）使用了标量值扩散函数，其定义为</p>\nw(x) = \\{ \\matrix{\n   {1,{d^2}(x) = 0}  \\cr \n   {1 + \\exp ( - { {3.315} \\over { { { ( {d^2}(x)/{a^2})}^4 } } } ) , {d^2}(x) > 0,(14)}  \\cr \n\n }\n\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is defined as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d(x) = {v^T}(x)\\nabla g(x) + {w^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. The functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{v^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{w^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> represent the directional derivatives of the seismic image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> in the directions along eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, respectively. Because the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> are aligned within the seismic reflections, the directional derivatives are computed along the seismic reflections. In 2D cases, the directional derivatives are computed only along the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x):d(x) = {v^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. Of course, there are a lot more sophisticated seismic attributes including semblance (Marfurt et al, 1998), coherency (Marfurt et al, 1999), variance (Van Bemmel and Pepper, 2000; Randen et al, 2001),and fault likelihoods (Hale, 2013) that may be even better than the structure-oriented diffusivity to detect faults from an original noisy seismic image. However, as denoted in equation 14, computing the diffusivity is much more efficient than all of these sophisticated attributes, and we will show that the diffusivity will be gradually updated and enhanced during our iterative diffusion and eventually provide a good detection of faults.</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 定义为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d(x) = {v^T}(x)\\nabla g(x) + {w^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 。函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{v^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{w^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 分别表示地震图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 沿特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 方向的方向导数。由于特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 在地震反射内对齐，因此方向导数沿地震反射计算。在二维情况下，只沿特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∇</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x):d(x) = {v^T}(x)\\nabla g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 计算方向导数 。当然，还有许多更复杂的地震属性，包括形似性（Marfurt 等，1998 年）、一致性（Marfurt 等，1999 年）、方差（Van Bemmel 和 Pepper，2000 年；Randen 等，2001 年）和断层似然（Hale，2013 年），这些属性可能比面向结构的扩散性更适合从原始噪声地震图像中探测断层。然而，如公式 14 所示，计算扩散率比所有这些复杂的属性都要有效得多，我们将证明扩散率将在迭代扩散过程中逐渐更新和增强，并最终提供良好的断层检测。</p>\n<p>Figure 5a shows a fault image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x) = 1 - s(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> , where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is diffusivity computed using equation 14 with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.12</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 0.12</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.12</span></span></span></span>. In this image, the features with relatively high values detect the fault positions in the seismic image but also highlight noise, which does not correspond to faults. In addition, the fault features are discontinuous as shown in this image (Figure 5). Therefore, we might want to further smooth the fault image along fault orientations so that the fault features are enhanced and more continuous while the features unrelated to faults are suppressed.</p>\n<p>图 5a 显示了断层图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x) = 1 - s(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 是利用公式 14 计算的扩散率，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.12</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 0.12</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.12</span></span></span></span>。在该图像中，数值相对较高的地物探测到了地震图像中的断层位置，但同时也突出了与断层不对应的噪声。此外，如该图像所示，断层特征是不连续的（图 5）。因此，我们可能希望沿断层方向进一步平滑断层图像，从而增强断层特征并使其更加连续，同时抑制与断层无关的特征。</p>\n<p>As discussed by Bakker (2002) and Hale (2009), faults often cut through multiple reflections and are often approximately dipping in directions perpendicular to seismic reflections. Therefore, the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> can be good approximations of the fault dip directions in most cases. Also as shown by Wu (2017), the fault strike directions can be approximated by eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. Therefore, we may want to smooth the diffusivity or fault image (Figure 5) in directions of eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> to enhance the image features related to faults and suppress noise that is often arbitrarily oriented. To smooth the image along the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, we use the anisotropic diffusion described in Algorithm 1 with the diffusion tensor field constructed as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mrow><mi>u</mi><mi>w</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>u</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{D_{uw}}(x) = u(x){u^T}(x) + w(x){w^T}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. In 2D cases, we smooth the fault image (Figure 5) along the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> with the diffusion tensor constructed as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>u</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x) = u(x){u^T}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. Figure 5a shows smoothed fault image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>s</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{f_u}(x) = 1 - {s_u}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mo fence=\"true\">⟨</mo><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo fence=\"true\">⟩</mo></mrow><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{s_u}(x) = {\\left\\langle {s(x)} \\right\\rangle _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> and the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> represent the anisotropic diffusion in directions along eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. The fault features in this image (Figure 5b) are more continuous compared with the one (Figure 5a) before the smoothing. However, we do not expect faults to be as thick as the features apparent in this image (Figure 5b). Therefore, we keep only the values on the ridges of the image and we set the values elsewhere to be zero to compute the corresponding thinned image as shown in Figure 6a. In this thinned image (Figure 6a), nonzero values are apparent at samples that are on faults but also at samples unrelated to faults. However, this is just an initial map of faults used to stop smoothing at faults in the nonlinear diffusion process. This map will be iteratively updated and improved during the iterative anisotropic diffusion process.</p>\n<p>正如 Bakker（2002）和黑尔（2009）所讨论的，<strong>断层通常穿过多次反射，并且通常大致倾斜于垂直于地震反射的方向</strong>。因此，在<strong>大多数情况下，特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 可以很好地近似断层倾角方向</strong>。同样如 Wu（2017）所示，<strong>断层走向方向可以通过特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 来近似</strong>。因此，我们可能希望在特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的方向上平滑扩散率或断层图像（图 5），以增强与断层相关的图像特征并抑制通常任意定向的噪声。为了沿着特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 平滑图像，我们使用算法 1 中描述的各向异性扩散，其中扩散张量场被构造为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mrow><mi>u</mi><mi>w</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>u</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{D_{uw}}(x) = u(x){u^T}(x) + w(x){w^T}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 。在 2D 情况下，我们沿着特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 平滑断层图像（图 5），扩散张量构造为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>u</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x) = u(x){u^T}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 。图 5a 示出了平滑的断层图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>s</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{f_u}(x) = 1 - {s_u}(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> ，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mo fence=\"true\">⟨</mo><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo fence=\"true\">⟩</mo></mrow><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{s_u}(x) = {\\left\\langle {s(x)} \\right\\rangle _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo fence=\"true\">⟨</mo><mo>⋅</mo><mo fence=\"true\">⟩</mo></mrow><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">{\\left\\langle  \\cdot  \\right\\rangle _u}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\">⋅</span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> 表示沿着特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 方向的各向异性扩散。该图像中的断层特征（图 5b）与平滑之前的断层特征（图 5a）相比更加连续。然而，我们并不期望断层像这幅图中明显的特征那样厚（图 5b）。因此，我们仅保留图像的脊上的值，并且我们将其他地方的值设置为零以计算对应的细化图像，如图 6a 所示。在该细化图像（图 6a）中，非零值在断层上的样本处明显，但在与断层无关的样本处也明显。然而，这只是用于在非线性扩散过程中的断层处停止平滑的故障的初始映射。该图将在迭代各向异性扩散过程期间迭代地更新和改进。</p>\n<p>The nonlinear and anisotropic diffusion for enhancing seismic reflections and updating the fault map can be described as in the pseudocodes in Algorithm 2.</p>\n<p>用于增强地震反射和更新断层图的非线性和各向异性扩散可以描述为算法 2 中的伪代码。</p>\n<p>In this algorithm of anisotropic diffusion with fault enhancing, we do not update the diffusion tensor field at each diffusion step <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> ; instead, we only update it at each cycle <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>:</mo><msub><mi>D</mi><mi>f</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">k:{D_f}(x;{t_k}) = {s_t}(x;{t_k})v{v^T} + {s_t}(x;{t_k})w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> , where only the thinned and smoothed diffusivity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is updated at each cycle but the vectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are not updated. This means that the diffusivity and diffusion tensor field are computed only <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> in this paper) times during the whole diffusion process. In 2D cases, the diffusion tensor field is computed using only the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><msub><mi>D</mi><mi>f</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">v(x):{D_f}(x;{t_k})v{v^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1274em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span>. Using this method, we are able to simultaneously obtain a smoothed seismic image with fault preservation and an enhanced fault image that highlights fault locations.</p>\n<p>在这种带断层增强的各向异性扩散算法中，我们在每个扩散步骤 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 不更新扩散张量场；相反，我们只在每个周期 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>:</mo><msub><mi>D</mi><mi>f</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">k:{D_f}(x;{t_k}) = {s_t}(x;{t_k})v{v^T} + {s_t}(x;{t_k})w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> 更新它：，其中只有变薄和平滑的扩散率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 在每个周期更新，但不更新矢量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 。这意味着在整个扩散过程期间仅计算扩散率和扩散张量场<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>（在本文中为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>）次。在 2D 情况下，仅使用本征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>:</mo><msub><mi>D</mi><mi>f</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">v(x):{D_f}(x;{t_k})v{v^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1274em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> 来计算扩散张量场。使用这种方法，我们能够同时获得一个平滑的地震图像与断层保存和增强的断层图像，突出断层位置。</p>\n<p>Figure 6b shows the finally updated fault image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{f_t}(x) = 1 - {s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> overlaid with the finally updated seismic image. We observe that a lot of suspicious features in the initial fault image (Figure 6a) are removed in the updated fault image (Figure 6b). The nonzero samples in the initial fault image (Figure 6a) indicate that the left- and right-neighboring reflections of these samples are discontinuous. However, such reflection discontinuities do not necessarily correspond to faults and they may actually correspond to noise. During the nonlinear and anisotropic diffusion process (Algorithm 2), smoothing is performed along the left and right reflections of these nonzero samples, but it is stopped at these samples. After some diffusion steps, the noise on the left and right reflections of these nonzero samples will be smoothed out. The smoothed reflections on the left and right sides of these nonzero samples will become consistent and continuous if these samples do not correspond to faults, but the left and right reflections will be still discontinuous and inconsistent if these samples correspond to true faults. Therefore, in the updated fault image (Figure 6b), the nonzero values corresponding to noise are removed whereas those corresponding to true faults are preserved. This updated fault image provides a good detection of the fault positions.</p>\n<p>图 6b 显示了最终更新的断层图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{f_t}(x) = 1 - {s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 与最终更新的地震图像的叠加。我们观察到，初始断层图像（图 6a）中的许多可疑特征在更新后的断层图像（图 6b）中被去除。初始断层图像（图 6a）中的非零样本表明这些样本的左右邻近反射是不连续的。然而，这种反射不连续并不一定与故障相对应，它们实际上可能与噪声相对应。在非线性和各向异性扩散过程中（算法 2），会沿着这些非零样本的左右反射进行平滑处理，但会在这些样本处停止。经过一些扩散步骤后，这些非零样本左右反射上的噪声将被平滑掉。如果这些非零样本对应的不是断层，则这些非零样本左右两侧的平滑反射将变得一致和连续，但如果这些样本对应的是真正的断层，则左右两侧的反射仍将是不连续和不一致的。因此，在更新后的断层图像（图 6b）中，与噪声相对应的非零值被去除，而与真正断层相对应的非零值则被保留。这种更新后的断层图像可以很好地检测出断层位置。</p>\n<p><img data-src=\"https://ptpimg.me/wfatpg.jpg\" alt=\"\" /></p>\n<p>Figure 5. Diffusivity image (a) before and (b) after anisotropic diffusion in the directions along eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>(perpendicular to the reflections).</p>\n<p>图 5. 沿特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>（垂直于反射）方向各向异性扩散之前和之后的扩散图像（a）和（b）。</p>\n<p><img data-src=\"https://ptpimg.me/3l7w9h.jpg\" alt=\"\" /></p>\n<p>Figure 6. (a) Thinned diffusivity image computed from Figure 5b by keeping its nonzero values only on the ridges. (b) Thinned diffusivity image after the anisotropic diffusion with reflection and fault enhancing.</p>\n<p>图 6. (a) 根据图 5b 计算出的稀释扩散率图像，只保留脊上的非零值。(b) 经过各向异性扩散、反射和断层增强后的稀释扩散图像。</p>\n<p><img data-src=\"https://ptpimg.me/cd3w3h.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://ptpimg.me/4u4i27.jpg\" alt=\"\" /></p>\n<p>Figure 7. (a) Smoothed image computed by the proposed anisotropic diffusion with reflection and fault enhancing. (b) Input-output difference.</p>\n<p>图 7：(a) 利用所提出的各向异性扩散计算出的平滑图像，并进行了反射和断层增强。(b) 输入输出差值。</p>\n<h2 id=\"diffusion-with-reflection-and-channel-enhancement\"><a class=\"anchor\" href=\"#diffusion-with-reflection-and-channel-enhancement\">#</a> Diffusion with reflection and channel enhancement</h2>\n<p>带有反射和通道增强功能的扩散</p>\n<p>In addition to the structural features of reflections and faults, stratigraphic features such as channels are also contained in a seismic image, as shown in Figure 8. This 3D seismic image is a subset extracted from the 1520 km2 Parihaka 3D seismic survey located at the Taranaki Basin, a broad sedimentary basin on the western side of the North Island, New Zealand. This Taranaki Basin covers approximately 100;000 km2, and the basin lying offshore is mostly at water depths between 50 and 250 m. A lot of large-scale and fine-scale channels are apparent within the acquired Parihaka 3D seismic volume (Johnston, 2014), and some of the channels are obviously visible on the time slice of the subset volume (Figure 8). Seismic channels are often aligned within dipping seismic reflections. We are able to observe channels in the horizontal time slice of the 3D seismic image in Figure 8 because the reflections in this seismic image are only slightly dipping.</p>\n<p>如图 8 所示，除了反射和断层等构造特征外，地震图像中还包含地层特征，如通道。这幅三维地震图像是从 1520 平方公里的 Parihaka 三维地震勘探中提取的子集，该勘探位于新西兰北岛西侧宽阔的沉积盆地 Taranaki 盆地。塔拉纳基盆地面积约为 100,000 平方公里，近海盆地的水深大多在 50 米至 250 米之间。在获取的帕里哈卡三维地震剖面中，可以看到许多大尺度和细尺度的地震道（Johnston，2014 年），其中一些地震道在子集剖面的时间片上清晰可见（图 8）。地震道通常在倾斜地震反射中排列。我们能够在图 8 中三维地震图像的水平时间片中观察到道，是因为该地震图像中的反射仅略微倾斜。</p>\n<p>Similar to seismic faults, the channels are also recognized as lateral discontinuities along seismic reflections as shown in the vertical slices in the 3D seismic image (Figure 8). Therefore, if we apply the structure-oriented smoothing method (Hale, 2009) to smooth the seismic image along seismic reflections, we are able to enhance the reflections but also smooth out the channels as shown in Figure 9. Similarly, if we perform simple anisotropic diffusion (Algorithm 1) along seismic reflections, we obtain almost the same smoothed results as shown in Figure 10. Figure 10a and 10b, respectively, shows the smoothed image and input-output difference image computed using the anisotropic diffusion (Algorithm 1) with a diffusion tensor field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> defined as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">D(x) = v{v^T} + w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9247em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span>. In Figure 10a and 10b, we observe that noise is removed and reflections are more continuous as shown in the vertical slices but the channels are also removed as shown in the horizontal time slices. Note that the fast explicit anisotropic diffusion used in this paper requires only 24.9 s to compute the smoothed image in Figure 10a compared with 43.8 s to compute the smoothed image in Figure 9a by using Hale’s method, which, again, demonstrates that the FED method is much more efficient.</p>\n<p>与地震断层类似，道也被认为是地震反射沿线的横向不连续性，如三维地震图像（图 8）中的垂直切片所示。因此，<strong>如果我们采用面向结构的平滑方法（Hale，2009 年）来平滑地震反射沿线的地震图像，就能增强地震反射，同时也能平滑道</strong>，如图 9 所示。同样，如果我们沿地震反射进行简单的各向异性扩散（算法 1），也能得到几乎相同的平滑结果，如图 10 所示。图 10a 和 10b 分别显示了使用各向异性扩散（算法 1）计算的平滑图像和输入输出差分图像，扩散张量场 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 定义为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">D(x) = v{v^T} + w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9247em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span>。在图 10a 和 10b 中，我们观察到噪声被去除，反射更加连续，如垂直切片所示，但通道也被去除，如水平时间切片所示。请注意，本文中使用的快速显式各向异性扩散计算图 10a 中的平滑图像只需要 24.9 秒，而使用 Hale 方法计算图 9a 中的平滑图像则需要 43.8 秒，这再次表明 FED 方法要高效得多。</p>\n<p><img data-src=\"https://ptpimg.me/7kw64g.jpg\" alt=\"\" /></p>\n<p>Figure 8. A 3D seismic image with channels apparent on the time slice.</p>\n<p>图 8. 三维地震图像，时间切片上有明显的道。</p>\n<p><img data-src=\"https://ptpimg.me/s7573a.jpg\" alt=\"\" /></p>\n<p>Figure 9. (a) Smoothed image computed by Hale’s method (computational time: 43.8 s). (b) Input-output difference.</p>\n<p>图 9. (a) 用 Hale 方法计算的平滑图像（计算时间：43.8 秒）。(b) 输入输出差值。</p>\n<p><img data-src=\"https://ptpimg.me/133x4f.jpg\" alt=\"\" /></p>\n<p>Figure 10. (a) Smoothed image computed by the proposed fast anisotropic diffusion with reflection enhancing (computational time: 24.9 s). (b) Input-output difference.</p>\n<p>图 10 (a) 利用拟议的快速各向异性扩散和反射增强计算出的平滑图像（计算时间：24.9 秒）。(b) 输入输出差值。</p>\n<p>Because the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> are laterally perpendicular to seismic channels whereas the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> are laterally parallel to the channels (Figure 2), we may define the diffusion tensor field as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">D(x) = w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> to smooth the seismic image only in directions along eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> to enhance seismic channels. Figure 11a and 11b, respectively, shows the smoothed image and input-output difference image computed using the anisotropic diffusion (Algorithm 1) with a diffusion tensor field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> defined as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">D(x) = w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> . In Figure 11a and 11b, we observe that noise is removed to some extent and reflections and channels are enhanced as shown in the vertical and horizontal slices.</p>\n<p>由于特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 在横向上垂直于地震道，而特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 在横向上平行于地震道（图 2），<strong>我们可以将扩散张量场定义为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">D(x) = w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> ，仅在沿特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的方向上平滑地震图像，以增强地震道</strong>。图 11a 和 11b 分别显示了使用各向异性扩散（算法 1）计算的平滑图像和输入输出差分图像，扩散张量场 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 定义为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">D(x) = w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> 。在图 11a 和 11b 中，我们观察到噪声在一定程度上被消除，反射和通道得到增强，如垂直和水平切片所示。</p>\n<p><img data-src=\"https://ptpimg.me/1c7bz9.jpg\" alt=\"\" /></p>\n<p>Figure 11. (a) Smoothed image by the proposed anisotropic diffusion with channel enhancing. (b) Input-output difference.</p>\n<p>图 11 (a) 利用通道增强的各向异性扩散技术平滑图像。(b) 输入输出差值。</p>\n<p><img data-src=\"https://ptpimg.me/nw92ij.jpg\" alt=\"\" /></p>\n<p>However, some noises, especially those in the crossline slice, are not removed because we smooth the image along only one direction of the eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and the noises may be coherent in this direction. Moreover, the smoothing generates some suspicious linear features in the areas highlighted by the yellow ellipses (Figure 11a), whereas the image features in the same areas of the original image (Figure 8) are actually isotropic. By smoothing along reflections in only one direction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, we actually assume that linear features, such as channels, are apparent everywhere along seismic reflections in the seismic image. This assumption is not true in most cases in which the image features along seismic reflections are mostly isotropic and are linear (anisotropic) in only limited areas. This means that the anisotropy of image features along reflections is actually spatially variant, which indicates that we should also apply spatially variant anisotropic smoothing to enhance the image features, instead of applying smoothing along eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> everywhere in the seismic image.</p>\n<p>然而，一些噪声，尤其是横线切片中的噪声，并没有被去除，因为我们只沿着特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的一个方向平滑图像，而噪声在这个方向上可能是一致的。此外，平滑处理会在黄色椭圆突出显示的区域（图 11a）产生一些可疑的线性特征，而原始图像（图 8）相同区域的图像特征实际上是各向同性的。通过只沿 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 一个方向的反射进行平滑处理，我们实际上假定地震图像中沿着地震反射的线性特征（如道）随处可见。<strong>在大多数情况下，沿地震反射方向的图像特征大多是各向同性的，只有在有限的区域内才是线性的（各向异性）</strong>。<strong>这意味着沿反射面的各向异性图像特征实际上是空间变化的，这表明我们也应该应用空间变化的各向异性平滑来增强图像特征，而不是在地震图像的任何地方应用沿特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的平滑</strong>。</p>\n<p>Specifically, in areas with isotropic features along reflections, we should apply isotropic smoothing along reflections in the directions of eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>. In areas with anisotropic (linear) features along reflections, we should apply anisotropic smoothing along reflections only in the direction of eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, which is aligned with the linear features. To implement such spatially variant (along reflections) smoothing, we use anisotropic diffusion with a diffusion tensor field defined as follows: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>15</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x) = c(x)v(x){v^T}(x) + w(x){w^T}(x),(15)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">15</span><span class=\"mclose\">)</span></span></span></span>  where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le c(x) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> is a map that highlights seismic channels with relatively low values. Near seismic channels, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is close to zero and the smoothing in the direction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> (perpendicular to channels) will be stopped. In areas without channels, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is close to one and the smoothing will be isotropic along reflections in the direction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p><strong>具体来说，在沿反射方向存在各向同性特征的区域，我们应该沿特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的方向对反射进行各向异性平滑处理。在沿反射方向存在各向异性（线性）特征的区域，我们应该只在特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的方向上沿反射方向应用各向异性平滑处理，该特征向量与线性特征对齐</strong>。为了实现这种空间变化（沿反射方向）平滑，我们使用各向异性扩散，扩散张量场定义如下： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>v</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>15</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D(x) = c(x)v(x){v^T}(x) + w(x){w^T}(x),(15)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">15</span><span class=\"mclose\">)</span></span></span></span> 其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le c(x) \\le 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7804em;vertical-align:-0.136em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 是一个突出地震道的地图，其值相对较低。<strong>在地震道附近，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 接近于零，将停止 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>（垂直于地震道）方向的平滑处理。在没有地震道的区域，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 接近于 1，沿 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 反射方向的平滑将是各向同性的</strong>。</p>\n<p>We compute such a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(c(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> of seismic channels, again, from the structure-oriented diffusivity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> (equation 14). Figure 12a shows a structure-oriented diffusivity image computed from the original 3D seismic image (Figure 8) with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 0.1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.1</span></span></span></span> . This diffusivity image highlights (with relatively low values) channels and also noise in the 3D seismic image. Similar to the diffusivity used in Algorithm 1, this diffusivity image is just an initial map of channels used to construct the diffusion tensor field. During the diffusion process, we will iteratively update the map and also enhance the map by smoothing it along channel orientations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(w(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> in each update. The pseudocodes below (Algorithm 3) describe the diffusion scheme that we used to simultaneously compute an image of channels and enhance seismic reflections and channels.</p>\n<p>我们同样根据面向结构的扩散率 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>（公式 14）计算出这样的地震道图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(c(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> 。图 12a 显示了根据原始三维地震图像（图 8）计算出的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 0.1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0.1</span></span></span></span> 的结构导向扩散图。这种扩散率图像突出了三维地震图像中的道和噪声（数值相对较低）。与算法 1 中使用的扩散率类似，该扩散率图像只是用于构建扩散张量场的初始道图。在扩散过程中，我们将迭代更新该图，并在每次更新中通过沿通道方向 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(w(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> 进行平滑来增强该图。下面的伪代码（算法 3）描述了我们用来同时计算道的动画和增强地震反射和道的扩散方案。</p>\n<p>In the whole diffusion process, we totally update the diffusivity image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> times (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span> in this paper). For each update, we smooth the diffusivity image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> in the direction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> to enhance the image features corresponding to seismic channels. This smoothed diffusivity image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mo fence=\"true\">⟨</mo><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo fence=\"true\">⟩</mo></mrow><mi>w</mi></msub></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k}) = {\\left\\langle {s(x;{t_k})} \\right\\rangle _w}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> is further used to update the diffusion tensor field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>c</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">{D_c}(x;{t_k}) = {s_w}(x;{t_k})v{v^T} + w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span>  This finally updated and smoothed diffusivity image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>M</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_M})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is also an output as a map detecting seismic channels.</p>\n<p>在整个扩散过程中，我们对扩散图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 进行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> 次（本文中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">M = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>）的完全更新。每次更新时，我们都会沿 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 方向平滑扩散图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">s(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，以增强地震道对应的图像特征。平滑后的扩散图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mo fence=\"true\">⟨</mo><mrow><mi>s</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo fence=\"true\">⟩</mo></mrow><mi>w</mi></msub></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k}) = {\\left\\langle {s(x;{t_k})} \\right\\rangle _w}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">⟨</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">⟩</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span> 进一步用于更新扩散张量场 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>c</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">{D_c}(x;{t_k}) = {s_w}(x;{t_k})v{v^T} + w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> 。最后更新和平滑的扩散图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>M</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_M})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 也作为地震道探测图输出。</p>\n<p>Figure 12b shows the final output diffusivity image in which the noise is removed and the channel features are much clearer and continuous compared to the initial diffusivity image (Figure 12a). Figure 13a shows the smoothed seismic image <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>M</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x;{t_M})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, in which the seismic reflections and channels are enhanced. In addition, the suspicious linear features, highlighted by the yellow ellipses in Figure 11a, do not appear in this smoothed seismic image (Figure 13a). From the input-output difference image shown in Figure 13b, noise in the original seismic image is removed but the seismic channels are well-preserved.</p>\n<p>图 12b 显示的是最终输出的扩散图像，与初始扩散图像（图 12a）相比，噪声被去除，道特征更加清晰和连续。图 13a 显示了平滑后的地震图像 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>M</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(x;{t_M})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，其中的地震反射和道都得到了增强。此外，图 11a 中黄色椭圆标出的可疑线性特征在平滑地震图像中没有出现（图 13a）。从图 13b 所示的输入输出差分图像来看，原始地震图像中的噪声被去除，但地震道得到了很好的保留。</p>\n<p><img data-src=\"https://ptpimg.me/e47348.jpg\" alt=\"\" /></p>\n<p>Figure 12. A diffusivity image (a) before and (b) after the anisotropic diffusion with reflection and channel enhancing.</p>\n<p>图 12. 各向异性扩散与反射和通道增强之前和之后的扩散图像（a）和（b）。</p>\n<p><img data-src=\"https://ptpimg.me/vlxm5r.jpg\" alt=\"\" /></p>\n<p>Figure 13. (a) Smoothed image by the proposed anisotropic diffusion with reflection and channel enhancing. (b) Input-output difference.</p>\n<p>图 13. (a) 利用拟议的各向异性扩散技术对图像进行平滑处理，并进行反射和通道增强。(b) 输入输出差值。</p>\n<h2 id=\"discussions\"><a class=\"anchor\" href=\"#discussions\">#</a> Discussions</h2>\n<p>In this paper, we first discussed a general method of enhancing seismic reflections, which, however, blurs faults and channels in the seismic image. We then discussed a method to simultaneously enhance reflections and faults in a seismic image while computing an image of seismic faults. We finally discussed a similar method to simultaneously enhance reflections and channels in a seismic image while computing an image of channels. We implement all the methods using the same FED scheme but with different diffusion tensor fields, which define the smoothing orientations and smoothing extents for the diffusion process.</p>\n<p>在本文中，我们首先讨论了增强地震反射的一般方法，但这种方法会模糊地震图像中的断层和道。然后，我们讨论了一种在计算地震断层图像的同时增强地震图像中反射和断层的方法。最后，我们讨论了一种类似的方法，在计算地震道图像的同时，同时增强地震图像中的反射和道。我们使用相同的 FED 方案实现了所有方法，但使用了不同的扩散张量场，这些扩散张量场定义了扩散过程的平滑方向和平滑范围。</p>\n<p>As shown in Figure 14, the diffusion tensors for the three methods, respectively, are defined as :</p>\n\\eqalign{\n  & (1).{D_r}(x) = v{v^T} + w{w^T}  \\cr \n  & (2).{D_f}(x;{t_k}) = {s_t}(x;{t_k})(v{v^T} + w{w^T})  \\cr \n  & (3).{D_c}(x;{t_k}) = {s_w}(x;{t_k})(v{v^T} + w{w^T}) \\cr}\n\n<p>As discussed in the previous sections, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> represents a thinned fault image or mapping and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> represents an image of seismic channels. From the definitions, the smoothing extents in the first method are spatially constant in the directions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> because the weights for the two terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">v{v^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> are equal to one. In the second method, the smoothing extents in the directions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are spatially variant and are defined by a weighting map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>. In the second method, the smoothing extents in the direction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> are spatially variant and are defined by a weighting map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, whereas the smoothing extents in the direction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are spatially constant.</p>\n<p>如图 14 所示，三种方法的扩散张量分别定义为：</p>\n\\eqalign{\n  & (1).{D_r}(x) = v{v^T} + w{w^T}  \\cr \n  & (2).{D_f}(x;{t_k}) = {s_t}(x;{t_k})(v{v^T} + w{w^T})  \\cr \n  & (3).{D_c}(x;{t_k}) = {s_w}(x;{t_k})(v{v^T} + w{w^T}) \\cr}\n\n<p>如前几节所述，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 代表断层薄化图像或绘图，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 代表地震道图像。根据定义，第一种方法的平滑范围在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 方向上是空间恒定的，因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">v{v^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">w{w^T}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span></span> 这两个项的权值等于 1。在第二种方法中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 方向上的平滑范围是空间变化的，由加权图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 定义。在第二种方法中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> 方向上的平滑范围在空间上是变化的，由加权图 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 定义，而 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 方向上的平滑范围在空间上是不变的。</p>\n<p>If we consider the smoothing in three directions of eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, then the diffusion in all the methods is anisotropic because in these methods we smooth a seismic image in directions parallel <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>a</mi><mi>n</mi><mi>d</mi><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u(x)andv(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> to but not perpendicular <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> to the reflections. However, because the direction of eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is not used in constructing the diffusion tensors in all three methods, we can actually consider the smoothing in only two directions of eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">&amp;</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">w(x)\\&amp; thinsp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">&amp;</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hin</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">p</span></span></span></span>;. Then, the smoothing in the first and second methods is always isotropic because the smoothing extents <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({s_t}(x;{t_k}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span> in the directions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> are always the same at each image sample <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>. The smoothing in the third method is mostly anisotropic ( <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k}) &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> in most areas) and is isotropic only in areas with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k}) = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> .</p>\n<p><strong>如果我们考虑在特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 三个方向上的平滑，那么所有方法中的扩散都是各向异性的，因为在这些方法中，我们在与反射平行 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>a</mi><mi>n</mi><mi>d</mi><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u(x)andv(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> 而非垂直 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(u(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> 的方向上平滑地震图像。然而，由于这三种方法在构建扩散张量时都不使用特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">u(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的方向，我们实际上可以只考虑特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">&amp;</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">w(x)\\&amp; thinsp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">&amp;</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">hin</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">p</span></span></span></span>; 两个方向的平滑。那么，第一种和第二种方法中的平滑总是各向同性的，因为在每个图像样本 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 上，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">w(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 方向上的平滑范围 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({s_t}(x;{t_k}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span> 总是相同的。第三种方法的平滑处理大多是各向异性的（大部分区域的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k}) &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>），只有在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k}) = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的区域才是各向同性的。</strong></p>\n<p>For seismic images with faults and channels, it is convenient to construct an anisotropic diffusion filter to simultaneously enhance reflections, faults, and channels by defining the diffusion tensor as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})[{s_w}(x;{t_k})v{v^T} + w{w^T}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>, where, again, the mappings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> highlight faults and channels with relatively low values. In this case, the diffusion will be anisotropic and the smoothing extent will be spatially variant.</p>\n<p>对于有断层和道的地震图像，可以方便地构建各向异性扩散滤波器，通过定义扩散张量为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">[</mo><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo><mi>v</mi><msup><mi>v</mi><mi>T</mi></msup><mo>+</mo><mi>w</mi><msup><mi>w</mi><mi>T</mi></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})[{s_w}(x;{t_k})v{v^T} + w{w^T}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> ，同时增强反射、断层和道，其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_t}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">;</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{s_w}(x;{t_k})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 的映射突出了值相对较低的断层和道。在这种情况下，扩散将是各向异性的，平滑程度也将是空间变化的。</p>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>We have discussed structure- and stratigraphy-oriented smoothing methods to simultaneously enhance reflections, faults, and channels in a seismic image while computing images of faults and channels. We implement these methods using FED with different diffusion tensors, which control the smoothing orientations and extents in the diffusion. In constructing such diffusion tensors, we use seismic structural and stratigraphic orientations to define the diffusion orientations and we use mappings of faults and channels to define the diffusion extents. During the entire diffusion processing, the mappings of faults and channels are iteratively updated together with the seismic image. In addition, these mappings are further enhanced at each update by fault- or channel-oriented smoothing.</p>\n<p>我们讨论了面向结构和地层的平滑方法，在计算断层和道的图像时，同时增强地震图像中的反射、断层和道。我们使用具有不同扩散张量的 FED 来实现这些方法，这些扩散张量可控制扩散中的平滑方向和范围。在构建这种扩散张量时，我们使用地震结构和地层方向来定义扩散方向，使用断层和道的映射来定义扩散范围。在整个扩散处理过程中，断层和道的映射与地震图像一起迭代更新。此外，每次更新时，这些映射都会通过面向断层或道的平滑处理得到进一步增强。</p>\n<p>Mappings with fault and channel detections are required to define small diffusion extents near the faults and channels and therefore to preserve reflection discontinuities near the faults and channels when smoothing a seismic image. On the other hand, the fault and channel mappings, computed as measurements of reflection discontinuities, are often sensitive to noise, which also generates reflection discontinuities in the seismic image. The smoothing of the seismic image can be helpful to remove the suspicious fault and channel detections due to noise. This is why we simultaneously update the fault and channel mappings while smoothing the seismic image. In addition, the reflection discontinuities corresponding to noise are often spatially inconsistent while faults and channels are apparent as spatially coherent reflection discontinuities in a seismic image. Therefore, before using the fault and channel mappings to construct diffusion tensors, we first apply fault- or channel-oriented smoothing to further enhance faults and channels and suppress noise in the mappings. In fault-oriented smoothing, we use the eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> to approximate the fault dip and strike directions, respectively. This has been proven to be a good approximation in many cases, but can be poor for some cases in which the faults are not dipping in directions perpendicular to seismic reflections. Therefore, a better way of estimating fault orientations is still desirable to further improve the methods discussed in this paper.</p>\n<p>断层和道检测映射需要定义断层和道附近的小扩散范围，因此在平滑地震图像时需要保留断层和道附近的反射不连续性。另一方面，作为反射不连续性测量值计算出来的断层和道映射往往对噪声很敏感，而噪声也会在地震图像中产生反射不连续性。对地震图像进行平滑处理有助于消除由于噪声造成的可疑断层和道检测。这就是我们在平滑地震图像的同时更新断层和道映射的原因。此外，与噪声相对应的反射不连续通常在空间上不一致，而断层和道在地震图像中明显表现为空间上一致的反射不连续。因此，在使用断层和道映射构建扩散张量之前，我们首先应用面向断层或面向道的平滑处理，以进一步增强断层和道，抑制映射中的噪声。在面向断层的平滑处理中，我们分别使用特征向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> 来逼近断层倾角和走向。这在许多情况下被证明是一种很好的近似方法，但在某些情况下，断层的倾角方向与地震反射方向并不垂直，这种近似方法的效果就会很差。因此，为了进一步改进本文所讨论的方法，仍然需要一种更好的估计断层方向的方法。</p>\n<p>The cyclic scheme of the FED method helps to reduce the extra computational costs required in updating and enhancing the fault and channel images. First, this scheme speeds up the diffusion processing by significantly reducing the number of diffusion steps. Second, in this scheme we do not update the fault and channel images at each diffusion step, we actually update these images only at each cycle and in total only three times in the entire smoothing processing.</p>\n<p>FED 方法的循环方案有助于减少更新和增强断层和通道图像所需的额外计算成本。首先，该方案大大减少了扩散步骤的数量，从而加快了扩散处理速度。其次，在该方案中，我们不会在每个扩散步骤中更新断层和通道图像，实际上我们只在每个周期更新这些图像，在整个平滑处理过程中总共只更新三次。</p>\n<p>Although faults and channels can be recognized as lateral reflection discontinuities in a seismic image, channels are also consistent linear features aligned within reflections in a 3D seismic image. Therefore, to enhance channels in a 3D seismic image, we not only sharpen the reflection discontinuities at the channel boundaries, but we also smooth the seismic image along the stratigraphic orientations to enhance the linear channel features.</p>\n<p>虽然断层和道在地震图像中可被识别为横向反射不连续面，但在三维地震图像中，道也是反射内排列一致的线性特征。因此，为了增强三维地震图像中的道，我们不仅要锐化道边界的反射不连续性，还要沿地层方向平滑地震图像，以增强线性道特征。</p>\n",
            "tags": [
                "Hyperstreamline"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/08/10/basic-theory/A-Flow-guided-Streamline-Seeding-Strategy/",
            "url": "https://sakurame.eu.org/2023/08/10/basic-theory/A-Flow-guided-Streamline-Seeding-Strategy/",
            "title": "A_Flow-guided_Streamline_Seeding_Strategy",
            "date_published": "2023-08-10T11:48:32.000Z",
            "content_html": "<h1 id=\"a-flow-guided-streamline-seeding-strategy\"><a class=\"anchor\" href=\"#a-flow-guided-streamline-seeding-strategy\">#</a> A Flow-guided Streamline Seeding Strategy</h1>\n<p>流程引导的流线型播种策略</p>\n<h2 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> Abstract</h2>\n<p>This paper presents a seed placement strategy for streamlines based on flow features in the dataset. The primary goal of our seeding strategy is to capture flow patterns in the vicinity of critical points in the flow field, even as the density of streamlines is reduced. Secondary goals are to place streamlines such that there is sufficient coverage in non-critical regions, and to vary the streamline placements and lengths so that the overall presentation is aesthetically pleasing (avoid clustering of streamlines, avoid sharp discontinuities across several streamlines, etc.). The procedure is straight forward and non-iterative. First, critical points are identified. Next, the flow field is segmented into regions, each containing a single critical point. The critical point in each region is then seeded with a template depending on the type of critical point. Finally, additional seed points are randomly distributed around the field using a Poisson disk distribution to minimize closely spaced seed points. The main advantage of this approach is that it does not miss the features around critical points. Since the strategy is not image-guided, and hence not view dependent, significant savings are possible when examining flow fields from different viewpoints, especially for 3D flow fields.</p>\n<p>本文介绍了一种基于数据集流动特征的流线种子放置策略。我们的播种策略的主要目标是捕捉流场中临界点附近的流动模式，即使流线的密度有所降低。次要目标是放置流线，使其充分覆盖非临界区域，并改变流线的位置和长度，使整体呈现美观（避免流线集群，避免多条流线出现尖锐的不连续性等）。该程序简单明了，无需迭代。首先，确定关键点。然后，将流场划分为若干区域，每个区域包含一个临界点。然后，根据临界点的类型，为每个区域的临界点添加模板种子。最后，使用泊松圆盘分布法在流场周围随机分布额外的种子点，以尽量减少种子点之间的紧密间隔。这种方法的主要优点是不会遗漏临界点周围的特征。由于该策略不是图像引导的，因此与视角无关，因此在从不同视角检查流场时，尤其是三维流场时，可以大大节省成本。</p>\n<p>Key Words and Phrases: seed placement, streamline, critical point, Voronoi diagram, Poisson disk distribution.</p>\n<p>关键词和短语：种子放置、流线、临界点、沃罗诺图、泊松圆盘分布。</p>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> INTRODUCTION</h2>\n<p>There are a number of methods for streamline placement that mostly address the aesthetic aspects of a flow visualization using streamlines. These methods [10, 16] describe how the streamlines should be placed in a flow field so that the visualization does not appear to be cluttered and there are no artifacts introduced in the visualization process that might lead to a misinterpretation of the flow field. In our work we address an important issue that has been largely neglected by these methods. Namely, whether the streamlines placed by these methods result in a visualization that captures all the important features (e.g. critical points) of the flow field. Our streamline seeding strategy guarantees that important features like critical points are not missed. If the streamlines are not seeded appropriately (e.g. using regular or random seeding), or using imageguided streamline placement alone, important details of the flow can be missed. This problem is illustrated in Figure 1. We can see that without proper seed placement, some details of the flow can be missed by the streamline visualization. The saddle critical point is not sufficiently captured by the streamlines in Figure 1a and Figure 1b. Streamlines generated using our method adequately highlights the critical points as shown in Figure 1c.</p>\n<p>目前有许多流线放置方法，主要针对使用流线进行流动可视化的美学方面。这些方法 [10, 16] 描述了如何将流线放置在流场中，从而使可视化效果不显得杂乱无章，并且在可视化过程中不会出现可能导致误读流场的假象。在我们的工作中，我们解决了这些方法在很大程度上忽略的一个重要问题。<strong>也就是说，这些方法所放置的流线是否能在可视化过程中捕捉到流场的所有重要特征（如临界点）</strong>。我们的流线播种策略可确保不遗漏临界点等重要特征。<strong>如果没有对流线进行适当的播种（如使用常规或随机播种），或仅使用图像引导的流线放置，则可能会遗漏流动的重要细节</strong>。图 1 举例说明了这一问题。我们可以看到，如果没有正确的播种位置，流线可视化可能会遗漏一些流动细节。图 1a 和图 1b 中的流线没有充分捕捉到鞍部临界点。如图 1c 所示，使用我们的方法生成的流线能充分突出临界点。</p>\n<p>There are some important goals to consider in order to generate an effective streamline visualization. In particular, a good seeding strategy should have the following characteristics:</p>\n<p>要生成有效的流线型可视化效果，需要考虑一些重要目标。特别是，好的播种策略应具备以下特点：</p>\n<p><strong>Coverage</strong>: The streamlines should not miss any interesting regions in the vector field. The interesting regions are those that we would like to study in the vector field, e.g. critical points, separation, and re-attachment lines. In addition, streamlines should cover the entire region of the field. Hence, even if the field is more or less uniform in a region, some streamlines should indicate the uniform nature of the flow in these regions. This goal is easier to achieve than other goals because one can always generate a lot of streamlines such that nothing important is missed. However, simply populating the field with more streamlines is not acceptable because some areas in the flow field, such as convergent regions, will force streamlines to cluster together, making it difficult to distinguish among individual streamlines. More importantly, it defeats the characteristic of uniformity as described next.</p>\n<p><strong>覆盖</strong>： 流线不应遗漏矢量场中任何有趣的区域。有趣的区域是我们希望在矢量场中研究的区域，例如临界点、分离线和重新连接线。此外，流线应覆盖整个矢量场区域。因此，即使某个区域的流场或多或少是均匀的，某些流线也应表明这些区域的流动是均匀的。这一目标比其他目标更容易实现，因为我们总是可以生成大量的流线，从而不会遗漏任何重要的流线。然而，简单地在流场中填充更多的流线并不可取，因为流场中的某些区域（如汇聚区域）会迫使流线聚集在一起，从而难以区分单条流线。更重要的是，这有悖于接下来描述的均匀性特征。</p>\n<p><strong>Uniformity</strong>: The streamlines should be more or less uniformly distributed over the field. This is a more challenging goal to achieve because while we can control where to place the seeds, we do not know how the resulting streamlines will behave. Uniformity is directly related to the density of streamlines crossing a unit area of the flow field. Hence, density of streamlines is an important parameter.</p>\n<p><strong>均匀性</strong>： 流线应或多或少均匀地分布在整个区域。要实现这一目标难度较大，因为我们可以控制种子的位置，但不知道所产生的流线将如何表现。均匀性与流场单位面积上的流线密度直接相关。因此，流线密度是一个重要参数。</p>\n<p><strong>Continuity</strong>: It is desirable from the point of view of aesthetics that the streamlines show continuity in the flow. Hence, one would prefer fewer long streamlines over many short streamlines. The latter tend to give the impression of “choppiness” while the former tend to give an impression of smooth continuous flow. In general, given an arbitrary flow field, the longer the streamlines, the higher the likelihood that they will tend to crowd together in some areas and disperse in other areas, thereby making it difficult to meet both the uniformity and continuity criteria simultaneously. Therefore, this parameter needs to be balanced against the uniformity criterion.</p>\n<p><strong>连续性</strong>：<strong>从美学角度来看，流线最好能显示出水流的连续性。因此，人们更喜欢长流线而不是较多的短流线。后者给人的印象往往是 &quot;波涛汹涌&quot;，而前者给人的印象则是平滑连续的流动</strong>。一般来说，在任意流场中，流线越长，就越有可能在某些区域聚集在一起，而在其他区域分散，从而难以同时满足均匀性和连续性标准。因此，这一参数需要与均匀性标准相平衡。</p>\n<p>Since most flow fields are defined over a grid, a popular seeding strategy is to seed at the grid points so that no important features are missed. This is usually an overkill and requires that more streamlines be traced than is necessary to capture all the desired details of the flow. Furthermore, the streamlines tend to clutter in ways that are difficult to predict. Even if the grid is sub-sampled to reduce the density of streamlines, cluttering is still difficult to avoid. Finally, regular seeding may also produce visualization artifacts that are not present in the flow field. Figure 2 shows streamlines with regular seed placement for two datasets. These images show that the streamlines placed on a regular grid can generate artifacts because the underlying regular grid can be perceived in the visualization (top image in Figure 2) and also create clutter if the streamlines are too long (bottom image in Figure 2).</p>\n<p>由于大多数流场都是在网格上定义的，因此常用的播种策略是在网格点上播种，以避免遗漏重要特征。这通常是矫枉过正，需要追踪更多的流线才能捕捉到所需的所有流动细节。此外，流线的杂乱程度往往难以预测。即使对网格进行子采样以降低流线密度，杂波仍然难以避免。最后，<strong>规则播种还可能产生流场中不存在的可视化假象</strong>。图 2 显示了两个数据集的常规种子放置流线。这些图像显示，<strong>放置在规则网格上的流线可能会产生伪影</strong>，因为在可视化中可以感知到底层的规则网格（图 2 中的上图），<strong>如果流线过长，还会产生杂波</strong>（图 2 中的下图）。</p>\n<p>Cluttering is of course dependent on the flow field. Blindly seeding on a regular grid results in a streamline visualization where the individual streamlines can be difficult to distinguish in important regions (e.g. regions where a critical point is present). If one does not seed all the grid locations and seed only every other grid point (for instance) then the streamlines might miss some interesting features. Regular seeding on a grid does not satisfy the requirements of coverage and uniformity for a good streamline visualization.</p>\n<p>当然，杂波取决于流场。在规则网格上盲目播种会导致流线可视化，在重要区域（如存在临界点的区域）难以区分单条流线。如果不对所有网格位置进行播种，而只对每隔一个网格点进行播种（例如），那么流线可能会错过一些有趣的特征。在网格上定期播种并不能满足良好的流线可视化对覆盖范围和均匀性的要求。</p>\n<p><img data-src=\"https://ptpimg.me/272tfe.jpg\" alt=\"\" /></p>\n<p>Figure 1: (a) Effects of regular seeding (49 streamlines), (b) effects of image-guided seeding (47 streamlines), (c) effects of flow-guided seeding (47 streamlines). Regular and image-guided seeding strategies may miss important flow features, especially when seeding is sparse. Both image-guided and flow-guided streamlines were generated such that the minimum separating distance of streamlines is 3% of the image width.</p>\n<p>图 1：(a) 常规播种的效果（49 条流线），(b) 图像引导播种的效果（47 条流线），(c) 流量引导播种的效果（47 条流线）。<strong>常规和图像引导播种策略可能会遗漏重要的水流特征</strong>，尤其是在播种稀疏的情况下。图像引导和流量引导流线的生成均使流线的最小分离距离为图像宽度的 3%。</p>\n<p><img data-src=\"https://ptpimg.me/k05cv7.jpg\" alt=\"\" /></p>\n<p>Figure 2: Streamlines are seeded on a regular grid for these two datasets. Top: the underlying regular grid can be perceived in the visualization. Bottom: streamlines can create clutter if their lengths are long.</p>\n<p>图 2：为这两个数据集在规则网格上播撒流线。上图：在可视化效果中可以看到底层的规则网格。下图：如果流线长度较长，则会造成杂乱。</p>\n<p>Image-guided techniques focus on the problem of cluttering. These methods also enforce a uniform spatial distribution of streamlines. However, they ignore coverage criterion, a scientifically important aspect of the flow visualization. The work presented in this paper attempts to alleviate this problem. We consider the coverage goal to be of greatest importance because from a scientific point of view the information content of any visualization is the most important. The goal of a uniform spatial distribution of streamlines is important only to the extent that it does not interfere with the most important goal of achieving a good coverage. The goal to achieve an aesthetically pleasing visualization has its merits but it should not compromise the other two goals (coverage and uniformity), hence it is lowest on our priority list. Another problem with image-guided techniques is that they are view dependent and do not permit interactive manipulation of viewpoint when studying flows over non-planer surfaces.</p>\n<p>图像引导技术主要解决杂波问题。这些方法也强制要求流线的空间分布均匀。然而，它们忽略了覆盖率标准，而这是流体可视化的一个重要科学方面。本文介绍的工作试图缓解这一问题。我们认为覆盖目标是最重要的，因为从科学的角度来看，任何可视化的信息内容都是最重要的。<strong>流线空间分布均匀的目标只有在不影响实现良好覆盖这一最重要目标的情况下才重要</strong>。实现美观的可视化目标固然有其优点，但不应影响其他两个目标（覆盖率和均匀性），因此在我们的优先级列表中排在最末。图像引导技术的另一个问题是，它们依赖于视角，在研究非平面表面上的流动时，不允许对视角进行交互式操作。</p>\n<p>Our approach starts with the assumption that if we know how the flow behaves and the location of the important features in the flow are known, then we can place seeds to trace streamlines more cleverly than the naive approach to place seeds at the grid locations, or to use an optimization strategy to reduce clutter. In fact, there has been significant research done to extract the important features we are interested in looking at. See [2, 6] for a definition and classification of critical points. These points are also used extensively in topological presentation of flow fields [6, 7, 8]. In this paper, we take advantage of the knowledge about the flow features in deciding how to place streamlines more intelligently. In particular, the type and location of the critical points are used to design and orient seeding templates that capture the flow patterns of these critical points. We are confident that our strategy can be easily extended to use information about other features like flow separation and reattachment lines, flow topology lines, etc. to further improve the flow-guided seed placement for streamlines. For example, information about automatically extracted separation and attachment lines [11] can be used to improve seeding to highlight those regions.</p>\n<p>我们的方法始于这样一个假设：如果我们知道水流是如何流动的，并且知道水流中重要特征的位置，那么我们就能比在网格位置放置种子或使用优化策略来减少杂波的天真方法更巧妙地放置种子来追踪流线。事实上，在提取我们感兴趣的重要特征方面，已有大量研究成果。关于临界点的定义和分类，请参阅 [2, 6]。这些点也被广泛用于流场的拓扑展示 [6, 7, 8]。在本文中，我们利用有关流动特征的知识来决定如何更智能地放置流线。特别是，<strong>我们利用临界点的类型和位置来设计和定位播种模板，以捕捉这些临界点的流动模式</strong>。我们相信，我们的策略可以很容易地扩展到使用其他特征信息，如流线分离和重新连接线、流线拓扑线等，以进一步改进流线的流线引导种子放置。例如，可以利用自动提取的分离线和附着线信息 [11] 来改进播种，以突出这些区域。</p>\n<h2 id=\"related-work\"><a class=\"anchor\" href=\"#related-work\">#</a> RELATED WORK</h2>\n<p>There are very few methods that address the problem of generating visualizations with good streamline placement strategies. It should be noted that placing seeds uniformly does not result in uniformly spaced streamlines. Hence methods like Dovey’s [4] to generate a uniform density of glyphs are not very useful for streamline placement. Max et al [14] use particle traces on a 3D surface that are terminated when they come too close to the path of other particles. Turk and Banks [16] use the minimization of an energy function to guide the placement of streamlines at a specified density. Their method uses a low-pass filtered version of the current image to measure the difference between the current image and the desired density value. The energy is reduced iteratively by changing the positions and lengths of streamlines, merging streamlines, and creating new streamlines. The resulting placement has a hand-placed appearance and the streamlines appear to be neither too sparse nor too crowded. Computation time for their method is significant. Jobard and Lefer’s method [10] creates evenly spaced streamlines that match the quality of streamlines generated using the image guided approach of Turk and Banks [16]. Furthermore, Jobard and Lefer’s method is non-iterative and is about 25 times faster than the image guided method. Recently, Mao et al [13] have extended the imagebased method of Turk and Banks to place streamlines on curvilinear grid surfaces for a fixed view point. A major drawback of all these methods is that they do not take guidance from the important features of the flow. None of the existing methods for streamline placement guarantee that the resulting streamlines will capture all the essential features of the flow field. If the streamline separation distance chosen in Jobard and Lefer’s method is not small enough, the streamlines could miss a critical point or the critical point might not be sufficiently captured by the streamlines. Our strategy guarantees that all the essential features will be captured by the resulting streamlines because we use the information about the location and type of critical points to seed the streamlines.</p>\n<p><strong>很少有方法可以解决使用良好的流线放置策略生成可视化效果的问题。需要注意的是，均匀放置种子并不会产生均匀分布的流线。因此，像 Dovey 的 [4] 生成均匀密度的字形的方法对于流水线布局并不是很有用。Max 等人 [14] 使用 3D 表面上的粒子轨迹，当它们太接近其他粒子的路径时会终止。Turk 和 Banks [16] 使用能量函数的最小化来指导流线在指定密度下的放置。他们的方法使用当前图像的低通滤波版本来测量当前图像和所需密度值之间的差异。通过改变流线的位置和长度、合并流线和创建新的流线来迭代地减少能量。由此产生的位置具有手工放置的外观，流线看起来既不太稀疏也不太拥挤。他们方法的计算时间是相当长的。Jobard 和 Lefer 的方法 [10] 创建的均匀间隔流线与使用 Turk 和 Banks 的图像导引方法生成的流线的质量相匹配 [16]。此外，Jobard 和 Lefer 的方法是非迭代的，并且比图像导引方法快约 25 倍。最近，毛等人 [13] 扩展了 Turk 和 Banks 的基于图像的方法，将流线放置在固定视点的曲线网格曲面上。所有这些方法的一个主要缺点是它们没有从流的重要特征中获得指导。现有的流线布置方法都不能保证得到的流线能够捕捉到流场的所有基本特征。如果 Jobard 和 Lefer 方法中选择的流线分离距离不够小，流线可能会错过临界点，或者流线可能不能充分捕捉到临界点。我们的策略保证所有基本特征都将被生成的流线捕获，因为我们使用有关临界点的位置和类型的信息来播种流线。</strong></p>\n<h2 id=\"flow-guided-streamline-placement\"><a class=\"anchor\" href=\"#flow-guided-streamline-placement\">#</a> FLOW-GUIDED STREAMLINE PLACEMENT</h2>\n<p>流导式流线布局</p>\n<p>Before we begin discussing our strategy to place seeds in a flow field, let us look at the different types of critical points in 2D flows. Figure 3 shows the different types of critical points that can be found in 2D flows.</p>\n<p>在开始讨论在流场中放置种子的策略之前，我们先来看看二维流中不同类型的临界点。图 3 显示了二维流中不同类型的临界点。</p>\n<p><img data-src=\"https://ptpimg.me/4071z2.jpg\" alt=\"\" /></p>\n<p>Figure 3: Different types of critical points possible in 2D flows.</p>\n<p>图 3：二维流可能出现的不同类型临界点。</p>\n<p>If the flow field contains only one critical point (of any type) and if we know the location and nature of the critical point, then we can easily decide where to place the seeds to trace streamlines. Figure 4 illustrates the seeding pattern for different types of critical points. We have studied the different critical point types and have come up with the following strategy to place seeds in the vicinity of the critical points so that the streamlines traced from these seeds bring out the nature of the flow around the critical points. We call these seeding patterns to be seed templates for critical points.</p>\n<p>如果流场只包含一个临界点（任何类型的临界点），并且我们知道临界点的位置和性质，那么我们就可以很容易地决定在哪里放置种子来追踪流线。图 4 展示了不同类型临界点的播种模式。我们对不同类型的临界点进行了研究，并提出了以下策略，即在临界点附近放置种子，以便从这些种子追踪到的流线能反映出临界点周围水流的性质。我们称这些播种模式为临界点种子模板。</p>\n<p>Center, spiral: place seeds along a straight line emanating from the critical point location. Figure 4a shows the seed template for center and spiral type of critical points.</p>\n<p>Source, sink: place seeds along the perimeter of a circle around the critical point. Figure 4b shows the seed template for this type of critical point.</p>\n<p>Saddle: place seeds along the lines that bisect the principal eigen directions. Figure 4c shows the seed template for saddles.</p>\n<p>中心、螺旋：沿临界点位置发出的直线放置种子。图 4a 显示了中心型和螺旋型临界点的种子模板。</p>\n<p>源、汇：沿临界点周围的圆周放置种子。图 4b 显示了此类临界点的种子模板。</p>\n<p>鞍形：沿着主特征方向的两分线放置种子。图 4c 显示了鞍形临界点的种子模板。</p>\n<p>In the following discussion, we will refer to the flow patterns around critical points, as depicted in Figure 3, as being ideal. That is, the flow pattern is representative of the flow that one might observe in the vicinity of these types of critical points. The flow pattern is the identifying characteristic that distinguishes one type of critical point from another. For example, we expect to see rotating flow around a center type of critical point.</p>\n<p>在下面的讨论中，我们将把临界点周围的流动模式（如图 3 所示）称为理想流动模式。也就是说，流动模式代表了人们在这类临界点附近可能观察到的流动。<strong>流动模式是区分一类临界点和另一类临界点的识别特征</strong>。例如，我们希望看到围绕中心临界点的旋转流动。</p>\n<p>An important parameter to decide for placing seeds along the template is the proximity of the seeds to the critical point. We have used some heuristics to decide how to choose the size of the template for a given critical point and other parameters like the distance between adjacent seeds on a template. The details of parameter selection are discussed in sections 3.1 and 3.2.</p>\n<p><strong>沿模板放置种子的一个重要参数是种子与临界点的距离</strong>。我们采用了一些启发式方法来决定如何为给定临界点选择模板的大小，以及模板上相邻种子之间的距离等其他参数。参数选择的细节将在第 3.1 和 3.2 节中讨论。</p>\n<p>The view of flow fields presented above is however very simplistic. In general, multiple critical points may be present in the flow and they interact with each other to give rise to patterns that deviate from the above presented simplistic notion of a flow field. Looking at Figure 5, we note that the flow near critical points is very similar to the ideal flow pattern for that type of critical point. As we go further and further from a critical point location, the flow pattern is influenced by other critical points. That is, the ideal flow pattern is most prominent in the immediate vicinity of the critical point. Consequently, for any general flow, we can always find a neighborhood around each critical point where the flow behaves as if other critical points were not present in the flow. If we can find this neighborhood then it will be easier to place seeds close to the critical points for a streamline visualization that highlights the critical points “nicely”. Hence, we proceed to determine a suitable partition of the flow such that only one critical point lies inside each partition. We have found that such a partition can be approximated by the Voronoi diagram constructed using all the critical point locations of the flow field.</p>\n<p>然而，上述流场观点非常简单。一般来说，流动中可能存在多个临界点，它们之间的相互作用会产生不同于上述简单流场概念的流动模式。观察图 5，我们会发现临界点附近的流动与该类临界点的理想流动模式非常相似。随着离临界点位置越来越远，流动模式会受到其他临界点的影响。也就是说，<strong>理想的流动模式在临界点附近最为突出</strong>。因此，对于任何一般流体，<strong>我们总能在每个临界点周围找到一个邻域，在这个邻域中，流体的行为就好像流体中没有其他临界点一样</strong>。<strong>如果我们能找到这个邻域，那么就能更容易地在临界点附近放置种子，从而使流线可视化 &quot;很好地&quot; 突出临界点</strong>。因此，我们着手确定一个合适的流体分区，使每个分区内只有一个临界点。我们发现，这样的分区可以通过使用流场的所有临界点位置构建的沃罗诺图来近似。</p>\n<p>Given a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> distinct points in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">{R^d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span></span> , the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> diagram is the partition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">{R^d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span></span> into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> polyhedral regions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>o</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">vo(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo>∈</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(p \\in S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span>. Each region <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>o</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">vo(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span>, called the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>, is defined as the set of points in  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">{R^d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span></span> which are closer to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> than to any other point in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> [5]. For our purposes, the set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is the set of critical point locations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">{R^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> . Since some of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> regions will be unbounded, we also compute the intersection of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> diagram with the flow data’s grid boundary. We chose to use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> partitioning because the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> regions are convex polygons with the property that every point in the Voronoi region around a critical point is closer to that critical point than to any of the other critical points. This means that the flow at the points in each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region is primarily influenced by the critical point it contains. This is an important heuristic because we have observed that the flow pattern at any point is influenced by its proximity to a critical point. The size of each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region is an approximation of the extent of the influence of the critical point it contains. In the following discussion, the boundary of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region will be called its <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> boundary.</p>\n<p>给定一个由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">{R^d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span></span> 中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个不同点组成的集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 图就是将 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">{R^d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span></span> 划分为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个多面体区域 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>o</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">vo(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo>∈</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(p \\in S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span>。每个区域 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>o</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">vo(p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span>，称为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> 的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域，定义为  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">{R^d}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span></span> 中比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 中任何其他点更靠近 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> 的点的集合 [5]。就我们的目的而言，集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">{R^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 中临界点位置的集合。由于有些沃罗诺伊区域是无边界的，因此我们还要计算沃罗诺伊图与流量数据网格边界的交集。<strong>我们选择使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 分割法，是因为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域是凸多边形，其特性是临界点周围 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域中的每个点都比其他临界点更靠近该临界点。这意味着每个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域中各点的流量主要受其包含的临界点的影响。这是一个重要的启发式方法</strong>，因为我们已经观察到，任何一点的流动模式都会受到其临近临界点的影响。每个沃罗诺伊区域的大小近似于它所包含的临界点的影响范围。在下面的讨论中，沃罗诺伊区域的边界将被称为沃罗诺伊边界。</p>\n<p><img data-src=\"https://ptpimg.me/01a23x.jpg\" alt=\"\" /></p>\n<p>Figure 4: Seed templates for various critical points. The seeds are placed along the solid lines. The bold dots represent the seed template and the dashed lines are the streamlines traced using the seeds from the template. (a) center, spiral; (b) source, sink; (c) saddle.</p>\n<p>图 4：不同临界点的种子模板。种子沿实线放置。粗点代表种子模板，虚线是使用模板中的种子描画的流线。(a) 中心、螺旋；(b) 源、汇；(c) 鞍部。</p>\n<p><img data-src=\"https://ptpimg.me/fi4035.jpg\" alt=\"\" /></p>\n<p>Figure 5: A flow can be partitioned using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> diagram of the critical point locations. Each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region contains only one critical point that represents the flow in that region.</p>\n<p>图 5：可以使用临界点位置的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 图来划分流量。每个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域只包含一个临界点，该临界点代表该区域内的流量。</p>\n<p>Figure 5 shows a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> partition of the dynamic vortices dataset. Notice that each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region contains exactly one critical point and the flow within a region is characterized by the type of critical point it contains. The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> regions are an approximation of the boundaries that partition the flow into different regions of flow types. Also important to notice is that around each critical point the flow would be close to ideal for that type of critical point. However, as you move away from the critical point, the flow will start to show influences from the flow around the neighboring critical points. It seems that the only critical points that might influence the flow near the boundary of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region are those that are its neighbors because the flow patterns near the edges of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> regions depend on the critical points on both sides of each edge.</p>\n<p>图 5 显示了动态涡流数据集的一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 分区。请注意，每个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域都包含一个临界点，区域内的气流以其包含的临界点类型为特征。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域是将气流划分为不同气流类型区域的边界的近似值。同样需要注意的是，在每个临界点周围，流动都接近于该类型临界点的理想状态。然而，当您远离临界点时，水流将开始受到邻近临界点周围水流的影响。看来，唯一可能影响<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域边界附近流动的临界点是其邻近的临界点，因为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域边缘附近的流动模式取决于每条边缘两侧的临界点。</p>\n<p>Given the above background, we can now outline a strategy to place seeds based on critical point location and types:</p>\n<p>Compute critical point locations and determine their types.</p>\n<p>Compute Voronoi partition of the set of critical points.</p>\n<p>Use template patterns around each critical point to place seeds and trace streamlines from these seeds.</p>\n<p>Place some “random” seeds to fill blanks and trace streamlines using them.</p>\n<p><strong>鉴于上述背景，我们现在可以概述一种根据临界点位置和类型放置种子的策略：</strong></p>\n<p><strong>计算临界点位置并确定其类型。</strong></p>\n<p><strong>计算临界点集合的 Voronoi 分区。</strong></p>\n<p><strong>在每个临界点周围使用模板模式放置种子，并从这些种子追踪流线。</strong></p>\n<p><strong>放置一些 &quot;随机&quot; 种子来填补空白，并利用它们来追踪流线。</strong></p>\n<p>We use FAST [1] to compute the critical point locations and to classify them. To compute the Voronoi diagram of the set of critical point locations, we use Jonathan Shewchuk’s publicly available software called triangle [15]. For step 3 in the procedure described above, we need to make the following decisions:</p>\n<p>How big should the template pattern be?</p>\n<p>How far apart should the seeds be placed in the template?</p>\n<p>How long should the streamlines be?</p>\n<p>** 我们使用 FAST [1] 计算临界点位置并对其进行分类。为了计算临界点位置集合的 Voronoi 图，我们使用了 Jonathan Shewchuk 的公开软件 triangle [15]。** 对于上述步骤中的第 3 步，我们需要做出以下决定：</p>\n<p>模板图案应该多大？</p>\n<p>种子在模板中的间距是多少？</p>\n<p>流线应该多长？</p>\n<p>We will discuss these issues in sections 3.1, 3.2, and 3.3, respectively. After seeding streamlines using templates for critical points, we add some random seeds that are distributed according to Poisson disk distribution. There are two important consequences of seeding with the seed template before the random seeds. By giving priority to seed templates, we ensure coverage of flow patterns near critical points. Furthermore, because we terminate a streamline when it comes close to an existing streamline (see Section 3.3), earlier streamlines will tend to be longer than later streamlines. Hence, streamlines traced from the seed templates are longer than those traced using seeds placed randomly to fill in blank spaces (see Section 3.4). Such a strategy ensures that the regions in the flow field close to critical points are given more importance than other regions.</p>\n<p>我们将在第 3.1、3.2 和 3.3 节中分别讨论这些问题。使用临界点模板播种流线后，我们会添加一些按照泊松圆盘分布的随机种子。在随机种子之前使用种子模板播种有两个重要的结果。通过优先使用种子模板，我们可以确保覆盖临界点附近的流型。此外，由于我们会在流线接近现有流线时终止它（见第 3.3 节），因此较早的流线往往会比较晚的流线长。因此，根据种子模板绘制的流线比使用随机放置的种子填补空白绘制的流线要长（见第 3.4 节）。这种策略可以确保流场中靠近临界点的区域比其他区域更受重视。</p>\n<h3 id=\"deciding-size-of-seed-templates\"><a class=\"anchor\" href=\"#deciding-size-of-seed-templates\">#</a> Deciding size of seed templates</h3>\n<p>决定种子模板的大小</p>\n<p>We are assuming that the flow inside each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region is characterized primarily by the type of critical point it contains. This means that each critical point should have its template constrained to lie completely within that critical point’s <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region.</p>\n<p>我们假定每个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域内的流动主要以其包含的临界点类型为特征。这意味着，每个临界点的模板都应限制在该临界点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域内。</p>\n<p>We use the following strategy to decide the size of the seed templates for the various critical points.</p>\n<p>我们采用以下策略来决定不同临界点的种子模板大小。</p>\n<p><strong>center, spiral</strong>: For center and spiral type of critical points, we find the line segment that joins the critical point to the closest point on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> boundary and seed along this line segment. One might ask what is so special about this particular line segment? We could have chosen many other line segments, for instance one that joins the critical point to the farthest point on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> boundary. We have experimented with many such possibilities and most of them resulted in too many streamlines and hence clutter. Basically, the ideal flow pattern of these critical points fade rather quickly.</p>\n<p><strong>中心型、螺旋型</strong>： <strong>对于中心型和螺旋型临界点，我们要找到连接临界点和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 边界上最近点的线段，并沿着这条线段播种</strong>。也许有人会问，这条线段有什么特别之处？我们可以选择许多其他线段，例如连接临界点和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 边界上最远点的线段。我们曾尝试过很多这样的可能性，但大多数都会导致流线过多，从而造成混乱。基本上，这些临界点的理想流动模式很快就会消失。</p>\n<p><strong>source, sink</strong>: For source and sink types of critical points, we seed along a circle’s perimeter. This circle has its center at the critical point and we chose it to be the largest circle that would fit completely inside the critical point’s <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region. Hence, the radius of this circle is equal to the distance between the critical point and the closest point on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> boundary. In contrast to centers and spirals, the ideal flow pattern of sources and sinks seem to extend further out.</p>\n<p><strong>源，汇</strong>： <strong>对于源临界点和汇临界点类型，我们沿着一个圆的周长进行播种</strong>。这个圆的圆心位于临界点，我们选择它作为能完全嵌入临界点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域的最大圆。因此，这个<strong>圆的半径等于临界点与 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 边界上最近点之间的距离</strong>。与中心和螺旋相比，源和汇的理想流动模式似乎要延伸得更远。</p>\n<p><strong>saddle</strong>: For a saddle we place seeds along two lines. These lines are the bisectors of the principal eigen vector directions. The extent of these lines is decided by their intersection with the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> boundary. We have found that the saddles are the trickiest to seed because if the the seed closest to the saddle’s location along the bisectors is not close enough then the saddles are not captured properly. For this reason, we decided to seed two special streamlines very close to the saddle. The seeds for these two streamlines are chosen to lie on the same bisector but on the opposite sides of the saddle’s center. The distance of these special seeds from the center is chosen to be equal to one half the cell size of the grid. An additional note is that the seed templates for saddles presented in this paper assume index zero saddles which result in separation of flow into 4 regions around the critical point. Other types of saddles, e.g. index of -1, may result in more than 4 flow regions around the saddle point, and would require a different type of seed template. However, they would still be based on bisector lines.</p>\n<p><strong>马鞍</strong> ：<strong>对于鞍区，我们沿着两条线放置种子。这两条线是主特征向量方向的平分线</strong>。这些线的范围取决于它们与 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 边界的交点。我们发现，鞍部是最难播种的地方，因为如果种子与鞍部位置的二等分线距离不够近，就无法正确捕捉到鞍部。因此，我们决定在非常靠近鞍部的位置播撒两条特殊的流线。这两条流线的种子被选择位于同一条平分线上，但在鞍中心的两侧。这些特殊种子与中心的距离等于网格单元大小的一半。另外需要注意的是，本文中介绍的鞍形种子模板是假定指数为零的鞍形，这会导致临界点周围的水流分离成 4 个区域。其他类型的鞍点，例如指数为 - 1 的鞍点，可能会导致鞍点周围出现多于 4 个流动区域，因此需要不同类型的种子模板。不过，它们仍将以平分线为基础。</p>\n<p><img data-src=\"https://ptpimg.me/828o0k.jpg\" alt=\"\" /></p>\n<p>Figure 6: Seeds placed using templates for the various critical points. Left: dynamic vortices dataset. Right: 5 critical points dataset. These datasets are the same as those shown in Figure 2. Also see Color Plate 1.</p>\n<p>图 6：使用模板在不同临界点放置种子。左：动态涡流数据集。右图：5 个临界点数据集。这些数据集与图 2 中的数据集相同。另见彩图 1。</p>\n<p>The size (i.e. extent) of the seed template is adjustable. In practice, we find that half of full size of the seed template is sufficient because the observed flow patterns are ideal only in the vicinity of the critical points. This means that for source and sink critical points, we seed along the perimeter of a circle centered at the critical point. The radius of this circle is equal to half the distance of the critical point to the closest point on the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> boundary. Figure 6 shows the template patterns for various critical points in two datasets. The red lines show the directions along which the seeds are placed in the saddle, center, and spiral templates. The bold red points represent the critical point locations and the blue points are the actual seed locations that form the seed template. Also note that if the size of the seed template was set to zero, then there will be no streamlines seeded based on flow information, and the resulting streamlines will all be seeded randomly with a Poisson disk distribution (see Section 3.4).</p>\n<p>种子模板的大小（即范围）是可调的。在实践中，我们发现种子模板全尺寸的一半就足够了，因为只有在临界点附近观察到的流动模式才是理想的。这意味着，对于源临界点和汇临界点，我们沿着以临界点为中心的圆周进行播种。这个圆的半径等于临界点到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 边界上最近点距离的一半。图 6 显示了两个数据集中不同临界点的模板模式。红线表示鞍形、中心和螺旋模板中种子的放置方向。粗体红点代表临界点位置，蓝点代表形成种子模板的实际种子位置。还需注意的是，如果将种子模板的大小设置为零，则不会根据流量信息播种流线，得到的流线都将是随机播种的泊松圆盘分布（见第 3.4 节）。</p>\n<h3 id=\"controlling-streamline-density\"><a class=\"anchor\" href=\"#controlling-streamline-density\">#</a> Controlling streamline density</h3>\n<p>控制流线密度</p>\n<p>The density of streamlines is determined to a large extent by the distance between the seeds. Once we have decided on the template patterns, it is straight forward to place seeds along these templates. We allow the user to control the density of the streamlines using a single parameter  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> seed which is the minimum distance between seeds. Seeds along the template are placed  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> seed apart from each other. Figure 6 shows the seeds along the templates for various critical points.</p>\n<p>流线的密度在很大程度上取决于种子之间的距离。一旦我们确定了模板模式，就可以直接沿着这些模板放置种子。我们允许用户使用种子间的最小距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 这一单一参数来控制流线的密度。沿模板放置 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的种子彼此相距较远。图 6 显示了不同临界点模板上的种子。</p>\n<h3 id=\"terminating-streamlines\"><a class=\"anchor\" href=\"#terminating-streamlines\">#</a> Terminating Streamlines</h3>\n<p>终止流线</p>\n<p>Our heuristic of seed placement according to templates works well to highlight the flow patterns around all the critical points present in the flow. If the streamline lengths are not chosen properly, then in some regions of the flow they will come too close to each other and create distracting clutter. We terminate a streamline when it comes close to an existing streamline by a user specified distance. Let the user defined minimum separating distance desired between any two streamlines be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> . The streamlines are represented as control points of a line strip. To check whether a given streamline is close to an existing streamline we determine whether the next control point during a streamline construction comes closer than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> to any control point of an already existing streamline. If the next control point of the current streamline is closer than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> from any control point of previously traced streamlines, then the current streamline is terminated. For this test to be valid, it is required that the distance between successive sample points along a streamline be closer than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> .</p>\n<p>我们根据模板放置种子的启发式方法可以很好地突出流体中所有关键点周围的流动模式。如果流线长度选择不当，那么在流体的某些区域，流线会相互靠得太近，造成干扰。当一条流线与现有流线的距离接近用户指定的距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 时，我们就会终止该流线。用户定义的两条流线之间的最小分离距离为流线。流线表示为线带的控制点。要检查给定的流线是否靠近已有的流线，我们需要确定流线构造过程中的下一个控制点是否比流线更靠近已有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的任何控制点。如果当前流线的下一个控制点比流线更接近先前追踪 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的任何控制点，那么当前流线将被终止。为使该测试有效，要求沿流线的连续采样点之间的距离比 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 更近。</p>\n<p>To efficiently implement this streamline proximity test, we superimpose a cartesian grid over the flow field. Each cell of this grid contains a list of pointers to sample points of streamlines that fall in that cell. The width and height of each cell is equal to the desired separation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> between the streamlines. To check whether a sample point on a streamline is close to an existing streamline, all we need to do is to find the cell in which the sample point lies, and check whether it comes within distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> of the points stored in the cell and its eight neighbors. If the current control point is closer than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> to the points stored in the cell and its eight neighbors, then the streamline is terminated. Although a user can specify a value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> directly, through experiments with several flow fields we have found that a value of 0:3 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> works well in practice.</p>\n<p><strong>为了有效地实施流线邻近性测试，我们在流场上叠加了一个笛卡尔网格。该网格的每个单元格都包含一个指向落在该单元格中的流线样本点的指针列表。每个单元格的宽度和高度等于流线之间所需的间距 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 。要检查流线上的采样点是否靠近现有的流线，我们只需找到采样点所在的单元格，然后检查它是否在该单元格及其八个相邻单元格中存储的点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 距离之内。如果当前控制点与存储在单元格中的点及其八个相邻点的距离大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的距离，则流线终止。虽然用户可以直接指定 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的值，但通过对多个流场的实验，我们发现 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的值为 0:3 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>，在实际应用中效果很好。</strong></p>\n<p>During our investigation of streamline placement, we have experimented with several other streamline termination criteria but found the strategy to terminate a streamline based on its proximity to other streamlines to work the best. We have tried terminating streamlines based on a winding angle test to prevent clutter around a spiral or center type of critical point. We have also experimented with terminating streamlines when they exit the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> region from which they were initiated, but found that the streamlines create distracting artifacts when many streamlines are terminated very close to straight edges of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> regions. Although the tests based on winding angle and crossing of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> edges work well to reduce clutter, they do not generate evenly spaced streamlines.</p>\n<p>在研究流线位置的过程中，我们尝试了其他几种流线终止标准，但发现根据流线与其他流线的接近程度来终止流线的策略效果最好。我们尝试过根据缠绕角测试来终止流线，以防止在螺旋或中心类型的临界点周围出现杂波。我们还尝试过在流线离开其起始的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域时终止流线，但发现当许多流线的终止点非常靠近 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 区域的直线边缘时，流线会产生令人分心的假象。虽然基于缠绕角和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mi>o</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">Voronoi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">oro</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span></span></span></span> 边缘交叉的测试能很好地减少杂波，但却不能生成间距均匀的流线。</p>\n<h3 id=\"random-seeds\"><a class=\"anchor\" href=\"#random-seeds\">#</a> Random Seeds</h3>\n<p>随机种子</p>\n<p>The placement of seeds according to templates for various critical points basically captures the location and behavior of the most interesting features of the flow. However, the strategy outlined above can leave “blank” spaces in our visualization where no streamlines are displayed. The flow in these regions is almost uniform and more or less parallel to their boundary. Figure 7 shows an example of streamlines generated using only the seed templates. The flow in these blank regions does not contain any additional features, hence we can afford to be less careful about the seed placement in these regions. Based on the observation that if the flow is uniform then we can place seeds arbitrarily as long as the streamlines do not crowd together to form distracting clusters, we chose to distribute seeds in these blank regions using a Poisson disk distribution [3]. Poisson disk distribution guarantees that these random seeds will be at least <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{poisson}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">sso</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> distance apart, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{poisson}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">sso</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> is chosen to be equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>. Choosing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{poisson}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">sso</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> to be equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> ensures that all the streamlines will be evenly distributed.</p>\n<p>根据不同临界点的模板放置种子，基本上可以捕捉到最有趣的流动特征的位置和行为。然而，上述策略可能会在我们的可视化中留下 &quot;空白&quot; 空间，在这些空间中不会显示流线。这些区域的流动几乎是均匀的，或多或少与边界平行。图 7 显示了仅使用种子模板生成的流线示例。这些空白区域中的水流不包含任何额外特征，因此我们可以在这些区域中不那么小心地放置种子。根据观察，如果流线是均匀的，那么只要流线不会挤在一起形成分散注意力的集群，我们就可以任意放置种子，因此我们选择在这些空白区域使用泊松圆盘分布 [3] 来分配种子。泊松圆盘分布保证这些随机种子至少相距 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{poisson}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">sso</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 距离，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{poisson}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">sso</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>。选择 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{poisson}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">sso</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 等于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 可以确保所有流线均匀分布。</p>\n<p>We do not actually find these blank regions. Instead, we define a region of influence for all critical points and place random seeds according to a Poisson disk distribution outside the region of influence. The region of influence of a critical point is defined as a circle around the critical point location. The radius of this circle is decided based on the type of critical point and the size of its template seeding pattern. We choose the radius of the circle of influence to be a fraction of the size of the seed template. We experimented with several values of this fraction for different flow fields and found that the value of 0.8 works well in practice. The yellow disks in Figure 8 show the regions of influence for each critical point. We have found that a few very short streamlines also result from tracing streamlines from the above introduced random seeds. Although they do not cause any artifacts, we chose to not draw them for aesthetic reasons. Excluding these few short streamlines does not result in poor visualizations.</p>\n<p>实际上，我们并没有找到这些空白区域。相反，我们为所有临界点定义了一个影响区域，并根据泊松圆盘分布在影响区域外放置随机种子。临界点的影响区域定义为临界点位置周围的一个圆。这个圆的半径是根据临界点的类型及其模板播种模式的大小决定的。我们选择的影响圈半径是种子模板大小的一部分。<strong>我们针对不同的流场尝试了几种影响半径的取值，发现 0.8 的取值在实际应用中效果很好</strong>。图 8 中的黄色圆盘显示了每个临界点的影响区域。我们发现，从上述引入的随机种子中追踪流线也会产生一些非常短的流线。虽然它们不会造成任何假象，但出于美观的考虑，我们选择不绘制它们。排除这些短流线并不会导致可视化效果不佳。</p>\n<p><img data-src=\"https://ptpimg.me/a56p4r.jpg\" alt=\"\" /></p>\n<p>Figure 7: Streamlines generated using only the seed templates. The interesting features are captured by the streamlines but there are some blanks left that need to be filled by adding more streamlines.</p>\n<p>图 7：仅使用种子模板生成的流线。流水线捕捉到了有趣的特征，但还有一些空白需要通过添加更多的流水线来填补。</p>\n<p><img data-src=\"https://ptpimg.me/a15gmq.jpg\" alt=\"\" /></p>\n<p>Figure 8: Regions of influence for each critical point are shown as yellow disks. The dataset is the same as the one shown in Figure 1. Also see Color Plate 2.</p>\n<p>图 8：每个临界点的影响区域显示为黄色圆盘。数据集与图 1 所示数据集相同。另见彩图 2。</p>\n<h2 id=\"results\"><a class=\"anchor\" href=\"#results\">#</a> RESULTS</h2>\n<p>The first comparison is whether the flow-guided approach is any better than regular seeding or random seeding. For this, we placed seeds according to Poisson disk distribution and traced streamlines that were terminated using the proximity test. We found that while the strategy of placing seeds according to Poisson disk distribution works better than placing seeds on a regular grid, it still generates streamlines that do not sufficiently capture the flow close to critical points (especially saddles). As demonstrated in Figure 9, there are both aesthetic problems as well as missing critical flow information with random seeding strategy. Figure 10 shows streamlines generated using our flow guided approach.</p>\n<p>首先要比较的是导流方法是否优于常规播种或随机播种。为此，我们根据泊松圆盘分布放置种子，并使用邻近性测试对终止的流线进行追踪。我们发现，虽然根据泊松圆盘分布放置种子的策略比在常规网格上放置种子效果更好，但它生成的流线仍不能充分捕捉临界点（尤其是鞍点）附近的流动。如图 9 所示，随机播种策略既存在美观问题，也会遗漏关键的水流信息。图 10 显示的是使用流动引导方法生成的流线。</p>\n<p><img data-src=\"https://ptpimg.me/2q4p5s.jpg\" alt=\"\" /></p>\n<p>Figure 9: These images were rendered by using seeds whose locations were generated randomly using a Poisson disk distribution.</p>\n<p>图 9：这些图像是使用种子渲染的，种子的位置是通过泊松圆盘分布随机生成的。</p>\n<p><img data-src=\"https://ptpimg.me/f48b27.jpg\" alt=\"\" /></p>\n<p>Figure 10: Streamlines generated using our flow-guided seeding strategy. The flow field contains six critical points.</p>\n<p>图 10：使用流动引导播种策略生成的流线。流场包含六个临界点。</p>\n<h2 id=\"results-2\"><a class=\"anchor\" href=\"#results-2\">#</a> RESULTS</h2>\n<p>The first comparison is whether the flow-guided approach is any better than regular seeding or random seeding. For this, we placed seeds according to Poisson disk distribution and traced streamlines that were terminated using the proximity test. We found that while the strategy of placing seeds according to Poisson disk distribution works better than placing seeds on a regular grid, it still generates streamlines that do not sufficiently capture the flow close to critical points (especially saddles). As demonstrated in Figure 9, there are both aesthetic problems as well as missing critical flow information with random seeding strategy. Figure 10 shows streamlines generated using our flow guided approach.</p>\n<p>首先要比较的是导流方法是否优于常规播种或随机播种。为此，我们根据泊松圆盘分布放置种子，并使用邻近性测试对终止的流线进行追踪。我们发现，虽然根据泊松圆盘分布放置种子的策略比在常规网格上放置种子效果更好，但它生成的流线仍不能充分捕捉临界点（尤其是鞍点）附近的流动。如图 9 所示，随机播种策略既存在美观问题，也会遗漏关键的水流信息。图 10 显示的是采用流动引导方法生成的流线。</p>\n<p>The next comparison is on how the flow-guided approach fared against the image-guided approaches. Figure 11 shows streamlines generated using our method for different values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> . These images show the critical points clearly at different streamline densities. The output using Turk and Banks’s imageguided streamline approach is also presented side by side for comparison. Efforts are made to bring the number of streamlines for corresponding densities as close as possible. The streamline separating distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> was chosen to be 0:3 * <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>. The values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> which controls the density of streamlines roughly corresponds to the separating distance for Turk and Banks’s method. On the top row, where the number of streamlines is very dense, the flow-guided approach captures the critical points better than the image-guided approach. This is the case even as we decrease the number of streamlines on the bottom row – particularly for saddles. The aesthetic quality, especially the uniformity of how the streamlines are distributed, seem to be better when using the image-guided approach as the number of streamlines is increased. This is attributed primarily to the effects of random Poisson disk streamlines. Note however, as the number of streamlines increases, the computation cost of the image-guided streamline placement increases significantly.</p>\n<p>接下来的比较是流量引导方法与图像引导方法的对比。图 11 显示了在不同的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 值下使用我们的方法生成的流线。这些图像清晰地显示了不同流线密度下的临界点。图 11 还并列显示了使用 Turk 和 Banks 图像引导流线方法生成的结果，以供比较。我们努力使相应密度下的流线数量尽可能接近。流线分离距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 选定为 0:3 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>。控制流线密度的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的值与 Turk 和 Banks 方法的分离距离基本一致。在流线数量非常密集的顶行，流线引导法比图像引导法更能捕捉临界点。即使我们减少底部一行的流线数量，情况也是如此，尤其是在鞍部。使用图像引导方法时，随着流线数量的增加，美学质量，特别是流线分布的均匀性似乎更好。这主要归因于随机泊松圆盘流线的影响。但需要注意的是，随着流线数量的增加，图像引导流线放置的计算成本也会显著增加。</p>\n<p>Our observation is that streamline images generated using our flow-guided approach are comparable in aesthetic quality to those produced using image-guided method of Turk and Banks [16] and the method of Jobard and Lefer [9]. Furthermore, our strategy guarantees that all the critical points present in the flow are highlighted by streamlines. Finally, the computational cost for seed placement is less using our method, especially as the number of streamlines increases.</p>\n<p>我们的观察结果表明，使用我们的流向引导方法生成的流线图像在美学质量上与使用 Turk 和 Banks [16] 的图像引导方法以及 Jobard 和 Lefer [9] 的方法生成的图像不相上下。此外，我们的策略还能保证流线突出显示流体中的所有关键点。最后，使用我们的方法，特别是当流线数量增加时，种子放置的计算成本更低。</p>\n<p><img data-src=\"https://ptpimg.me/izvf4x.jpg\" alt=\"\" /></p>\n<p>Figure 11: Left: images produced using Turk and Banks’s image-guided streamline placement method. Right: our flow-guided streamline seeding method. The streamlines separation is chosen to be 1% of image width for images in the first row, 1.67% for the images in the second row, and 3% for images in the third row.</p>\n<p>图 11：左：使用 Turk 和 Banks 的图像引导流线放置法生成的图像。右图：我们的流线引导流线播种方法。第一行图像的流线分离度为图像宽度的 1%，第二行图像的分离度为 1.67%，第三行图像的分离度为 3%。</p>\n<h2 id=\"discussion-and-future-work\"><a class=\"anchor\" href=\"#discussion-and-future-work\">#</a> DISCUSSION AND FUTURE WORK</h2>\n<p>We have presented a technique for flow-guided seeding strategy that ensures coverage of important flow features, produces streamlines that are more or less uniformly spaced, and a greedy approach to producing long streamlines. The advantage over image-guided placement strategy is most obvious as the number of streamlines decreases. There are a number of extensions, improvements, and applications of this work that we are pursuing.</p>\n<p>我们提出了一种流向引导播种策略技术，该技术可确保覆盖重要的流向特征，产生间距基本均匀的流线，并采用一种贪婪的方法来产生长流线。随着流线数量的减少，该技术与图像引导播种策略相比优势最为明显。我们正在对这项工作进行一些扩展、改进和应用。</p>\n<p>One of the motivations behind our research on streamline placement is to use as few streamlines as possible to represent the flow such that no important flow features are missed. Streamlines generated by our method can be used in texture synthesis techniques like PLIC [17]. PLIC uses texture mapped streamlines to generate visualizations that look like LIC images. However, due to the regular placement of the streamlines, the visualizations can have some distracting Moir´e patterns. Generating streamlines using our method will eliminate the artifacts from PLIC images.</p>\n<p>我们对流线位置进行研究的动机之一是使用尽可能少的流线来表示流动，这样就不会遗漏重要的流动特征。我们的方法生成的流线可用于纹理合成技术，如 PLIC [17]。PLIC 使用纹理映射流线生成类似 LIC 图像的可视化效果。然而，由于流线有规律地放置，可视化效果可能会有一些令人分心的 Moir´e 图案。使用我们的方法生成流线将消除 PLIC 图像中的人工痕迹。</p>\n<p>Streamlines are hard to use for studying 3D flow patterns because in three dimensions it becomes difficult to perceive the flow even if a moderate number of streamlines are used. The usual method is to use a rake to trace streamlines. While the rake approach is useful because the visualization is not very cluttered, the exploration of the flow using rakes is still quite ad hoc. The ideas in this work can be carried to three dimensions by identifying the critical points, partitioning the flow, and using suitable seed templates for three dimensional critical points. We also believe that a similar strategy to place streamlines in 3D will pave way for extending PLIC to 3D as well.</p>\n<p>流线很难用于研究三维流动模式，因为在三维空间中，即使使用适量的流线也很难感知流动。通常的方法是使用耙子追踪流线。虽然耙式方法很有用，因为可视化效果不会很杂乱，但使用耙式方法来探索流动仍然是非常特别的。通过识别临界点、划分流线以及为三维临界点使用合适的种子模板，可以将这项工作中的想法应用到三维领域。我们还相信，在三维空间中放置流线的类似策略也将为 PLIC 扩展到三维空间铺平道路。</p>\n<p>We have observed that saddles can be better seeded if the seeds are placed along the bisectors of the topology lines of the saddle. This would increase the quality of seeding in the vicinity of the saddles. Sometimes the distinction between sinks and attracting spirals, and sources and repelling spirals may become obscure using the parameterization reported in [12]. In this case, additional checks are necessary to determine which type of seed template is most appropriate.</p>\n<p>我们观察到，如果沿着鞍座拓扑线的二等分线放置种子，鞍座的播种效果会更好。这将提高鞍附近的播种质量。有时，使用 [12] 中报告的参数化方法，汇和吸引螺旋与源和排斥螺旋之间的区别可能会变得模糊不清。在这种情况下，有必要进行额外检查，以确定哪种类型的种子模板最合适。</p>\n<p>Our method currently does not handle higher order critical points but can be easily extended to place seeds intelligently in the vicinity of higher order critical points. The template for a higher order critical point will also be based on bisector lines. For instance, one can place seeds along lines that bisect the six regions around a saddle of index -1. We also do not take into account cycles present in the flow. Our strategy can also be extended to place seeds intelligently in the vicinity of flow separation and re-attachment lines.</p>\n<p>我们的方法目前还不能处理高阶临界点，但可以很容易地扩展到在高阶临界点附近智能地放置种子。高阶临界点的模板也将基于平分线。例如，我们可以沿着指数为 - 1 的鞍点周围六个区域的平分线放置种子。我们也不考虑流动中存在的循环。我们的策略还可以扩展到在流动分离线和重新连接线附近智能地放置种子。</p>\n<p>Although our heuristic to determine the size and shape of the seed templates works well for most cases we feel that it is not the most optimal and can be improved further. We are currently exploring ways to use the $\\alpha  - \\beta $ space parameterization of critical points [12] to determine the shape and size of seed templates. We are also exploring ways to use topology lines of a flow field along with critical point information to determine the shape of the seed templates. One of the limitations of our method is that the seed templates are not sensitive to the spatial distribution of the critical points and hence not sensitive to the “strengths” of critical points (e.g. how tight or loose a spiral is, and also how a source or sink may transition into a spiral). We believe that using the $\\alpha  - \\beta $ space parameterization of critical points to determine the shape and size of seed templates will help in overcoming this limitation.</p>\n<p>虽然我们确定种子模板大小和形状的启发式方法在大多数情况下都很有效，但我们认为它并不是最优的，还可以进一步改进。我们目前正在探索如何使用临界点的 $\\alpha  - \\beta $ 空间参数化 [12] 来确定种子模板的形状和大小。我们还在探索如何利用流场拓扑线和临界点信息来确定种子模板的形状。我们的方法有一个局限性，即种子模板对临界点的空间分布不敏感，因此对临界点的 &quot;强度&quot; 也不敏感（例如，螺旋的松紧程度，以及源或汇如何过渡到螺旋）。我们相信，使用临界点的 $\\alpha  - \\beta $ 空间参数化来确定种子模板的形状和大小将有助于克服这一局限。</p>\n<p>Multiple levels-of-details, either in a zooming in/out operation or as required by some rendering quota, can be easily supported by using seed templates with higher seed density <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>, and smaller streamline separation distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> . The idea is that only some of the seeds are traced if the viewpoint is far away (or the average number of streamlines per unit area of the screen is low). As the user zooms in for a closer inspection, more detail of the flow are presented by tracing out the other seed points and ramping up their alpha values to minimize popping.</p>\n<p>无论是在放大 / 缩小操作中，还是在某些渲染配额的要求下，使用种子密度较高的种子模板 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>e</mi><mi>e</mi><mi>d</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{seed}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">see</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 和较小的流线分离距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>δ</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>m</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\delta _{streamline}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\">am</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 都可以轻松支持多级细节。这样做的目的是，如果视点较远（或屏幕单位面积上的流线平均数量较少），则只跟踪部分种子。当用户拉近视角仔细观察时，就会通过追踪其他种子点和增加它们的 alpha 值来呈现更多的流线细节，从而最大限度地减少 &quot;弹出&quot; 现象。</p>\n",
            "tags": [
                "Hyperstreamline"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/08/09/basic-theory/Creating-Evenly-Spaced-Streamlines-of-Arbitrary-Density/",
            "url": "https://sakurame.eu.org/2023/08/09/basic-theory/Creating-Evenly-Spaced-Streamlines-of-Arbitrary-Density/",
            "title": "Creating_Evenly-Spaced_Streamlines_of_Arbitrary_Density",
            "date_published": "2023-08-09T11:36:58.000Z",
            "content_html": "<h1 id=\"creating-evenly-spaced-streamlines-of-arbitrary-density\"><a class=\"anchor\" href=\"#creating-evenly-spaced-streamlines-of-arbitrary-density\">#</a> Creating Evenly-Spaced Streamlines of Arbitrary Density*</h1>\n<p>创建任意密度的均匀分布流线 *</p>\n<h2 id=\"abstract\"><a class=\"anchor\" href=\"#abstract\">#</a> Abstract.</h2>\n<p>This paper presents a new evenly-spaced streamlines placement algorithm to visualize 2D steady flows. The main technical contribution of this work is to propose a single method to compute a wide variety of flow field images, ranging from texture-like to hand-drawing styles. Indeed the control of the density of the field is very easy since the user only needs to set the separating distance between adjacent streamlines, which is related to the overall density of the image. We show that our method produces images of a quality at least as good as other methods but that it is computationally less expensive and offers a better control on the rendering process.</p>\n<p>摘要</p>\n<p>本文提出了一种新的均匀分布流线算法，用于将二维稳定流可视化。这项工作的主要技术贡献在于提出了一种单一的方法来计算从纹理到手绘风格的各种流场图像。事实上，流场密度的控制非常简单，因为用户只需设置相邻流线之间的分离距离，这与图像的整体密度有关。我们的研究表明，我们的方法所生成的图像质量至少不亚于其他方法，但计算成本更低，而且能更好地控制渲染过程。</p>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>The problem of visualizing vector fields has been widely addressed in the past years because it has numerous applications. The main issue is to visualize properly the direction and magnitude of the flow. Spatial resolution techniques such as arrow plots, streamlines or particles traces suffer from their spatial resolution that limits drastically their usefulness, in particular in the presence of a turbulent flow. Moreover the effectiveness of the streamline and particle methods depends critically on the placement of the forming seed points. Texture-like methods, such as Spot Noise [10] and LIC [1] produce dense field images showing the flow features in fine-grain detail. Another issue is to compute sparse flow fields, laying stress on the visual appearance of the field, which produces handdrawing style images. Recently, Turk and Banks presented an imaged-guided streamline placement to compute hand-drawing style representations of a flow field [9]. This paper presents another effective algorithm for the placement of evenly-spaced streamlines. The main technical contribution of this work is to propose a single method to compute a wide variety of flow field images, ranging froin texture-like to hand-drawing styles. Indeed the control of the density of the field is very easy since the user only needs to set the separating distance between adjacent streamlines, which is related to the overall density of the image.</p>\n<p>矢量场的可视化问题在过去几年中得到了广泛的研究，因为它有着众多的应用。主要问题是如何正确可视化流动的方向和大小。空间分辨率技术（如箭头图、流线或粒子轨迹）的空间分辨率大大限制了其实用性，尤其是在湍流情况下。此外，流线和颗粒方法的有效性在很大程度上取决于形成种子点的位置。类似纹理的方法，如 Spot Noise [10] 和 LIC [1]，可以生成密集的场图像，显示细粒度的流动特征。另一个问题是计算稀疏流场，强调流场的视觉外观，从而产生手绘风格的图像。最近，Turk 和 Banks 提出了一种图像引导流线放置法，用于计算手绘风格的流场表示 [9]。本文提出了另一种有效的均匀分布流线的算法。这项工作的主要技术贡献在于提出了一种单一的方法来计算从类纹理到手绘风格的各种流场图像。事实上，流场密度的控制非常简单，因为用户只需设置相邻流线之间的分隔距离，这与图像的整体密度有关。</p>\n<h2 id=\"related-work\"><a class=\"anchor\" href=\"#related-work\">#</a> Related work</h2>\n<p>相关工作</p>\n<p>Visualizing a vector field in a general manner requires high spatial resolution techniques to properly render fine-grain details. Such methods generally yield dense field representations. However there are situations where a sparse density image is needed, by instance to produce an illustration similar to those used to enhance the purpose of text fields in a book. Methods proposed to visualize a flow field falls into these two categories: dense field representations and handdrawing style.</p>\n<p>要以一般方式将矢量场可视化，需要采用高空间分辨率技术来正确呈现细粒度细节。这些方法通常会产生密集的场表示。不过，在某些情况下也需要稀疏的密度图像，例如制作类似用于增强书中文本字段目的的插图。所提出的流场可视化方法可分为两类：密集场表示法和手绘风格。</p>\n<p>The first method for representing a flow field with high spatial resolution has been proposed by van Wijk [10]. The spot noise method creates a directional texture by superimposing many flow-oriented ellipses. Each ellipse is generated by projecting a spherical spot onto a surface and by advecting the spot with the direction and magnitude of the vector field at the projection point. This amounts to the flow field-controlled generation of a band-limited noise. Initially straight, the spots are now bent along short streamlines to follow the curvature of the vector field [2]. An important feature of this method is the local control on the generated image. More spots gives rise to more accuracy. With spot noise the generation time depends on the number of spots used to generate the texture. Consequently, by setting the number of spots a trade-off can be obtained between image quality and rendering time.</p>\n<p>van Wijk [10] 提出了第一种以高空间分辨率表示流场的方法。点噪声法通过叠加许多流向椭圆来创建方向纹理。每个椭圆的产生都是通过将一个球形点投影到一个表面上，并在投影点上以矢量场的方向和大小平移该点。这相当于在流场控制下产生带限噪声。投影点最初是直的，现在会沿着短流线弯曲，以追随矢量场的曲率 [2]。这种方法的一个重要特点是对生成图像的局部控制。光斑越多，精度越高。对于光斑噪声，生成时间取决于生成纹理所使用的光斑数量。因此，通过设置点的数量，可以在图像质量和渲染时间之间取得平衡。</p>\n<p>Another interesting method is the line integral convolution (LIC) proposed by Cabral and Leedom [1] [4] [8]. A LIC texture is generated by convoluting an input texture with a streamline-oriented one dimensional filter kernel. The images obtained with this technique are very effectives, showing more details than the previously enumerated one. But this is obtained at the expense of computation. This computation cost is mainly due to the number of streamlines that have to be computed, and let us notice that even with the fastLIC method [8], several streamlines cover each single pixel of the resulting texture, giving rise to frequent recomputations.</p>\n<p>另一种有趣的方法是 Cabral 和 Leedom 提出的线积分卷积（LIC）[1] [4] [8]。LIC 纹理是通过将输入纹理与面向流线的一维滤波核进行卷积而生成的。使用这种技术生成的图像效果非常好，比之前列举的图像显示出更多细节。但这是以计算量为代价的。我们注意到，即使使用 fastLIC 方法 [8]，也会有多条流线覆盖生成纹理的每个像素，从而导致频繁的重新计算。</p>\n<p>The image-guided streamline placement method proposed in [9] uses a stochastic mechanism to iterately refine the placement of the streamlines. First an initial set of randomly placed streamlines is created. Then this set of streamlines is updated using three valid operations: (1) changing the position and/or length of a streamline, (2) joining streamlines that nearly abut, and (3) creating a new streamline to fill a gap. At each step of the refinement process a small change, i.e. a combination of the three operations mentioned above, is randomly performed. An energy function consults a low-pass-filtered (blurred) version of the image to measure the variation of energy between the current and the updated images and the modification is only accepted if the variation of energy if negative. This method produces high quality images but the convergence is very slow and obtaining a good visual appearance often requires several minutes for each image to be computed. Moreover this method is not suitable for dense field images because of the combinatorial explosion of the possible modifications at each step.</p>\n<p>文献 [9] 中提出的图像引导流线放置方法采用随机机制来迭代改进流线的放置。首先创建一组随机放置的初始流线。然后使用三种有效操作更新这组流线：(1) 改变流线的位置和 / 或长度；(2) 连接几乎相邻的流线；(3) 创建新的流线以填补空白。在细化过程的每一步，都会随机进行一个小的改变，即上述三种操作的组合。能量函数会参考图像的低通滤波（模糊）版本，测量当前图像和更新图像之间的能量变化，只有当能量变化为负时，修改才会被接受。这种方法能生成高质量的图像，但收敛速度非常慢，而且要获得良好的视觉效果，每计算一幅图像往往需要几分钟的时间。此外，由于每一步可能的修改都会出现组合爆炸，因此这种方法并不适用于密集场图像。</p>\n<p>The remainder of this paper is organized as follows. In section 2 we present a method for effective user-controlled evenly-spaced streamlines placement. Section 3 describes the use of the method to produce hand-drawing style images and we compare our approach with the image-guided streamline placement from Turk and Banks. In section 4 we show how texture-like images can be obtained and we discuss the advantages and drawbacks of this method compared to LIe. We conclude and offer directions for future research in section 5.</p>\n<p>本文的其余部分安排如下。在第 2 节中，我们介绍了一种有效的用户控制均匀分布流线的方法。第 3 节介绍了如何使用该方法生成手绘风格的图像，并将我们的方法与 Turk 和 Banks 的图像引导流线放置法进行了比较。在第 4 节中，我们展示了如何获得类纹理图像，并讨论了该方法与 LIe 相比的优缺点。最后，我们将在第 5 节中总结并提出未来的研究方向。</p>\n<p><img data-src=\"https://ptpimg.me/4him2f.jpg\" alt=\"\" /></p>\n<p>Fig.!. (a) Long streamlines with seed points placed on a regular grid (left); (b) Same flow field computed using our streamline placement method (right)</p>\n<p>图 (a) 在规则网格上放置种子点的长流线（左图）；(b) 使用我们的流线放置方法计算出的相同流场（右图）</p>\n<h2 id=\"algorithm-overview\"><a class=\"anchor\" href=\"#algorithm-overview\">#</a> Algorithm overview</h2>\n<p>算法概述</p>\n<p>The goal of this work is to produce long and evenly spaced streamlines in a single pass. The basic principle of our algorithm is similar to a method presented by Max et al in [6]. The goal of their work was to cover a 3D surface (not necessary tangential to the field) with a set of streamlines. Once a seed point has been selected in the field, they make a streamline growing beyond that point backward and forward. The growing process is stopped when the streamline reaches an edge of the surface, a singularity in the field (source or sink) or becomes too close to another streamline. The streamline is then divided into a set of small segments of contrasting color and projected onto the surface. Although Max's method was intended to visualize a flow on a 3D surface, it can be generalized to all kinds of steady 2D field.</p>\n<p>这项工作的目标是一次性生成间隔均匀的长流线。我们算法的基本原理与 Max 等人在文献 [6] 中提出的方法相似。他们的工作目标是用一组流线覆盖一个 3D 表面（不一定要与场相切）。<strong>一旦在场域中选择了一个种子点，他们就会在该点之后向前和向后延伸出一条流线。当流线到达表面边缘、场中的奇点（源或汇）或与另一条流线过于接近时，生长过程就会停止。然后，流线会被分成一组色彩对比鲜明的小段，并投射到表面上</strong>。虽然麦克斯的方法是为了将三维表面上的流动可视化，但它可以推广到各种稳定的二维场。</p>\n<p>We extend this work in the following manner. First we give a number of precisions concerning the implementation of the algorithm together with a couple of optimizations. Second we show how the algorithm can be controlled by the user to produce a wide range of flow fields images, ranging from hand-drawing to LIC-like style.</p>\n<p>我们通过以下方式对这项工作进行了扩展。首先，我们给出了一些关于算法实现的精确定位以及一些优化方案。其次，我们展示了用户如何控制该算法，以生成从手绘到类似 LIC 风格的各种流场图像。</p>\n<p>An important feature of the algorithm is that it processes in a single pass (as compared to TUrk's progressive refinement approach). To compute an image, a number of streamlines are calculated until a user-fixed density level has been obtained. Computing a new streamline is achieved in the following manner. A new seed point is chosen at a minimal distance apart from all existing streamlines. Then a new streamline is integrated beyond the seed point backward and forward until either it goes too close from another streamlines or it leaves the 2D domain over which the computation takes place. The algorithm ends when no more valid seed point can be found. Figure 1b shows an image obtained with our algorithm and figure la shows the same flow field visualized using a distribution of the seed points over a regular grid. The three following sections detail three important points of the algorithm: the control of the distance between adjacent , streamlines, seed points selection and streamline integration.</p>\n<p>该算法的一个重要特点是一次性处理（与鲁克的渐进细化方法相比）。<strong>要计算一幅图像，需要计算多条流线，直到获得用户固定的密度水平。计算新流线的方法如下。选择一个新的种子点，该点与所有现有流线的距离最小。然后，一条新的流线在种子点之外向前向后整合，直到它与其他流线的距离过近或离开计算所覆盖的二维域为止</strong>。<strong>当再也找不到有效的种子点时，算法结束</strong>。图 1b 显示了利用我们的算法获得的图像，图 1a 显示了利用种子点在规则网格上的分布对同一流场进行的可视化处理。下面三节将详细介绍<strong>该算法的三个要点：控制相邻流线之间的距离、种子点选择和流线整合</strong>。</p>\n<h3 id=\"control-of-the-separating-distance\"><a class=\"anchor\" href=\"#control-of-the-separating-distance\">#</a> Control of the separating distance</h3>\n<p>控制流线分离距离</p>\n<p>Density is a global feature of the field. However we need to express it as a local feature in order to have a local control on the texture generation. We express the density as the distance between two adjacent streamlines. Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> be this distance. Hence the control of the density of the field is achieved by controlling that there is not any pair of streamlines apart from a distance lower than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> This control occurs during the construction of each streamline. During the construction, a new sample point is valid only if it is at a separating distance greater than d. ep . If it is not the case, the streamline is stopped in this direction (during construction streamlines grow in both directions independently). In order to make the computation of the separating distance faster, rather than computing the exact distance from the new seed point location to the streamline, we compute the distance from the seed point to the sample points along the streamline. To make this approximation acceptable, the sample points on a streamline must be evenly spaced and the distance between them must be smaller than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> . Thus, a new sample point is valid if the distance between it and all the existing sample points is greater than the separating distance. Since this test has to be computed for all the sample points, it must be as fast as possible. To accelerate the computation of the distance, we use a cartesian grid superposed to the vector field domain, the width and height of a cell being exactly <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> . Each cell contains a list of pointers to the sample points located within the cell. Thus, given a new seed point location, the cell containing the location is easily determined. Let us call this cell the local cell. The distance has to be computed only for the sample points located either within the local cell or within the eight cells surrounding the local cell. In practice, we have noticed that an average of 5-7 distance computations is necessary to determine if a new sample point is valid or not. The denser is the grid, the less comparisons are required.</p>\n<p>密度是实地的一个整体特征。但我们需要将其表示为局部特征，以便对纹理生成进行局部控制。我们将密度表示为相邻两条流线之间的距离。让 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 成为这个距离。因此，<strong>对场密度的控制是通过控制没有任何一对流线之间的距离小于  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 来实现的 -- 这种控制发生在每条流线的构建过程中</strong>。在构建过程中，一个新的采样点只有在分隔距离大于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 时才有效。否则，流线将在该方向上停止（在构建过程中，流线在两个方向上独立生长）。<strong>为了加快分离距离的计算速度，我们不计算新种子点位置到流线的精确距离，而是计算种子点到流线沿线样本点的距离</strong>。为使这一近似值可以接受，流线上的样本点必须均匀分布，且它们之间的距离必须小于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 。因此，如果一个新采样点与所有现有采样点之间的距离大于分离距离，则该采样点有效。由于需要对所有样本点进行计算，因此必须尽可能快地完成测试。为了加快距离的计算速度，我们在矢量场域中叠加了一个直角坐标网格，网格的宽度和高度分别为 b</p>\n<p>remark: Practically, we consider two important distances, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> . <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> is the separating distance given by the user. It represents the minimal distance between seed points and streamlines. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is a percentage of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>u</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{up}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> . It corresponds to the minimal distance under which the integration of the streamline will be stopped in the current direction. We found <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> = 0.5 X <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> gives good visual result by producing long streamlines. For instance, images of Figure 2 have been calculated with two different values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> .</p>\n<p>注释 : <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 是用户给出的分离距离，表示种子点和流线之间的最小距离。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>u</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{up}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 的百分比。它对应于流线在当前方向上停止积分的最小距离。我们发现 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> = 0.5 X <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 能产生较长的流线，从而获得良好的视觉效果。例如，图 2 中的图像是用两个不同的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 值计算得出的。</p>\n<p><img data-src=\"https://ptpimg.me/4ncm1p.jpg\" alt=\"\" /></p>\n<p>Fig.2. increasing difference between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> lengthen streamlines; (left) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><msub><mi>d</mi><mn>1</mn></msub><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_1}_{test}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8941em;vertical-align:-0.1997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2309em;\"><span style=\"top:-2.5003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1997em;\"><span></span></span></span></span></span></span></span></span></span> = 0.9 x <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>; (right) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><msub><mi>d</mi><mn>2</mn></msub><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_2}_{test}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8941em;vertical-align:-0.1997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2309em;\"><span style=\"top:-2.5003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1997em;\"><span></span></span></span></span></span></span></span></span></span> = 0.5 x <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>图 2：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 之间的差值越大，链线越长；（左）<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><msub><mi>d</mi><mn>1</mn></msub><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_1}_{test}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8941em;vertical-align:-0.1997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2309em;\"><span style=\"top:-2.5003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1997em;\"><span></span></span></span></span></span></span></span></span></span> = 0.9 x <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>；（右）<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><msub><mi>d</mi><mn>2</mn></msub><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_2}_{test}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8941em;vertical-align:-0.1997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2309em;\"><span style=\"top:-2.5003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1997em;\"><span></span></span></span></span></span></span></span></span></span> = 0.5 x <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<h3 id=\"seed-points-selection\"><a class=\"anchor\" href=\"#seed-points-selection\">#</a> Seed points selection</h3>\n<p>种子点选择</p>\n<p>When using streamlines for vector field visualization, a common problem is to select proper seed points for path tracking. Dovey proposed two approaches to resample non-uniformly spaced grids in order to achieve an uniform density of vector glyphs [3). A vector field is represented with short segments oriented by the flow. In case of short streamlines or hedgehogs, the resulting image mainly depends on the distribution and density of the seed points over the domain. In case of long streamlines a constant density of seed points do not ensure a good distribution of the streamlines.</p>\n<p>在使用流线进行矢量场可视化时，一个常见问题是为路径跟踪选择合适的种子点。Dovey 提出了两种对非均匀间隔网格进行重采样的方法，以获得均匀密度的矢量字形 [3]。矢量场是用流动方向的短线段来表示的。如果是短流线或刺猬，生成的图像主要取决于种子点在域中的分布和密度。对于长流线，种子点的恒定密度并不能确保流线的良好分布。</p>\n<p>In order to obtain a good visual appearance of the flow field, an accurate seed point selection has to be perform, The principle of our algorithm is to derive all the seed points possible to find from an existing streamline before trying with another existing one. The proposed seed points are chosen at a distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">d = {d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> from the sample points of each streamline. Our algorithm uses a queue to store the newly created streamlines which are processed from the older one to the more recently created one, The algorithm is given below.</p>\n<p>为了获得流场的良好视觉效果，必须进行精确的种子点选择。我们算法的原理是从现有流线中找出所有可能的种子点，然后再尝试另一条现有流线。建议的种子点选择在与每条流线的样本点之间的距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">d = {d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 处。我们的算法使用一个队列来存储新创建的流线，这些流线从较早创建的流线到最近创建的流线依次处理，算法如下。</p>\n<p><img data-src=\"https://ptpimg.me/2p9a2s.jpg\" alt=\"\" /></p>\n<p>Figure 3 shows all the streamlines the algorithm has been able to derive from the first streamline for a given vector field.</p>\n<p>图 3 显示了算法能够从给定矢量场的第一条流线推导出的所有流线。</p>\n<p><img data-src=\"https://ptpimg.me/ct1a9q.jpg\" alt=\"\" /></p>\n<p>Fig. 3. streamlines are derived from the first (thick) one by choosing seed points (circles) at a distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">d = {d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>  from it</p>\n<p>图 3. 在距离第一条（粗）流线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">d = {d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 处选择种子点（圆圈），由此导出流线</p>\n<p><img data-src=\"https://ptpimg.me/zy57f0.jpg\" alt=\"\" /></p>\n<p>Fig.4. Two seed points selection method with the same density of streamlines: (left) random selection, (right) our selection method</p>\n<p>图 4. 流线密度相同的两种种子点选择方法：（左）随机选择，（右）我们的选择方法</p>\n<p>For sparse illustrations choosing to start streamlines close to existing ones gives better visual results than selecting seed points in a random fashion (see figure 4) but is more time-consuming. For dense texture generation, the quality of images produced with various seed point selection methods is quite similar.</p>\n<p>对于稀疏插图，选择靠近现有流线的流线开始，比随机选择种子点的视觉效果更好（见图 4），但更耗时。对于密集纹理生成，不同种子点选择方法生成的图像质量非常相似。</p>\n<h3 id=\"streamline-integration\"><a class=\"anchor\" href=\"#streamline-integration\">#</a> Streamline integration</h3>\n<p>流线简化整合</p>\n<p>In order to measure a consistent separating distance between a point and a streamline, sample points along a streamline must be evenly spaced (see section 2.1). Many integrators are able to produce such evenly spaced sequences of sample points. They can be classified into three categories:</p>\n<p>fixed step size integrators such as Euler, Midpoint or Runge-Kutta methods with normalized vector fields,</p>\n<p>non constant or adaptive step size integrators with a post interpolation phase such as cubic Hermite-interpolation, which deal with large distances between neighboring sample points and curvature of the streamlines [8],</p>\n<p>continuous integration methods such as DOPRI5, which is a fifth order Runge-Kutta integrator with adaptive step size monitoring and fourth order error estimation and produces a dense output directly by using informations gathered at each step of the integration [5].</p>\n<p>为了测量点与流线之间一致的分离距离，沿流线的采样点必须均匀分布（见第 2.1 节）。许多积分器都能产生这种均匀分布的采样点序列。它们可以分为三类：</p>\n<p>固定步长积分器，如欧拉积分法、中点积分法或 Runge-Kutta 积分法等归一化矢量场积分器、</p>\n<p><strong>具有后插值阶段的非恒定或自适应步长积分法，如立方赫米特插值法，可处理相邻样本点之间的大距离和流线曲率问题</strong> [8]、</p>\n<p><strong>连续积分法，如 DOPRI5，它是一种五阶 Runge-Kutta 积分器，具有自适应步长监控和四阶误差估计功能，可直接利用积分每一步收集的信息生成密集输出 [5]</strong>。</p>\n<p>At present we use the Midpoint integrator but future investigations will concern the choice of a better integration method. In particular using an adaptive step size integrator will decrease the number of integrations required, reducing overall computation time.</p>\n<p>目前，我们使用中点积分器，但未来的研究将涉及选择更好的积分方法。特别是使用自适应步长积分器将减少所需的积分次数，从而缩短整体计算时间。</p>\n<p><img data-src=\"https://ptpimg.me/964f6h.jpg\" alt=\"\" /></p>\n<p>Fig. 5. Image comparisons for separating distances of 6%, 3% and 1.5% of image width; left column: Image-guided placement; right column: Our streamline placement.</p>\n<p>图 5. 分离距离为图像宽度的 6%、3% 和 1.5% 时的图像对比；左列： 图像引导放置；右栏： 我们的流线型布局。</p>\n<h2 id=\"hand-drawing-style\"><a class=\"anchor\" href=\"#hand-drawing-style\">#</a> Hand-drawing style</h2>\n<p>手绘风格</p>\n<p>Sparse illustrations of flows fields are the more interesting application of our method. Turk et al proposed a method to compute such a representation in [9]. The method computes an initial set of streamlines which is then iterately refined until the global energy of the image falls below a fixed threshold or the user stops the process. The images obtained with this method are of great quality but the convergence of the iterative process is very slow and becomes much slower when desired density increases. Moreover the energy function used to measure the quality of the result is not directly related to the visual appearance of the image, requiring the appreciation of the user to stop the process.</p>\n<p>流场的稀疏表示是我们的方法更有趣的应用。Turk 等人在文献 [9] 中提出了一种计算此类表示的方法。该方法先计算一组初始流线，然后对其进行迭代改进，直到图像的全局能量低于固定阈值或用户停止该过程。用这种方法得到的图像质量很好，但迭代过程的收敛速度非常慢，当所需密度增加时，收敛速度会变得更慢。此外，用于衡量结果质量的能量函数与图像的视觉外观没有直接关系，需要用户的赞赏才能停止处理。</p>\n<p>The advantage of our method as compared to Turk's one is that it processes in a single pass, computing the final image directly. Figure 5 shows the same flow field computed by Turk's method with various refinement degrees and by our method and table 1 gives computation times necessary to produce the different images. We see that our method produces images of the same quality as Turk's ones but is less time-consuming.</p>\n<p>与特克的方法相比，我们的方法的优势在于一次性处理，直接计算最终图像。图 5 显示了用特克的方法和我们的方法计算出的具有不同细化程度的相同流场，表 1 给出了生成不同图像所需的计算时间。我们可以看到，我们的方法生成的图像质量与特克的方法相同，但耗时更短。</p>\n<p><img data-src=\"https://ptpimg.me/32b1lz.jpg\" alt=\"\" /></p>\n<p>Table 1. ComputatIOn tImes on a MIPS R4600 Processor, 132Mhz wIth 32Mo. Imageguided placement images and computation times were obtained with the Greg Turk's original publicly available algorithm.</p>\n<p>表 1. 在 132Mhz 和 32Mo MIPS R4600 处理器上的计算时间。图像引导放置图像和计算时间是使用格雷格 - 特克的原始公开算法获得的。</p>\n<p><img data-src=\"https://ptpimg.me/bv7ix0.jpg\" alt=\"\" /></p>\n<p>Fig. 6. Hand-drawing style images computed without and with the tapering effect</p>\n<p>图 6. 在没有锥形效应和有锥形效应的情况下计算的手绘风格图像</p>\n<p>Tapering effect. As stated in section 2.1 the actual distance between streamlines is not constant. Since the density is related to the distance between streamlines, disparities of density may appear in the resulting image. To reduce this visual artifact, Turk suggested to taper the ends of the streamlines by decreasing the thickness of the lines as they go closer to another one. In case of Turk's algorithm, this is achieved in a post-processing step. Our implementation allows to directly include the tapering optimization during the growing process of each streamline. The width of the streamline is computed using the following formula:</p>\n<p>锥形效应。如第 2.1 节所述，流线之间的实际距离并不是恒定的。由于密度与流线之间的距离有关，因此在生成的图像中可能会出现密度差异。为了减少这种视觉假象，特克建议将流线的末端变细，当流线越靠近另一条流线时，其厚度越小。在特克的算法中，这是通过后处理步骤实现的。而我们的算法则可以在每条流线的生长过程中直接进行锥度优化。流线宽度的计算公式如下</p>\n<p><img data-src=\"https://ptpimg.me/uci709.jpg\" alt=\"\" /></p>\n<p>where d is the distance to the closer streamline (see section 2.1 for the definition of the different distances).</p>\n<p>其中 d 是到较近流线的距离（不同距离的定义见第 2.1 节）。</p>\n<p>Fig 6 shows the same image computed without and with the tapering effect.</p>\n<p>图 6 显示了在没有锥形效应和有锥形效应的情况下计算得出的相同图像。</p>\n<p><strong>Glyph mapping</strong>. Once the streamline placement has been computed, the streamlines can be viewed as skeletons on which directional glyphs can be mapped. Figure 7 shows an image obtained by mapping such kind of icons onto the computed streamlines. This enables to add a directional information in the field.</p>\n<p><strong>字形映射</strong> 计算出流线位置后，就可以将流线视为骨架，在骨架上映射出方向性字形。图 7 显示了将此类图标映射到计算出的流线后得到的图像。这样就可以在字段中添加方向信息。</p>\n<p><img data-src=\"https://ptpimg.me/l972ez.jpg\" alt=\"\" /></p>\n<p>Fig. 7. examples of illustrations with glyph mapping</p>\n<p>图 7：带有字形映射的插图示例</p>\n<h2 id=\"texture-generation\"><a class=\"anchor\" href=\"#texture-generation\">#</a> Texture generation</h2>\n<p>纹理生成</p>\n<p>By decreasing the separating distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> , the coverage of the streamlines becomes dense over the field. To depict the tangential component of the flow in a dense representation we have to differentiate close streamlines to be able to follow them over the field. This is achieved by mapping a periodic intensity function onto the streamline. Let us consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> a function which associates an intensity to every sample point on a streamline where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is the rank of the sample point within the streamline. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> will give the shape of the intensity wave on the streamline. For instance, one may associate the two functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> given below:</p>\n<p>通过减小分离距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>，流线的覆盖范围会在场上变得密集。为了用密集表示法描述流动的切向分量，我们必须区分近距离的流线，以便在场上跟踪它们。这可以通过将周期性强度函数映射到流线上来实现。让我们考虑一下 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>，它是一个将强度与流线上的每个采样点相关联的函数，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 是采样点在流线上的位置。例如，我们可以将下面给出的两个函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 联系起来：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mfrac><mrow><mn>2</mn><mi>π</mi><mi>x</mi></mrow><mi>N</mi></mfrac><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi>a</mi><mi>n</mi><mi>d</mi><msub><mi>f</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>x</mi><mtext> </mtext><mo lspace=\"0.22em\" rspace=\"0.22em\"><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow></mo><mtext> </mtext><mi>N</mi></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">{f_1} (x) = {1 \\over 2} (1 + \\sin ( { {2\\pi x} \\over N} ) ) and {f_2} (x) = { {x\\bmod N} \\over {N - 1} }\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mord mathnormal\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mclose\">))</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">d</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1408em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></span></p>\n<p>where N is the length of the period as a number of sample points.</p>\n<p>其中，N 是作为样本点数的周期长度。</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> will give a smooth continuously increasing and decreasing intensity while the modulo function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> will produce discontinuous segments of increasing intensity in order to remove ambiguities about the orientation of the flow. Figures 8 and 9 show an image obtained using this pair of functions.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 将产生平滑的连续递增和递减的强度，而调制函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 将产生强度递增的不连续片段，以消除流动方向的模糊性。图 8 和图 9 展示了使用这对函数得到的图像。</p>\n<p><img data-src=\"https://ptpimg.me/59i731.jpg\" alt=\"\" /></p>\n<p>Fig.8. textures generated with the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> function for intensity effects; (left) short and (right) long period of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>图 8. 使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 功能生成的纹理强度效果；（左）<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的短周期和（右）长周期</p>\n<p>The images obtained with our method look like LIC images. In fact our algorithm is somehow a dual version of LIC. With LIC, for each pixel p of the output image, one integrates a particle path centered on p forward and backward and then averages intensities of the input texture pixels to get the intensity of the pixel being calculated. In our method, we find an optimal dense coverage of the field which minimizes the number of integrated streamlines and then associate  an intensity to each pixel of all the streamlines.</p>\n<p>用我们的方法得到的图像看起来就像 LIC 图像。事实上，我们的算法在某种程度上是 LIC 的双重版本。使用 LIC 时，对于输出图像的每个像素 p，我们都要对以 p 为中心的粒子轨迹进行前后积分，然后对输入纹理像素的强度求平均值，从而得到被计算像素的强度。在我们的方法中，我们会找到一个最佳的密集覆盖区域，使积分流线的数量最小，然后将强度与所有流线的每个像素相关联。</p>\n<p><img data-src=\"https://ptpimg.me/t22ms0.jpg\" alt=\"\" /></p>\n<p>Fig.9. textures generated with the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> function for intensity effects; (left) short and (right) long period of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>图 9. 用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 函数生成的纹理强度效应；（左）短周期和（右）<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{f_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的长周期</p>\n<p>Now let us point on the advantages of our method over LIC. The first advantage is that our method does not require an input texture to process. With LIC a problem arises when one want to change the length of the apparent streamlines. In case of LIC, it is necessary to change the length of the convolution filter, which gives rise to a computation overhead. It is stated in [1] that doubling the length increases the computation time by a factor of four. Okada and Lane have proposed another solution, which consists in executing the LIC algorithm twice, the resulting image of the first execution being used as the input of the second execution [7]. This method results in lines which are more easily distinguishable but it concentrates the pixels values in a narrow range of intensity, which decreases the global contrast. This effect can be removed by applying post-filters to the final image, but this is done at the expense of a computation overhead (approximately by a factor of two).</p>\n<p>现在，让我们来谈谈我们的方法与 LIC 相比的优势。第一个优点是我们的方法不需要处理输入纹理。使用 LIC 方法时，如果要改变表观流线的长度，就会出现问题。在 LIC 方法中，必须改变卷积滤波器的长度，这就会产生计算开销。文献 [1] 指出，长度增加一倍，计算时间增加四倍。Okada 和 Lane 提出了另一种解决方案，即两次执行 LIC 算法，将第一次执行的图像作为第二次执行的输入 [7]。这种方法得到的线条更容易分辨，但会将像素值集中在一个较窄的强度范围内，从而降低整体对比度。通过对最终图像进行后置滤波可以消除这种影响，但这样做会增加计算开销（约为原来的两倍）。</p>\n<p>With our approach we are able to change the length of the apparent streamlines on demand by simply changing the length of the period of the function as described above, without recomputation of any streamline.</p>\n<p>采用我们的方法，我们只需改变上述函数周期的长度，就能按需改变表观流线的长度，而无需重新计算任何流线。</p>\n<p>In the traditional LIC algorithm, a streamline integration and a line convolution are computed for each individual pixels, so most of the time is spent in convolution and integration operations. Decreasing the number of streamlines computed would greatly benefit the LIC algorithm. Stalling and Hege proposed the FastLIC algorithm which reduces the overall number of streamline computations by sharing the line integral convolution information of each streamline with all the pixels it goes through [8].</p>\n<p>在传统的 LIC 算法中，每个像素都要计算流线积分和线卷积，因此大部分时间都花在卷积和积分操作上。减少计算流线的数量将大大有利于 LIC 算法。Stalling 和 Hege 提出了 FastLIC 算法，该算法通过与流经的所有像素共享每条流线的线积分卷积信息来减少流线计算的总次数 [8]。</p>\n<p>With our approach, we compute the minimum number of streamlines necessary to cover entirely the 2D area over which the field is studied.</p>\n<p>利用我们的方法，我们可以计算出完全覆盖所研究场域的二维区域所需的最少流线数量。</p>\n<p>For instance, the computation of textures images of size 512 x 512 (such as figures 8 and 9) takes about 25 seconds on a R5000SC-64Mo based system. These results have been obtained using a random seed points selection method and a separating distance of 0.3%. As far as dense texture images are concerned, a drawback of our method is the aliasing effect due to the drawing of adjacent line segments of different colors. To remove this artifact we can smooth the final image by simply applying a blur filter.</p>\n<p>例如，在基于 R5000SC-64Mo 的系统上计算大小为 512 x 512 的纹理图像（如图 8 和图 9）大约需要 25 秒。这些结果是采用随机种子点选择方法和 0.3% 的分离距离计算得出的。就高密度纹理图像而言，我们方法的一个缺点是绘制不同颜色的相邻线段时会产生混叠效应。为了消除这种假象，我们可以通过简单地应用模糊滤波器来平滑最终图像。</p>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>结论</p>\n<p>We have presented an effective method to place long evenly-spaced streamlines with an accurate control on the density of the final image. By changing the separating distance between streamlines we are able to produce from sparse to dense representations of flow fields. We show that our method produces images of a quality at least as good as other methods but that it is computationally less expensive and offers a better control on the rendering process. Future investigations will concern a more efficient integrator, generalization to unsteady flows and real time animation.</p>\n<p>我们提出了一种有效的方法来放置均匀分布的长流线，并对最终图像的密度进行精确控制。通过改变流线之间的分离距离，我们能够生成从稀疏到密集的流场图像。我们的研究表明，我们的方法生成的图像质量至少不亚于其他方法，但计算成本更低，对渲染过程的控制也更好。未来的研究将涉及更高效的积分器、非稳态流的通用性和实时动画。</p>\n",
            "tags": [
                "Hyperstreamline"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/07/11/basic-theory/Over-Two-Decades-of-Integration-Based-Geometric-Flow-Visualization/",
            "url": "https://sakurame.eu.org/2023/07/11/basic-theory/Over-Two-Decades-of-Integration-Based-Geometric-Flow-Visualization/",
            "title": "Over_Two_Decades_of_Integration-Based_Geometric_Flow_Visualization",
            "date_published": "2023-07-11T14:23:47.000Z",
            "content_html": "<h1 id=\"over-two-decades-of-integration-based-geometric-flow-visualization\"><a class=\"anchor\" href=\"#over-two-decades-of-integration-based-geometric-flow-visualization\">#</a> Over Two Decades of Integration-Based, Geometric Flow Visualization</h1>\n<p>二十多年来基于集成的几何流可视化的发展</p>\n<p>Abstract</p>\n<p>With ever increasing computing power, it is possible to process ever more complex fluid simulations. However, a gap between data set sizes and our ability to visualize them remains. This is especially true for the field of flow visualization, which deals with large, time-dependent, multivariate simulation data sets. In this paper, geometry-based flow visualization techniques form the focus of discussion. Geometric flow visualization methods place discrete objects in the velocity field whose characteristics reflect the underlying properties of the flow. A great amount of progress has been made in this field over the last two decades. However, a number of challenges remain, including placement, speed of computation and perception. In this survey, we review and classify geometric flow visualization literature according to the most important challenges when considering such a visualization, a central theme being the seeding algorithm upon which they are based. This paper details our investigation into these techniques with discussions on their applicability and their relative merits and drawbacks. The result is an up-to-date overview of the current state-of-the-art that highlights both solved and unsolved problems in this rapidly evolving branch of research. It also serves as a concise introduction to the field of flow visualization research.</p>\n<p>摘要 随着计算能力的不断提高，我们有可能处理更复杂的流体模拟。然而，在数据集的大小和我们对其进行可视化的能力之间仍然存在着差距。这对于处理大型的、随时间变化的、多变量的模拟数据集的流动可视化领域尤其如此。在本文中，基于几何的流动可视化技术是讨论的重点。几何流动可视化方法在速度场中放置离散的物体，其特征反映了流动的基本属性。在过去的二十年里，这一领域已经取得了很大的进展。然而，仍然存在一些挑战，包括放置、计算速度和感知。在这项调查中，我们根据考虑这种可视化时最重要的挑战对几何流可视化文献进行了回顾和分类，一个中心主题是它们所基于的播种算法。本文详细介绍了我们对这些技术的调查，讨论了它们的适用性及其相对的优点和缺点。其结果是对当前最先进的技术的最新概述，突出了这一快速发展的研究分支中已解决和未解决的问题。它也是对流动可视化研究领域的一个简明介绍。</p>\n<p>Keywords: flow visualization, vector fields, time-dependent data</p>\n<p>Categories and Subject Descriptors (according to ACM CCS): I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling</p>\n<p>关键词：流量可视化，矢量场，随时间变化的数据</p>\n<p>分类和主题描述符（根据 ACM CCS）： I.3.5 [计算机图形学]： 计算几何和物体建模</p>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>Flow visualization is a classic branch of scientific visualization. Its applications cover a broad spectrum ranging from turbomachinery design to the modeling and simulation of weather systems. The goal of flow visualization is to present the behavior of simulation data in a meaningful manner from which important flow features and characteristics can be easily identified and analyzed.</p>\n<p>简介</p>\n<p>流动可视化是科学可视化的一个经典分支。它的应用范围很广，从涡轮机械设计到天气系统的建模和模拟。流动可视化的目标是以一种有意义的方式展示模拟数据的行为，从中可以很容易地识别和分析重要的流动特征和特性。</p>\n<p>Given the large variety of techniques currently utilized in visualization applications, selecting the most appropriate visualization technique for a given data set is a non-trivial task.</p>\n<p>鉴于目前在可视化应用中使用的技术种类繁多，为给定的数据集选择最合适的可视化技术是一项非艰巨的任务。</p>\n<p>Considerations have to be made taking into account the type of information the user wishes to extract from the visualization along with the spatial and temporal characteristics of the data set being analyzed. Different approaches have to be designed for different types of data. For example, visualization of 2D data is much different from visualizing 3D data.On top of this is the further complication of temporal dimensionality, with varying techniques more suited to steady flow compared to time-dependent flow fields and vice versa. To this end, different tools have been developed according to the different needs of the users and the differing dimensionality of velocity field data.</p>\n<p>必须考虑到用户希望从可视化中提取的信息类型，以及被分析的数据集的空间和时间特征。必须为不同类型的数据设计不同的方法。例如，二维数据的可视化与三维数据的可视化有很大的不同。在此基础上，时间维度的进一步复杂化，不同的技术更适合于稳定流与时间相关的流场，反之亦然。为此，我们根据用户的不同需求和速度场数据的不同维度开发了不同的工具。</p>\n<h3 id=\"challenges-in-flow-visualization\"><a class=\"anchor\" href=\"#challenges-in-flow-visualization\">#</a> Challenges in flow visualization</h3>\n<p>流量可视化的挑战</p>\n<p>Flow simulations, or CFD (computational fluid dynamics) simulations, are computed using methods such as the Navier–Stokes equations [CSvS86] and are used to simulate experiments such as wind-tunnel tests on cars and airplanes. The visualization of these simulations poses many challenges, the most important of which we outline here.</p>\n<p>流动模拟，或 CFD（计算流体力学）模拟，是用纳维 - 斯托克斯方程等方法计算的 [CSvS86]，并被用来模拟实验，如汽车和飞机的风洞测试。这些模拟的可视化带来了许多挑战，其中最重要的是我们在此概述。</p>\n<p><strong>Large data sets</strong>. A major technical issue arises from the sheer volume of data that may be generated from complex simulations. Velocity data comprise scalar values for each x, y,z velocity component at each sample point within the data domain. When coupled with several scalar data attributes and consisting of many time-steps, a large amount of data results. Advances in hardware are leading to more computational power and the ability to process larger, more complex simulations with faster computation times. Therefore, flow visualization algorithms must be able to handle this large amount of data and present the results (ideally) at interactive frame rates in order to be most useful in the investigation and analysis of simulation data.</p>\n<p><strong>大型数据集</strong>。一个主要的技术问题来自于复杂模拟中可能产生的大量的数据。速度数据包括数据域内每个采样点的 x、y、z 速度分量的标量值。当与几个标量数据属性结合在一起并由许多时间步长组成时，会产生大量的数据。硬件的进步导致了更多的计算能力和处理更大、更复杂的模拟的能力，而且计算时间更快。因此，流量可视化算法必须能够处理这种大量的数据，并以交互式帧速率呈现结果（最好是），以便在调查和分析模拟数据时发挥最大作用。</p>\n<p><strong>Interaction, seeding and placement.</strong> One of the main challenges specific to geometric flow visualization is the seeding strategy used to place the objects within the data domain.Geometric flow visualization techniques produce discrete objects whose shape, size, orientation and position reflect the characteristics of the underlying velocity field. The position of the objects greatly affects the final visualization. Different features of the velocity field may be depicted depending on the final position and the spatial frequency of the objects in the data domain. It is critical that the resulting visualization captures the features of the velocity field, e.g. vortices, turbulence, sources, sinks and laminar flow, which the user is interested in. This aspect becomes an even greater challenge in the case of 3D where a balance of field coverage, occlusion and visual complexity must be maintained. Time-dependent data also raise a challenge because the visualization then depends on when objects are seeded.</p>\n<p><strong>互动、播种和放置</strong>。几何流可视化的主要挑战之一是用于在数据域中放置对象的播种策略。几何流可视化技术产生的离散对象的形状、大小、方向和位置反映了基础速度场的特征。对象的位置对最终的可视化效果影响很大。根据数据域中物体的最终位置和空间频率，可以描绘出速度场的不同特征。至关重要的是，最终的可视化结果能捕捉到用户感兴趣的速度场的特征，如涡流、湍流、源、汇和层流。这方面在三维的情况下成为更大的挑战，因为必须保持场覆盖、遮挡和视觉复杂性的平衡。与时间有关的数据也是一个挑战，因为可视化取决于物体何时被播种。</p>\n<p><strong>Computation time and irregular grids</strong>. Another challenge stems from the computation time. Most of the visualizations compute a geometry that is tangential to the velocity field, e.g.the path a massless particle would take when placed into the flow. Computing such curves through 3D, unstructured grids is non-trivial. Thus, much research has been devoted to this and similar topics, see Section 2.4. A recent trend to increase performance has been to move computations from the CPU and perform them on the graphics processing unit (GPU) [BSK∗07]. Although the resultant rendering looks the same as a CPU version (see Figure 1), this may offer a significant improvement in performance as the vector calculations are suited to the multiple execution units on the GPU – resulting in high performance parallel processing.</p>\n<p><strong>计算时间和不规则网格</strong>。另一个挑战来自于计算时间。大多数的可视化计算都是计算与速度场相切的几何图形，例如一个无质量的粒子被放入流中时的路径。通过三维非结构化网格计算这种曲线是不容易的。因此，很多研究都是针对这个和类似的主题，见第 2.4 节。最近一个提高性能的趋势是将计算从 CPU 转移到图形处理单元（GPU）上进行 [BSK∗07]。虽然最终的渲染结果看起来与 CPU 版本相同（见图 1），但由于矢量计算适合于 GPU 上的多个执行单元，这可能会带来性能上的显著提高 -- 导致高性能的并行处理。</p>\n<p><strong>Perception</strong>. A central challenge in flow visualization (and visualization in general) relates to perceptual challenges in visualizing 3D and 4D velocity fields as well as multi-variate data sets. If streamlines are used to visualize flow in 3D, too many lines cause clutter, visual complexity and occlusion. If too few are rendered, important characteristics may not be visualized. Thus, an optimal balance between coverage and perception must be achieved. Animated flow presents its own unique challenges to the perception of the user. For instance, it may not be intuitive what a user sees from a cloud of moving particles or a surface deforming to the local flow characteristics. It may also be difficult to discern the movement direction is 3D space.</p>\n<p><strong>感知</strong>。流动可视化（以及一般的可视化）的一个核心挑战涉及到三维和四维速度场以及多变量数据集的可视化的感知挑战。如果用流线来显示三维流动，太多的线会造成杂乱、视觉复杂和遮挡。如果呈现的线条太少，重要的特征可能就无法显示。因此，必须在覆盖率和感知力之间取得最佳平衡。动画流对用户的感知提出了自己独特的挑战。例如，用户从移动的粒子云或根据局部流动特征变形的表面看到的东西可能并不直观。在三维空间中，也可能很难辨别运动方向。</p>\n<p><img data-src=\"https://ptpimg.me/hat087.jpg\" alt=\"\" /></p>\n<p>Figure 1: A set of streamlines exploiting the power of modern programmable GPUs for faster computation [DGKP09].</p>\n<p>图 1：一组利用现代可编程 GPU 的力量进行快速计算的流线 [DGKP09]。</p>\n<h3 id=\"contributions\"><a class=\"anchor\" href=\"#contributions\">#</a> Contributions</h3>\n<p>In light of these challenges and the more than two decades of research the main benefits and contributions of this paper are:</p>\n<p>鉴于这些挑战和二十多年的研究，本文的主要好处和贡献是：</p>\n<p>We review the latest developments in geometry-based flow visualization research.</p>\n<p>• We introduce a novel classification scheme based on challenges including seeding. This scheme lends itself to an intuitive grouping of papers that are naturally related to each other. This allows the reader to easily extract the relevant literature without having to read the entire survey.</p>\n<p>• Our classification highlights both unsolved problems in the area of geometric flow visualization and mature areas where many solutions have been provided.</p>\n<p>• This survey is the most up-to-date presentation on this popular topic. The last time this topic was addressed in the literature was over six years ago [PVH∗03].</p>\n<p>• We provide a very concise introduction and overview in the area of vector field visualization for those who are new to the topic and wishing to carry out research in this area</p>\n<p>我们回顾了基于几何的流动可视化研究的最新进展。</p>\n<p>我们介绍了一种基于挑战（包括播种）的新型分类方案。这个方案适合于对那些相互之间有自然联系的论文进行直观的分组。这使得读者可以很容易地提取相关文献，而不必阅读整个调查报告。</p>\n<p>我们的分类既强调了几何流可视化领域的未解决的问题，也强调了已经提供了许多解决方案的成熟领域。</p>\n<p>这份调查报告是对这个热门话题的最新介绍。上一次在文献中讨论这个话题是在六年多以前 [PVH∗03]。</p>\n<p>我们在矢量场可视化领域提供了一个非常简明的介绍和概述，供那些刚接触这个主题和希望在这个领域进行研究的人参考。</p>\n<p>Table 1: An overview and classification of integration-based geometric methods in flow visualization along the x-axis. Research is grouped based on the temporal dimensionality along the y-axis. Each group is then split into techniques that are applicable to steady or unsteady flow. Finally the entries are grouped into chronological order. The subscript “p” indicates visualization using particles. This table provides an overview of research and highlights unsolved problems as well as challenges for which a range of solutions have been provided.</p>\n<p>表 1：流量可视化中基于集成的几何方法的概述和分类（沿 X 轴）。研究根据 Y 轴上的时间维度进行分组。然后，每组被分成适用于稳定或不稳定流动的技术。最后，条目按时间顺序进行分组。下标 &quot;p&quot; 表示使用粒子进行可视化。这个表格提供了一个研究的概述，并强调了未解决的问题以及已经提供了一系列解决方案的挑战。</p>\n<p><img data-src=\"https://ptpimg.me/c0kw49.jpg\" alt=\"\" /></p>\n<p>We have made a great effort not to provide simply an enumeration of related papers in integration-based, geometric flow visualization, but to compare different methods, related to one another and weigh their relative merits and weaknesses.</p>\n<p>我们做了很大的努力，不是简单地列举基于集成的几何流可视化的相关论文，而是比较不同的方法，彼此相关，权衡它们的相对优点和缺点。</p>\n<h3 id=\"classification\"><a class=\"anchor\" href=\"#classification\">#</a> Classification</h3>\n<p>One of the main challenges of a survey is classifying these approaches and presenting them in a meaningful order. There are four general categories into which vector-field visualization approaches can be divided: direct, dense texture-based, geometric and feature-based. This paper focuses on the geometric approaches to flow visualization, which received little coverage in previous surveys [LHD∗04, PVH∗03, LHZP07]. A large volume of research work has been undertaken in geometry-based vector field visualization. We use four tiers of categorization. Our top level of classification groups the literature by the dimensionality of the object used in the resulting visualization, i.e. curves, surfaces and volumes. We then subdivide the literature further according to the spatial dimensionality of the data domain, i.e. 2D velocity fields, velocity fields on surfaces and in 3D volumes. Temporal dimensionality is also used to group papers together, i.e. steady vs. unsteady flow. And finally, those papers belonging to the same sub-class appear chronologically (see Table 1). Classifying the literature in this way facilitates comparison of similar papers with one another. It also highlights unaddressed challenges and problems for which a range of solutions exist. We give a brief overview and comparison of the four main categories before analyzing the geometric approaches in more detail.</p>\n<p>调查的主要挑战之一是对这些方法进行分类，并以有意义的顺序来介绍它们。矢量场可视化方法可以分为四类：直接、基于密集纹理、几何和基于特征。本文重点讨论流量可视化的几何方法，这在以前的调查中几乎没有涉及 [LHD∗04, PVH∗03, LHZP07]。在基于几何的矢量场可视化方面，已经进行了大量的研究工作。我们采用四级分类法。我们的顶层分类是按所产生的可视化中使用的对象的维度对文献进行分组，即曲线、曲面和体积。然后，我们根据数据域的空间维度进一步细分文献，即二维速度场、表面的速度场和三维体积的速度场。时间维度也被用来对论文进行分组，即稳定流与非稳定流。最后，那些属于同一子类的论文按时间顺序排列（见表 1）。以这种方式对文献进行分类，有利于类似论文的相互比较。它还突出了未解决的挑战和存在一系列解决方案的问题。在更详细地分析几何方法之前，我们对四个主要类别进行了简要概述和比较。</p>\n<h3 id=\"direct-texture-based-and-feature-based-flow-visualization\"><a class=\"anchor\" href=\"#direct-texture-based-and-feature-based-flow-visualization\">#</a> Direct, texture-based and feature-based flow visualization</h3>\n<p>直接的、基于纹理的和基于特征的流量可视化</p>\n<p>Direct techniques are the most primitive methods of flow visualization. Typical examples involve placing an arrow glyph at each sample point in the domain to represent the vector data or mapping color according to local velocity magnitude. Direct techniques are simple to implement and computationally inexpensive. They allow for immediate investigation of the flow field. However, direct techniques may suffer from visual complexity and imagery that lacks in visual coherency. They also suffer from serious occlusion problems when applied to 3D data sets.</p>\n<p>直接技术是最原始的流动可视化方法。典型的例子是在域中的每个采样点放置一个箭头字样来表示矢量数据或根据局部速度大小来映射颜色。直接技术实现起来很简单，计算成本也不高。它们允许对流场进行即时调查。然而，直接技术可能受到视觉复杂性和图像缺乏视觉一致性的影响。当应用于三维数据集时，它们还存在着严重的遮挡问题。</p>\n<p>Dense, texture-based techniques, as the name implies, exploit textures to form a representation of the flow. The general approach uses texture (generally a filtered noise pattern), which is smeared and stretched according to the local properties of the velocity field. Texture-based approaches provide a dense visualization result, provide lots of detail, and capture many flow characteristics even in areas of intricate flow such as vortices, sources and sinks. Texture-based methods generally cover the entire domain. They also share some of the same weakness of 3D domain representation as direct methods and are generally more suited to 2D or surfaces. A thorough investigation of texture-based flow visualization is presented by Laramee et al [LHD∗04].</p>\n<p>密集的、基于纹理的技术，顾名思义，利用纹理来形成流动的表示。一般的方法是使用纹理（一般是过滤后的噪声模式），根据速度场的局部特性进行涂抹和拉长。基于纹理的方法提供了密集的可视化结果，提供了大量的细节，甚至在错综复杂的流动区域，如涡流、源和汇，也能捕获许多流动特征。基于纹理的方法通常覆盖整个领域。它们也和直接方法一样有一些三维域表示的弱点，一般更适合于二维或表面。Laramee 等人 [LHD∗04] 对基于纹理的流动可视化进行了深入研究。</p>\n<p>Feature-based algorithms focus the visualization on selected features of the data such as vortices or topological information rather than the entire data set. This may result in a large reduction of the required data and thus these techniques are suited to large data sets that may consist of many time-steps. Since they generally perform a search of the domain, these techniques require considerably more processing before visualization. A survey of feature-based approaches is presented by Post et al [PVH∗03].</p>\n<p>基于特征的算法将可视化的重点放在数据的选定特征上，如涡流或拓扑信息，而不是整个数据集。这可能会导致所需数据的大量减少，因此这些技术适合于可能由许多时间步长组成的大型数据集。由于它们通常对领域进行搜索，这些技术在可视化之前需要相当多的处理。Post 等人 [PVH∗03] 对基于特征的方法进行了调查。</p>\n<h3 id=\"integration-based-geometric-flow-visualization\"><a class=\"anchor\" href=\"#integration-based-geometric-flow-visualization\">#</a> Integration-based, geometric flow visualization</h3>\n<p>基于整合的几何流动可视化</p>\n<p>Geometric methods define sets of seeding points from which trajectories (streamlines or pathlines) are computed. Trajectories are then used for building geometric objects, in contrast to other methods where they are used for filtering or advecting textures or for topological analysis.</p>\n<p>几何方法定义了一些播种点，从中计算出轨迹（流线或路径线）。轨迹随后被用于构建几何对象，而其他方法则用于过滤或平移纹理或进行拓扑分析。</p>\n<p>Geometric approaches compute discrete objects within the data domain. Velocity, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>X</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">V = { { dX} \\over {dt } }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\">t</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span> , is a derivative quantity. If we imagine tracking a massless particle through a velocity field, the displacement of such a point can be described by:</p>\n<p>几何方法计算数据域中的离散对象。速度，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>X</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">V = { {dX} \\over { dt } }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2251em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\">t</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span> ，是一个导数量。如果我们想象通过速度场追踪一个无质量的粒子，这样一个点的位移可以用以下方式描述：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>x</mi><mo>=</mo><mi>v</mi><mo>⋅</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">dx = v \\cdot dt\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span></span></span></span></span></p>\n<p>where x is the position of the point, t is the time and v is the velocity field. The analytical solution is approximated using a numerical integration method. Thus, geometry-based techniques are also known as integration-based and characterize the flow field with their geometry. It is a non-trivial task to automatically distribute the objects such that all of the important features of the velocity field are captured in the resulting visualization.</p>\n<p>其中 x 是点的位置，t 是时间，v 是速度场。分析解是用数值积分法来近似的。因此，基于几何的技术也被称为基于积分的技术，用它们的几何形状来描述流场的特征。自动分配对象，使速度场的所有重要特征都能在所产生的可视化中得到体现，这是一项非难事。</p>\n<p>Two main aspects of geometric flow visualization dominated research for a decade. In the first decade, the focus was on particle tracing, i.e. the numerical computation of trajectories for various types of data discretization. In the second decade, interest shifted to particle seeding strategies. Geometric visualization techniques are suited to all spatial and temporal dimensions. However, without careful use they are susceptible to visual clutter and occlusion problems. These problems mainly arise from poor seeding strategies and thus considerable effort has been put into researching seeding strategies that provide clear, detailed visualizations. We start out our survey of the literature with the point-based seeding algorithms in 2D velocity field domains.</p>\n<p>几何流可视化的两个主要方面主导了十年的研究。在第一个十年中，重点是粒子追踪，即对各种类型的数据离散化的轨迹进行数值计算。在第二个十年中，兴趣转移到了粒子播种策略。几何可视化技术适用于所有空间和时间维度。然而，如果不仔细使用，它们很容易受到视觉杂乱和遮挡问题的影响。这些问题主要来自于不良的播种策略，因此，人们在研究提供清晰、详细的可视化的播种策略方面付出了大量的努力。我们从二维速度场域中基于点的播种算法开始对文献进行调查。</p>\n<p>Table 1 provides a concise overview of the literature grouped according to our classification scheme. Literature is divided up based upon both the dimensionality of the geometry-based objects in the domain and the dimensionality of the data domain itself. Organizing the literature in this way points out the mature areas where many solutions are offered and those areas still rich with unsolved problems.</p>\n<p>表 1 提供了根据我们的分类方案分组的文献的简明概述。文献是根据领域中基于几何的对象的维度和数据领域本身的维度来划分的。以这种方式组织的文献指出了有许多解决方案的成熟领域和那些仍有大量未解决问题的领域。</p>\n<h3 id=\"terminology\"><a class=\"anchor\" href=\"#terminology\">#</a> Terminology</h3>\n<p>Here we introduce some common, important flow visualization terminology. The most common geometric technique is the streamline. A streamline is a curve that is everywhere tangent to the steady-state flow field. A critical point is a location in the velocity field where the velocity magnitude is zero. The behavior of the flow in the region around the critical point is used to classify its type. Some examples of critical points are sources, sinks and saddle points.</p>\n<p>这里我们介绍一些常见的、重要的流动可视化术语。最常见的几何技术是流线。流线是一条与稳态流场到处相切的曲线。临界点是速度场中速度大小为零的一个位置。临界点周围区域的流动行为被用来对其类型进行分类。临界点的一些例子是源点、汇点和鞍点。</p>\n<p>Velocity fields are either steady (static) or unsteady (changing over time). There are a variety of techniques that are usually more suited to one temporal dimensionality over the another. Unsteady flow is generally more challenging than steady flow. A natural way of representing timedependent flow is through animation, which explicitly shows the changes over time. Animation can also be used to visualize steady flows where the animation is used to indicate the downstream motion of the flow or to depict local velocity magnitude.</p>\n<p>速度场要么是稳定的（静态），要么是不稳定的（随时间变化）。有多种技术通常更适合于一种时间维度而不是另一种。不稳定流通常比稳定流更具挑战性。表示随时间变化的流动的一种自然方式是通过动画，它明确显示随时间的变化。动画也可用于稳定流的可视化，其中动画被用来表示流动的下游运动或描述局部速度大小。</p>\n<p>Unsteady flow is not restricted to being visualized by animation. Streaklines and pathlines, for instance, are computed from successive time-steps together so that multiple time-steps may be displayed in a single static image. A pathline or particle trace is the trajectory that a massless particle takes in an unsteady fluid flow. A streakline is the line joining a set of particles that have all been seeded at the same spatial location (but at successive times). If seeded at the same location in a steady flow field streamlines, pathlines and streaklines are identical. A timeline is a line connecting all particles that have been simultaneously released in a velocity field. The timeline is advected through the flow field and is deformed according to the local velocity variations. Streamlets are short streamline segments. A stream surface is a surface that is everywhere tangent to the vector field, it is the locus of a set of streamlines from a shared seeding curve. Path surfaces and streak surfaces are extensions of pathlines and streaklines that are obtained by seeding from a curve instead of a point. For a path surface, seeding is done at a fixed time and particle positions are traced over time, while for a streak surface seeding is done continually and particle positions correspond to a fixed time. A time surface is the generalization of timelines, connecting particles that have been released from positions on a surface.</p>\n<p>不稳定的流动并不局限于通过动画进行可视化。例如，条纹和路径线是由连续的时间步长计算出来的，因此，多个时间步长可以显示在一个静态图像中。路径线或粒子轨迹是一个无质量的粒子在不稳定的流体流动中的轨迹。轨迹线是连接一组粒子的线，这些粒子都是在同一空间位置（但在连续的时间）被播种。如果在稳定流场中的同一位置播种，流线、路径线和条纹线是相同的。时间线是一条连接所有在速度场中被同时释放的粒子的线。时间线在流场中流动，并根据当地的速度变化而变形。小流是短的流线段。流面是一个处处与矢量场相切的表面，它是一组来自共享播种曲线的流线的位置。路径面和条纹面是路径线和条纹线的延伸，它们是由一条曲线而不是一个点来播种得到的。对于路径面来说，播种是在一个固定的时间进行的，粒子的位置是随着时间的推移而追踪的，而对于条纹面来说，播种是持续进行的，粒子的位置对应于一个固定的时间。时间面是时间线的概括，连接着从表面上的位置释放的粒子。</p>\n<p><img data-src=\"https://ptpimg.me/838v4b.jpg\" alt=\"\" /></p>\n<p>Figure 2: Arrows showing the wind direction and magnitude over Australia. The arrows are placed along streamlines generated using the image-guided placement technique of Turk and Banks [TB96]. Image courtesy of Greg Turk.</p>\n<p>图 2：显示澳大利亚上空风向和风量的箭头。箭头是沿着 Turk 和 Banks [TB96] 的图像引导放置技术产生的流线放置的。图片由 Greg Turk 提供。</p>\n<h2 id=\"integral-curve-objects-in-2d\"><a class=\"anchor\" href=\"#integral-curve-objects-in-2d\">#</a> Integral Curve Objects in 2D</h2>\n<p>2D 中的积分曲线对象</p>\n<h3 id=\"streamlines-in-2d-steady-state-flow-fields\"><a class=\"anchor\" href=\"#streamlines-in-2d-steady-state-flow-fields\">#</a> Streamlines in 2D steady-state flow fields</h3>\n<p>二维稳态流场中的流线</p>\n<p>Here we group those methods restricted to two-dimensional, steady state domains.</p>\n<p>在此，我们将那些限制在二维稳态域的方法进行分组。</p>\n<p>Streamline placement for 2D flow fields greatly affects the final image(s) produced by visualization applications. Streamlines that are seeded in arbitrary locations may provide an unsatisfactory result. Critical features in the flow field may be missed if there are regions containing only a sparse amount of streamlines. Conversely, where there is a large number of streamlines in a localized region, a cluttered image may result making it difficult to distinguish flow behavior.</p>\n<p>二维流场的流线位置对可视化应用产生的最终图像影响很大。在任意位置播种的流线可能提供一个不令人满意的结果。如果有些区域只包含稀疏的流线，那么流场中的关键特征可能会被忽略。相反，如果在一个局部区域有大量的流线，可能会导致图像杂乱无章，难以区分流动行为。</p>\n<p>An image-guided streamline placement algorithm was introduced by Turk and Banks in 1996 [TB96]. One of the goals of this algorithm is to produce visualizations similar to hand-drawn illustrations found in textbooks. Prior seeding algorithms were simply based on regular grids, random sampling or interactive seeding [BL92]. The seeding of the streamlines is influenced by the resultant image. The goal is to obtain a uniformly dense streamline coverage. It is formulated as an optimization problem where the objective is to minimize the variation of a low-pass filtered (blurred) image. Starting from a random initial streamline seed, the problem is solved by iteratively performing one of the operations move (displace a seed), insert, lengthen, shorten and combine (connect two streamlines with sufficiently close end points) on the set of streamlines. Figure 2 shows one result.</p>\n<p>1996 年，Turk 和 Banks 提出了一种图像引导的流线放置算法 [TB96]。该算法的目标之一是产生类似于教科书中手绘插图的可视化效果。之前的播种算法只是基于规则网格、随机抽样或互动播种 [BL92]。流水线的播种受到了结果图像的影响。目标是获得一个均匀密集的流线覆盖。它被表述为一个优化问题，目标是最小化低通滤波（模糊）图像的变化。从一个随机的初始流线种子开始，该问题通过在流线集上迭代执行移动（替换种子）、插入、延长、缩短和合并（连接两条端点足够接近的流线）中的一个操作来解决。图 2 显示了一个结果。</p>\n<p>A follow-up technique is presented by Jobard and Lefer [JL97a]. The motivation is to introduce a new streamline seeding strategy that was computationally efficient and less costly than the previous streamline seeding strategy [TB96] and allows the user to control the density of the displayed streamlines. The authors introduce two user-controlled parameters <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> . These parameters are used to control the distance between adjacent streamlines. Existing streamlines are used to seed new streamlines and candidate seed points are chosen that are at a distance d = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>, from a streamline. All candidate points of one streamline are used before moving on to the next streamline. This process stops when there are no candidate points generated. The <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> parameter is a proportion of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is used to control the closest distance that streamlines are allowed to one another. Sufficient coverage (i.e. a minimum density) is ensured by seeding streamlines at a distance <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> from one another. The method was also combined with texture advection techniques [JL97b] for animating steady flow fields.</p>\n<p>Jobard 和 Lefer [JL97a] 提出了一个后续技术。其动机是引入一种新的流线播种策略，与以前的流线播种策略 [TB96] 相比，计算效率高，成本低，并允许用户控制显示的流线密度。作者引入了两个用户控制的参数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 。这些参数用于控制相邻流线之间的距离。现有的流线被用来作为新流线的种子，候选的种子点被选择在距离流线 d = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 的地方。一条流线的所有候选点在进入下一条流线之前都会被使用。当没有候选点产生时，这个过程就会停止。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 参数是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 的一个比例。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{test}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">es</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 被用来控制允许流线之间的最近距离。足够的覆盖率（即最小密度）是通过在彼此之间的距离 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 播种流线来保证的。该方法还与纹理平流技术 [JL97b] 相结合，用于制作稳定流场的动画。</p>\n<p>Jobard and Lefer [JL01] introduce a novel algorithm that produces images of a vector field with multiple simultaneous densities of streamlines. The paper builds upon the previous technique [JL97a]. The multi-resolution property is ideal for vector field exploration as it allows for sparse streamline placement for a quick overview of the vector field, the streamline density can then be increased to allow for a more detailed investigation into areas of interest. They also demonstrate the use of the technique for zooming and enrichment.</p>\n<p>Jobard 和 Lefer [JL01] 介绍了一种新的算法，该算法可以产生具有多个同时密度的流线的矢量场的图像。该论文建立在以前的技术 [JL97a] 的基础上。多分辨率的特性是矢量场探索的理想选择，因为它允许稀疏的流线放置以快速浏览矢量场，然后可以增加流线密度以允许对感兴趣的区域进行更详细的调查。他们还展示了该技术在缩放和丰富方面的应用。</p>\n<p>Lefer et al provide a novel technique for producing variable-speed animations [LJL04]. This method encodes the motion information in a so-called motion map and a color table is utilized to animate the streamlines. Once streamlines have been computed they remain valid for all frames due to the steady vector field, so the challenge of animating the streamlines is simplified to a coloring the streamlines appropriately. The algorithm begins by creating a dense set of streamlines that cover every single pixel. Animating the streamlines is achieved by shifting the color table entries so that the color pattern appears to travel down the streamlines. The local velocity magnitude is taken into account when computing how fast to move the color pattern.</p>\n<p>Lefer 等人提供了一种制作变速动画的新技术 [LJL04]。这种方法将运动信息编码在一个所谓的运动地图中，并利用一个颜色表来制作流线的动画。一旦流线被计算出来，由于稳定的矢量场，它们对所有的帧都是有效的，所以流线动画的挑战被简化为对流线进行适当的着色。该算法首先创建一个密集的流线集，覆盖每一个像素。流水线的动画化是通过移动颜色表项来实现的，这样颜色图案就会沿着流水线移动。在计算移动颜色图案的速度时，当地的速度大小被考虑在内。</p>\n<p>Verma et al present a novel method of streamline placement that focuses on capturing flow patterns in the vicinity of critical points [VKP00]. Templates are defined for types of critical points that may be present in 2D flow fields. The algorithm begins by determining the location and type of critical points in the field. Verma et al use Voronoi partitioning around the critical points that contain regions that exhibit similar flow behavior. A random Poisson disk seeding strategy is finally used to populate streamlines in sparse regions. Seeding in regions of critical points first ensures that they are covered by a sufficient amount of streamlines and that these streamlines have a longer length. In this implementation, FAST [BMP∗90] is used to compute critical point locations and determine their nature, Voronoi diagrams are computed using triangle [She96].</p>\n<p>Verma 等人提出了一种新的流线布置方法，重点是捕捉临界点附近的流动模式 [VKP00]。为二维流场中可能存在的临界点类型定义了模板。该算法首先确定场中临界点的位置和类型。Verma 等人在临界点周围使用 Voronoi 分区，该分区包含表现出类似流动行为的区域。最后使用随机泊松盘播种策略来填充稀疏区域的流线。在临界点区域的播种首先确保它们被足够数量的流线所覆盖，并且这些流线具有较长的长度。在这个实现中，FAST [BMP∗90] 被用来计算临界点的位置并确定其性质，Voronoi 图是用 triangle [She96] 计算的。</p>\n<p>The work of Mebarki et al [MAD05] builds upon previous research by Turk and Banks [TB96] and Jobard and Lefer [JL97a]. The results produced are of comparable quality to the work of Turk and Banks [TB96] while being produced faster [MAD05]. The algorithm uses a farthest seeding point strategy. Roughly speaking, when a new streamline is created, the point furthest away from all current streamlines is used as the seed point for the subsequent streamline. Using a farthest point seeding strategy ensures that long streamlines are produced. To determine the farthest point, the points of the streamlines are inserted in a 2D Delauney triangulation. The incident triangles of a newly integrated point are used to generate a minimal circumdiameter. Any diameter that is above the desired spacing distance and below a saturation level is pushed onto a priority queue that is sorted by length. The top circle is then popped out of the queue, the center may then be used as the seeding point for the next streamline.</p>\n<p>Mebarki 等人的工作 [MAD05] 建立在 Turk 和 Banks [TB96] 以及 Jobard 和 Lefer [JL97a] 以前的研究之上。产生的结果与 Turk 和 Banks [TB96] 的工作质量相当，同时产生的速度更快 [MAD05]。该算法使用最远播种点策略。粗略地说，当一个新的流线被创建时，离所有当前流线最远的点被用来作为后续流线的种子点。使用最远点播种策略可以确保产生长的流线。为了确定最远点，流线的各点被插入一个二维 Delauney 三角图中。新整合的点的入射三角形被用来生成一个最小的圆周直径。任何高于所需间隔距离和低于饱和度的直径都会被推到一个按长度排序的优先队列中。然后，最上面的圆被从队列中弹出，然后中心可能被用作下一条流线的播种点。</p>\n<p><img data-src=\"https://ptpimg.me/v6rr63.jpg\" alt=\"\" /></p>\n<p>Figure 3: A representative set of streamlines generated by the Illustrative Streamline Placement algorithm [LHS08]. Image courtesy of Han-Wei Shen.</p>\n<p>图 3：由图解流线放置算法 [LHS08] 产生的一组有代表性的流线。图片由 Han-Wei Shen 提供。</p>\n<p>The work of Liu et al [LM06] introduces another evenly spaced streamline algorithm. It builds upon the work of Jobard and Lefer [JL97a] and Mebarki et al [MAD05]. Cubic Hermite polynomial interpolation is used to create fewer evenly spaced streamline samples in the neighborhood of each previous streamline in order to reduce the amount of distance checking. Placement quality is enhanced by double queues to favor long streamlines (this minimizes discontinuities). The presented method is faster than that of Jobard and Lefer [JL97a]. In addition, it incorporates the detection of streamline loops.</p>\n<p>Liu 等人的工作 [LM06] 介绍了另一种均匀间隔的流线算法。它建立在 Jobard 和 Lefer [JL97a] 以及 Mebarki 等人 [MAD05] 的工作之上。立体 Hermite 多项式插值被用来在每个前一个流线的附近创建较少的均匀流线样本，以减少距离检查的数量。放置质量通过双队列来提高，以利于长的流线（这最大限度地减少了不连续现象）。所提出的方法比 Jobard 和 Lefer [JL97a] 的方法要快。此外，它还包含了对流线循环的检测。</p>\n<p>Li et al [LHS08] introduced a novel method for streamline placement, which is different from its predecessors in that its goal is to generate the fewest number of streamlines possible while still capturing the most important flow features of the vector fields (see Figure 3). The images produced use a small amount of streamlines and are intended to be similar to hand-drawn diagrams. This is achieved by taking advantage of spatial coherence and by using distance fields to determine the similarity between streamlines. New streamlines are only created when they represent flow characteristics that are not already shown by neighboring streamlines. This way repetitive flow patterns are omitted. Similarity between streamlines is measured locally by the directional difference between the original vector at each grid point and an approximate vector derived from nearby streamlines, and globally by the accumulation of local dissimilarity at every integrated point along the streamline path.</p>\n<p>Li 等人 [LHS08] 介绍了一种新颖的流线放置方法，与前人不同的是，它的目标是生成尽可能少的流线，同时仍能捕捉到矢量场中最重要的流动特征（见图 3）。产生的图像使用少量的流线，目的是为了类似于手绘图。这是通过利用空间一致性和使用距离场来确定流线之间的相似性来实现的。只有当新的流线代表了相邻流线尚未显示的流动特征时，才会创建新的流线。这样，重复的流动模式就被省略了。流线之间的相似性是通过每个网格点的原始矢量和从附近的流线得出的近似矢量之间的方向性差异来衡量的，而全局则是通过沿流线路径的每个综合点的局部差异的累积。</p>\n<p>Reflection: The two most notable contributions to streamline seeding in planar flows are by Turk and Banks [TB96] and Jobard and Lefer [JL97a]. Turk and Banks are the first to introduce the notion of a user-controlled spatial frequency for streamlines, while Jobard and Lefer accelerate the idea to fast rendering times. The contributions that follow are all variations on these two themes. Overall, we believe the challenge of streamline seeding in 2D steady flow to be a solved problem.</p>\n<p>反射： Turk 和 Banks [TB96] 以及 Jobard 和 Lefer [JL97a] 对平面流中的流线播种有两个最显著的贡献。Turk 和 Banks 首先引入了用户控制的流线空间频率的概念，而 Jobard 和 Lefer 则将这个想法加速到快速渲染的时间。接下来的贡献都是这两个主题的变化。总的来说，我们认为二维稳定流中的流线播种的挑战是一个已经解决的问题。</p>\n<h3 id=\"integral-curves-in-a-2d-time-varying-domain\"><a class=\"anchor\" href=\"#integral-curves-in-a-2d-time-varying-domain\">#</a> Integral curves in a 2D, time-varying domain</h3>\n<p>二维时变域中的积分曲线</p>\n<p>Jobard and Lefer extend their evenly spaced streamline technique [JL97a] to unsteady flow [JL00]. Streamlines across several time-steps represent the global nature of the flow at each step and give insight into the evolution of the vector field over time. However, simply generating a set of streamlines at each step and cycling between them leads to an incoherent animation. The authors present a set of parameters that are used to choose a suitable set of streamlines for the next time-step using the current set of streamlines as a basis. A so-called feed forward method is used which selects an appropriate subset of streamlines from the subsequent time-step that correlate with the current set. A technique is employed that quantitatively evaluates the corresponding criterion between streamlines. The best candidates are then used for the next time-step. Several methods are used to improve the animation quality, such as giving priority to circular streamlines and adding tapering effects to the streamlines. A cyclical texture is also applied and this is animated to indicate the downstream direction of the flow on the streamlines.</p>\n<p>Jobard 和 Lefer 将他们的匀速流线技术 [JL97a] 扩展到非稳态流 [JL00]。跨越几个时间步长的流线代表了每一步流动的整体性质，并使人们了解矢量场随时间的演变。然而，简单地在每一步生成一组流线并在它们之间循环，会导致不连贯的动画。作者提出了一套参数，用来为下一个时间步长选择一套合适的流线，以当前的流线集为基础。使用了一种所谓的前馈方法，从下一个时间步长中选择与当前流线集相关的适当流线子集。采用一种技术对流线之间的相应标准进行定量评估。然后，最佳候选者被用于下一个时间步长。有几种方法被用来提高动画质量，如优先考虑圆形流线和给流线添加渐变效果。还应用了循环纹理，并以动画的形式表示流线的下游方向。</p>\n<p>We have not discovered any literature describing the solution to explicit pathline or streakline seeding algorithms for 2D, unsteady flow. This is still an open challenge.</p>\n<p>我们没有发现任何文献描述二维、非稳态流动的显式路径线或条纹线播种算法的解决方案。这仍然是一个开放的挑战。</p>\n<h3 id=\"streamline-seeding-on-surfaces\"><a class=\"anchor\" href=\"#streamline-seeding-on-surfaces\">#</a> Streamline seeding on surfaces</h3>\n<p>简化表面播种</p>\n<p>In practice, most vector field domains consist of either two or three spatial dimensions. Some approaches are more suitable for one spatial dimension over the others. Typically, as we move from 2D to 3D, the complexity of algorithms increases.This is due, in part, to the effort required to minimize visual clutter and occlusion and, to the extra complexity of another spatial dimension.</p>\n<p>在实践中，大多数矢量场域包括两个或三个空间维度。有些方法更适合于一个空间维度，而不是其他的。通常情况下，当我们从二维到三维时，算法的复杂性就会增加。这部分是由于需要努力将视觉杂乱和遮挡降到最低，以及另一个空间维度的额外复杂性所造成的。</p>\n<p>A novel visualization scheme based upon a particle system is introduced by Van Wijk [vW92]. The particles can be seeded from a variety of geometric objects. The most obvious objects are: points, lines, circles, rectangles and spheres. The sources also have a temporal attribute too, the particles can be injected at discrete time pulses or as a continuous stream. A continuous point source will result in streamlines being created by the particles and a stream surface will be created if a curve-based continuous source is used. The particles have a normal, which allows the lighting equations to be used in order to apply shading and provide greater depth cues. A Gaussian filter is used to smooth the visualization, softening aliasing and strobing artifacts.</p>\n<p>Van Wijk [vW92] 介绍了一种基于粒子系统的新型可视化方案。粒子可以从各种几何对象中选取种子。最明显的对象是：点、线、圆、矩形和球体。粒子源也有时间属性，粒子可以在离散的时间脉冲中注入，也可以作为一个连续的流注入。一个连续的点源会导致粒子产生流线，如果使用基于曲线的连续源，则会产生一个流面。粒子有一个法线，这允许使用照明方程，以便应用阴影并提供更大的深度线索。一个高斯滤波器被用来平滑可视化，软化混叠和频闪伪影。</p>\n<p>Van Wijk [vW93a] builds upon his previous work in [vW92]. Here an improved shading model is used to reduce the aliasing and strobing artifacts that were found in [vW92]. A more detailed discussion of the seeding objects is also presented detailing the flexibility of using the surface particles to emulate an array of visualization techniques such as streamlines, stream surfaces and stream tubes. We classified the work of Van Wijk [vW92, vW93a] into point-based objects on a surface domain because the focus of the research is on how to effectively render particles on stream surfaces.</p>\n<p>Van Wijk [vW93a] 在他之前的工作 [vW92] 的基础上进一步发展。这里使用了一个改进的阴影模型来减少 [vW92] 中发现的混叠和频闪伪影。还对播种对象进行了更详细的讨论，详细介绍了使用表面粒子来模拟一系列可视化技术的灵活性，如流线、流面和流管。我们将 Van Wijk [vW92, vW93a] 的工作归入面域上基于点的对象，因为研究的重点是如何有效地渲染流面的粒子。</p>\n<p>Mao et al [MHHI98] present an evenly spaced streamlines technique for curvilinear grids. They expand upon the work of Turk and Banks [TB96] by applying the seeding strategy to parameterized surfaces. This algorithm takes the vectors from the 3D surface and maps them to computational space. An extended 2D image-guided algorithm is then applied and streamlines of a desired density are generated. The streamlines are then mapped back onto the 3D curvilinear surface. However, curvilinear grid cells can vary significantly in size. This means that streamlines distributed evenly in computational space will not necessarily be evenly spaced when they are mapped back to physical space. This challenge is overcome by altering the computational-space streamline density. The streamline density is locally adapted to the inverse of the grid density in physical space [MHHI98]. This is achieved by using Poisson ellipse sampling, which distributes a set of rectangular windows in computational space.</p>\n<p>Mao 等人 [MHHI98] 提出了一种用于曲线网格的均匀间隔流线技术。他们在 Turk 和 Banks [TB96] 的工作基础上，将播种策略应用于参数化表面。该算法从三维表面获取矢量并将其映射到计算空间。然后应用一个扩展的二维图像引导算法，生成所需密度的流线。然后，这些流线被映射到三维曲线表面。然而，曲线网格单元的大小可以有很大的不同。这意味着在计算空间均匀分布的流线在映射到物理空间时不一定是均匀的。这一挑战是通过改变计算空间的流线密度来克服的。流线密度被局部调整为物理空间中网格密度的逆值 [MHHI98]。这是通过使用泊松椭圆取样来实现的，它在计算空间中分配了一组矩形窗口。</p>\n<p>Spencer et al [SLCZ09] extend the 2D evenly spaced streamlines technique by Jobard and Lefer to surfaces, Figure 4 shows evenly spaced streamlines on the boundary surface of a gas engine simulation. It starts by projecting the vector data onto the image plane, by rendering a socalled velocity image into the frame buffer. Performing the streamline computations in image space effectively reduces the complexity of the 3D problem into a 2D one. This also has the advantage of a simpler implementation using the programmable portions of the graphics pipeline and inherently takes advantage of the hardware interpolators. Another major performance benefit arises from the z-buffer and frustum culling. These discard any occluded fragments and clipped geometry, this prevents unnecessary streamline computations on areas that are not visible to the user. A combination of seeding strategies is employed. A grid traversal strategy, checking each cell as a candidate seeding position, is used in combination with seeding based on current streamlines, like Jobard and Lefer’s algorithm [JL97a]. This ensures that all visible regions of the geometry are processed.</p>\n<p>Spencer 等人 [SLCZ09] 将 Jobard 和 Lefer 的二维匀速流线技术扩展到表面，图 4 显示了一个气体发动机模拟的边界表面的匀速流线。它首先将矢量数据投射到图像平面上，将所谓的速度图像渲染到帧缓冲区。在图像空间进行流线计算，有效地将三维问题的复杂性降低到二维问题。这也有一个好处，即使用图形管道的可编程部分进行更简单的实现，并在本质上利用了硬件插值器的优势。另一个主要的性能优势来自于 Z-buffer 和 frustum culling。这些都会丢弃任何被遮挡的片段和被剪切的几何体，这就避免了在用户不可见的区域进行不必要的流线计算。采用了一种组合的播种策略。网格遍历策略，检查每个单元作为候选播种位置，与基于当前流线的播种结合使用，如 Jobard 和 Lefer 的算法 [JL97a]。这确保了几何体的所有可见区域都得到处理。</p>\n<p><img data-src=\"https://ptpimg.me/k1h5lz.jpg\" alt=\"\" /></p>\n<p>Figure 4: Evenly spaced streamlines on the boundary surface of a gas engine simulation. Perspective foreshortening is utilized and the density of streamlines further away from the viewpoint is increased [SLCZ09].</p>\n<p>图 4：燃气发动机模拟的边界表面上均匀分布的流线。利用了透视法，离视点较远的流线密度增加了 [SLCZ09]。</p>\n<p>More recently, Rosanwo et al [RPP∗09] provide a solution to streamline seeding based on dual streamlines. Dual streamlines run orthogonal to the vector field instead of tangential. Two sets of streamlines are maintained, a set of tangential streamlines, S, and a set of dual streamlines, D. This is similar to the technique used by Mebarki et al [MAD05] where the largest voids are found in order to place a new seed. Streamlines are seeded in a similar way using the dual streamline segments. As this method only uses the arc-length of distance metric it may be efficiently applied to curved surfaces where other distance metrics such as geodesic distance are more computationally expensive and/or are hard to apply correctly. This algorithm requires that a suitable starting set of streamlines are used in order to be efficient and to ensure complete domain coverage and critical points. This is achieved by computing the topological skeleton of the dual field as the initial dual streamline set. In cases where the vector field contains no topology randomly seeded dual streamlines are seeded. This method shows a slower growth in computation time when increasing the streamline density compared to algorithms by Verma et al [VKP00] and Mebarki et al [MAD05].</p>\n<p>最近，Rosanwo 等人 [RPP∗09] 提供了一个基于双流线的流线播种解决方案。双重流线与矢量场正交而不是切向运行。这与 Mebarki 等人 [MAD05] 使用的技术相似，即找到最大的空隙以放置新的种子。流水线也是以类似的方式使用双流线段进行播种。由于这种方法只使用弧长距离度量，它可以有效地应用于曲面，而其他距离度量如测地距离的计算成本较高或难以正确应用。该算法要求使用合适的流线起始集，以实现高效，并确保完整的领域覆盖和临界点。这可以通过计算对偶场的拓扑骨架作为初始对偶流线集来实现。在矢量场不包含拓扑结构的情况下，随机播种的双流线被播种。与 Verma 等人 [VKP00] 和 Mebarki 等人 [MAD05] 的算法相比，这种方法在增加流线密度时显示了较慢的计算时间增长。</p>\n<p>Reflection: An important solution to the challenge of streamline seeding on surfaces comes from Spencer et al [SLCZ09]. This is the only solution of its kind that handles general surfaces and unstructured, adaptive resolution meshes. It is also a fast algorithm that supports exploration through user interaction. Pathline and streakline seeding on surfaces remains an open challenge however.</p>\n<p>反思： Spencer 等人提出了解决表面流线播种问题的一个重要方案。[SLCZ09]。这是同类解决方案中唯一能处理一般曲面和非结构化的自适应分辨率网格的方案。它也是一种快速算法，支持通过用户交互进行探索。然而，表面上的路径线和条纹线播种仍然是一个公开的挑战。</p>\n<h2 id=\"efficient-particle-tracing-in-3d\"><a class=\"anchor\" href=\"#efficient-particle-tracing-in-3d\">#</a> Efficient particle tracing in 3D</h2>\n<p>高效的三维粒子追踪</p>\n<p>This subsection summarizes particle tracing strategies in 3D space. The volume cell types used in simulations vary, depending upon the model used to generate them. The simplest grid type is a Cartesian grid. Curvilinear grids, commonly used in flow simulations, contain the same cell type but the grid is usually distorted (usually curving) so that it fits around a geometry. Unstructured data may contain several different cell types, tetrahedra and hexahedra are commonly used. Unstructured grids are generally more challenging than structured grids and some algorithms are specifically aimed at particle tracing solutions on them. Computations on unstructured grids may either be performed in physical space or computational space on a per-cell basis. Physical space uses the velocity field and grid as output from the simulation. Computational space transforms a grid cell to make it axis aligned and unit length, and adjusts the velocities accordingly. Computational-space methods are used to simplify certain operations such as point location.</p>\n<p>本小节总结了三维空间的粒子追踪策略。仿真中使用的体积单元类型各不相同，这取决于用于生成它们的模型。最简单的网格类型是笛卡尔网格。曲线网格，通常用于流动模拟，包含相同的单元类型，但网格通常是扭曲的（通常是弯曲的），以便它适合于一个几何体。非结构化数据可能包含几种不同的单元类型，四面体和六面体是常用的。非结构化网格通常比结构化网格更具挑战性，一些算法专门针对它们的粒子追踪解决方案。在非结构化网格上的计算可以在物理空间或计算空间进行，以每个单元为基础。物理空间使用速度场和网格作为模拟的输出。计算空间对网格单元进行转换，使其成为轴对齐和单位长度，并对速度进行相应调整。计算空间方法被用来简化某些操作，如点定位。</p>\n<p>This collection of papers focuses on computational methods, addressing the challenge of providing fast, accurate results that can be utilized by other visualization methods to improve their performance. This is in contrast to the other methods that directly provide novel visualizations. The forerunners to these techniques along with some of their applications can be found in [BS87, RBM87, Bun89].</p>\n<p>这组论文的重点是计算方法，解决的挑战是提供快速、准确的结果，可以被其他可视化方法利用来提高其性能。这与其他直接提供新型可视化的方法形成对比。这些技术的先驱以及它们的一些应用可以在 [BS87, RBM87, Bun89] 中找到。</p>\n<h3 id=\"3d-particle-tracing-in-steady-vector-fields\"><a class=\"anchor\" href=\"#3d-particle-tracing-in-steady-vector-fields\">#</a> 3D particle tracing in steady vector fields</h3>\n<p>稳定矢量场中的三维粒子追踪</p>\n<p>PLOT3D [BS87, WBPE90] is a command line driven program for displaying results of CFD simulations on structured and unstructured grids. Besides a wide range of graphics functionality, e.g. hidden line and hidden surface techniques, PLOT3D offers 2D and 3D streamlines of the velocity field, the vorticity field (vortex lines), and the wall shear stress field (skin friction lines). The software was designed to run on supercomputers, e.g. for computing movies, but also on the first graphics terminals and workstations with hardware supported viewing transformations. PLOT3D was the precursor of FAST (Flow Analysis Software Toolkit) [BMP∗90], a modular redesign which added a GUI and distributed processing. Visual2 [GH90] and Visual3 [HG91] were packages written by Haimes and Giles for the visualization of 2D and 3D flow fields. Linked to user-written main program, they provided interactive X-windows-based visualization of steady or unsteady flow fields given on unstructured grids. Visual3 was later adapted to network computing and renamed to pV3 [Hai94]. The techniques for vector fields available in Visual3 include streamlines and variants such as ribbons and tufts (or streamlets).</p>\n<p>PLOT3D [BS87, WBPE90] 是一个命令行驱动程序，用于显示结构化和非结构化网格上的 CFD 模拟结果。除了广泛的图形功能，如隐藏线和隐藏面技术，PLOT3D 还提供速度场、涡度场（涡流线）和壁面切应力场（皮层摩擦线）的二维和三维流线。该软件被设计成可以在超级计算机上运行，例如用于计算电影，但也可以在第一批图形终端和工作站上运行，并有硬件支持的观测转换。PLOT3D 是 FAST（流动分析软件工具箱）[BMP∗90] 的前身，是一个模块化的重新设计，增加了 GUI 和分布式处理。Visual2 [GH90] 和 Visual3 [HG91] 是 Haimes 和 Giles 编写的软件包，用于 2D 和 3D 流场的可视化。与用户编写的主程序相连，它们提供了基于 X-windows 的稳定或不稳定流场的交互式可视化，并在非结构化网格上给出。Visual3 后来被改编为网络计算，并更名为 pV3 [Hai94]。Visual3 中可用的矢量场技术包括流线和变体，如带状物和束状物（或小流）。</p>\n<p>Ueng et al [USM96] present an efficient method of streamline construction in unstructured grids. This method uses calculations performed in computational space to reduce computational cost of the streamline generation. To perform the calculation in computational space the physical-space coordinates of a cell and its corresponding vector data must be transformed into canonical coordinates. A cell searching strategy similar to that used in [KL96] takes advantage of the canonical coordinates to simplify and speed up the operation. A specialized Runge–Kutta integrator is also presented for use in the canonical coordinate system, which offers improved computation times compared to the secondand fourth-order Runge–Kutta integrators that perform in physical space.</p>\n<p>Ueng 等人 [USM96] 提出了一种在非结构化网格中构建流线的有效方法。该方法使用在计算空间进行的计算来减少流线生成的计算成本。为了在计算空间进行计算，一个单元的物理空间坐标及其相应的矢量数据必须转化为典型坐标。类似于 [KL96] 中使用的单元搜索策略利用了典型坐标来简化和加快操作。此外，还提出了一个专门的 Runge-Kutta 积分器，用于规范坐标系统，与在物理空间执行的二阶和四阶 Runge-Kutta 积分器相比，它提供了更好的计算时间。</p>\n<p>The techniques used for <strong>streamtube</strong> and <strong>streamribbon</strong> construction are also described in [USM96]. Streamtubes are created by placing circular curves, oriented normal to the flow, at the streamline integration points. The circular cross-sections are then connected to form an enclosed tube object. The radius of the streamtube illustrates the local cross flow divergence and is calculated at each streamline point, i.e. when the circular glyphs are created. Streamribbons are created using the streamline for one edge and then using a constant length normal vector generate the position of the opposite edge. The constant length normal rotates around the initial streamline in order to depict local flow vorticity.</p>\n<p><strong>流管</strong>和<strong>流带</strong>的构造技术在 [USM96] 中也有描述。流管是通过在流线集成点上放置圆形曲线来创建的，这些曲线的方向与水流的方向一致。然后将圆形截面连接起来，形成一个封闭的管状物体。流管的半径说明了局部横流发散，并在每个流线点，即在创建圆形字形时计算。流水带的创建是使用一个边缘的流线，然后使用一个恒定长度的法线矢量生成对面边缘的位置。恒定长度的法线围绕初始流线旋转，以描述局部流动的涡度。</p>\n<p>UFLOW is a system introduced by Lodha et al [LPSW96] to analyze the changes resulting from different integrators and step sizes used for computing streamlines. A pair of streamlines are interactively seeded by the user and each streamline is generated using a different integrator or integration step size. It is also possible to create a single streamline and then trace it backwards from its end point and compare it to the initial streamline (see Figure 5).</p>\n<p>UFLOW 是由 Lodha 等人 [LPSW96] 引入的一个系统，用于分析计算流线的不同积分器和步长所产生的变化。一对流线由用户交互播种，每条流线都是用不同的积分器或积分步长生成。也可以创建一条流线，然后从其终点向后追踪，并与初始流线进行比较（见图 5）。</p>\n<p><img data-src=\"https://ptpimg.me/hdhv8j.jpg\" alt=\"\" /></p>\n<p>Figure 5: Comparing streamlines of two data sets simulated using different turbulence models. The streamlines are compared using line glyphs, strip envelopes and sphere glyphs to highlight the differences between them. Image courtesy of Alex Pang [VP04].</p>\n<p>图 5：比较使用不同湍流模型模拟的两个数据集的流线。使用直线字形、条形包络和球形字形对流线进行了比较，以突出它们之间的差异。图片由 Alex Pang 提供 [VP04]。</p>\n<p>Sadarjoen et al present a comparison of several algorithms used for particle tracing on 3D curvilinear grids [SvWHP97]. The particle tracing process is broken down, with a brief description, into basic components: point-location, locating which cell a point is in, interpolation, and integration. A more thorough discussion and comparison of physicalspace and computational-space algorithms then ensues. Results for the implemented algorithms are also given showing that physical-space computation algorithms generally perform better than their computational-space counterpart.</p>\n<p>Sadarjoen 等人对用于三维曲线网格的粒子追踪的几种算法进行了比较 [SvWHP97]。粒子追踪过程被简单地分解为几个基本部分：点定位、定位一个点所在的单元、内插和积分。然后，对物理空间和计算空间的算法进行了更深入的讨论和比较。还给出了已实施算法的结果，表明物理空间计算算法通常比其计算空间的对应算法表现更好。</p>\n<p>Sadarjoen et al [SdBPM98] present a 6-tetrahedra decomposition method for σ-transformed grids. σ-transformed grids are structured hexahedral curvilinear grids in which the x and y dimensions differ by 2–3 orders of magnitude from the z dimension, thus resulting in very thin cells. The method presented here is more accurate and allows for faster operations to be performed than the more common 5-tetrahedra decomposition that is usually employed [SvWHP97]. Decomposing the hexahedral cells into 6 tetrahedra prevents a center tetrahedron covering the center of the cell and thus makes point location much easier. This method also reduces the chances of infinite loops between two cells when using the 5-decomposition approach [SdBPM98].</p>\n<p>Sadarjoen 等人 [SdBPM98] 提出了一种用于 σ 变换网格的 6 四面体分解方法。σ 变换网格是结构化的六面体曲线网格，其中 x 和 y 维度与 z 维度相差 2-3 个数量级，因此会产生非常薄的单元。这里提出的方法比通常采用的更常见的 5 - 四面体分解法更准确，并且可以更快地进行操作 [SvWHP97]。将六面体单元分解为 6 个四面体可以防止中心四面体覆盖单元的中心，从而使点的定位更加容易。这种方法也减少了使用 5 次分解方法时两个单元之间出现无限循环的机会 [SdBPM98]。</p>\n<p>Schulz et al [SRBE99] present a set of flow visualization techniques that are tailored for PowerFLOW, a lattice-based CFD simulator. The grids in these simulations are multiresolution Cartesian grids, where finer voxels are used in areas of interesting flow or boundary surface geometry. Particle tracing and collision detection are discussed, demonstrating the need for collision detection between the particle and the object surface. When a collision occurs the particle tracing for that line may either terminate or follow a path along the object boundary. The system has several seeding types, that can be interactively manipulated, ranging from rakes, planes and cubes.</p>\n<p>Schulz 等人 [SRBE99] 提出了一套为 PowerFLOW 量身定做的流动可视化技术，这是一个基于格子的 CFD 模拟器。这些模拟中的网格是多分辨率笛卡尔网格，在有趣的流动或边界表面几何形状的区域使用更细的体素。讨论了粒子追踪和碰撞检测，证明了在粒子和物体表面之间进行碰撞检测的必要性。当碰撞发生时，该线的粒子追踪可能会终止或沿着物体边界的路径进行追踪。该系统有几种播种类型，可以交互操作，包括耙子、平面和立方体。</p>\n<p>Nielson et al introduce efficient methods for computing tangent curves for three-dimensional flow fields [NJ99]. This technique is an extension to 3D of their previous research [NJS∗97]. The techniques are designed to be used on tetrahedral grids. Incremental methods are used for stepping along the analytic solution of the streamline ODE and as a result produce exact results. Techniques for both Cartesian and barycentric coordinates are presented, allowing the user to use the tools for the coordinate system that is most suited to the current application. Several cases are defined based on the types of the eigenvalues found at a particular point, these in turn are used for the calculation of a tangent curve through a tetrahedron. Results are presented that compare the accuracy of the presented algorithms compared to Euler and fourth-order Runga–Kutta integrators.</p>\n<p>Nielson 等人介绍了计算三维流场的切线曲线的有效方法 [NJ99]。该技术是他们先前研究 [NJS∗97] 的三维扩展。这些技术被设计为用于四面体网格。增量方法用于沿流线 ODE 的分析解步进，因此产生精确的结果。介绍了直角坐标和重心坐标的技术，允许用户使用最适合当前应用的坐标系统的工具。根据在某一点发现 的类型定义了几种情况，这些情况又被用于计算通过四面体的切线曲线。结果显示，与欧拉和四阶 Runga-Kutta 积分器相比，所提出的算法的准确性得到了比较。</p>\n<p>Verma and Pang present methods for comparing streamlines and streamribbons [VP04] (Figure 5), and some of their methods are loosely based on those that appear in the UFLOW system [LPSW96]. Large CFD simulations are generally run on supercomputers, however the applications used to visualize these simulations are generally run on workstations. Some of these simulations have to be approximated with smaller data sets to make their use on workstations more feasible. Different data sets are compared simultaneously, with the second data set being a subsampled version of the first data set. A metric for measuring difference is needed and here the Euclidean distance between associated streamline points is used. Associated points are connected by lines, giving a ladder effect, which aids the visual representation of the differences between the streamlines. Strip envelopes, which fill in the ladder sections and spheres are also used to depict the difference when comparing a pair of streamlines.</p>\n<p>Verma 和 Pang 提出了比较流线和流带的方法 [VP04]（图 5），他们的一些方法松散地基于出现在 UFLOW 系统中的方法 [LPSW96]。大型 CFD 模拟一般在超级计算机上运行，然而用于可视化这些模拟的应用程序一般在工作站上运行。其中一些模拟必须用较小的数据集进行近似，以使其在工作站上的使用更加可行。不同的数据集被同时比较，第二个数据集是第一个数据集的子采样版本。需要一个衡量差异的指标，这里使用相关流线点之间的欧几里得距离。相关的点被线连接起来，产生了阶梯效应，这有助于直观地表示流线之间的差异。在比较一对流线时，条状包络物填充在梯形部分和球体中，也被用来描述差异。</p>\n<p>Reflection: We consider the challenge of particle tracing to be solved for the case of steady-state structured grids only. This is because many streamlines can be traced interactively for steady-state fields. The same cannot be said for large unstructured grids however. Tracing many streamlines (hundreds) tends to be non-interactive. This is still and unsolved problem.</p>\n<p>反思： 我们认为粒子追踪的挑战只在稳态结构网格的情况下得到解决。这是因为对于稳态场来说，许多流线是可以交互追踪的。然而，对于大型非结构化网格来说，情况就不一样了。追踪许多流线（数百条）往往是不交互的。这仍然是一个未解决的问题。</p>\n<h3 id=\"3d-particle-tracing-in-unsteady-vector-fields\"><a class=\"anchor\" href=\"#3d-particle-tracing-in-unsteady-vector-fields\">#</a> 3D particle tracing in unsteady vector fields</h3>\n<p>非稳态矢量场中的三维粒子追踪</p>\n<p>Lane introduces a system for using streaklines (refer to Section 2.2 for the visualization of unsteady flows) [Lan93]. Lane presents the numerical background for particle integration over many time-steps as well as integration over simulations that involve a moving grid, a feature demonstrated in very few systems. The two data sets visualized are in excess of 15GB and 64GB including both their grids and solutions. Seeding points are positioned manually. Lane shows that only two time-steps need to be loaded at once to perform integration for one step, thus enabling this technique to be applied to large data sets. The tools in this application build upon similar systems such as the Virtual Wind Tunnel [BL92] (see also Section 2.6).</p>\n<p>Lane 介绍了一个使用条纹线的系统（关于非稳态流的可视化请参考第 2.2 节）[Lan93]。Lane 介绍了在许多时间步长上进行粒子积分的数值背景，以及在涉及到移动网格的模拟上进行积分的数值背景，这一特点在很少的系统中得到证明。两个可视化的数据集分别超过 15GB 和 64GB，包括其网格和解决方案。播种点是手动定位的。Lane 显示，只需要一次加载两个时间步长就可以进行一步的整合，从而使这种技术可以应用于大型数据集。该应用中的工具建立在类似的系统之上，如虚拟风洞 [BL92]（也见第 2.6 节）。</p>\n<p>UFAT [Lan94] is a system that is used to generate streaklines on data sets with a large number of time-steps. One of the major challenges of unsteady flow is the size of the data sets that may be produced. The size makes them difficult to store in memory. This is also true when a time-dependent grid is used. Examples of moving grids are shown, such as engine cylinder simulations with a moving piston, and turbine simulations with rotating blades. A second-order Runge–Kutta with adaptive step size is used to advect the particles through the flow field. The system stores the streaklines at each time on disk so that they can be recovered without re-computation and used to create an animation. This system builds upon work done on systems such as the Virtual Wind Tunnel [BL92], pV3 [Hai94] and FAST [BMP∗90].</p>\n<p>UFAT [Lan94] 是一种用于在具有大量时间步长的数据集上生成条纹的系统。非定常流的主要挑战之一是可能产生的数据集的大小。它们的大小使它们难以存储在内存中。当使用与时间相关的网格时也是如此。给出了移动网格的例子，例如带有移动活塞的发动机气缸模拟，以及带有旋转叶片的涡轮模拟。采用自适应步长二阶龙格 - 库塔算法对颗粒进行平流。系统每次将条纹存储在磁盘上，这样它们就可以在不重新计算的情况下恢复并用于创建动画。该系统建立在虚拟风洞 [BL92]、pV3 [Hai94] 和 FAST [BMP * 90] 等系统的基础上。</p>\n<p>Kenwright and Lane [KL95, KL96] present methods that increase the efficiency of particle tracing for simulations on curvilinear grids. Many simulations output the vector data on curvilinear grids. In this case, particle tracing can be calculated in physical space, i.e. on the curvilinear grid in its original state, or in computational space, which transforms the curvilinear grids coordinates into Cartesian space. Calculations in computational space are easier to perform but tend to be less accurate due to the vector field transformation using approximated Jacobian matrices. Physical space computation is more accurate but point location, can be an expensive operation if done naively (e.g. a brute force linear search in every cell). The authors overcome this barrier by implementing a more efficient point-location strategy for tetrahedral grids.</p>\n<p>Kenwright 和 Lane [KL95, KL96] 提出了提高曲线网格模拟中粒子跟踪效率的方法。许多仿真都是在曲线网格上输出矢量数据。在这种情况下，粒子跟踪可以在物理空间中进行计算，即在原始状态的曲线网格上进行计算，也可以在计算空间中进行计算，将曲线网格坐标转换为笛卡尔空间。计算空间中的计算更容易执行，但由于使用近似雅可比矩阵的向量场变换，往往不太准确。物理空间计算更准确，但点的位置，可能是一个昂贵的操作，如果天真地完成 (例如，在每个单元中进行蛮力线性搜索)。作者通过实现更有效的四面体网格点定位策略克服了这一障碍。</p>\n<p>Teitzel et al [TGE97] describe an analysis of integration methods used in scientific visualization. The integration methods investigated are both adaptive and non-adaptive Runge–Kutta integrators of orders 2, 3 and 4. A robust integration scheme is found by establishing the link in numerical errors between the integration method and the linear interpolation of the vector field values between the discretely sampled grid points. Their approach is shown to be more efficient than that of [BLM95] and [KL95]. The authors also describe implicit integration methods for use in stiff problems (areas of strong shear or vorticity).</p>\n<p>Teitzel 等人 [TGE97] 描述了对科学可视化中使用的积分方法的分析。所研究的积分方法是 2、3 和 4 阶的自适应和非自适应 Runge-Kutta 积分器。通过建立积分方法与离散采样网格点之间的矢量场值的线性插值之间的数值误差联系，发现了一个稳健的积分方案。他们的方法被证明比 [BLM95] 和 [KL95] 的方法更有效。作者还描述了用于刚性问题的隐式积分方法（强剪切力或涡度的区域）。</p>\n<p>Teitzel et al [TGE98] introduce a particle tracing method for sparse grids built upon their previous work [TGE97]. The main difficulty in this task is the interpolation operation to find the vector values along an integral path. On a full grid the tri-linear interpolation is done as a local operation. To help with the efficiency the authors have used an array to store the contributing coefficients of the sparse grid as values can be accessed directly. Functions are added to calculate the contributing samples and to accumulate them over the different levels of the sparse grid. The flow is visualized with color-coded streak balls, streak tubes and streak bands (or ribbons). <strong>Streak balls</strong> follow the same path as streaklines, however, the spacing between objects depicts acceleration and the size of the ball depicts local flow convergence and divergence. <strong>Streak tubes</strong> (a derivative of stream tubes) use a closed-curve seeding object resulting in a tube that follows a streakline path. The diameter of the tube depicts flow divergence and convergence. A <strong>streak band</strong> uses a short line segment as a seeding object. This results in a ribbon when traced through unsteady flow whose twisting depicts the vorticity (or swirling motion) of the flow.</p>\n<p>Teitzel 等人 [TGE98] 在他们以前的工作 [TGE97] 基础上，介绍了一种稀疏网格的粒子追踪方法。这个任务的主要困难是插值操作，以找到沿积分路径的向量值。在全网格上，三线插值是作为一个局部操作完成的。为了帮助提高效率，作者使用了一个数组来存储稀疏网格的贡献系数，因为数值可以直接访问。添加了一些函数来计算贡献的样本，并在稀疏网格的不同层次上累积它们。流动用彩色编码的条纹球、条纹管和条纹带（或带子）来显示。<strong>条纹球</strong>遵循与条纹线相同的路径，然而，物体之间的间距描述了加速度，球的大小描述了局部流动的收敛和发散。<strong>流管</strong>（流管的衍生物）使用一个封闭曲线的播种对象，形成一个遵循条纹线路径的管子。管子的直径描述了流动的发散和收敛。<strong>条纹带</strong>使用一个短线段作为播种对象。这导致在不稳定的流动中形成一条带子，其扭曲描述了流动的涡度（或漩涡运动）。</p>\n<p>Teitzel et al [TE99] also introduce an improved method to accelerate particle tracing on sparse grids and introduce particle tracing on curvilinear sparse grids. An adaptive evaluation of the sparse grids is implemented. This is achieved by omitting contribution coefficients with a norm below a given error criterion during the interpolation process. The combination technique is also used to improve the efficiency. Streaklines, streak balls and streak tetrahedra are used to visualize flow on curvilinear sparse grids. <strong>Streak tetrahedra</strong> attempt to combine the advantages of streaklines, ribbons, tubes, and balls. The displacement of the tetrahedra along a streakline path depicts acceleration, rotation depicts vorticity, and volume reflects convergence and divergence.</p>\n<p>Teitzel 等人 [TE99] 也介绍了一种改进的方法来加速稀疏网格上的粒子追踪，并介绍了曲线稀疏网格上的粒子追踪。实现了对稀疏网格的自适应评估。这是通过在插值过程中省略规范低于给定误差标准的贡献系数来实现的。组合技术也被用来提高效率。条纹线、条纹球和条纹四面体被用于可视化曲线稀疏网格上的流动。<strong>条纹四面体</strong>试图结合条纹线、带子、管子和球的优点。四面体沿条纹线路径的位移描述了加速度，旋转描述了涡度，体积反映了收敛和发散。</p>\n<p>Reflection: We consider the challenge of particle tracing in 3D, unsteady vector fields to still be a challenge for the case of unstructured grids. Tracing many integral curves is generally still not interactive from a performance point of view.</p>\n<p>反思： 我们认为，对于非结构化网格的情况，在三维、非稳态矢量场中进行粒子追踪仍然是一个挑战。从性能的角度来看，追踪许多积分曲线通常仍然是不互动的。</p>\n<h3 id=\"streamline-rendering-and-placement-in-a-3d-steady-state-domain\"><a class=\"anchor\" href=\"#streamline-rendering-and-placement-in-a-3d-steady-state-domain\">#</a> Streamline rendering and placement in a 3D steady-state domain</h3>\n<p>三维稳态域中的流线型渲染和放置</p>\n<p>This section surveys streamlines used to visualize 3D vector fields. Here, the challenges are perceptual. Rendering too many field lines results in clutter, complexity, occlusion, and other perceptual problems. Rendering too few field lines may lead to missing important characteristics of the data. Conveyance of depth and spatial orientation are also challenges.</p>\n<p>本节调查用于可视化三维矢量场的流线。这里的挑战是知觉上的。渲染太多的场线会导致杂乱、复杂、遮挡和其他感知问题。渲染太少的场线可能会导致丢失数据的重要特征。深度和空间方向的传达也是挑战。</p>\n<p>In 1993, Hin and Post introduce a method for depicting turbulent flow using a particle system [HP93]. Turbulence is a common feature of flow fields, however, there are relatively few techniques that are specifically focused on this flow feature. Turbulence is modeled on Reynolds’ decomposition [Rey95], which expresses turbulence of flow into mean flow and fluctuation, where the fluctuation represents local turbulent motion. This was implemented using a stochastic process whereby a compound velocity was composed of the mean velocity and a random perturbation generated using random-walk models. Tracing the random-walk particles over many steps leads to an effect representing turbulent behavior. The seeding of particles is based on a uniform Cartesian grid aligned with the domain boundary.</p>\n<p>1993 年，Hin 和 Post 介绍了一种使用粒子系统来描绘湍流的方法 [HP93]。湍流是流场的一个常见特征，然而，专门针对这一流动特征的技术相对较少。湍流是以 Reynolds 的分解为模型的 [Rey95]，它将流动的湍流表达为平均流和波动，其中波动代表局部湍流运动。这是用随机过程实现的，即复合速度是由平均速度和使用随机漫步模型产生的随机扰动组成。在许多步骤中追踪随机漫步粒子导致了代表湍流行为的效果。粒子的播种是基于与领域边界对齐的统一笛卡尔网格。</p>\n<p>Zockler et al introduce a method of illuminating stream- ¨ lines [ZSH96]. Graphics APIs such as OpenGL support hardware acceleration for lighting when applied to surface primitives. OpenGL uses the Phong reflection model which typically uses the orientation of the surface (i.e. its normal) with respect to the light direction and the viewing angle. However, there is no native support for the lighting of line primitives in these libraries, due to the fact that line primitives have no unique normal vector.</p>\n<p>Zockler 等人介绍了一种照亮流线的方法 [ZSH96]。像 OpenGL 这样的图形 API 在应用于表面基元时支持硬件加速照明。OpenGL 使用 Phong 反射模型，该模型通常使用表面（即其法线）相对于光线方向和观察角度的方向。然而，由于线状基元没有唯一的法线矢量，因此这些库中没有对线状基元的照明的本地支持。</p>\n<p>From the set of possible normal vectors, the method chooses the ones that maximize diffuse and specular reflection, respectively. For this, two products <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mi>L</mi><mo>⋅</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">{t_1} = L \\cdot T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mi>V</mi><mo>⋅</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">{t_2} = V \\cdot T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> are computed from the light, tangent and view unit vectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo separator=\"true\">,</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">L,T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> on the vertices. By using specially constructed textures and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{t_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{t_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> as texture coordinates, diffuse and specular terms are obtained per pixel.</p>\n<p>从可能的法线矢量集合中，该方法分别选择了能使漫反射和镜面反射最大化的矢量。为此，从顶点上的光、切线和视图单位向量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo separator=\"true\">,</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">L,T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 计算出两个乘积 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mi>L</mi><mo>⋅</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">{t_1} = L \\cdot T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mi>V</mi><mo>⋅</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">{t_2} = V \\cdot T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> 。通过使用专门构建的纹理和 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{t_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">{t_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 作为纹理坐标，可以得到每个像素的漫反射和镜面反射项。</p>\n<p>A streamline placement algorithm is also introduced. For the placement technique a stochastic seeding algorithm is applied. The degree of interest in each cell is defined on some scalar value (i.e. velocity magnitude). An equalization strategy is then employed to distribute the seed points more homogeneously. See Weinkauf et al [WT02, WHN∗03] for applications of this seeding strategy.</p>\n<p>还介绍了一种流线型放置算法。对于安置技术，采用的是随机播种算法。每个单元的兴趣度是根据一些标量值（即速度大小）定义的。然后采用均衡化策略，使种子点的分布更加均匀。关于这种播种策略的应用，见 Weinkauf 等人 [WT02, WHN∗03]。</p>\n<p>Mattausch et al [MT∗03] combine the illuminated streamlines technique of [ZSH96] with an extension of the evenly spaced streamlines seeding strategy of Jobard and Lefer [JL97a] to 3D. With the 2D version of evenly spaced streamlines presented by Jobard and Lefer [JL97a] the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> parameter is used in connection to the current streamline point for the candidate streamline seed points. In 2D there are only two possible positions for this new candidate seed position (one on either side of the streamline). When this is extended to 3D there are an infinite number of positions around a line at an orthogonal distance of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>. The authors simplify the extension to 3D by defining six points around a streamline that may be used for the candidate seed point generation.</p>\n<p>Mattausch 等人 [MT∗03] 将 [ZSH96] 的照明流线技术与 Jobard 和 Lefer [JL97a] 的均匀间隔流线播种策略扩展到三维。在 Jobard 和 Lefer [JL97a] 提出的二维匀速流线版本中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 参数被用于与当前流线点有关的候选流线种子点。在二维中，这个新的候选种子位置只有两个可能的位置（在流线的两侧各一个）。当扩展到三维时，在正交距离为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 的直线周围有无数个位置。 <strong>作者通过定义流线周围的六个点来简化三维的扩展，这些点可用于生成候选种子点。</strong></p>\n<p>Mallo et al present an improved illuminated lines technique [MPSS05]. This method builds upon the previous illuminated lines by Zockler et al [ZSH96] and the cylinder av- ¨ eraging technique presented by Schussman and Ma [SM04]. This method calculates the diffuse and specular components of lighting from the infinitesimal facets of a cylinder. The authors take advantage of programmable GPUs and implement shader programs. This technique improves upon Zockler et ¨ al’s technique which used maximal reflection due to the fact that the maximal reflection technique produces bi-directional lighting. The cylinder averaging technique does not produce bi-directional lighting and thus provides clearer orientation and depth information without having to use a strong specular component. Figure 6 shows an example of illuminated streamlines.</p>\n<p>Mallo 等人提出了一种改进的照明线技术 [MPSS05]。该方法建立在 Zockler 等人 [ZSH96] 以前的照明线和 Schussman 和 Ma [SM04] 提出的圆柱体平均成像技术的基础上。该方法从圆柱体的无限小面计算照明的漫反射和镜面成分。作者利用了可编程 GPU 的优势，实现了着色器程序。这项技术改进了 Zockler 等人的技术，该技术使用了最大反射，因为<strong>最大反射技术产生双向照明。圆柱体平均技术不会产生双向照明</strong>，因此可以提供更清晰的方向和深度信息，而不需要使用强大的镜面成分。图 6 显示了一个被照亮的流线的例子。</p>\n<p><img data-src=\"https://ptpimg.me/4b5v2v.jpg\" alt=\"\" /></p>\n<p>Figure 6: A Lorenz attractor visualized using streamlines. The streamlines are illuminated using a cylinder averaging presented by Mallo et al [MPSS05].</p>\n<p>图 6：使用流线可视化的洛伦兹吸引子。流线是用 Mallo 等人提出的圆柱体平均法照亮的 [MPSS05]。</p>\n<p>Fuhrmann and Groller [FG98] present a technique for virtual environments that aims to reduce perceptual problems in visualizing 3D data such as occlusion and visual clutter. The concept of a dashtube is introduced. A dashtube is an animated, opacity mapped streamline. The dashtubes are seeded using a straightforward extension of the evenly spaced streamlines algorithm [JL97a] to 3D. For simplicity the tube portions are set to either being fully opaque or fully transparent. The opacity mapping is achieved using textures with animation taking place in texture space to improve efficiency and ease of implementation. This method, like most texture-based algorithms, can suffer from aliasing problems. The authors present two methods for resolving this. The first method is a variation of well-known mip-mapping, which instead of filtering the mip-maps, produces sub-maps. The second method uses a texture with bands of varying sizes for different sized regions on the streamline (regions further away from the user appear smaller). The authors also present focus and context techniques: magic lenses and magic boxes. The region within the lens contains a higher density of dashtubes and allows the user to investigate selected areas in more detail. The magic box shows a discrete volume which forms the focus and works on the same principle as the lens while allowing the user to change viewing position and orientation.</p>\n<p>Fuhrmann 和 Groller [FG98] 提出了一种用于虚拟环境的技术，旨在减少 3D 数据可视化中的感知问题，如遮挡和视觉杂乱。介绍了 dashtube 的概念。一个 dashtube 是一个动画的、不透明映射的流线。dashtubes 的种子是用均匀间隔的流线算法 [JL97a] 直接扩展到三维的。为了简单起见，管子的部分被设置为完全不透明或完全透明。不透明度映射是通过纹理实现的，动画在纹理空间中进行，以提高效率，便于实施。这种方法和大多数基于纹理的算法一样，会出现混叠问题。作者提出了两种方法来解决这个问题。第一种方法是众所周知的 mip-mapping 的变种，它不是过滤 mip-map，而是产生 sub-maps。第二种方法是在流线上不同大小的区域使用不同大小的纹理带（离用户较远的区域看起来较小）。作者还提出了聚焦和背景技术：魔镜和魔盒。透镜内的区域包含密度更高的小管，允许用户更详细地调查选定的区域。魔术盒显示了一个形成焦点的离散体积，其工作原理与镜头相同，同时允许用户改变观看位置和方向。</p>\n<p>Laramee and Hauser present a set of geometric visualization techniques including the introduction of two novel approaches: the streamcomet and a fast animating technique [LH05]. These techniques are demonstrated in the context of CFD simulation data. Oriented streamlines improve upon standard streamlines by depicting the downstream direction of the flow in a static image. Animation of streamlines is achieved by a stipple pattern. The streamcomet is a metaphor that offers a large amount of flexibility and interaction from the user. A streamcomet is comprised of a head section and a tail section.</p>\n<p>Laramee 和 Hauser 提出了一套几何可视化技术，包括引入两种新的方法：Streamcomet 和快速动画技术 [LH05]。这些技术在 CFD 模拟数据的背景下被证明。定向流线在标准流线的基础上进行了改进，在静态图像中描述了流动的下游方向。流线的动画化是通过波纹图案实现的。streamcomet 是一个隐喻，提供了大量的灵活性和用户的互动。一个流形图是由头部和尾部组成的。</p>\n<p>Ye et al [YKP05] present a method for streamline placement in 3D flow domains. This paper addresses the common goals of streamline placement, namely, the generation of uncluttered visualizations, and sufficient coverage of the domain to ensure that all important features are captured by the visualization. Conceptually, this algorithm can be viewed as an extension of Verma et al’s method [VKP00] to 3D.</p>\n<p>Ye 等人 [YKP05] 提出了一种在三维流域中放置流线的方法。本文解决了流线放置的共同目标，即生成不杂乱的可视化，以及充分覆盖领域以确保所有重要特征被可视化所捕获。从概念上讲，这种算法可以被看作是 Verma 等人的方法 [VKP00] 在三维领域的扩展。</p>\n<p>This approach scans the vector field for critical points and extracts them, identifying important areas of interest. Different seeding templates are defined a priori and positioned around the vicinity of critical points. This approach also contains an operation which detects the proximity of one critical point to another. A proximity map is then used to merge the two most appropriate templates. Poisson sphere seeding is used to add streamlines to regions of low streamline density. Filtering of the streamlines is then used to remove redundant streamlines and to avoid visual clutter. The filtering process is multi-staged and considers both geometrical and spatial properties. First the streamlines with short lengths and small winding angles are removed. The next step considers the similarity of the remaining streamlines. The streamlines are ranked in order of winding angle. The distance between endpoints and centroids of streamlines with similar winding angles are then considered. If the distance is below a predefined threshold then one of them is filtered out.</p>\n<p>这种方法扫描矢量场的临界点并将其提取出来，确定重要的关注区域。不同的播种模板被预先定义，并被定位在临界点的周围。这种方法还包含一个检测一个临界点与另一个临界点的接近程度的操作。然后用一个接近图来合并两个最合适的模板。泊松球体播种被用来在流线密度低的区域添加流线。然后对流线进行过滤，以去除多余的流线，避免视觉上的杂乱。滤波过程是多阶段的，考虑了几何和空间属性。首先，长度较短和缠绕角度较小的流线被去除。下一步考虑剩余流线的相似性。流水线按照缠绕角度的大小进行排序。然后考虑具有相似缠绕角的流线的端点和中心点之间的距离。如果距离低于预定的阈值，那么其中一条就被过滤掉了。</p>\n<p>Chen et al [CCK07] present a novel method for the placement of streamlines. Unlike many other streamlines placement methods this technique does not rely solely on density placement or feature extraction. Streamline generation methods relying on a density measure may contain redundant streamlines. Strategies based on the extraction of critical points in the field require binary filtering of data based on whether or not they describe a feature. This approach is based on a similarity method which compares candidate streamlines based on their shape and direction as well as their Euclidean distance from one another.</p>\n<p>Chen 等人 [CCK07] 提出了一种新型的流线放置方法。与许多其他的流线放置方法不同，这种技术并不完全依赖于密度放置或特征提取。依靠密度测量的流线生成方法可能包含多余的流线。基于现场关键点提取的策略需要根据是否描述一个特征对数据进行二元过滤。这种方法基于一种相似性方法，该方法根据候选流线的形状和方向以及它们之间的欧氏距离进行比较。</p>\n<p>Li et al [LS07] present a streamline placement strategy for 3D vector fields. The motivation is drawn from the fact that streamlines that are generally well organized in 3D space may still produce a cluttered visualization when projected to the screen. This is the only approach of its kind – where an image-based seeding strategy is used for 3D flow visualization (see Figure 7). The approach presented here places the streamline seeds in image space and then unprojects them back onto object space. The first stage of this algorithm is to randomly select a seed point on the image plane for the initial streamline. This position is then unprojected back into object space. Switching between image space and object space is made possible by exploiting a depth map. Once the initial seed has been placed, the streamline is integrated and placed into a queue. The oldest streamline is then removed from the queue and used to generate a new seed position for another streamline. There are two candidate positions for the seeds, one on either side of the streamline. The new streamline is integrated until it is within a threshold, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>, from other streamlines, it is then placed in the queue. This process is then repeated. Complications arise when 3D streamlines in object space then overlap in image space. Halos are one of the tools used to address this problem.</p>\n<p>Li 等人 [LS07] 提出了一种三维矢量场的流线放置策略。其动机来自于这样一个事实：在三维空间中通常组织良好的流线在投射到屏幕上时仍可能产生杂乱的可视化。这是唯一的一种方法 --<strong> 基于图像的播种策略被用于三维流的可视化</strong>（见图 7）。这里介绍的方法是将流线种子置于图像空间，然后将其解投到物体空间。该算法的第一阶段是在图像平面上随机选择一个种子点作为初始流线。然后，这个位置被解投回物体空间。在图像空间和物体空间之间的切换是通过利用深度图来实现的。一旦初始种子被放置，流线被整合并放入队列中。然后，最老的流线被从队列中移除，并用于为另一条流线生成一个新的种子位置。种子有两个候选位置，一个在流线的两侧。新的流线被整合，直到它与其他流线在一个阈值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>s</mi><mi>e</mi><mi>p</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{d_{sep}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 之内，然后将其放入队列。然后重复这个过程。当物体空间中的三维流线在图像空间中重叠时，就会出现复杂的情况。光晕是用来解决这个问题的工具之一。</p>\n<p><img data-src=\"https://ptpimg.me/7u7cn5.jpg\" alt=\"\" /></p>\n<p>Interactive, seeding strategies have been used in various modern, real-world applications including the investigation and visualization of engine simulation data [Lar02, LWSH04, LGD∗05] (see Figure 8).</p>\n<p>交互式的播种策略已被用于各种现代的、现实世界的应用，包括发动机模拟数据的调查和可视化 [Lar02, LWSH04, LGD∗05]（见图 8）。</p>\n<p><img data-src=\"https://ptpimg.me/wsx6kz.jpg\" alt=\"\" /></p>\n<p>Figure 8: Stream surfaces showing the flow through an engine cooling jacket. Either side of the surface is colored differently to easily identify the orientation of the surface [LGD∗05]</p>\n<p>图 8：显示流经发动机冷却夹套的流面。表面的任何一面都有不同的颜色，以方便识别表面的方向 [LGD∗05] 。</p>\n<p>Reflection: One of the major milestones to perception in 3D vector fields came from Zockler et al [ZSH96]. They were ¨ the first to introduce an enhanced lighting and illumination model for 3D streamlines. However, we still consider perception of 3D vector fields to be an open problem with various unsolved challenges. For example, no user-study evaluation of illuminated streamlines exists.</p>\n<p>反思： 三维矢量场感知的一个重要里程碑来自于 Zockler 等人 [ZSH96]。他们是第一个为三维流线引入强化照明和照度模型的人。然而，我们仍然认为三维矢量场的感知是一个开放的问题，有各种未解决的挑战。例如，目前还没有对照明流线的用户研究评估。</p>\n<h3 id=\"integral-curve-placement-in-a-3d-time-varying-domain\"><a class=\"anchor\" href=\"#integral-curve-placement-in-a-3d-time-varying-domain\">#</a> Integral curve placement in a 3D, time-varying domain</h3>\n<p>在三维时变域中放置积分曲线</p>\n<p>The following research focuses on point-based seeding in unsteady, 3D vector fields. Bryson and Levit [BL92] introduce the Virtual Wind Tunnel. The tunnel is a virtual environment for the exploration of vector fields. It utilizes a mounted head-tracked stereoscopic display. This serves two main purposes: The stereoscopic display provides depth information to the user and the head-tracking allows the user to change their view point within the application by physically changing the position and orientation of their head. This system also allows the user to interact and manipulate objects (such as seed positions) in the system through the use of a glove with input based on gestures from the user. Visualization techniques that are used include tufts, streaklines, particle paths and streamlines. Performance issues arise due to the nature of time-dependent visualization, large data sets and result in high bandwidth and memory requirements when using techniques that simultaneously depict many time-steps. This problem is exaggerated more by the head-tracking feature, the application needs to maintain a minimum execution performance rate (A minimum of 10fps is recommended) to prevent the user from losing co-ordination within the virtual environment.</p>\n<p>下面的研究集中在非稳态的三维矢量场中基于点的播种。Bryson 和 Levit [BL92] 介绍了虚拟风洞。该隧道是一个用于探索矢量场的虚拟环境。它利用了一个安装在头部的立体显示器。这有两个主要目的： 立体显示器向用户提供深度信息，而头部追踪允许用户通过物理改变他们头部的位置和方向来改变他们在应用中的视角。该系统还允许用户通过使用手套与基于用户手势的输入进行互动并操纵系统中的对象（如种子位置）。所使用的可视化技术包括束状物、条纹、粒子路径和流线。由于随时间变化的可视化的性质、大型数据集，以及在使用同时描述许多时间步长的技术时导致的高带宽和内存要求，性能问题就出现了。这个问题因头部追踪功能而更加夸张，应用程序需要保持最低的执行性能率（建议最低为 10fps），以防止用户在虚拟环境中失去协调性。</p>\n<p>Wiebel and Scheuermann present two methods for static visualization of unsteady flow [WS05]. This is opposed to using animation which is much more commonly used to visualize unsteady flow. The first method involves bundles of streaklines and pathlines that pass through one point in space (the eyelet) at different times. A group of pathlines or streaklines passing through the eyelet point (at different times) form the basis of a tangent surface. This method is similar to the technique proposed by Hultquist [Hul92], however in the cases of convergence, a line trace is not terminated, it is just simply ignored for the purpose of surface construction. In the case of divergence a test is made to see if there are any pathlines that are currently being ignored and if so and they are in the correct place they are then used again. If no appropriate pathline exists then a new line must be traced from the eyelet. It is not adequate to simply interpolate a new position between two pathline for a seed point, this is because this new seed point will not necessarily pass through the eyelet. Regions of high activity are of more interest for investigation in general and iso-surfaces are used to separate regions of high activity from regions of (nearly) steady flow. This effectiveness of this visualization technique depends greatly upon the placement of the eyelets within the flow field. Positioning the eyelet is based on sharp edges or corners of objects in the simulation, vortices, critical points, and regions of high activity, i.e. rapidly fluctuating flow direction.</p>\n<p>Wiebel 和 Scheuermann 提出了两种用于静态可视化非稳态流的方法 [WS05]。这与使用动画是相反的，后者更常用于非稳态流的可视化。第一种方法涉及在不同时间通过空间中的一个点（孔口）的条纹线和路径线束。一组（在不同时间）通过孔口点的路径线或条纹线构成了切线面的基础。这种方法类似于 Hultquist [Hul92] 提出的技术，但是在收敛的情况下，一条线迹并没有被终止，只是在构建曲面时被简单地忽略了。在发散的情况下，我们会测试是否有任何路径线被忽略，如果有，并且它们在正确的位置，就会再次使用。如果没有合适的路径线，那么就必须从孔口开始追踪一条新的线路。简单地在两条路径线之间插入一个新的位置作为种子点是不够的，这是因为这个新的种子点不一定会通过孔口。一般来说，高活动区域对调查更有兴趣，等值面被用来将高活动区域与（几乎）稳定流动的区域分开。这种可视化技术的有效性在很大程度上取决于小孔在流场中的位置。定位孔眼的依据是模拟中物体的尖锐边缘或角落、旋涡、临界点和高活动区域，即快速波动的流向。</p>\n<p>Helgeland and Elbroth present a hybrid geometric and texture-based method for visualizing unsteady vector fields [HE06]. The seed positions for the field lines are computed as a pre-processing step. A random initial seed position is used to prevent visual artifacts that may arise when using a uniform distribution of seed points. The seeding algorithm is based upon the evenly spaced streamline strategy introduced by Jobard and Lefer [JL97a]. As a seed point is placed it is advected both upstream and downstream a certain distance. If the field lines don’t maintain a minimum distance, di, from all other field lines, the seed point is removed. The final set of seed points are stored in a 3D texture. Particle advection is implemented using a fourth-order Runge–Kutta integrator. Particles are added at inflow boundaries using the same scheme as the initial seeding strategy. During the course of the visualization, particles may cluster together producing both regions of high particle density and regions of low particle density. To prevent this particles are removed in regions of high density and new particles are injected into sparse regions of particles. A texture-based approach is then used to generate the field lines.</p>\n<p>Helgeland 和 Elbroth 提出了一种基于几何和纹理的混合方法，用于可视化非稳态矢量场 [HE06]。场线的种子位置作为一个预处理步骤被计算出来。一个随机的初始种子位置被用来防止在使用均匀分布的种子点时可能出现的视觉假象。播种算法是基于 Jobard 和 Lefer [JL97a] 所介绍的均匀间隔的流线策略。当一个种子点被放置时，它在上游和下游都被平移了一定距离。如果场线与所有其他场线不能保持最小距离，即 di，种子点就会被移除。最后一组种子点被储存在一个三维纹理中。粒子平流是用四阶 Runge-Kutta 积分器实现的。使用与初始播种策略相同的方案在流入边界添加粒子。在可视化的过程中，粒子可能会聚集在一起，产生高粒子密度和低粒子密度的区域。为了防止这种情况的发生，在高密度区域的粒子被移除，新的粒子被注入到粒子稀疏的区域。然后用一种基于纹理的方法来生成场线。</p>\n<p>Reflection: Overall, there has been very little work in seeding of integral curves in 3D, unsteady flow fields. We consider this an open problem. Challenges related to both interactive computation time and perception remain. Also, there is no general consensus on an optimal seeding strategy in 3D.</p>\n<p>反思： 总的来说，在三维非稳态流场中的积分曲线播种方面的工作非常少。我们认为这是一个开放的问题。与交互式计算时间和感知有关的挑战仍然存在。另外，对于三维的最佳播种策略也没有普遍的共识。</p>\n<h2 id=\"surface-based-integral-objects\"><a class=\"anchor\" href=\"#surface-based-integral-objects\">#</a> Surface-based Integral Objects</h2>\n<p>基于表面的积分对象</p>\n<p>This section describes geometric methods involving surfacebased integral objects. Increasing the seeding object dimensionality increases the dimensionality of the resulting integral object. Surfaces have the added benefit of providing greater perceptual information over line primitives, as shading provides better depth cues. Surfaces also suffer to a lesser extent from visual complexity when compared to line primitives as many lines can be replaced by a single surface, providing more spatial coherency. We note that a significant amount of related work has also been carried out in the applied mathematics community. See Krauskopf et al [KOD∗05] for an overview.</p>\n<p>本节介绍涉及基于曲面的积分对象的几何方法。增加播种对象的维度会增加所产生的积分对象的维度。表面有一个额外的好处，就是比线状基元提供了更多的感知信息，因为阴影提供了更好的深度线索。与线条基元相比，曲面的视觉复杂性也较低，因为许多线条可以被一个单一的曲面所取代，提供了更多的空间一致性。我们注意到，在应用数学界也进行了大量的相关工作。参见 Krauskopf 等人 [KOD∗05] 的概述。</p>\n<h3 id=\"surface-based-objects-in-3d-steady-state-domain\"><a class=\"anchor\" href=\"#surface-based-objects-in-3d-steady-state-domain\">#</a> Surface-based objects in 3D steady-state domain</h3>\n<p>三维稳态域中基于表面的物体</p>\n<p>In 1992, Hultquist introduced a novel stream surface construction algorithm [Hul92]. Streamlines are seeded from a curve and are advanced through the vector field. The sampling frequency is updated at the integration step if necessary. This is achieved using distance tests for neighboring streamline front points. For convergent flow the distance between neighboring points reduces and conversely for divergent flow. In the case of divergent flow a new streamline is seeded when the points exceed a pre-determined distance. In the case of convergent flow, the advancement of a streamline may be terminated if neighboring streamlines come too close. These operations help control the density of the points of the advancing front and maintain a sampling frequency that accurately reconstructs the vector field. The streamline points are used for the stream surface mesh. A locally-greedy tiling strategy is used to tile the mesh with triangles to construct the surface. The stream surfaces may also split apart in order to visualize flow around highly divergent areas such as the flow around an object boundary. The stream surfaces are seeded using an interactive seeding rake.</p>\n<p>1992 年，Hultquist 引入了一种新的流面构造算法 [Hul92]。流线从曲线中播种，通过矢量场推进。如有必要，采样频率在积分步骤中被更新。这是用相邻流线前沿点的距离测试来实现的。对于收敛流，相邻点之间的距离减少，反之，对于发散流，则减少。在发散流的情况下，当这些点超过一个预先确定的距离时，一个新的流线就被播种。在收敛流的情况下，如果相邻的流线靠得太近，流线的推进可能会被终止。这些操作有助于控制前进前线的点的密度，并保持一个准确重建矢量场的采样频率。流线点被用于流面网格。一个局部贪婪的平铺策略被用来用三角形平铺网格来构建表面。流面也可以分割开来，以便将高度发散区域的流动可视化，如物体边界周围的流动。流面是用交互式播种耙进行播种的。</p>\n<p>In contrast to the local method of stream surface presented by Hultquist [Hul92], Van Wijk presents a global approach for stream surface generation [vW93b]. A continuous function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,y,z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span> is placed on the boundaries of the data set. A scalar field is then computed throughout the domain by streamlines placed at all grid boundary points and propagating the value of f along the streamline. An isosurface of this so-called stream function can then be extracted to construct the stream surface. One drawback of this approach is that it only generates stream surfaces that intersect the domain boundary.</p>\n<p>与 Hultquist [Hul92] 提出的流面局部方法相比，Van Wijk 提出了一种流面生成的全局方法 [vW93b]。一个连续的函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x,y,z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span> 被放在数据集的边界上。然后通过放置在所有网格边界点的流线来计算整个域的标量场，并将 f 的值沿流线传播。然后可以提取这个所谓流函数的等值面来构造流面。这种方法的一个缺点是，它只生成与域边界相交的流面。</p>\n<p>Scheuermann et al present a method of stream surface construction on tetrahedral grids [SBH∗01] that builds upon previous work introduced by Hultquist [Hul92]. This method advances the surface through the grid one tetrahedron at a time and calculates where the surface intersects with the tetrahedron. When the surface passes through the tetrahedron the end points are traced as streamlines. For each point on a streamline, a line is added connecting it to its counterpoint. These are then clipped against the faces of the tetrahedron cell and the result is the surface within the cell. Due to the nature of this method, i.e. using the underlying grid in the surface construction process, this method is inherently compatible with multi-resolution grids and thus benefits from the increased grid resolution in interesting flow regions, such as near object boundaries within the flow field.</p>\n<p>Scheuermann 等人在 Hultquist [Hul92] 介绍的工作基础上，提出了一种在四面体网格上构建流面的方法 [SBH∗01]。该方法每次通过网格推进流面，并计算流面与四面体的相交位置。当曲面通过四面体时，终点会被追踪为流线。对于流线上的每一个点，都会有一条线连接到它的对应点。然后将这些线与四面体单元的面进行剪切，结果就是单元内的曲面。由于这种方法的性质，即在表面构造过程中使用底层网格，这种方法本质上与多分辨率网格兼容，因此在有趣的流动区域，如流场中的物体边界附近，受益于网格分辨率的提高。</p>\n<p>Brill et al [BHR∗94] introduce the concept of a <strong>streamball</strong> and apply them to the visualization of steady and unsteady flow fields. Streamballs are defined by a set of discrete points in the vector field based on the metaballs of Wyvill et al [WMW86]. A streamball follows the same path of a streamline, however acceleration and deceleration are depicted by the amount of displacement between neighboring spheres. Other local properties of the flow can be mapped to the radius of the sphere.</p>\n<p>Brill 等人 [BHR∗94] 介绍了<strong>流球</strong>的概念，并将其应用于稳定和不稳定流场的可视化。流球是由一组基于 Wyvill 等人的元球的矢量场中的离散点定义的。[WMW86]。一个流球遵循相同的流线路径，然而加速和减速是由相邻球体之间的位移量来描述的。流动的其他局部属性可以映射到球体的半径上。</p>\n<p>Using discrete streamball placement it is possible to construct streamlines and pathlines by ensuring that the center points for each streamball are close enough so that they blend together and form an implicit surface [BHR∗94]. This technique can also be applied to stream surface construction by advancing a set of streamballs that are seeded along a curve. This produces a smooth surface where the streamballs merge automatically in areas of convergence and split in areas of flow divergence.</p>\n<p>使用离散的流球放置，可以通过确保每个流球的中心点足够接近来构建流线和路径线，从而使它们融合在一起并形成一个隐含的表面 [BHR∗94]。这种技术也可以应用于流线表面的构建，通过推进一组沿曲线播种的流球。这就产生了一个光滑的表面，在这个表面上，流球在汇合的地方自动合并，在流向分歧的地方自动分裂。</p>\n<p>Westermann et al [WJE00] present a level-set method for the visualization of flow fields. Vector-field data are converted into a scalar level-set representation. These level sets are used to create implicit time surfaces. This approach is similar to the implicit stream surfaces method of van Wijk [vW93b]. Once we have this scalar representation the surfaces can then be computed using an iso-surface extraction technique.</p>\n<p>Westermann 等人 [WJE00] 提出了一种用于流场可视化的水平集方法。矢量场数据被转换为标量水平集表示。这些水平集被用来创建隐含的时间曲面。这种方法类似于 van Wijk [vW93b] 的隐性流面方法。一旦我们有了这个标量表示，就可以用等值面提取技术来计算曲面。</p>\n<p>Garth et al [GTS∗04] introduce a stream surface technique that handles areas of intricate flow more accurately than previous techniques such as the method presented by Hultquist [Hul92]. The algorithm is demonstrated in the context of vortex structures and is based upon an advancing front with the insertion and deletion of points at each integration step in order to maintain sufficient resolution for the construction of an accurate stream surface. In order to handle more complex flow regions, a high-order integrator is used as well as streamline integration being based upon arc length as opposed to parameter length, as used in Hultquist’s method [Hul92]. This results in an improved triangulation for the stream surface mesh, i.e. triangles are more regular throughout the mesh. For the insertion of a new streamline the authors also introduce a new rule based upon the angle between triples of neighboring points on the stream surface front.</p>\n<p>Garth 等人 [GTS∗04] 介绍了一种流面技术，它比以前的技术（如 Hultquist [Hul92] 提出的方法）能更准确地处理复杂的流动区域。该算法是在涡流结构的背景下演示的，它基于一个前进的前沿，在每个积分步骤中插入和删除点，以保持足够的分辨率来构建一个精确的流面。为了处理更复杂的流动区域，使用了一个高阶积分器以及基于弧长的流线积分，而不是像 Hultquist 方法 [Hul92] 中使用的参数长度。这使得流面网格的三角形得到改善，即整个网格的三角形更加规则。对于新流线的插入，作者还引入了一个新的规则，即基于流面前沿相邻点的三角形之间的角度。</p>\n<p>Loffelmann et al [LMG97] introduce an extension called ¨ stream-arrows for the enhancement of stream surfaces.</p>\n<p>Loffelmann 等人 [LMG97] 介绍了一个名为 &quot;流箭&quot; 的扩展，用于增强流面。</p>\n<p><img data-src=\"https://ptpimg.me/r9906y.jpg\" alt=\"\" /></p>\n<p>Figure 9: Stream-arrows textured to a streamsurface. The portions outside the arrows are semi-transparent reducing the occlusion by the surface [Lof98]. Image courtesy of Hel- ¨ wig Hauser</p>\n<p>图 9：溪流箭头的纹理为溪流表面。箭头外的部分是半透明的，减少了表面的遮挡 [Lof98]。图片由 Hel- ¨ wig Hauser 提供</p>\n<p><strong>Stream-arrows</strong> are partitions that are removed from the surface in order to convey inner flow structure within the surface (see Figure 9). The removal of the partition also help to reduce occlusion as the area behind the removed portion is visible. In the original stream-arrows algorithm the arrows were placed on the stream surface using regular tiling. However, this technique may provide unsatisfactory results in regions of convergence and divergence, as the arrows may become too small or too large. The hierarchical extension overcome this shortfall by generating a stack of stream-arrow textures, where each texture contains a unique resolution of arrows. The most appropriate texture is then chosen according to the size of the stream surface, this ensures that the stream-arrows all keep a similar size.</p>\n<p><strong>溪流箭头</strong>是为了传达表面内的流动结构而从表面上去除的隔断（见图 9）。移除分区也有助于减少遮挡，因为被移除部分后面的区域是可见的。在最初的流 - 箭头算法中，箭头是用规则的平铺方式放在流表面上的。然而，这种技术在收敛和发散区域可能提供不令人满意的结果，因为箭头可能变得太小或太大。分层扩展克服了这一不足，它生成了一个流箭头纹理的堆栈，其中每个纹理包含一个独特的箭头分辨率。然后根据流面的大小选择最合适的纹理，这就保证了流箭都保持相似的大小。</p>\n<p>Laramee et al [LGSH06] present a hybrid method by applying texture advection to stream surfaces. This hybrid technique enables the visualization to convey more information about its inner flow structure. This technique has been used on iso-surfaces [LSH04] but the textures can mislead the user. If an iso-surface is generated using velocity magnitude, there is no guarantee that the surface will be everywhere tangent to the flow. This means there may be a component of the flow vector that is, at least in part, orthogonal to the iso-surface and thus the advection may be misleading. Stream surfaces don’t suffer from this weakness as they are, by definition, always aligned with the flow field.</p>\n<p>Laramee 等人 [LCSH06] 提出了一种混合方法，将纹理平流应用于流表面。这种混合技术使得可视化能够传达更多关于其内部流动结构的信息。这种技术已经被用于等值面 [LSH04]，但纹理会误导用户。如果一个等值面是用速度大小生成的，就不能保证该面在任何地方都能与流动相切。这意味着流速矢量中可能有一个分量，至少有一部分是与等值面正交的，因此，平流可能会产生误导。流面则没有这个弱点，因为根据定义，它们总是与流场对齐。</p>\n<p>Peikert and Sadlo[PS09] present a hybrid seeding and construction method for topologically relevant stream surfaces. The topology of the velocity field is used to compute the seeding curve of the most expressive stream surfaces. Seeding for cases such as periodic orbits and critical points is described to ensure that the stream surface is not multiply covered. Cases of open and closed seeding curves are described. A quadbased construction method is used to compute the stream surfaces. Quadrilateral cells are added at the front of the surface enclosed by streamlines and orthogonal curves. Sinks within the velocity field are detected when the orthogonal edge segments become too small. These edges are flagged as inactive. Integration terminates when there are no more active edges. Saddle points are handled by tearing the surface resulting in a closed surface front becoming an open one and an already open front splitting into separate portions.</p>\n<p>Peikert 和 Sadlo [PS09] 提出了一种用于拓扑相关流面的混合播种和构建方法。速度场的拓扑结构被用来计算最具表现力的流面的播种曲线。对周期性轨道和临界点等情况的播种进行了描述，以确保流面不被多重覆盖。描述了开放和封闭的播种曲线的情况。一个基于四边形的构造方法被用来计算流面。在由流线和正交曲线围成的表面前端添加四边形单元。当正交边缘段变得太小时，速度场内的汇被检测出来。这些边缘被标记为不活跃。当不再有活动的边时，集成就结束了。鞍点的处理是通过撕裂曲面，使封闭的曲面前沿变成开放的，已经开放的前沿分成独立的部分。</p>\n<p>Reflection: A milestone in this category was that of Hultquist who introduced the first stream surfaces for 3Dsteady flow [Hul92]. The work that follows improves that work in terms of performance and perception. A few of the open challenges here relate to performance and perception. How to minimize occlusion while maximizing coverage is a big challenge. Interactive computation of stream surfaces for unstructured grids still remains to be seen.</p>\n<p>反思： 这方面的一个里程碑是 Hultquist 的工作，他介绍了第一个三维稳定流的流面 [Hul92]。接下来的工作在性能和感知方面改进了这项工作。这里的一些开放性挑战与性能和感知有关。如何在最大化覆盖率的同时尽量减少遮挡是一个很大的挑战。非结构化网格的流面的交互式计算仍有待观察。</p>\n<h3 id=\"surface-based-objects-in-3d-time-dependent-domain\"><a class=\"anchor\" href=\"#surface-based-objects-in-3d-time-dependent-domain\">#</a> Surface-based objects in 3D time-dependent domain</h3>\n<p>三维时空领域中基于表面的物体</p>\n<p>Schafhitzel et al [STWE07] introduce a point-based stream surface construction and rendering method. This method is also applicable to unsteady flow fields, for which it generates path surfaces. This method was implemented to exploit graphics hardware acceleration and therefore all data structures used lend themselves to being stored in textures. Like the method presented by Hultquist [Hul92] this algorithm includes operations to adjust the density of the surface front. By adding or removing points this method updates the sampling frequency and allows for accurate surface construction in flow exhibiting local convergent or divergent behavior. A method and conditions for splitting the surface are also implemented which are similar to the technique Hultquist [Hul92] used in his algorithm.</p>\n<p>Schafhitzel 等人 [STWE07] 介绍了一种基于点的流面构造和渲染方法。该方法也适用于非稳态流场，为其生成路径曲面。这个方法是为了利用图形硬件加速而实现的，因此所有使用的数据结构都可以存储在纹理中。与 Hultquist [Hul92] 提出的方法一样，该算法包括调整表面前沿密度的操作。通过添加或删除点，该方法更新了采样频率，并允许在表现出局部收敛或发散行为的流中准确地构建表面。还实现了分割曲面的方法和条件，这与 Hultquist [Hul92] 在其算法中使用的技术相似。</p>\n<p>In order to render the surface, particles are distributed with a sufficient density (to cover the image space represented by the surface) so that point sprites can be used, this results in a closed surface. Surface normals can be estimated for each particle and this allows the surface to benefit from shading and its associated advantages, i.e. greater depth cues etc. A surface-based LIC algorithm was also applied in order to provide internal visual structure for the surfaces.</p>\n<p>为了渲染表面，粒子以足够的密度分布（以覆盖表面所代表的图像空间），因此可以使用点状精灵，这导致一个封闭的表面。每个粒子的表面法线都可以被估计出来，这使得表面可以从阴影及其相关的优势中获益，即更大的深度线索等。一个基于表面的 LIC 算法也被应用，以便为表面提供内部的视觉结构。</p>\n<p>Von Funck et al present a novel technique for smoke surface construction that provides nearly interactive frame-rates by avoiding the expensive mesh re-triangulation at every time-step [vFWS∗08]. No re-triangulation of the mesh leads to irregular triangles due to flow characteristics such as divergence. This method exploits these irregular triangles and maps the opacity of the triangle to its size and shape. This provides a fair approximation of the optical model for smoke resulting in surfaces that give a smoke-like effect. A number of enhancements are also given, showing how simple modifications to the core algorithm can be used to simulate smoke injection from nozzles and wool tufts attached to the boundary surface of geometries within the flow domain.</p>\n<p>Von Funck 等人提出了一种新的烟雾表面构造技术，通过避免在每个时间步的昂贵的网格重新三角化来提供近乎交互式的帧速率 [vFWS∗08]。由于发散等流动特性，没有重新三角化的网格会导致不规则三角形。该方法利用这些不规则三角形，将三角形的不透明度映射到其大小和形状。这为烟雾的光学模型提供了一个公平的近似，从而使表面呈现出类似烟雾的效果。还给出了一些改进措施，显示了如何通过对核心算法的简单修改来模拟从喷嘴和附着在流域内几何体边界表面的羊毛丛中喷出的烟雾。</p>\n<p>Garth et al present a novel stream and path surface technique focusing on accuracy [GKT∗08]. This method defines refinement criteria that are based upon the order of continuity of the surface lines. New points are added when the curves need to be refined. When discontinuities of first and second order are encountered, the portions of the surface either side of the discontinuity are treated independently of each other, like the surface tearing as handled by Hultquist [Hul92]. This method has no mechanism for removing points from the surface, where sampling is more than sufficient. They trade the cost of the extra integrations for the cost of performing the tests for redundant points and their removal. The meshlines are stored as polynomials and the mesh is discretized after the entire advection stage.</p>\n<p>Garth 等人提出了一种注重精度的新型流和路径表面技术 [GKT∗08]。这种方法定义了细化标准，这些标准是基于表面线的连续性顺序的。当曲线需要被细化时，就会增加新的点。当遇到一阶和二阶不连续时，不连续两侧的曲面部分会被独立处理，就像 Hultquist [Hul92] 所处理的曲面撕裂一样。这种方法没有从曲面上去除点的机制，在这种情况下采样是绰绰有余的。他们用额外积分的成本换取对冗余点的测试和移除的成本。网格线以多项式的形式存储，网格在整个平流阶段后被离散化。</p>\n<p>McLoughlin et al [MLZ09b] present a simplified stream and path surface construction technique (Figure 10). This method is closely related to Hultquist’s technique [Hul92]. This technique makes use of simpler data structures – a 2D array, compared to the tracer and ribbon structures used by Hultquist. This simpler approach is made possible by the use of quad primitives for the surface construction. Quads lend themselves naturally to a 2D array, which forms an implicit parameterization of the surface. However, memory may be wasted as elements of the 2D array may be empty, containing no geometry information, but maintain the parameterization property of the surface. Insertion and deletion of vertices is performed to maintain a sufficient sampling of the vector field. This is achieved by processing the mesh quad by quad, dividing and merging quads when a change in resolution is required. Shear flow is also handled by an adaptive step-size integration technique along the quad edge to ensure the quads are more regular.</p>\n<p>McLoughlin 等人 [MLZ09b] 提出了一种简化的流和路径表面构造技术（图 10）。该方法与 Hultquist 的技术 [Hul92] 密切相关。与 Hultquist 使用的示踪和带状结构相比，该技术使用了更简单的数据结构 -- 一个二维阵列。这种简单的方法是通过使用四边形基元来构建曲面而实现的。四元数组很自然地形成了一个二维数组，形成了表面的隐含参数化。然而，内存可能会被浪费，因为二维数组的元素可能是空的，不包含任何几何信息，但保持了曲面的参数化属性。顶点的插入和删除是为了保持矢量场的充分采样。这是通过逐个处理网格，在需要改变分辨率的时候划分和合并网格来实现的。剪切流也是通过沿四边形边缘的自适应步长积分技术来处理的，以确保四边形更加规则。</p>\n<p><img data-src=\"https://ptpimg.me/m4m006.jpg\" alt=\"\" /></p>\n<p>Figure 10: A stream surface visualizing a tornado simulation [MLZ09b]. Surfaces reduce visual complexity compared to line primitives.</p>\n<p>图 10：龙卷风模拟中的流面可视化 [MLZ09b]。与线状基元相比，面状基元降低了视觉复杂性。</p>\n<p>Krishnan et al [KGJ09] present a novel streak and time surface algorithm (see Figure 11). This technique guarantees a C1 continuous curve for the integral curves due to the use of an adaptive step-size fifth-order Runge–Kutta outputting a sequence of fourth-order polynomials. This allows for interim points to be computed easily and provides more accurate results than gained from a simple piecewise linear interpolation between sample points. Three basic operations are defined for the surface adaptation process, these are edge split, edge flip and edge collapse. An edge split ensures that no edge on a triangle is longer than a prescribed threshold. A new vertex is inserted and this is used to create a new integral curve. Egde flipping locally refines an area to maximize the minimum angles within the triangles such that triangles are more regular. Edge collapse removes edges from the mesh in regions where the density of triangles is too high. This prevents the unnecessary propagation of curves in future computations. The algorithm is demonstrated on large unsteady unstructured grid simulations, which inherently consume much processing effort. It is shown that this technique lends itself to parallelism.</p>\n<p>Krishnan 等人 [KGJ09] 提出了一种新颖的条纹和时间面算法（见图 11）。由于使用了自适应步长的五阶 Runge-Kutta 输出四阶多项式序列，该技术保证了积分曲线的 C1 连续曲线。这使得临时点的计算很容易，并提供了比样本点之间简单的片状线性插值更精确的结果。为表面适应过程定义了三个基本操作，它们是边缘分割、边缘翻转和边缘塌陷。边缘分割确保三角形上的任何边缘都不长于规定的阈值。一个新的顶点被插入，这被用来创建一个新的积分曲线。边缘翻转局部细化一个区域，使三角形内的最小角度最大化，从而使三角形更加规则。边缘折叠（Edge collapse）在三角形密度过高的区域将边缘从网格中移除。这可以防止在未来的计算中出现不必要的曲线传播。该算法在大型非稳态非结构化网格模拟中进行了演示，这本身就消耗了很多处理工作。结果表明，这种技术适合于并行计算。</p>\n<p>Burger et al [BFTW09] present two streak surface tech- ¨ niques implemented on the GPU. These techniques provides interactive rates throughout the surface construction. The first technique is based on quads. Each quadrilateral patch contains four vertices. The same vertex is stored (and propagated) multiple times. Refinement of patches is achieved by splitting the longest edge of the quadrilateral and the edge opposite it. This may result in discontinuities within the mesh. A two-pass rendering operation ensures that the quads form a smooth surface during the rendering phase. The first pass creates a depth imprint of the enlarged quadrilateral patches in respect to the position of the viewer. On the second pass a biased depth test is used on the depth imprint to ensure that only patch samples close to the surface are used. A smooth transition for shading, coloring etc. is done by using a Gaussian kernel at each path centroid to weight the attributes which are finally accumulated using additive blending and normalization.</p>\n<p>Burger 等人 [BFTW09] 提出了两种在 GPU 上实现的条纹曲面技术。这些技术在整个曲面构造过程中提供了交互率。第一种技术基于四边形。每个四边形补丁包含四个顶点。同一个顶点被存储（和传播）多次。通过分割四边形的最长边和与之相对的边实现补丁的细化。这可能会导致网格内出现不连续性。两遍渲染操作可确保四边形在渲染阶段形成光滑表面。第一遍渲染是根据观察者的位置对放大的四边形斑块进行深度印记。在第二遍渲染中，对深度印记进行有偏差的深度测试，以确保只使用接近表面的补丁样本。在每个路径中心点使用高斯核对属性进行加权，最后使用加法混合和归一化对属性进行累积，从而实现阴影、着色等的平滑过渡。</p>\n<p>The second technique more closely follows the more common mesh approaches. Duplicate vertices are not stored explicitly. This is handled by memory layout in the vertex buffer. Surface refinement is performed in three stages: timeline refinement, connectivity update, streakline refinement. During timeline refinement particles may be inserted, spawning new streaklines, or particles may be removed. Connectivity is updated by each particle on a timeline searching along neighboring timelines for the closest match based on a uniqueness criterion. In the streakline refinement phase a test for the maximum Euclidean distance is performed for neighboring timelines. If the distance is above or below given thresholds, an entire streakline is added or removed respectively.</p>\n<p>第二种技术更接近于常见的网格方法。重复的顶点不会显式存储。这将通过顶点缓冲区中的内存布局来处理。曲面细化分三个阶段进行：时间轴细化、连接性更新和条纹细化。在时间轴细化过程中，可能会插入粒子，产生新的条纹线，也可能会移除粒子。连接性更新是通过时间轴上的每个粒子沿相邻时间轴搜索，根据唯一性标准寻找最匹配的粒子。在细化时间线阶段，对相邻时间线的最大欧氏距离进行测试。如果距离大于或小于给定的阈值，则分别添加或删除整条链线。</p>\n<p>Reflection: Constructing and rendering of integral surfaces in 3D unsteady flow is clearly an unsolved problem with various challenges remaining including performance and perception. Current solutions do not handle shear flow very well. Also, the combination of large data sets and interaction still poses challenges. This category of techniques is currently and active area of research.</p>\n<p>反思： 在三维非稳态流中构建和渲染积分表面显然是一个尚未解决的问题，仍然存在各种挑战，包括性能和感知。目前的解决方案不能很好地处理剪切流。此外，大型数据集和交互的结合仍然构成挑战。这类技术目前是一个活跃的研究领域。</p>\n<h2 id=\"volume-integral-objects\"><a class=\"anchor\" href=\"#volume-integral-objects\">#</a> Volume Integral Objects</h2>\n<p>体积积分对象</p>\n<p>This section describes geometric methods involving 2D surface or planar-based seeding objects. Once more, increasing the dimensionality of the seeding object increases the dimensionality of the integral object. The result is a geometric object that sweeps a volume. The volume of these objects can be used to depict flow characteristics such flow convergence and divergence.</p>\n<p>本节将介绍涉及二维表面或基于平面的播种对象的几何方法。同样，增加播种对象的维数也会增加积分对象的维数。结果是一个几何对象扫过一个体积。这些对象的体积可用于描述流动特征，如流动收敛和发散。</p>\n<h3 id=\"volumetric-integral-in-a-3d-steady-state-domain\"><a class=\"anchor\" href=\"#volumetric-integral-in-a-3d-steady-state-domain\">#</a> Volumetric integral in a 3D steady-state domain</h3>\n<p>三维稳态域中的体积积分</p>\n<p>Schroeder et al introduce the Stream Polygon [SVL91]. A <strong>stream polygon</strong> is a regular n-sided polygon that is oriented normal to the vector field. The stream polygon can be used by placing a new polygon for each point of a streamline or it may be swept along the streamline to form a tube. The polygon is deformed according to the local flow properties. Rotation of the polygon reflects the local vorticity of the flow field. There are no constraints on the polygon maintaining a rigid body structure, therefore deformation of the polygon is used to illustrate the local strain of the flow field.</p>\n<p>Schroeder 等人提出了<strong>流多边形</strong> [SVL91]。流多边形是一个规则的 n 边多边形，其方向为矢量场的法线方向。流多边形可用于为流线的每个点放置一个新的多边形，也可沿流线扫过形成管状。多边形根据局部流动特性进行变形。多边形的旋转反映了流场的局部涡度。多边形没有保持刚体结构的约束，因此多边形的变形用于说明流场的局部应变。</p>\n<p>Max et al introduce <strong>flow volumes</strong> [MBC93]. A flow volume (Figure 12) is the volumetric equivalent of a streamline. This method draws inspiration from experimental flow visualization, using a tracer material released into a fluid flow.</p>\n<p>Max 等人提出了<strong>流动体积</strong> [MBC93]。流动体积（图 12）相当于流线的体积。这种方法的灵感来自于实验性的流动可视化，使用的是释放到流体流动中的示踪材料。</p>\n<p><img data-src=\"/home/sakura/Documents/%25E8%25AE%25BA%25E6%2596%2587%25E9%259B%2586/2023-07-10-19-11-17.jpg\" alt=\"\" /></p>\n<p>Figure 12: A flow volume created using the tornado data set. Image courtesy of Roger Crawfis [MBC93].</p>\n<p>图 12：使用龙卷风数据集创建的流动体积。图片由 Roger Crawfis 提供 [MBC93]。</p>\n<p>As the trace propagates through the flow it forms into a flow volume. The flow volume is divided into a set of tetrahedra, the projection of which are divided into triangles. Color and opacity are computed for each tetrahedra using the density emitter model of Sabella [Sab88]. The contributing pixel values can be composited in an arbitrary manner, thus negating the need for a complex sorting algorithm for the volumetric cells. This is suitable as it produces a reasonable approximation of the tracer material effect that the authors are aiming for. An interactive seeding object is used which is always oriented normal to the local flow field and allows the user to change attributes of the seed object such as: position, color and opacity of the smoke and the number of sides for the seeding polygon.</p>\n<p>当轨迹在流体中传播时，形成流体体积。流动体积被划分为一组四面体，其投影被划分为三角形。使用 Sabella [Sab88] 的密度发射器模型计算每个四面体的颜色和不透明度。像素值可以任意合成，因此不需要对体积单元进行复杂的排序算法。这样做是合适的，因为它合理地近似了作者所追求的示踪材料效果。使用的交互式播种对象始终与局部流场方向一致，用户可以改变播种对象的属性，如：烟雾的位置、颜色和不透明度以及播种多边形的边数。</p>\n<p>Xue et al introduce implicit flow volumes [XZC04]. This idea builds upon flow volumes introduced by Max et al [MBC93] and the implicit stream surface technique presented by Van Wijk [vW93b]. Two techniques are presented for the rendering of the implicit flow volume, a slice-based 3D texture mapping and interval volume rendering. The first approach renders the flow field directly without the inflow mapping to a scalar field, as used by Van Wijk [vW93b]. Volume shaders can be used to change the appearance and representation of the flow volume. This method allows for high levels of interactivity and fine texture detail in all regions of the flow volume (see Figure 13). The second approach utilizes a flow mapping that produces a scalar field, the flow volume created from the interval volume enclosed between two iso-surfaces. The rendering of the volume is then achieved by using a tetrahedron-based technique.</p>\n<p>Xue 等人提出了隐式流动体积 [XZC04]。这个想法建立在 Max 等人 [MBC93] 提出的流动体积和 Van Wijk [vW93b] 提出的隐式流面技术的基础上。隐式流体积的渲染有两种技术，一种是基于切片的三维纹理映射，另一种是区间体积渲染。第一种方法直接渲染流场，而不像 Van Wijk [vW93b] 使用的那样将流入映射为标量场。体积着色器可用于改变流动体积的外观和表现。这种方法可以在流体的所有区域实现高水平的交互性和精细的纹理细节（见图 13）。第二种方法是利用流动映射生成标量场，即由两个等曲面之间的间隔体积创建的流动体积。然后使用基于四面体的技术对体积进行渲染。</p>\n<h3 id=\"volumetric-integral-in-a-3d-time-dependent-domain\"><a class=\"anchor\" href=\"#volumetric-integral-in-a-3d-time-dependent-domain\">#</a> Volumetric integral in a 3D time-dependent domain</h3>\n<p>三维时域中的体积积分</p>\n<p>Becker et al extend the flow volume technique [MBC93] for the use with unsteady vector fields [BLM95]. Flow volumes in steady flow fields are created using a set of streamlines seeded from a polygon oriented normal to the local flow. To extend this to unsteady flow, Becker et al construct the flow volumes using streaklines. As in the steady case, the volume is divided up into tetrahedra and volume rendered using hardware. Using streaklines instead of streamlines introduces several complications to the initial flow volume strategy. In the steady case, only the end points of each streamline are advected and a new layer is added to the end of the flow volume in the downstream direction during each integration step. However, when streaklines are used, every point on the streakline must be advected (not just the end points). This may result in the flow volume geometry changing over time. The subdivision strategy used in [MBC93] was performed only at the end of the flow volume, but the changing geometry here requires a subdivision strategy that operates anywhere in the volume. A subdivision created in a previous time-step may be unnecessary in future time-steps. Subdivision in time is also required, if all particles within a given layer exceed a given distance threshold from the previous layer, a new layer is inserted between them. The reverse is also applicable with the possibility that a layer may be removed.</p>\n<p>Becker 等人将流动体积技术 [MBC93] 扩展到非稳态矢量场 [BLM95]。稳定流场中的流动体积是通过一组流线来创建的，这些流线来自于与局部流向法线方向一致的多边形。为了将其扩展到非稳态流场，Becker 等人使用流线来构造流动体积。与稳定情况下一样，体积被划分为四面体，并使用硬件进行体积渲染。使用条纹线代替流线给初始流动体积策略带来了一些复杂性。在稳定情况下，只有每条流线的端点被平流，并且在每个积分步骤中，新的层被添加到下游方向的流动体积末端。然而，当使用流线时，流线上的每一点都必须平流（而不仅仅是端点）。这可能导致流动体积的几何形状随时间变化。在 [MBC93] 中使用的细分策略仅在流动体积的末端执行，但这里不断变化的几何形状要求细分策略在体积的任何位置执行。前一时间步创建的细分在未来的时间步中可能是不必要的。如果给定层内的所有颗粒与上一层的距离超过给定距离阈值，则在它们之间插入一个新层。反之亦然，也有可能删除一层。</p>\n<p><img data-src=\"https://ptpimg.me/2rylox.jpg\" alt=\"\" /></p>\n<p>Figure 13: An implicit flow volume based on the technique of Xue et al [XZC04]. Image courtesy of Roger Crawfis.</p>\n<p>图 13：基于 Xue 等人 [XZC04] 技术的隐式流动体积。图片由 Roger Crawfis 提供。</p>\n<p>Reflection: Work on volume integral objects is clearly less mature in comparison to research using curve- and surfacebased solutions. Also, no individual contribution has triggered a chain of follow-up approaches offering enhancements to the original. Both computational and perceptual challenges remain in this area. Seeding is also a challenge that has not been addressed.</p>\n<p>反思： 与基于曲线和曲面解决方案的研究相比，关于体积积分物体的研究显然不够成熟。此外，没有任何一个单独的研究成果能够引发一系列的后续研究，对原有的研究成果进行改进。在这一领域，计算和感知方面的挑战依然存在。播种也是一个尚未解决的挑战。</p>\n<h2 id=\"discussion-and-conclusions\"><a class=\"anchor\" href=\"#discussion-and-conclusions\">#</a> Discussion and Conclusions</h2>\n<p>讨论与结论</p>\n<p>A variety of techniques have been discussed, each with their own relative merits and shortcomings. As clearly illustrated in this literature, there is no single visualization tool which provides optimal results for all given phenomena. The most appropriate method is dependent upon several factors such as the data dimensionality (both spatial and temporal). The size of the simulation output and the goal of the user are also factors, i.e. is the visualization to be used for detailed investigation in specific regions, is the visualization intended for fast exploration of the vector field or for high-quality presentation purposes.</p>\n<p>人们讨论了各种技术，每种技术都有其相对的优点和缺点。这些文献清楚地表明，没有一种可视化工具能够为所有给定现象提供最佳结果。最合适的方法取决于多个因素，如数据维度（空间和时间维度）。模拟输出的大小和用户的目标也是因素之一，即可视化是否用于特定区域的详细调查，可视化是否用于矢量场的快速探索或高质量的演示目的。</p>\n<p>In the context of geometric approaches, a large volume of effort has been placed on streamlines. Streamlines are an effective tool and coupled with an effective seeding strategy may produce some insightful visualizations. The success of streamlines comes partly from their ease of implementation and the quality of the results produced. Streamline enhancements tend to fall in one of two categories, particle tracing or seeding algorithms. The particle tracing algorithms also have their own subset of classifications, with their contributions differentiating them from other tracing algorithms. Most effort has been undertaken on providing ever faster tracing, while other methods have focused tracing on specific grid types, while others on accuracy, producing exact results rather than approximations when using a numerical integration method. Particle tracing methods were a popular area of research in the 1990s with comparatively very little work been undertaken recently. This may be due to the efficiency of current methods, making it more difficult to obtain further significant gains in performance.</p>\n<p>在几何方法方面，大量的工作都放在了流线上。流线是一种有效的工具，配合有效的播种策略，可以产生一些有深度的可视化效果。流水线的成功部分源于其易于实施和所产生结果的质量。流线型增强技术通常分为两类：粒子追踪算法或播种算法。粒子追踪算法也有自己的分类子集，其贡献区别于其他追踪算法。大多数方法致力于提供更快的跟踪速度，而其他方法则侧重于特定网格类型的跟踪，还有一些方法则侧重于精度，在使用数值积分方法时产生精确结果而不是近似结果。粒子追踪方法是 20 世纪 90 年代的一个热门研究领域，但最近的研究相对较少。这可能是由于目前的方法效率较高，使得进一步大幅提高性能变得更加困难。</p>\n<p>Seeding strategies have been heavily researched and are still an area of active research. Many algorithms are based on providing aesthetic, insightful visualizations in image space. The focus of these papers tends to be on producing uncluttered visualizations that avoid bombarding the user with visual overload. The majority of seeding algorithms have been targeted at 2D domains with only a handful being extended or specifically aimed at higher spatial dimensions. We believe that seeding in 3D domains is still a fruitful area of research and seeding strategies may be extended to providing efficient algorithms for unsteady flow fields.</p>\n<p>对播种策略进行了大量研究，目前仍是一个活跃的研究领域。许多算法都基于在图像空间中提供美观、有洞察力的可视化效果。这些论文的重点往往是制作不杂乱的可视化图像，避免给用户造成视觉过载。大多数播种算法都针对二维领域，只有少数算法针对更高的空间维度进行了扩展或专门设计。我们相信，三维领域的播种仍然是一个富有成果的研究领域，播种策略可以扩展到为非稳态流场提供高效算法。</p>\n<p>During the composition of this survey we identified an interesting trend. As the dimensionality of the integral object increases the volume of research decreases, this is evident from Table 1. We believe that this is due to the added complexity of creating higher dimensional geometric objects and ensuring that they maintain an accurate representation of the underlying vector field. We have already stated the advantages that surfaces and volumes present over line primitives, but these advantages are countered by the difficulty of creating a suitable mesh for a surface or volume. Stream surfaces are a very useful tool for flow visualization; however, research and their implementation in industrial applications is limited. While several algorithms exist for stream surface construction, their complexity is often a barrier for a developer. We believe better construction methods that are both efficient and simple are possible. The extension to unsteady flow fields is also an attractive prospect with relatively few papers explicitly showing a time-dependent implementation using surfaces. We also note that there are very few strategies that focus on automatic placement of these structures in the flow field. We expect this to be a very active area of research in the coming years.</p>\n<p>在调查过程中，我们发现了一个有趣的趋势。随着积分对象维度的增加，研究量也随之减少，这一点从表 1 中可以明显看出。我们认为这是由于创建更高维的几何对象并确保其保持对底层矢量场的准确表示所增加的复杂性。我们已经阐述了曲面和体相对于线基元的优势，但这些优势也被为曲面或体创建合适网格的困难所抵消。流体曲面是一种非常有用的流动可视化工具，但在工业应用中的研究和实现却非常有限。虽然有多种流表面构造算法，但其复杂性往往成为开发人员的障碍。我们相信有可能找到更好的既高效又简单的构建方法。扩展到非稳态流场也是一个很有吸引力的前景，相对较少的论文明确展示了使用曲面的随时间变化的实现。我们还注意到，很少有策略专注于在流场中自动放置这些结构。我们预计这将是未来几年非常活跃的研究领域。</p>\n<p>Many of the techniques here are used in commercial applications. The array of tools is too vast for all of them to be combined into a single package and so the most appropriate subset must be chosen. This will be more successful if the application designer works closely with a CFD engineer who has expert knowledge of the simulations they will be creating and the phenomena they wish to investigate.</p>\n<p>这里的许多技术都用于商业应用。由于工具种类繁多，不可能将所有工具都集成到一个软件包中，因此必须选择最合适的子集。如果应用设计者与 CFD 工程师紧密合作，将会取得更大的成功，因为 CFD 工程师对他们将创建的模拟和他们希望研究的现象具有专业知识。</p>\n<p>Some of the key areas we identified needing additional work are: • Higher dimensional (both spatial and temporal) data domain seeding strategies.</p>\n<p>• Uncertainty visualization tools for geometric techniques.</p>\n<p>• Comparative visualization tools for geometric techniques.</p>\n<p>• Improved surface and volume construction methods.</p>\n<p>• Surfaces for visualizing unsteady flow fields.</p>\n<p>• Automatic seeding for surfaces and volumes.</p>\n<p>• Interactive, real-time visualization of unsteady flow fields.</p>\n<p>Specialized vector field compression techniques must be used to reduce the bottleneck of loading new time-steps into the GPU.</p>\n<p>• GPU-based methods on unstructured grids.</p>\n<p>我们认为需要开展更多工作的一些关键领域包括</p>\n<p>高维（空间和时间）数据域播种策略。</p>\n<p>几何技术的不确定性可视化工具。</p>\n<p>几何技术的比较可视化工具。</p>\n<p>改进的曲面和体积构建方法。</p>\n<p>用于非稳定流场可视化的曲面。</p>\n<p>曲面和体的自动播种。</p>\n<p>非稳态流场的交互式实时可视化。必须使用专门的矢量场压缩技术来减少将新的时间步加载到 GPU 的瓶颈。</p>\n<p>基于 GPU 的非结构网格方法。</p>\n<p>A large amount of success has been gained for 2D vector fields and more recent techniques are offering a less significant improvement over current methods. Three-dimensional vector fields have also attained a high level of progress. However, due to the added challenges, there is still room for significant improvement in many areas. Similarly, many problems remain unsolved when visualizing unsteady flow and the barriers are constantly pushed as simulations are increasing the size of their output and ever more efficient methods are required to address this expansion.</p>\n<p>二维矢量场已经取得了很大的成功，最新的技术比现有的方法有了较小的改进。三维矢量场也取得了很大进展。然而，由于面临更多的挑战，许多领域仍有很大的改进空间。同样，在非稳态流动可视化方面，许多问题仍未得到解决，而且随着模拟输出规模的不断扩大，需要更有效的方法来解决这一问题，因此障碍也在不断增加。</p>\n",
            "tags": [
                "Hyperstreamline"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/07/11/basic-theory/A-Topologically-Informed-Hyperstreamline/",
            "url": "https://sakurame.eu.org/2023/07/11/basic-theory/A-Topologically-Informed-Hyperstreamline/",
            "title": "A_Topologically-Informed_Hyperstreamline",
            "date_published": "2023-07-11T14:17:55.000Z",
            "content_html": "<h1 id=\"a-topologically-informed-hyperstreamline-seeding-method-for-alignment-tensor-fields\"><a class=\"anchor\" href=\"#a-topologically-informed-hyperstreamline-seeding-method-for-alignment-tensor-fields\">#</a> A Topologically-Informed Hyperstreamline Seeding Method for Alignment Tensor Fields</h1>\n<p>对准张量场的拓扑信息超流线播种方法</p>\n<p>Abstract</p>\n<p>A topologically-informed hyperstreamline seeding method is presented for visualization of alignment tensor fields. The method is inspired by and applied to visualization of nematic liquid crystal (LC) orientation dynamics simulations. The method distributes hyperstreamlines along domain boundaries and edges of a nearest-neighbor graph whose vertices are degenerate regions of the alignment tensor field, which correspond to orientational defects in a nematic LC domain.This is accomplished without iteration while conforming to a user-specified spacing between hyperstreamlines and avoids possible failure modes associated with hyperstreamline integration in the vicinity of degeneracies in alignment (orientational defects). It is shown that the presented seeding method enables automated hyperstreamline-based visualization of a broad range of alignment tensor fields which enhances the ability of researchers to interpret these fields and provides an alternative to using glyph-based techniques.</p>\n<p>摘要提出了一种基于拓扑学的超流线播种方法，用于排列张量场的可视化。该方法受向列型液晶（LC）取向动力学模拟的启发并应用于可视化。该方法沿域边界和最近邻图的边缘分布超流线，其顶点是排列张量场的退化区域，对应于向列型液晶域中的取向缺陷。这无需迭代，同时符合用户指定的超流线间距，避免了与排列退化（取向缺陷）附近的超流线整合有关的可能失败模式。研究表明，所提出的播种方法能够实现基于超流线的广泛排列张量场的自动可视化，这增强了研究人员解释这些场的能力，并为使用基于字形的技术提供了一个替代方案。</p>\n<p>Index Terms—</p>\n<p>Scientific visualization, tensor visualization, hyperstreamlines, nematic liquid crystals</p>\n<p>索引词 - 科学可视化，张量可视化，超流线，向列型液晶</p>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> INTRODUCTION</h2>\n<p>SIMULATION-BASED research of liquid crystalline (LC) phases has played a key role both in the contribution to our fundamental understanding of these phases and to engineering of LC devices.</p>\n<p>LC phases, or mesophases, behave like disordered liquids at high temperatures, but upon cooling, transition to a lower symmetry liquid-like phase which possesses some degree of phase order. The most simple of the LC phases is the nematic phase, which possesses some degree of orientational order at the molecular scale. This orientational order is theoretically characterized using a second-order symmetric traceless tensor Q, the alignment tensor [1]. Applications of nematic LCs are pervasive in our daily lives ranging from LC-based displays (LCDs) to biological systems [2].</p>\n<p>基于模拟的液态结晶（LC）相的研究在促进我们对这些相的基本理解和 LC 设备的工程方面都发挥了关键作用。液晶相或中间相，在高温下表现得像无序的液体，但在冷却后，过渡到低对称性的类似液体的相，拥有某种程度的相序。最简单的 LC 相是向列相，它在分子尺度上拥有某种程度的定向秩序。这种定向秩序在理论上是用二阶对称无踪张量 Q，即排列张量来表征的 [1]。在我们的日常生活中，从基于 LC 的显示器（LCD）到生物系统，向列式 LC 的应用无处不在 [2]。</p>\n<p>Resolution of the nanoscale structure and dynamics of nematic domains is challenging for experimental analysis, and thus simulation-based approaches are frequently employed both in fundamental and applied science. The theoretical bases of these simulations have progressed from simple, but visually intuitive, vector fieldbased approximations of LC orientational order to more descriptive alignment tensor theories [1], [3]. Alignment tensor theory is more descriptive in that it captures degeneracies in alignment (orientational defects) and phase transition. One of the persistent challenges resulting from using alignment tensor theory is that resulting three-dimensional transient simulation data have proven difficult to interpret.</p>\n<p>解决纳米级结构和动态的向列域对实验分析来说是一个挑战，因此在基础科学和应用科学中经常采用基于模拟的方法。这些模拟的理论基础已经从简单但直观的基于矢量场的 LC 定向顺序近似发展到更具描述性的排列张量理论 [1], [3]。对齐张量理论的描述性更强，因为它能捕捉到对齐（方向性缺陷）和相变中的退化现象。使用排列张量理论带来的一个持续的挑战是，由此产生的三维瞬态模拟数据被证明难以解释。</p>\n<p>Approaches to visualization of nematic alignment tensor fields have, until recently, resorted to simplifications such as extracting the major eigenvector of the tensor and visualizing it as a vector</p>\n<p>field [4], [5], [6]. Vector field visualization methods, especially streamline methods, are well-studied in the literature, and several methods for creating high quality streamline placements for two-dimensional data have been proposed [7], [8], [9], [10], [11], [12], [13]. These include an image-guided algorithm using lowpass filtering [7], an approach based on separation distances [8], a method that uses templates for different types of critical points [9], a farthest point seeding strategy [10], similarity-guided streamline placement [11], and topology-aware streamline placement [13]. A thorough review of these streamline seeding strategies can be found in [14]. However, while vector field approximations of alignment tensor fields enable visualization using standard streamline approaches, there are two significant drawbacks. First, degeneracies in alignment that are frequently present in alignment tensor fields result in singularities in vector fields. Second, much information is lost through the vector field approximation including the degree (or magnitude) of alignment and the presence of multiple alignment axes (biaxiality).</p>\n<p>直到最近，对向列张量场进行可视化的方法都是采用简化的方法，如提取张量的主要特征向量并将其可视化为一个向量场 [4], [5], [6]。矢量场可视化方法，特别是流线方法，在文献中得到了很好的研究，并且已经提出了几种为二维数据创建高质量流线放置的方法 [7], [8], [9], [10], [11], [12], [13]。** 其中包括使用低通滤波的图像引导算法 [7]、基于分离距离的方法 [8]、使用不同类型临界点模板的方法 [9]、最远点播种策略 [10]、相似性引导的流线放置 [11]、以及拓扑感知的流线放置 [13]。对这些流线播种策略的全面回顾可以在 [14] 中找到。** 然而，虽然对齐张量场的矢量场近似能够使用标准流线方法进行可视化，但有两个明显的缺点。首先，排列张量场中经常出现的排列退化现象导致了矢量场的奇异性。其次，通过矢量场的近似，许多信息被丢失，包括排列的程度（或幅度）和多个排列轴的存在（双轴性）。</p>\n<p>As a result, recent advances have been made using tensor glyph methods [15] (Fig. 1), particularly the work by JankunKelly and Mehta [16], [17] which improves upon standard tensor glyph visualization by applying superellipsoids rather than using conventional glyph shapes. More recently, Callan-Jones et al employed streamsurfaces [18] and streamtubes [19] to nematic domains that include topological defects in orientation [20] (Fig. 1), or disclinations, using Westin metrics to characterize the alignment tensor field. This method relies on iterative culling of computed streamlines in order to refine the visualization. An adaptive streamtube seeding algorithm incorporating tensor dissimilarity measures also exists [21]. Asymmetric tensor field visualization has also been studied [22], [23], although as the alignment tensor is symmetric, these methods cannot be directly adapted.</p>\n<p>因此，最近使用张量字形方法 [15]（图 1）取得了进展，特别是 JankunKelly 和 Mehta [16], [17] 的工作，通过应用超椭圆体而不是使用传统字形形状，改进了标准张量字形的可视化。最近，Callan-Jones 等人将流面 [18] 和流管 [19] 应用于包括方向 [20] 的拓扑缺陷 [图 1] 的线状体，或披露，使用 Westin 度量来描述排列张量场的特征。这种方法依赖于对计算的流线进行迭代剔除，以完善可视化。还存在一种包含张量异同度量的自适应流管播种算法 [21]。非对称张量场的可视化也被研究过 [22], [23], 尽管由于对齐张量是对称的，这些方法不能直接适应。</p>\n<p>Hyperstreamline visualization of tensor fields [24] (Fig. 2) is an alternative approach to glyph-based techniques. Analogous to streamline visualization of vector fields, hyperstreamlines are enhanced such that, in addition to direction, they have volume.This enables simultaneous visualization of all eigenvalues and eigenvectors of an alignment tensor field. They are constructed by first computing a streamline using the major eigenvector field,</p>\n<p>张量场的超流线可视化 [24]（图 2）是基于字形的技术的一种替代方法。类似于矢量场的流线可视化，超流线被加强了，除了方向，它们还有体积。这使得对齐张量场的所有特征值和特征向量都能同时可视化。它们是通过首先使用主要的特征向量场来计算流线而构建的、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mo lspace=\"0em\" rspace=\"0em\">&lt;</mo><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">!</mo></mfrac><mo>−</mo><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>g</mi><mtext>￼</mtext><mn>0</mn><mo>−</mo><mo>−</mo><mo>&gt;</mo><mo>&lt;</mo><mo stretchy=\"false\">!</mo><mo>−</mo><mo>−</mo><mi>s</mi><mi>w</mi><mi>i</mi><mi>g</mi><mtext>￼</mtext><mn>1</mn><mo>−</mo><mo>−</mo><mo>&gt;</mo><mo>=</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac = n(r)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.9021em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2161em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">!</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">&lt;</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">￼0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">￼1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> is the position of the streamline, s is the arc length along the streamline, and n is the major eigenvector of the alignment tensor field. Using this streamline as a template, a hyperstreamline is then formed by rendering an elliptic cylinder such that the major/ minor axis is aligned with the secondary/tertiary eigenvector field (of the alignment tensor). The lengths of the major/minor elliptic axes are specified by the magnitude of the secondary/tertiary eigenvalue, as shown in Fig. 2. Thus, in contrast to streamlines, hyperstreamlines incorporate all information quantified by the alignment tensor in a higher-dimensional form than that of tensor glyphs.</p>\n<p>其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 是流线的位置，s 是沿流线的弧长，n 是对齐张量场的主要特征矢量。以该流线为模板，通过渲染一个椭圆体形成超流线，使其主 / 次轴与（对齐张量的）二级 / 三级特征向量场对齐。主 / 次椭圆轴的长度由二级 / 三级特征值的大小来指定，如图 2 所示。因此，与流线相比，超流线以比张量字形更高的维度形式纳入了由排列张量量化的所有信息。</p>\n<p>As with streamline visualizations [9], one of the major challenges of employing hyperstreamlines is that existing seeding methods are either (i) simplistic (uniform spatial distributions) which result in difficult to interpret visualizations [25] or (ii) are complex iterative algorithms which are impractical for large threedimensional transient datasets. Additionally, alignment tensor fields frequently include degeneracies in their major eigenvector fields such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> in eqn. (1) is not well-defined. In this context, the objectives of this work are to develop a hyperstreamline seeding method such that:</p>\n<p>与流线可视化 [9] 一样，采用超流线的主要挑战之一是，现有的播种方法要么是 (i) 简单化 (均匀的空间分布)，导致难以解释的可视化 [25]，要么是 (ii) 复杂的迭代算法，对于大型三维瞬态数据集不实用。此外，对齐张量场经常包括其主要特征向量场的退化，如公式（1）中的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span> 不是很明确。在这种情况下，这项工作的目标是开发一种超流线播种方法，从而：</p>\n<p><img data-src=\"https://ptpimg.me/b8788f.jpg\" alt=\"\" /></p>\n<p>Fig. 1. Two types of orientational defects commonly observed in nematic liquid crystals visualized with rectangular glyphs and hyperstreamlines: (a) a + orientational defect and (b) a - orientational defect</p>\n<p>图 1. 在向列型液晶中通常观察到的两种类型的定向缺陷，用矩形字形和超流线表示：（a）a + 定向缺陷和（b）a - 定向缺陷</p>\n<ol>\n<li>\n<p>generation of seed points results in approximately welldistributed hyperstreamline visualizations.</p>\n</li>\n<li>\n<p>generated seed points avoid computation of hyperstreamlines which intersect areas of degenerate alignment.</p>\n</li>\n<li>\n<p>iteration is not required so that the method is feasible for use in the visualization of large three-dimensional transient datasets.</p>\n</li>\n<li>\n<p>a priori knowledge of the alignment tensor field, specifically the type of orientational degeneracies that are present, is not required.</p>\n</li>\n</ol>\n<p>1）种子点的生成导致了近似良好分布的超流线可视化。</p>\n<p>2）生成的种子点避免了计算与退化排列区域相交的超流线。</p>\n<p>3）不需要迭代，因此该方法在大型三维瞬态数据集的可视化中是可行的。</p>\n<p>4）不需要对齐张量场的先验知识，特别是不需要存在方向性退行的类型。</p>\n<p>Methods do exist to identify and avoid tensor degeneracies [25], but they are computationally complex and preclude the use of functionality in existing visualization libraries, specifically the Visualization Toolkit (VTK) [26]. Recent work has shown that utilization of the orientational topology of alignment tensor fields could result in significant gains [9], [27], [28].</p>\n<p>确实存在识别和避免张量退化的方法 [25]，但这些方法在计算上很复杂，而且不能使用现有可视化库的功能，特别是可视化工具包（VTK）[26]。最近的工作表明，利用对齐张量场的方向性拓扑结构可以带来显著的收益 [9], [27], [28]。</p>\n<p>In this work, a seeding method is presented for the visualization of alignment tensor fields using hyperstreamlines in a way that incorporates topological information. Degeneracies in alignment and orientational defects are used to form a spatial graph with edges determined from nearest-neighbor triangulation. The vertices and edges are then used as a template for seeding in a way that, without resorting to iteration or pruning, both approximates an optimal distribution of hyperstreamlines throughout the domain and avoids hyperstreamline computation in the vicinity of defects. The method is evaluated using a representative set of twodimensional alignment tensor fields resulting from continuum simulations of nematic LC orientation dynamics.</p>\n<p>在这项工作中，提出了一种播种方法，以纳入拓扑信息的方式，使用超流线对排列张量场进行可视化。对齐和方向性缺陷中的退行性被用来形成一个空间图，其边缘由最近的邻接三角法确定。然后，顶点和边被用作播种的模板，在不诉诸迭代或修剪的情况下，既接近整个领域的超流线的最佳分布，又避免了缺陷附近的超流线计算。该方法是用一组有代表性的二维对准张量场进行评估的，这些张量场是由连续模拟的非线性 LC 取向动力学产生的。</p>\n<p>The paper is organized as follows: the alignment tensor and simulation method are described in Section 2, the topologicallyinformed seeding method is presented in Section 3, results of applying the method to various two-dimensional alignment tensor fields are presented and discussed in Section 4, and conclusions are made in Section 5.</p>\n<p>本文的组织结构如下：第 2 节描述了排列张量和模拟方法，第 3 节介绍了拓扑信息播种方法，第 4 节介绍并讨论了将该方法应用于各种二维排列张量场的结果，第 5 节是结论。</p>\n<h2 id=\"background\"><a class=\"anchor\" href=\"#background\">#</a> BACKGROUND</h2>\n<h3 id=\"the-alignment-tensor\"><a class=\"anchor\" href=\"#the-alignment-tensor\">#</a> The Alignment Tensor</h3>\n<p>对齐张量</p>\n<p>The alignment tensor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is a real second-order symmetrictraceless tensor and thus has distinct eigenvectors and real eigenvalues. A symmetric tensor can be decomposed using its eigenvectors <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>l</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n,m,l)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">)</span></span></span></span> and eigenvalues <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>λ</mi><mi>n</mi></msub><mo separator=\"true\">,</mo><msub><mi>λ</mi><mi>m</mi></msub><mo separator=\"true\">,</mo><msub><mi>λ</mi><mi>l</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({\\lambda _n},{\\lambda _m},{\\lambda _l})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> using Dyadic/Gibbs tensor notation [29]:</p>\n<p>对齐张量 Q 是一个真实的二阶对称无痕张量，因此具有明显的特征向量和真实的特征值。对称张量可以用其特征向量<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>l</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n,m,l)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">)</span></span></span></span> 和特征值<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>λ</mi><mi>n</mi></msub><mo separator=\"true\">,</mo><msub><mi>λ</mi><mi>m</mi></msub><mo separator=\"true\">,</mo><msub><mi>λ</mi><mi>l</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">({\\lambda _n},{\\lambda _m},{\\lambda _l})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 进行分解，使用 Dyadic/Gibbs 张量符号 [29]：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>λ</mi><mi>n</mi></msub><mi>n</mi><mi>n</mi><mo>+</mo><msub><mi>λ</mi><mi>m</mi></msub><mi>m</mi><mi>m</mi><mo>+</mo><msub><mi>λ</mi><mi>l</mi></msub><mi>l</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">Q = {\\lambda _n}nn + {\\lambda _m}mm + {\\lambda _l}ll\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">nn</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">mm</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span></span></span></span></span></p>\n<p>As in [18] we introduce the modified alignment tensor D with nonnegative eigenvalues to simplify implementation of the method,</p>\n<p>如同在 [18] 中，我们引入了具有非负特征值的修正对齐张量 D，以简化方法的实施、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>D</mi><mo>=</mo><mi>Q</mi><mo>+</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>δ</mi></mrow><annotation encoding=\"application/x-tex\">D = Q + {1 \\over 3}\\delta\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span></span></span></span></span></p>\n<p><img data-src=\"https://ptpimg.me/14s43b.jpg\" alt=\"\" /></p>\n<p>where $\\lambda _n^\\prime  \\ge \\lambda _m^\\prime  \\ge \\lambda _l^\\prime $are the eigenvalues of D, the eigenvectors of D remain the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> and $\\delta $ is the identity tensor.</p>\n<p>其中 $\\lambda _n^\\prime  \\ge \\lambda _m^\\prime  \\ge \\lambda _l^\\prime $ 是 D 的特征值，D 的特征向量与 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> 保持一致，$\\delta $ 是身份张量。</p>\n<p>A useful decomposition of the modified alignment tensor D uses Westin metrics [30]: the isotropy measure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{c_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>, the linear anisotropy measure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub></mrow><annotation encoding=\"application/x-tex\">{c_l}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>, and the planar anisotropy measure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">{c_p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span>,</p>\n<p>修改后的排列张量 D 的一个有用的分解使用了 Westin 度量 [30]：各向同性度量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{c_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> ，线性各向异性度量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub></mrow><annotation encoding=\"application/x-tex\">{c_l}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> ，以及平面各向异性度量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">{c_p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>c</mi><mi>s</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>l</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>p</mi></msub><mo>∈</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>s</mi></msub><mo>+</mo><msub><mi>c</mi><mi>l</mi></msub><mo>+</mo><msub><mi>c</mi><mi>p</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_s},{c_l},{c_p} \\in [0,1],{c_s} + {c_l} + {c_p} = 1\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8252em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></p>\n<p>The alignment tensor characterizes three general types of alignment:</p>\n<p>对齐张量表征了三种一般的对齐类型：</p>\n<ol>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>s</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_s} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> —isotropy or no preferred alignment.</p>\n</li>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_l} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> —uniaxial alignment along n.</p>\n</li>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_p} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7692em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> —biaxial alignment along n and m.</p>\n</li>\n</ol>\n<p>1)<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>s</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_s} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> - 各向同性或无首选排列。</p>\n<p>2)<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_l} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> - 沿 n 的单轴排列。</p>\n<p>3)<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_p} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7692em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> - 沿 n 和 m 的双轴排列。</p>\n<p>The relationship between the eigenvalues of D and Westin metrics are [18]:</p>\n<p>D 的特征值和 Westin 度量之间的关系是 [18]：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub><mo>=</mo><msubsup><mi>λ</mi><mi>n</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>−</mo><msubsup><mi>λ</mi><mi>m</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>p</mi></msub><mo>=</mo><mn>2</mn><mo stretchy=\"false\">(</mo><msubsup><mi>λ</mi><mi>m</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>−</mo><msubsup><mi>λ</mi><mi>l</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>s</mi></msub><mo>=</mo><mn>3</mn><msubsup><mi>λ</mi><mi>l</mi><mo mathvariant=\"normal\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">{c_l} = \\lambda _n^\\prime  - \\lambda _m^\\prime ,{c_p} = 2(\\lambda _m^\\prime  - \\lambda _l^\\prime ),{c_s} = 3\\lambda _l^\\prime\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0489em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.088em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0519em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0519em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0489em;vertical-align:-0.247em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord mathnormal\">λ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>Fig. 3 shows schematic examples of the three types of alignment corresponding to different Westin metrics values.</p>\n<p>图 3 显示了对应于不同 Westin 度量值的三种排列方式的示意性例子。</p>\n<h3 id=\"nematic-orientation-dynamics\"><a class=\"anchor\" href=\"#nematic-orientation-dynamics\">#</a> Nematic Orientation Dynamics</h3>\n<p>向列相取向动力学</p>\n<p>Alignment tensor fields analyzed in this work are generated through simulations of nematic orientation dynamics in the absence of flow. Nematic dynamics equations are described in detail in [2], and are summarized here. A gradient flow model is used to simulate dynamics of the alignment tensor [31], [32],</p>\n<p>本文分析的取向张量场是在无流动的情况下通过模拟向列相取向动力学而产生的。向列相动力学方程在 [2] 中有详细的描述，并在此进行了总结。梯度流模型用于模拟排列张量 [31]、[32]、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">∂</mi><mi>Q</mi></mrow><mrow><mi mathvariant=\"normal\">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mo>−</mo><mi mathvariant=\"normal\">Γ</mi><mo>:</mo><mfrac><mrow><mi mathvariant=\"normal\">∂</mi><mi>F</mi></mrow><mrow><mi mathvariant=\"normal\">∂</mi><mi>Q</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">{ { \\partial Q } \\over { \\partial t } } = - \\Gamma :{ { \\partial F } \\over { \\partial Q } }\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">Q</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.2519em;vertical-align:-0.8804em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\">Q</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></span></p>\n<p>where F is the total free energy of the domain and the kinetic coefficient $\\Gamma $ is defined to preserve the symmetry and traceless properties of the alignment tensor. As previously mentioned, Dyadic/ Gibbs tensor notation [29] is used where  represents the dot product, : represents the double-dot product, etc.</p>\n<p>其中 F 是区域的总自由能，定义了动力学系数 $\\Gamma $ 以保持排列张量的对称性和无迹性质。如前所述，使用并元 / 吉布斯张量表示法 [29]，其中表示点积，：表示双点积等。</p>\n<p>The free energy density of the nematic domain used is given by the Landau-de Gennes model [3], [33],</p>\n<p>所用的线状域的自由能密度是由 Landau-de Gennes 模型 [3], [33] 给出、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>f</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>a</mi><mo stretchy=\"false\">(</mo><mi>Q</mi><mo>:</mo><mi>Q</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>b</mi><mo stretchy=\"false\">(</mo><mi>Q</mi><mo>⋅</mo><mi>Q</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>Q</mi><mo>+</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mi>c</mi><mrow><mo stretchy=\"false\">(</mo><mi>Q</mi><mo>:</mo><mi>Q</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mi>L</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∇</mi><mi>Q</mi><mi><mi mathvariant=\"normal\">⋮</mi><mpadded height=\"0em\" voffset=\"0em\"><mspace mathbackground=\"black\" width=\"0em\" height=\"1.5em\"></mspace></mpadded></mi><mi mathvariant=\"normal\">∇</mi><mi>Q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = {1 \\over 2}a(Q:Q) - {1 \\over 3}b(Q \\cdot Q):Q + {1 \\over 4}c{(Q:Q)^2} + {1 \\over 2}{L_1}(\\nabla Q \\vdots \\nabla Q)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">3</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">4</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord mathnormal\">c</span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.186em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">∇</span><span class=\"mord mathnormal\">Q</span><span class=\"mord\"><span class=\"mord\">⋮</span><span class=\"mord rule\" style=\"border-right-width:0em;border-top-width:1.5em;bottom:0em;\"></span></span><span class=\"mord\">∇</span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>where material constants a/b/c characterize the stability of the aligned LC (nematic) phase and  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{L_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> characterizes the energetic cost of spatial variations in orientation. Integration of the free energy density over the domain volume (V ) results in the total free energy F,</p>\n<p>其中材料常数 a/b/c 表征排列的 LC（向列）相的稳定性，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">{L_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 表征取向的空间变化的能量成本。对领域体积（V）上的自由能密度进行整合，得出总自由能 F、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo>=</mo><munder><mo largeop=\"false\">∫</mo><mi>V</mi></munder><mi>f</mi><mi>d</mi><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">F = {\\smallint _V}fdV\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8555em;vertical-align:-1.0499em;\"></span><span class=\"mord\"><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8056em;\"><span style=\"top:-2.0501em;margin-left:-0.1945em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span></span></span><span style=\"top:-3.0006em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;\">∫</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0499em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">fd</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span></span></p>\n<p><img data-src=\"https://ptpimg.me/5zc31b.jpg\" alt=\"\" /></p>\n<p>Fig. 3. Tensor ellipsoid representations of the modified alignment tensor D for differing Westin metrics values corresponding to: (a) no alignment (isotropy, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>S</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_S} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ), (b) uniaxial alignment ( <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_l} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ), and (c) biaxial alignment ( <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_p} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7692em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ).</p>\n<p>图 3. 在不同的 Westin 度量值下，修改后的对齐张量 D 的张量椭圆体表示，对应于： (a) 无对齐（各向同性，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>S</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_S} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ），(b) 单轴对齐（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>l</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_l} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6331em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ），(c) 双轴对齐（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_p} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7692em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ）。</p>\n<h2 id=\"methods\"><a class=\"anchor\" href=\"#methods\">#</a> METHODS</h2>\n<p>方法</p>\n<p>The presented method is described for two-dimensional alignment tensor fields. The method is composed of three steps:</p>\n<ol>\n<li>\n<p>Identification of a topological template for the field from the domain boundary and orientational defects (if present).</p>\n</li>\n<li>\n<p>Computation of an approximation of the optimal distribution of seed points guided by the topological template.</p>\n</li>\n<li>\n<p>Computation of hyperstreamlines at every seed point using the topological template while avoiding regions with orientational defects.</p>\n</li>\n</ol>\n<p>所提出的方法是针对二维对齐张量场的描述。该方法由三个步骤组成：</p>\n<p>1）从域边界和方向性缺陷（如果存在的话）中识别出场的拓扑模板。</p>\n<p>2）在拓扑模板的指导下，计算种子点的最佳分布的近似值。</p>\n<p>3）利用拓扑模板计算每个种子点的超流线，同时避开有方向性缺陷的区域。</p>\n<p>The method requires only one parameter from the user, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>, the desired spacing between hyperstreamlines in the final visualization. For alignment tensor fields corresponding to nematic LC domains, there also exists a physical length scale over which the alignment tensor can vary, ${ l_n } = \\sqrt { { { { L_1 } } \\over a } } $ [3], which is used as a basis for choosing ls in the present work.</p>\n<p>该方法只需要用户提供一个参数，即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>，即最终可视化中超流线之间的理想间距。对于对应于非线性 LC 域的排列张量场，也存在一个排列张量可以变化的物理长度尺度，${l_n} = \\sqrt { { { { L_1 } } \\over a } } $ [3]，它被用作本工作中选择 ls 的基础。</p>\n<h3 id=\"identification-of-a-topological-template\"><a class=\"anchor\" href=\"#identification-of-a-topological-template\">#</a> Identification of a Topological Template</h3>\n<p>确定一个拓扑模板</p>\n<p>The alignment tensor field is first analyzed for the presence of degeneracies (orientational defects) in alignment (Fig. 1) through identifying regions with biaxial alignment ( <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_p} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7692em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ). From this analysis, a set of points in space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is generated which provides topological information for the field</p>\n<p>对齐张量场首先通过识别具有双轴对齐的区域（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>p</mi></msub><mo>≈</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">{c_p} \\approx 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7692em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ）来分析对齐中是否存在退化（方向性缺陷）（图 1）。从这个分析中，产生了一组空间 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 的点，为场提供了拓扑学信息</p>\n<p>Once <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> is determined, an undirected graph $\\varsigma $ is formed whose vertices are composed of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> and whose edges relate each point to its nearest neighbor in space (via Delaunay triangulation). The resulting graph is referred to as the topological template. Using this template, curves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> (where i is used arbitrarily to index each curve) are defined from a combination of the line segments/ graph edges connecting nearest-neighbor defects and circles enclosing each defect/vertex. In the case of well-aligned domains the set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> could be empty. Thus the orientational topology of the domain is completely described by the alignment at the domain boundary, which is used to define the curves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>一旦确定了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>，就会形成一个无向图 $\\varsigma $，其顶点由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 组成，其边缘将每个点与空间中最近的邻居联系起来（通过德劳内三角法）。得到的图被称为拓扑模板。使用这个模板，曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>（其中 i 被任意用来索引每条曲线）是由连接最近邻缺陷的线段 / 图边和包围每个缺陷 / 顶点的圆圈组合而成的。在排列整齐的域的情况下，集合 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> 可能是空的。因此，域的方向性拓扑结构完全由域边界的排列来描述，它被用来定义曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 。</p>\n<h3 id=\"seed-distribution\"><a class=\"anchor\" href=\"#seed-distribution\">#</a> Seed Distribution</h3>\n<p>种子分配</p>\n<p>Approximating an optimal distribution of seed points along the curves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> resulting from the topological template requires comparing the unit tangent vector to the curve, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>, to the local alignment, represented by the major eigenvector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> of the alignment tensor field (along the curve). For example, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> is always parallel to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> then the curve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{r_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> lies along a hyperstreamline and only a single seed point is needed anywhere within the curve, regardless of the desired spacing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> (Fig. 4a). The other extreme is if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> is always orthogonal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>, which would require <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant=\"normal\">/</mi><msub><mi>l</mi><mi>s</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = {S_i}/{l_s} + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> seed points equally distributed along the curve, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{S_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is the arc length of the curve (Fig. 4b).</p>\n<p>沿着拓扑模板产生的曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 的种子点的最佳分布需要比较曲线的单位切线矢量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 和局部排列，由排列张量场的主要特征矢量 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 代表（沿着曲线）。例如，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 总是平行于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> ，那么曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{r_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 位于超流线上，在曲线的任何地方只需要一个种子点，而不需要考虑期望的间距 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>（图 4a）。另一个极端是，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">t(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 总是与 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 正交，则需要一个 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant=\"normal\">/</mi><msub><mi>l</mi><mi>s</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = {S_i}/{l_s} + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 的种子点沿曲线平均分布，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{S_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 是弧长曲线的弧长（图 4b）。</p>\n<p>In the presented method, for every curve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> in the topological template a weighting function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\omega _i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> is defined,</p>\n<p>在所提出的方法中，对于拓扑模板中的每条曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 都定义了一个加权函数 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\omega _i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi mathvariant=\"normal\">∣</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">{\\omega _i}(s) = 1 - |t(s) \\cdot n(s)|\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span></span></span></span></span></p>\n<p>By integrating this weighting function along the curve, a renormalized arc length $S_i^\\prime $ of the curve can be found,</p>\n<p>通过沿曲线积分这个加权函数，可以找到曲线的重归一化弧长 $S_i^\\prime $</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><msub><mi>S</mi><mi>i</mi></msub></msubsup><mrow><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mi>d</mi><mi>s</mi></mrow></mrow><annotation encoding=\"application/x-tex\">S_i^\\prime  = \\int_0^ { { S_i } } { {\\omega _i} (s)ds }\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0489em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.5032em;vertical-align:-0.9119em;\"></span><span class=\"mop\"><span class=\"mop op-symbol large-op\" style=\"margin-right:0.44445em;position:relative;top:-0.0011em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5912em;\"><span style=\"top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.8129em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.0576em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9119em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span></span></span></span></span></span></p>\n<p>The number of seed points to be distributed along the curve is then given by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mi mathvariant=\"normal\">/</mi><msub><mi>l</mi><mi>s</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = S_i^\\prime /{l_s} + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0106em;vertical-align:-0.2587em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4413em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2587em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>. Finally, these $\\alpha $ seed points are distributed at specific points <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>→</mo><mi>α</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{S_{i,j = 1 \\to \\alpha }}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">→</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> along the arc length of the curve governed by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> constraints of the form,</p>\n<p>然后，沿曲线分布的种子点的数量由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mi mathvariant=\"normal\">/</mi><msub><mi>l</mi><mi>s</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = S_i^\\prime /{l_s} + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0106em;vertical-align:-0.2587em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4413em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2587em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 给出。最后，这些 $\\alpha $ 曲线的弧长分布在特定的点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>→</mo><mi>α</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{S_{i,j = 1 \\to \\alpha }}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span><span class=\"mrel mtight\">→</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span></span> 上，由 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> 形式的约束所支配、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub><mo>=</mo><msubsup><mo>∫</mo><msub><mi>S</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><msub><mi>S</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></msubsup><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">{l_s} = \\int_{ {S_{i,j} } }^{ {S_{i,j + 1} } } { {\\omega _i} } (s)ds\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.7005em;vertical-align:-1.1093em;\"></span><span class=\"mop\"><span class=\"mop op-symbol large-op\" style=\"margin-right:0.44445em;position:relative;top:-0.0011em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5912em;\"><span style=\"top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.0576em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2819em;\"><span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.8129em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.0576em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2819em;\"><span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1093em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span></span></span></span></span></p>\n<p>This procedure is repeated for all curves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>  in the topological template which results in sets of seed points <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{P_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>. Note that the unit tangent for each curve must first be computed as a function of arc length,</p>\n<p>对拓扑模板中的所有曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 重复这一程序，从而得到种子点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">{P_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的集合。请注意，每条曲线的单位切线必须首先作为弧长的函数来计算、</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>t</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mrow><mo fence=\"true\">∥</mo><mfrac><mrow><mi>d</mi><mi>r</mi></mrow><mrow><mi>d</mi><mi>s</mi></mrow></mfrac><mo fence=\"true\">∥</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mfrac><mrow><mi>d</mi><mi>r</mi></mrow><mrow><mi>d</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">t(s) = {\\left\\| { { {dr} \\over {ds} } } \\right\\|^{ - 1} } { {dr} \\over {ds}} \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.604em;vertical-align:-0.95em;\"></span><span class=\"mord\"><span class=\"minner\"><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.45em;\"><span class=\"pstrut\" style=\"height:4.4em;\"></span><span style=\"width:0.556em;height:2.400em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.556em' height='2.400em' viewBox='0 0 556 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z\nM367 15 v585 v1200 v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v1200 v585 h43z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span><span class=\"mclose\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.45em;\"><span class=\"pstrut\" style=\"height:4.4em;\"></span><span style=\"width:0.556em;height:2.400em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.556em' height='2.400em' viewBox='0 0 556 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z\nM367 15 v585 v1200 v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v1200 v585 h43z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.654em;\"><span style=\"top:-3.9029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></span></p>\n<p>which is accomplished by using spatial interpolation of the curve using cubic splines [34].</p>\n<p>这是通过使用立方样条曲线的空间插值来完成的 [34]。</p>\n<p><img data-src=\"https://ptpimg.me/0u0h62.jpg\" alt=\"\" /></p>\n<p>Fig. 4. Schematic showing two extreme distributions of seed points (in green) on a curve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> (in red) of arc length <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mn>3</mn><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">S = 3{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> superimposed on the major eigenvector field nðsÞ (in black), in which: (a) the tangent to the curve and the major eigenvector are parallel, in which case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">S_i^\\prime  = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0106em;vertical-align:-0.2587em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4413em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2587em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and thus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, and (b) the tangent to the curve and the major eigenvector are orthogonal, in which case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>=</mo><mn>3</mn><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i^\\prime  = 3{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0106em;vertical-align:-0.2587em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4413em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2587em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>4</mn><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 4{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">4</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>图 4. 示意图显示了弧长为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mn>3</mn><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">S = 3{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>（红色）上的种子点（绿色）与主要特征向量场 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>（黑色）的两种极端分布，其中： (a) 曲线的切线和主要特征向量是平行的，在这种情况下 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">S_i^\\prime  = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0106em;vertical-align:-0.2587em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4413em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2587em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> ，因此 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> ；(b) 曲线的切线和主要特征向量是正交的，在这种情况下 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>S</mi><mi>i</mi><mo mathvariant=\"normal\">′</mo></msubsup><mo>=</mo><mn>3</mn><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i^\\prime  = 3{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0106em;vertical-align:-0.2587em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4413em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">′</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2587em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">3</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> ，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi><mo>=</mo><mn>4</mn><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\alpha  = 4{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">4</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 。</p>\n<p><img data-src=\"https://ptpimg.me/y11135.jpg\" alt=\"\" /></p>\n<p>Fig. 5. Visualizations of a uniform defect-free alignment tensor field within a two-dimensional circular domain using: (a) rectangular tensor glyphs, (b) hyperstreamlines seeded uniformly in the field, (c) hyperstreamlines seeded along the boundary using the seed distribution method from Section 3.2. The value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is 0:02 in all cases and the domain diameter is 1.</p>\n<p>图 5. 在一个二维圆形域内，使用以下方法对统一的无缺陷排列张量场进行可视化：(a) 矩形张量字形，(b) 在场内统一播种的超流线，(c) 使用 3.2 节的种子分布方法沿边界播种的超流线。在所有情况下，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的值为 0:02，域的直径为 1。</p>\n<h3 id=\"hyperstreamline-computation\"><a class=\"anchor\" href=\"#hyperstreamline-computation\">#</a> Hyperstreamline Computation</h3>\n<p>超流线计算</p>\n<p>Once the set of seed points <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mo>∪</mo><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P =  \\cup {P_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\">∪</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is determined, hyperstreamlines are computed and rendered at every seed point. Directionality of the hyperstreamline computation is constrained when seed points lie on curves that enclose degeneracies/defects (identified from the topological template). For these seed points hyperstreamlines are computed only in the direction pointing away from the vertex/degeneracy. This approach avoids computation of hyperstreamlines in the vicinity of regions in the alignment tensor field where the major eigenvector becomes degenerate.</p>\n<p>一旦种子点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>=</mo><mo>∪</mo><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">P =  \\cup {P_i}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\">∪</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的集合被确定，超流线就会在每个种子点被计算和渲染。当种子点位于包含退化 / 缺陷（从拓扑模板中识别）的曲线上时，超流线计算的方向性受到限制。对于这些种子点，超流线只在指向远离顶点 / 退化的方向上计算。这种方法避免了在对齐张量场中主要特征向量变得退化的区域附近计算超流线。</p>\n<p>Hyperstreamline computation and rendering was performed using the Visualization Toolkit [26] (version 5.10.1). The algorithm which this library implements is as follows:</p>\n<p>超流线的计算和渲染是使用 Visualization Toolkit [26]（5.10.1 版）进行的。该库实现的算法如下：</p>\n<ol>\n<li>\n<p>Given an alignment tensor field in the form of an unstructured grid, the Jacobi eigendecomposition algorithm is used to solve for the eigenvectors and eigenvalues at every grid-point.</p>\n</li>\n<li>\n<p>Integration of eqn. (1) at every seed point is then performed using a second-order Runge-Kutta method and spatial interpolation between grid-points.</p>\n</li>\n<li>\n<p>The size of the cross-section and its orientation along each hyperstreamline is scaled appropriately with respect to the size of the domain in order to improve visibility. Additional scalar field data, such as biaxiality or major eigenvalues, can be represented through coloring of the hyperstreamline surface.</p>\n</li>\n</ol>\n<p>1) 给定非结构化网格形式的对齐张量场，使用 Jacobi 特征分解算法来求解每个网格点处的特征向量和特征值。</p>\n<p>2) 方程的积分然后使用二阶 Runge-Kutta 方法和网格点之间的空间插值来执行在每个种子点处的①等式</p>\n<p>3) 横截面的大小及其沿着每个超流线的方向相对于域的大小适当地缩放，以便提高可见性。额外的标量场数据，如双轴性或主要特征值，可以通过超流线表面的着色来表示。</p>\n<p>In this work, the major eigenvalue field was used for hyperstreamline coloring.</p>\n<p>在这项工作中，主要特征值场被用于超流线着色。</p>\n<h2 id=\"results-and-discussion\"><a class=\"anchor\" href=\"#results-and-discussion\">#</a> RESULTS AND DISCUSSION</h2>\n<p>结果和讨论</p>\n<p>The presented algorithm was applied to seeding three general types of two-dimensional alignment tensor fields observed in orientation dynamics of nematic LCs: uniformly aligned defect-free domains, well-aligned domains with minimal defects present, and complex domains with many defects present. These three cases represent the breadth of scenarios that might be encountered by a researcher. In each case, domains are visualized using tensor glyphs and two different types of hyperstreamline seeding methods, in addition to the presented method. The two alternative hyperstreamline seeding methods used for comparison are uniform and boundary seeding. In Sections 4.1 to 4.2, circular twodimensional alignment tensor fields are used and in Section 4.3, a square domain is used.</p>\n<p>所提出的算法被应用于在向列式液晶显示器的取向动力学中观察到的三种一般类型的二维排列张量场的播种：均匀排列的无缺陷域、存在最小缺陷的良好排列域和存在许多缺陷的复杂域。这三种情况代表了研究人员可能会遇到的各种情况的广度。在每个案例中，除了所提出的方法外，还使用张量字形和两种不同类型的超流线播种方法对域进行可视化。用于比较的两种替代性超流线播种方法是均匀播种和边界播种。在第 4.1 至 4.2 节中，使用了圆形的二维对齐张量场，在第 4.3 节中，使用了方形域。</p>\n<p>In all three visualizations, the same value of the hyperstreamline spacing parameter is used <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub><mo>=</mo><mn>2</mn><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s} = 2{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is a characteristic length scale of the tensor field which is governed by the physics of the problem (see Section 3). Additionally, two optional parameters were included which were found to be useful for creating uncluttered hyperstreamline visualizations: the vertex seed radius and the vertex/edge seed ratio. The vertex seed radius is the radius of the circle used as the curve <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> around an orientational defect (vertex in the undirected graph) and was chosen to be 2:5<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> in the following visualizations. The vertex/edge seed ratio specifies the relationship between the hyperstreamline spacing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> along boundaries/graph vertices versus along curves encompassing defects.The value of this parameter used was 2, which corresponds to the hyperstreamline spacing along edges (between defects) being twice that of the spacing around defects. These two additional parameters are not data-specific, and thus the only input required from the user is the specification of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>在所有三个可视化中，使用相同的超流线间距参数值 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub><mo>=</mo><mn>2</mn><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s} = 2{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">2</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> ，其中 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 是张量场的特征长度尺度，由问题的物理学决定（见第 3 节）。此外，还包括两个可选参数，发现它们对于创建整洁的超流线可视化非常有用：顶点种子半径和顶点 / 边种子比率。顶点种子半径是用作围绕取向缺陷（无向图中的顶点）的曲线 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 的圆的半径，并且在以下可视化中被选择为 2.5 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 。顶点 / 边缘种子比率指定了沿着边界 / 图形顶点的超流线间距 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 与沿着包含缺陷的曲线的超流线间距 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 之间的关系。这两个附加参数不是特定于数据的，因此用户所需的唯一输入是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_s}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的规范。</p>\n<h3 id=\"uniform-alignment\"><a class=\"anchor\" href=\"#uniform-alignment\">#</a> Uniform Alignment</h3>\n<p>均匀对齐</p>\n<p>Figs. 5a, 5b, and 5c show visualizations of an alignment tensor field within a circular domain using both rectangular tensor glyphs, uniform hyperstreamline seeding in the domain, and boundary hyperstreamline seeding using the seed distribution method described in Section 3.2. In this case, the alignment tensor field contains no orientational defects and thus the presented method forms the topological template using the physical boundary (Fig. 5c).</p>\n<p>图 5a、5b 和 5c 显示了使用矩形张量字形、域内均匀超流线播种和使用第 3.2 节中描述的种子分布方法的边界超流线播种两种方法在圆形域内对准张量场的可视化。在这种情况下，对齐张量场不包含方向性缺陷，因此，所提出的方法利用物理边界形成拓扑模板（图 5c）。</p>\n<p>The tensor glyph visualization shown in Fig. 5a uses a random distribution of points within the domain so that the scale of the glyph is large enough to be distinguishable. In this simple case, using tensor glyphs results in a visualization that is indicative of the alignment tensor field configuration.</p>\n<p>图 5a 所示的张量字形可视化使用了域内的随机分布的点，因此字形的比例大到可以分辨出来。在这种简单的情况下，使用张量字形的结果是一种可视化，表明了对齐张量场的配置。</p>\n<p>Using uniform hyperstreamline seeding, as shown in Fig. 5b, results in a significant amount of hyperstreamline overlap in that multiple seed points are placed along lines of constant alignment.</p>\n<p>Fig. 4a illustrates this scenario which results in a visualization that is severely cluttered. Alternatively, the use of topology of the domain through seeding on its boundary (in the absence of defects) in combination with the presented seeding distribution method results in a hyperstreamline visualization (Fig. 5c) that is approximately optimal, given the user-specified hyperstreamling spacing criteria.</p>\n<p>使用均匀的超流线播种，如图 5b 所示，会导致大量的超流线重叠，因为多个种子点是沿着恒定排列的线放置的。图 4a 说明了这种情况，其结果是视觉上的严重杂乱。另外，通过在域的边界播种（在没有缺陷的情况下）使用域的拓扑结构，结合所提出的播种分布方法，在用户指定的超流线间距标准下，产生了一个近似最佳的超流线可视化（图 5c）。</p>\n<h3 id=\"minimal-defects-in-alignment\"><a class=\"anchor\" href=\"#minimal-defects-in-alignment\">#</a> Minimal Defects in Alignment</h3>\n<p>对齐中的最小缺陷</p>\n<p>Figs. 6a, 6b, 6c, and 6d show visualizations of an alignment tensor field, now with two defects present, within a circular domain using both rectangular tensor glyphs and hyperstreamlines. In this case, the presented method uses the undirected graph formed from the defects, shown in Fig. 7, as opposed to the boundary.</p>\n<p>图 6a、6b、6c 和 6d 显示了一个对齐张量场的可视化，现在有两个缺陷存在，在一个圆形域内使用矩形张量字形和超流线。在这种情况下，所提出的方法使用由缺陷形成的无定向图，如图 7 所示，而不是边界。</p>\n<p><img data-src=\"https://ptpimg.me/12g1b3.jpg\" alt=\"\" /></p>\n<p>Fig. 6. Visualizations of an alignment tensor field within a two-dimensional circular domain with minimal defects (shown in red) using: (a) rectangular tensor glyphs, (b) hyperstreamlines seeded uniformly in the field, (c) hyperstreamlines seeded along the boundary, (d) hyperstreamlines seeded along the topological template (shown in Fig. 7). The value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is 0:02 in all cases and the domain diameter is 1.</p>\n<p>图 6. 使用：（a）矩形张量字形，（b）在场内均匀播种的超流线，（c）沿边界播种的超流线，（d）沿拓扑模板播种的超流线（如图 7 所示），在一个具有最小缺陷的二维圆形域内对准张量场进行可视化。在所有情况下，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的值为 0:02，域直径为 1。</p>\n<p>Compared to the tensor glyph visualization (Fig. 6a), which again uses a random distribution of points within the domain, all three of the hyperstreamline visualizations provide a more understandable representation of the alignment tensor field. In this case, the tensor field has significant gradients in alignment which are poorly represented in the glyph case. This could be addressed by increasing the density of tensor glyphs proportional to the local spatial gradient in alignment, but this would result in an overlapping of glyphs and/or rescaling to the point that the glyphs are not distinguishable. The advantage of using higher-dimensional hyperstreamline visualization is clear in comparing Fig. 6a with Figs. 6b, 6c and 6d. The continuous variation in orientation that the hyperstreamline represents is not accessible with tensor glyphs.</p>\n<p>与张量字形可视化（图 6a）相比，同样使用域内点的随机分布，所有三个超流线可视化提供了一个更容易理解的对齐张量场的表示。在这种情况下，张量场在排列上有明显的梯度，这在字形情况下表现得很差。这可以通过增加张量字形的密度与对齐的局部空间梯度成正比来解决，但这将导致字形的重叠和 / 或重新缩放，以至于字形无法辨认。将图 6a 与图 6b、6c 和 6d 相比较，使用高维超流线可视化的优势很明显。超流线所代表的方向的连续变化是张量字形所不能达到的。</p>\n<p>Comparing Figs. 6b, 6c, and 6d using uniform seeding, boundary seeding with the presented seed distribution method, and the presented topological template/seed distribution method (Fig. 7) demonstrates two significant disadvantages of both the uniform and boundary seeding methods. First, both the uniform and boundary seeding methods admit the possibility of hyperstreamlines entering defect regions where degeneracies in alignment result in instabilities in the numerical method used to solve eqn. (1). An example of this is shown in the left-center region of Fig. 6c where a hyperstreamline abruptly ends in the vicinity of a defect. The hyperstreamline integration (Section 3.3) failed in this region due to two eigenvalues having equivalent magnitudes. The topologically-informed template results in seeding that avoids this failure-mode, as shown in Fig. 6d, in that computation of hyperstreamlines within the degeneracy seed radius is explicitly avoided.</p>\n<p>比较图 6b、6c 和 6d，使用均匀播种、用所提出的种子分布方法进行边界播种以及所提出的拓扑模板 / 种子分布方法（图 7），显示出均匀播种和边界播种方法的两个显著缺点。首先，均匀播种法和边界播种法都承认超流线有可能进入缺陷区，而缺陷区的排列退化导致用于解决公式（1）的数值方法的不稳定。这方面的一个例子显示在图 6c 的左侧中心区域，其中一条超流线在缺陷附近突然结束。由于两个特征值的大小相等，超流线积分（第 3.3 节）在该区域失败。如图 6d 所示，拓扑信息模板的播种结果避免了这种失败模式，因为在退化种子半径内的超流线的计算被明确地避免了。</p>\n<p>The second disadvantage of using both the uniform and boundary seeding methods is that the spacing of hyperstreamlines is poorly constrained within the bulk of the domain. In Fig. 6b, the same type of cluttering is observed as described in the previous case. In Fig. 6c, the imposed spacing on the boundary is constrained well, but this results in cluttering of hyperstreamlines in the bulk of the domain. The use of the topological template/ seed distribution, shown in Fig. 6d, results in an approximately optimal hyperstreamline distribution such that the spacing is wellconstrained in the bulk of the domain, while relaxing this spacing at the boundaries. This hyperstreamline distribution is clearly preferred in that it results in an uncluttered visualization throughout the domain.</p>\n<p>同时使用均匀播种和边界播种方法的第二个缺点是，超流线的间距在域的大体上受到的约束很差。在图 6b 中，观察到与前一个案例中描述的相同类型的杂波。在图 6c 中，边界上的强加间距受到了很好的约束，但这导致了域内大部分超流线的杂乱。使用图 6d 所示的拓扑模板 / 种子分布，可以得到一个近似最佳的超流线分布，这样，在域的大部分地区，间距受到了很好的约束，而在边界处则放宽了这个间距。这种超流线分布显然是最好的，因为它能使整个领域的视觉效果不受干扰。</p>\n<p><img data-src=\"https://ptpimg.me/0pu671.jpg\" alt=\"\" /></p>\n<p>Fig. 7. Visualization of the undirected graph representing the topological template (Section 3.1) and seed points of the tensor field used in Section 4.2. Seed points are shown in yellow and green, defects in red, and the curves comprising the template <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> are represented by dotted lines.</p>\n<p>图 7. 代表拓扑模板（第 3.1 节）和第 4.2 节使用的张量场的种子点的无定向图的可视化。种子点用黄色和绿色表示，缺陷用红色表示，构成模板 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{r_i}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> 的曲线用虚线表示。</p>\n<h3 id=\"many-defects-in-alignment\"><a class=\"anchor\" href=\"#many-defects-in-alignment\">#</a> Many Defects in Alignment</h3>\n<p>对位中的多缺陷</p>\n<p>Figs. 8a, 8b, 8c, and 8d show visualizations of a complex alignment tensor field with many defects. This alignment tensor field would require analysis at multiple scales, including the largest scale (the whole domain) as is shown. The significant disadvantage of tensor glyphs is apparent in comparing Fig. 8a to Figs. 8b, 8c, and 8d; in order for the glyphs to be distinguishable, their scale must be large with respect to the characteristic length of variation in alignment.Thus many important features of the alignment tensor field are not represented due to the coarseness of the visualization. Once again, the higher-dimensional character of hyperstreamlines provides a more useful visualization in all cases.</p>\n<p>图 8a、8b、8c 和 8d 显示了一个具有许多缺陷的复杂排列张量场的可视化情况。这种排列张量场需要在多个尺度上进行分析，包括如图所示的最大尺度（整个域）。将图 8a 与图 8b、8c 和 8d 相比较，张量字形的显著缺点是显而易见的；为了使字形能够被分辨出来，它们的尺度相对于排列变化的特征长度必须很大。因此，由于可视化的粗糙性，排列张量场的许多重要特征没有得到体现。再一次，超流线的高维特征在所有情况下都提供了一个更有用的可视化。</p>\n<p><img data-src=\"https://ptpimg.me/rmg6lc.jpg\" alt=\"\" /></p>\n<p>Fig. 8. Visualizations of a complex alignment tensor field within a two-dimensional square domain with many defects demonstrating: (a) rectangular tensor glyphs, (b) hyperstreamlines seeded uniformly in the field, (c) hyperstreamlines seeded along the boundary, (d) hyperstreamlines seeded along the topological template, and (e) the topological template corresponding to (d) with a semi-transparent overlay of the generated hyperstreamlines. The value of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> is 0:008 in all cases where the domain scale is 1.</p>\n<p>图 8. 在一个有许多缺陷的二维正方形领域内的复杂排列张量场的可视化演示：(a) 矩形张量字形，(b) 在领域内均匀播种的超流线，(c) 沿边界播种的超流线，(d) 沿拓扑模板播种的超流线，以及 (e) 对应于 (d) 的拓扑模板与生成的超流线的半透明覆盖物。在领域比例为 1 的所有情况下，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>l</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">{l_n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span> 的值为 0:008。</p>\n<p>Focusing on uniform hyperstreamline seeding, Fig. 8b, the degree of hyperstreamline overlap is severe. While visualization of the largest scale of the alignment tensor field is distinguishable, analysis at smaller scales is infeasible due to overlap. Comparing boundary and topological template seeding, Figs. 8c and 8d, it is observed that both disadvantages described in the previous section are magnified for boundary seeding in this larger and more complex alignment tensor field. Through the use of the topological template, shown in Fig. 8e, these features are accounted for and the resulting visualization is meaningful on multiple scales, ranging from the whole field to sub-regions.</p>\n<p>关注均匀的超流线播种，图 8b，超流线的重叠程度很严重。虽然最大尺度的对准张量场的可视化是可分辨的，但由于重叠，较小尺度的分析是不可行的。比较边界和拓扑模板播种，图 8c 和 8d，可以看出，在这个更大更复杂的排列张量场中，上一节描述的两个缺点都被边界播种放大了。通过使用拓扑模板，如图 8e 所示，这些特征被考虑在内，由此产生的可视化在多个尺度上是有意义的，从整个领域到子区域。</p>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> CONCLUSION</h2>\n<p>结论</p>\n<p>A topologically-informed method is presented for seeding of hyperstreamlines for visualization of alignment tensor fields. The method is shown to approximate an optimal distribution of hyperstreamlines for a breadth of two-dimensional alignment tensor fields ranging from those without defects to those with complex topology. The method requires only a single parameter from the user, avoids possible failure modes in hyperstreamline computation, and requires no iteration to yield satisfactory hyperstreamline spacing. The results of applying the presented seeding method show that it enables automated efficient hyperstreamline-based visualization of alignment tensor fields and thus enhances the ability of researchers to interpret this type of data. While the description of the method and results were limited to two-dimensional tensor fields, the presented work provides a basis for extension of the seeding method to three-dimensional alignment tensor fields</p>\n<p>提出了一种基于拓扑学的超流线播种方法，用于排列张量场的可视化。该方法被证明是对二维对齐张量场的最佳分布的近似方法，范围从没有缺陷的张量场到具有复杂拓扑结构的张量场。该方法只需要用户提供一个参数，避免了超流线计算中可能出现的故障模式，并且不需要迭代就可以得到满意的超流线间距。应用所提出的播种方法的结果表明，它能使基于超流线的对齐张量场自动有效地可视化，从而提高了研究人员解释这类数据的能力。虽然该方法的描述和结果仅限于二维张量场，但所提出的工作为将播种方法扩展到三维排列张量场提供了基础。</p>\n",
            "tags": [
                "Hyperstreamline"
            ]
        }
    ]
}