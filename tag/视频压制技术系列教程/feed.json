{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sakura • All posts by \"视频压制技术系列教程\" tag",
    "description": "一个专注于技术和思考分享的博客",
    "home_page_url": "https://sakurame.eu.org",
    "items": [
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A08-bit%E4%BD%8E%E7%A0%81%E7%8E%87%E5%8E%8B%E5%88%B6/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A08-bit%E4%BD%8E%E7%A0%81%E7%8E%87%E5%8E%8B%E5%88%B6/",
            "title": "第十二章8-bit低码率压制",
            "date_published": "2024-03-16T15:20:02.000Z",
            "content_html": "<h1 id=\"第十二章-8-bit低码率压制\"><a class=\"anchor\" href=\"#第十二章-8-bit低码率压制\">#</a> 第十二章 8-bit 低码率压制</h1>\n<h2 id=\"1-8-bit下的抗色带处理\"><a class=\"anchor\" href=\"#1-8-bit下的抗色带处理\">#</a> 1. 8-bit 下的抗色带处理</h2>\n<p>8-bit 低码率通常用于字幕组内嵌成品的压制，其受众往往对画质要求不高，因此压制重点放在尽可能缩小体积的前提下保留画质。</p>\n<p>既然都低码率了，自然码率要花在刀刃上。暗场平面的色带是最容易出现，也最容易被观察到的瑕疵，而 8-bit 下由于精度问题，几乎一定会出现色带，因此抗色带处理是 8-bit  低码率压制中的关键。当然，低码率下纹理和线条也会被涂抹地比较厉害，但一般观众也不容易看出，可以忽略。</p>\n<p>之前的章节提过，抗色带的基本手段就是加噪，一个自然的想法是借助 dither 的力量。dither 的算法多种多样，预览效果不错，但编码器往往不吃这套。就算加了高质量 dither，也会被编码器抹掉，还会留下丑陋的噪点尸体。</p>\n<p>所以这种情况下，我们只有一种选择， <code>ordered dither</code> 。ordered dither 虽然丑陋，但是占体积小，并且难以被编码器抹平。如果我们需要把一个 16bit 视频降到 8bit 输出给编码器，可以这样写：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> dither<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ampo<span class=\"token operator\">=</span><span class=\"token number\">1.5</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>mvf 默认用的是 fmtc，可以查看文档。 <code>dither=0</code> ，就是 ordered dither。 <code>ampo</code>  指定 ordered dither 的静态噪点强度。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTEyL2ltYWdlMDE=\">https://guides.vcb-s.com/media/basic-guide-12/image01</span> dither.png)</p>\n<p>如果你觉得噪点比较难看，也可以选择加点动噪：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> dither<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ampo<span class=\"token operator\">=</span><span class=\"token number\">1.5</span><span class=\"token punctuation\">,</span> ampn<span class=\"token operator\">=</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里  <code>ampn</code>  为随机的动态噪点强度。</p>\n<p>到了这一步，我们已经解决了大部分问题，但是注意到，这样全图的 ordered dither 并不是我们想要的。因为人眼只能注意到暗场的色带，亮场就不需要加上 ordered dither，这样可以省去一部分码率。</p>\n<p>VS 中提供了一个内置滤镜来根据亮度划分区域， <code>std.Binarize</code> 。</p>\n<p>我们可以使用以下代码来做一个最简单的亮度 mask，将亮度 96 以上的区域置为最大值，而以下的区域置为最小值：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Binarize<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> <span class=\"token number\">96</span><span class=\"token punctuation\">,</span> planes<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>于是我们就可以用这样的方法，对亮场做 rounding，对暗场做 ordered dithering。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>bright <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> dither<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>dark <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> dither<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> ampo<span class=\"token operator\">=</span><span class=\"token number\">1.5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>luma_mask <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Binarize<span class=\"token punctuation\">(</span>bright<span class=\"token punctuation\">,</span> <span class=\"token number\">96</span><span class=\"token punctuation\">,</span> planes<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MaskedMerge<span class=\"token punctuation\">(</span>dark<span class=\"token punctuation\">,</span> bright<span class=\"token punctuation\">,</span> luma_mask<span class=\"token punctuation\">,</span> first_plane<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里我们小小的引入一点后续章节才会讲到的 mask 内容。我们知道  <code>std.Merge(clipa, clipb, weight)</code>  可以根据 weight 融合两个 clip。而如果 weight 不是固定的，而是每个位置的像素都有一个独立的 weight，那么这些所有  weight 也构成一个 clip，这个 clip 就是一个 mask。这样通过一个 mask 来进行 clip 的融合，就是  <code>std.MaskedMerge(clipa, clipb, mask)</code>  的功能。</p>\n<p>这里使用的 std.Binarize 生成的是最简单的二值化 mask，今后我们还会遇到更复杂的，甚至是连续的 mask，当然这里二值化的 mask 也够用了。</p>\n<p>以上就是 8-bit 的抗色带处理，总结来说：</p>\n<ol>\n<li>加噪可以一定程度上干扰肉眼辨识色带。</li>\n<li>而在码率预算捉襟见肘的情况下，我们为了防止色带出现，会采用 ordered dither 的方法，通过调整 ampo, ampn 来调整 dither 噪点强度，同时辅以 mask 来处理。</li>\n</ol>\n<h2 id=\"2-720p的制作\"><a class=\"anchor\" href=\"#2-720p的制作\">#</a> 2. 720p 的制作</h2>\n<p>如果成品是 1080p，那么做完上面的抗色带操作，就可以送入编码器压制了。但有时字幕组也会需要压制 720p 的版本，这时就需要在 VS 中进行 downscale 处理。</p>\n<p>在缩小时，为了避免亮度损失问题，需要使用  <code>gamma-aware downscale</code> ，将 Y 平面转到线性光下缩小。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gray <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> colorfamily<span class=\"token operator\">=</span>vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>gray <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>transfer<span class=\"token punctuation\">(</span>gray<span class=\"token punctuation\">,</span> transs<span class=\"token operator\">=</span><span class=\"token string\">'709'</span><span class=\"token punctuation\">,</span> transd<span class=\"token operator\">=</span><span class=\"token string\">'linear'</span><span class=\"token punctuation\">,</span> fulls<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> fulld<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>gray <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>gray<span class=\"token punctuation\">,</span> <span class=\"token number\">1280</span><span class=\"token punctuation\">,</span> <span class=\"token number\">720</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>gray <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>transfer<span class=\"token punctuation\">(</span>gray<span class=\"token punctuation\">,</span> transs<span class=\"token operator\">=</span><span class=\"token string\">'linear'</span><span class=\"token punctuation\">,</span> transd<span class=\"token operator\">=</span><span class=\"token string\">'709'</span><span class=\"token punctuation\">,</span> fulls<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> fulld<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>UV <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">1280</span><span class=\"token punctuation\">,</span> <span class=\"token number\">720</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>down <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>gray<span class=\"token punctuation\">,</span>UV<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里首先分离出 Y 平面 gray，然后转到线性光，进行缩小。这里缩小使用 fmtc.resample 的默认算法 spline36，非常适合图像缩小。</p>\n<p>UV 平面则是将源整体缩小，避免分平面时的 chroma placement 处理。最后合并 Y 和 UV，得到最终缩小后的结果。</p>\n<h2 id=\"3-添加字幕\"><a class=\"anchor\" href=\"#3-添加字幕\">#</a> 3. 添加字幕</h2>\n<p>通常 8-bit 低码率都是字幕组内嵌版本，需要加上字幕。不管先前做过哪些处理，字幕一定要在整个流程的最后加入。字幕滤镜前面章节已经介绍过，这里不再赘述，只提几个实际制作中的要点。</p>\n<p>首先是字幕文件名的问题，如果只是压制单集，手动指定不会有太大问题，但如果一季度批量压制，每次改就显得非常繁琐。</p>\n<p>一般来说我们利用 OKE 的改名机制，将字幕改为与输入视频同名，只有后缀不同，然后通过以下方式自动替换：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#OKE:INPUTFILE</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">R'00000.mkv'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>replace<span class=\"token punctuation\">(</span><span class=\"token string\">'.mkv'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'.chs.ass'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>xyvsf<span class=\"token punctuation\">.</span>TextSub<span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>另一个麻烦的问题是字体，在压制前必须保证已经安装所有需要的字体，否则无法正确渲染。通常会使用两个小工具：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMuYWNncmlwLmNvbS90aHJlYWQtMzg0OC0xLTEuaHRtbA==\">FontLoaderSub</span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMuYWNncmlwLmNvbS90aHJlYWQtMTg5NC0xLTEuaHRtbA==\">ListAssFonts</span>。</p>\n<p>FontLoaderSub 可以分析字幕使用的字体，并临时挂载，避免在系统中安装过多的字体。需要将 FontLoaderSub 放到字体包目录下，第一次运行建立字体数据库，之后拖入字幕即可临时挂载字体。</p>\n<p>如下图，[ok] 是加载成功的字体，显示路径说明是临时加载的。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTEyL2ltYWdlMDI=\">https://guides.vcb-s.com/media/basic-guide-12/image02</span> FontLoaderSub.png)</p>\n<p>点击  <code>菜单</code>  按钮，可以选择  <code>导出字体</code> ，导出所有临时加载的字体到指定目录。注意不能导出系统已经安装的字体。</p>\n<p>ListAssFonts 也可以分析字幕使用的字体，但是分析更加精准。FontLoaderSub 会报出定义了样式但实际不使用的字体，而 ListAssFonts  只会给出实际使用的字体。另外，ListAssFonts  还会对字幕格式做一些检查，比如样式的语法、字体是否缺字等。但是注意，ListAssFonts 不能检测出 FontLoaderSub  临时挂载的字体，会认为它们缺失。</p>\n<p>如下图，黑色是系统已有的字体，红色是缺少的字体。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTEyL2ltYWdlMDM=\">https://guides.vcb-s.com/media/basic-guide-12/image03</span> ListAssFonts.png)</p>\n<p>勾选  <code>Save Fonts</code> ，并选择  <code>Select ASS/SSA Folder</code>  中指定目录，可以导出系统已经安装的字体。</p>\n<p>通过这俩配合，就能导出所有安装和未安装的字体，这在没有字体包时候会非常有用。</p>\n<p>当然，和字幕组合作时，对方都会给出字体包，可以用 FontLoaderSub 临时挂载，或者直接安装，但无论使用哪种都需要验证压制之前已经安装 / 挂载好所有需要的字体。</p>\n<h2 id=\"4-压制参数\"><a class=\"anchor\" href=\"#4-压制参数\">#</a> 4. 压制参数</h2>\n<p>8-bit 低码率通常定位都是兼容移动端的，因此使用 x264 来编码。另一方面，x265-8bit 表现实在太差，没有使用价值，都用 hevc 了，还是 10-bit 吧。</p>\n<p>8-bit 低码率需要注意这样几个参数：</p>\n<p><code>--fgo 1或者2</code> <br />\n 当然，这里的 fgo 不是你想的那个 fgo，它其实是 film grain optimization，可以把码率暴力分配给噪点。<br />\n <code>--psy-trellis 0.2~0.3</code> <br />\n 就是 --psy-rd 的第二个参数，效果与 fgo 类似。</p>\n<p><code>--psy-rd 0</code> <br />\n 这时候别用 psy-rd 了，这东西是会 “保留复杂度” 而不是 “保留噪点”，它会把噪点搅拌压碎，很难看。<br />\n <code>--qcomp 0.7</code> <br />\n 这个不给高的话，动态和一些静止场面会比较难看，也可以关闭 mbtree 来代替。</p>\n<p>给一个参考编码参数：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>--preset veryslow --crf 18 --threads 16 --deblock -1:-1 --keyint 600 --min-keyint 1 --bframes 8 --ref 4 --qcomp 0.6 --no-mbtree --rc-lookahead 70 --aq-strength 0.8 --me tesa --psy-rd 0:0 --chroma-qp-offset -1 --fgo 1 --no-fast-pskip --aq-mode 3 --colorprim bt709 --transfer bt709 --colormatrix bt709 --chromaloc 0 --range tv</pre></td></tr></table></figure><p>注意这里用了  <code>--fgo 1, --psy-rd 0:0, --no-mbtree</code> 。当然这里还有一些可以改进的地方，在低码率下，可以适当开启  <code>deblock</code> ，开到  <code>0:-1</code>  或者  <code>0:0</code>  都可以。 <code>--keyint 600</code>  其实稍微有点大，最大约为 25s 一个关键帧，对于静态镜头较多的番拖进度会比较困难，可以减少到 360 甚至 240 比较合适。 <code>--crf 18</code>  可以根据番剧实际情况，调整到 18~21 左右都行。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0OKEGui%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0OKEGui%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "第十一章OKEGui的使用",
            "date_published": "2024-03-16T15:15:44.000Z",
            "content_html": "<h1 id=\"第十一章-okegui的使用\"><a class=\"anchor\" href=\"#第十一章-okegui的使用\">#</a> 第十一章 OKEGui 的使用</h1>\n<p>本章介绍 VCB-Studio 的压制生产力工具 OKEGui。</p>\n<h2 id=\"1-vpy脚本与项目配置文件的编写\"><a class=\"anchor\" href=\"#1-vpy脚本与项目配置文件的编写\">#</a> 1. vpy 脚本与项目配置文件的编写</h2>\n<p>VCB-Studio 的生产力工具 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZjYi1zL09LRUd1aQ==\">OKEGui</span>，全名 One Key Encode Gui，用于全自动压片。你可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdG9vbHMvcmVsZWFzZXM=\">这里</span>下载到已经打包好的版本，解压即用。在 OKEGui\\examples 中提供了多个配置文件样例，可以作为参考。</p>\n<p>OKE 的功能比较复杂，因此本小节只讲基本用法，剩下的高级功能放到后续小节讲解。</p>\n<p>需要注意的是，OKE 的鲁棒性不是很好，只保证按规范进行操作的结果。</p>\n<p>每个 OKE 任务需要总监准备 2 个文件，一个 vpy 脚本文件和一个项目配置文件。<br />\n这 2 个文件需要放在同目录下，一般放在对应 BD 的根目录。</p>\n<h3 id=\"1-预处理脚本文件vpy\"><a class=\"anchor\" href=\"#1-预处理脚本文件vpy\">#</a> (1). 预处理脚本文件（vpy）</h3>\n<p>vpy 脚本文件和正常脚本一样，但是会有几个由 OKEGui 读取的固定 tag。</p>\n<h4 id=\"okeinputfile\"><a class=\"anchor\" href=\"#okeinputfile\">#</a>  <code>#OKE:INPUTFILE</code></h4>\n<p>这是唯一一个<strong>必选 tag</strong>，作用是指定输入文件。</p>\n<p>接下来一行必须是 “变量 = 文件名” 的格式，比如这样：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#OKE:INPUTFILE</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">\"00000.m2ts\"</span> <span class=\"token comment\"># will be replaced</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>src <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>OKE 在执行任务的时候，会把文件名自动替换为指定的输入文件。</p>\n<h4 id=\"okedebug\"><a class=\"anchor\" href=\"#okedebug\">#</a>  <code>#OKE:DEBUG</code></h4>\n<p>这是一个<strong>可选 tag</strong>，用于处理本组祖传的 debug 开关。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#OKE:DEBUG</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Debug <span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">if</span> Debug<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Preview<span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span> res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>写脚本的时候， <code>Debug=1</code> ，输出 RGB；压制的时候， <code>Debug=0</code> ，输出 YUV 10bit。</p>\n<p>OKE 读取这个 tag，压制的时候将其替换为  <code>None</code> ，保证压制时永远执行  <code>else</code>  分支。</p>\n<h4 id=\"okeprojectdir\"><a class=\"anchor\" href=\"#okeprojectdir\">#</a>  <code>#OKE:PROJECTDIR</code></h4>\n<p>用来获取 vpy 脚本文件所在的绝对路径。</p>\n<p>也是一个<strong>可选 tag</strong>，一般用于加载额外的脚本或滤镜。</p>\n<p>加载名为 <span class=\"exturl\" data-url=\"aHR0cDovL2N1c3RvbS5weQ==\">custom.py</span> 的脚本：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> sys</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> os</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#OKE:PROJECTDIR</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>projDir <span class=\"token operator\">=</span> <span class=\"token string\">'.'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>sys<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>insert<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> projDir<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">import</span> custom</pre></td></tr></table></figure><p>加载名为  <code>libcustom.dll</code>  的滤镜：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> sys</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> os</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#OKE:PROJECTDIR</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>projDir <span class=\"token operator\">=</span> <span class=\"token string\">'.'</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>sys<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>insert<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> projDir<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>LoadPlugin<span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>realpath<span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>projDir<span class=\"token punctuation\">,</span> <span class=\"token string\">'libcustom.dll'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>当然，需要确保额外加载的脚本和滤镜和 vpy 脚本同目录。</p>\n<p>这个功能用的时候很少。</p>\n<h4 id=\"okememory\"><a class=\"anchor\" href=\"#okememory\">#</a>  <code>#OKE:MEMORY</code></h4>\n<p>注意，这是一个<strong>已经弃用</strong>的<strong>可选 tag</strong>。</p>\n<p>在一些旧脚本中，会见到：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>num_threads <span class=\"token operator\">=</span> <span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#OKE:MEMORY</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>core<span class=\"token punctuation\">.</span>max_cache_size <span class=\"token operator\">=</span> <span class=\"token number\">8000</span></pre></td></tr></table></figure><p><code>num_threads</code>  指定运行时的线程。<br />\n <code>max_cache_size</code>  指定运行时的内存。</p>\n<p>前者现在不推荐指定，让 VS 自己管理线程池比较好一点。</p>\n<p>后者，在 VS API4 时代，已经不需要手动指定内存，都是让 VS 自动收敛。</p>\n<p>如果设置这个 tag，OKE 会根据主界面 “空闲内存数”，和现有的任务数，来设置  <code>max_cache_size</code> 。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-11/image01.png\" alt=\"img\" /></p>\n<p>当然，现在不用这个 tag 了，“空闲内存数” 直接填任意小于 2000 的数就行。<br />\n大于 2000 的话 OKE 会在启动任务的时候检查系统是否有那么多空闲内存，在压制中途加任务时会带来一些不必要的麻烦。</p>\n<h4 id=\"rp-checker\"><a class=\"anchor\" href=\"#rp-checker\">#</a> RP Checker</h4>\n<p>OKE 还提供 RPC（RP Checker） 功能。</p>\n<p>在压制完成后，用成品和源跑一个 PRC，判断是否花屏 。</p>\n<p>如果使用这个功能，需要在 vpy 脚本里输出作为 ref 的源视频：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res.set_output()</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>src8.set_output(1)</pre></td></tr></table></figure><p>一般用  <code>src8</code>  或者  <code>src16</code>  即可，<strong>源视频必须输出到 1 节点</strong>。</p>\n<p>另外还需要注意：</p>\n<ol>\n<li>必须有相同的帧率和帧数<br />\n如果成品做了 IVTC/deinterlace/trim/splice 之类的操作，则为 RPC 准备的 clip 也需要做</li>\n<li>必须有相同的画面内容<br />\n如果做了对画面改动较大的操作，例如 crop/textsub 等操作，则为 RPC 准备的 clip 也需要做</li>\n<li>分辨率和 bitdepth 不重要，因为 RPC 会自动转为与成品相同的规格</li>\n</ol>\n<h3 id=\"2-项目配置文件json-或-yaml\"><a class=\"anchor\" href=\"#2-项目配置文件json-或-yaml\">#</a> (2). 项目配置文件（json 或 yaml）</h3>\n<p>项目配置文件，支持 json 和 yaml，下面以 json 为例。</p>\n<p>大家可以参考  <code>OKEGui\\examples\\demo.json</code> ，本小节只讲基础的部分。</p>\n<p>需要注意，以下的 tag 名字是严格区分大小写的。另外  <code>bool</code>  类型的 tag 不能写  <code>1/0</code>  必须写  <code>true/false</code> 。</p>\n<ul>\n<li>\n<p><code>Version</code></p>\n<p><strong>必须设置为  <code>3</code> </strong>，此时会强制检查 VS 环境版本，即必须搭配我们的 portable 包使用。</p>\n</li>\n<li>\n<p><code>VSVersion</code></p>\n<p>指定 portable VS 包的版本。</p>\n</li>\n<li>\n<p><code>ProjectName</code></p>\n<p>项目名，可随意填写，用于在 OKE 里区分用的脚本。<br />\n一般写： <code>xx main</code> ， <code>xx op</code> ，  <code>xx pv</code>  之类的。</p>\n</li>\n<li>\n<p><code>EncoderType</code></p>\n<p>编码器类型，可以选  <code>x264</code> 、 <code>x265</code> 、 <code>svtav1</code> 。</p>\n</li>\n<li>\n<p><code>Encoder</code></p>\n<p>指定编码器路径，可以使用相对或绝对路径。<br />\n可以不指定，这时选用 OKE 自带的。<br />\n一般除非要测试新编码器，否则都用 OKE 自带的就行。</p>\n</li>\n<li>\n<p><code>EncoderParam</code></p>\n<p>编码器参数，不需要写  <code>--y4m</code>  和  <code>--output</code> 。</p>\n</li>\n<li>\n<p><code>ContainerFormat</code></p>\n<p>压制成品封装容器，可以选  <code>mp4</code>  或  <code>mkv</code> 。</p>\n</li>\n<li>\n<p><code>AudioTracks</code></p>\n<p>这是一个列表，其中每一项表述源文件的一个音轨，源文件包含几条音轨，这个列表就必须有几项。</p>\n<p>每项有这些功能：</p>\n<ul>\n<li>\n<p><code>OutputCodec</code></p>\n<p>输出格式，可选  <code>flac</code> 、 <code>aac</code> 、 <code>ac3</code>  或  <code>dts</code> 。<br />\n其中  <code>ac3</code>  和  <code>dts</code>  只能作为抽取原盘相同编码音轨使用，不支持重编码为这些格式。</p>\n</li>\n<li>\n<p><code>Bitrate</code></p>\n<p>编码 aac 的码率，前一项为  <code>aac</code>  时有效，可以指定码率，默认为  <code>192</code> 。</p>\n</li>\n<li>\n<p><code>MuxOption</code></p>\n<p>封装格式，可选  <code>Default</code> 、 <code>Mka</code> 、 <code>External</code> 、 <code>ExtractOnly</code>  或  <code>Skip</code> 。</p>\n<p>默认为  <code>Default</code> ，表示正常封装。<br />\n <code>Mka</code>  表示额外封装在 MKA 文件中。<br />\n <code>External</code>  表示外挂，会给文件名加上 CRC32，这个实际中已经不会使用。<br />\n <code>ExtractOnly</code>  只做抽取。<br />\n <code>Skip</code>  直接不抽取。</p>\n</li>\n<li>\n<p><code>Language</code></p>\n<p>轨道语言，默认为  <code>jpn</code> ，可选  <code>eng</code> 、 <code>chi</code>  等等。</p>\n</li>\n<li>\n<p><code>Name</code></p>\n<p>轨道名称，多音轨时可以设置。<br />\n例如  <code>Main</code> 、 <code>Commentary</code> 、 <code>2.0ch</code> 、 <code>5.1ch</code>  等等。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>SubtitleTracks</code></p>\n<p>字幕轨列表，其中每一项表述源文件的一个字幕，当源有 PGS 字幕时才会用。</p>\n<p>与音轨类似，有  <code>MuxOption</code> ， <code>Language</code> ， <code>Name</code>  子项。</p>\n</li>\n<li>\n<p><code>InputScript</code></p>\n<p>输入 vpy 脚本的文件名。<br />\n注意，脚本文件<strong>必须</strong>和 json 文件放在<strong>同一目录</strong>下。</p>\n</li>\n<li>\n<p><code>Fps</code></p>\n<p>脚本输出的帧率，可选  <code>1.0</code> 、 <code>23.976</code> 、 <code>24.000</code> 、 <code>25.000</code> 、 <code>29.970</code> 、 <code>50.000</code> 、 <code>59.940</code> 。</p>\n<p>当帧率不是上述七种之一时，使用  <code>FpsNum</code>  和  <code>FpsDen</code>  指定。</p>\n</li>\n<li>\n<p><code>Rpc</code></p>\n<p>表示是否在压制完成后执行 RPC，可选  <code>true</code>  或  <code>false</code> 。<br />\n启用 RPC 时 vpy 脚本需要输出 ref 视频。</p>\n</li>\n</ul>\n<h3 id=\"3-oke运行任务\"><a class=\"anchor\" href=\"#3-oke运行任务\">#</a> (3). OKE 运行任务</h3>\n<p>OKE 任务需要以一个完整视频为基本单位。遇到肉酱和连体，需要先转为 1 集一个 mkv 文件来压制。</p>\n<p>用法比较简单：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-11/image02.jpg\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-11/image03.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-11/image04.png\" alt=\"img\" /></p>\n<p>如果需要多开，点击右下角 “新建工作单元”。</p>\n<p>如果载入任务出错，或者压制过程中出错，需要清掉所有任务，重新添加。</p>\n<p>压制完成后，json 文件所在目录下会有一个名为  <code>output</code>  的目录。<br />\n包含所有成品文件，如 MKV、MKA 和 MP4 等。<br />\n如果花屏检查未通过，RPC 结果文件也将出现在  <code>output</code>  里。</p>\n<p>还有一个  <code>X_</code>  目录，这里  <code>X</code>  是 json 所在盘符，会保存中间的临时文件。</p>\n<h2 id=\"2-音轨的处理\"><a class=\"anchor\" href=\"#2-音轨的处理\">#</a> 2. 音轨的处理</h2>\n<p>除了前一小节提到的基础音轨功能，OKE 还提供以下功能：空音轨和重复音轨的检测、可选音轨、音轨重排序、有损音轨压制、默认轨道标志的处理。</p>\n<h3 id=\"1-空音轨和重复音轨的检测\"><a class=\"anchor\" href=\"#1-空音轨和重复音轨的检测\">#</a> (1). 空音轨和重复音轨的检测</h3>\n<p>OKE 可以自动检测空音轨和重复音轨，在封装成品时将它们删去。在编写配置文件时，不用判断是否是空音轨和重复音轨，都当做正常封装来处理，OKE 会自动决定是否保留。</p>\n<h3 id=\"2-可选音轨\"><a class=\"anchor\" href=\"#2-可选音轨\">#</a> (2). 可选音轨</h3>\n<p>在一些新番中，往往不再使用空音轨和重复音轨来处理评论音轨的问题，而是直接使用不同数量的音轨。这就造成，一个项目配置文件无法兼容所有集数的情况。</p>\n<p>OKE 采用可选标签  <code>Optional</code>  来处理这个问题。对于每条音轨，都可以设置 Optional 标签。如果为 true，则在原盘不存在该条轨道时直接忽略，而不报错。</p>\n<p>以下用法可以兼容一条主音轨，和一条主音轨加上一条评论音轨的情况。</p>\n<figure class=\"highlight json\"><figcaption data-lang=\"JSON\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token property\">\"AudioTracks\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token property\">\"OutputCodec\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"flac\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token property\">\"Name\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"Main Audio\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token property\">\"OutputCodec\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"aac\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token property\">\"Bitrate\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"192\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token property\">\"Name\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"Audio Commentary\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token property\">\"Optional\"</span> <span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>需要注意的是，如果有多条轨道均标记为  <code>Optional = true</code> ，则要求它们要么都存在，要么都不存在。</p>\n<h3 id=\"3-音轨重排序\"><a class=\"anchor\" href=\"#3-音轨重排序\">#</a> (3). 音轨重排序</h3>\n<p>默认情况下，成品音轨的封装顺序与原盘中的顺序相同，但少数情况下这种顺序并不是我们希望的。</p>\n<p>OKE 提供了一种重新排序的方式，对于每条音轨，可以设置  <code>Order</code> 。Order 是一个非负整数，OKE 会按照 Order 对音轨进行稳定的升序排序，即更小 Order 的轨道会在前面。</p>\n<p>默认情况下，所有音轨有最大的 Order，因此如果希望将某一音轨提到最前面，只需要设置  <code>Order = 1</code>  即可。</p>\n<h3 id=\"4-有损音轨压制\"><a class=\"anchor\" href=\"#4-有损音轨压制\">#</a> (4). 有损音轨压制</h3>\n<p>OKE 支持编码音轨为 AAC，但正常情况下只对无损音轨生效，有损音轨只能保持原状。根据整理规范，对于码率 &gt;= 512kbps 的有损音轨，需要二压为更低码率的 AAC。</p>\n<p>OKE 提供了有损音轨压制的方式，对于每条音轨，可以设置  <code>Lossy</code>  标签。如果为 true，则当源音轨为有损编码格式时也可重编码为 AAC。</p>\n<p>需要注意的是，并非所有有损格式都能二压，比如 eac3 格式，目前不支持二压。</p>\n<h3 id=\"5-默认轨道标志\"><a class=\"anchor\" href=\"#5-默认轨道标志\">#</a> (5). 默认轨道标志</h3>\n<p>OKE 会自动调整各音轨的默认轨道标志，只有正常封装的第一条音轨被标记为  <code>yes</code> ，其他所有音轨，包括 mka 中的音轨都会被标记为  <code>no</code> 。这样可以避免挂载 mka 时同时解码两条音轨，在部分播放环境下出错的问题。</p>\n<h2 id=\"3-字幕的处理\"><a class=\"anchor\" href=\"#3-字幕的处理\">#</a> 3. 字幕的处理</h2>\n<p>与音轨类似，对于字幕轨，OKE 提供以下功能：空字幕轨的检测、可选字幕轨、字幕轨重排序、默认轨道标志的处理。</p>\n<p>前三个功能与音轨完全相同，字幕轨也同样支持 Optional 和 Order 标签功能，不再赘述。</p>\n<p>关于默认轨道标志，与音轨不同，原盘的字幕轨往往是日文或者英文，因此均默认标记为  <code>no</code> ，这样播放时不会自动挂载字幕轨。</p>\n<p>除了原盘的 PGS 字幕，OKE 也能识别 ass 和 srt 字幕，但是不支持封装，只能设置  <code>MuxOption = Skip</code>  来丢弃。这一功能在压制 webrip 时会用到。</p>\n<h2 id=\"4-章节的处理\"><a class=\"anchor\" href=\"#4-章节的处理\">#</a> 4. 章节的处理</h2>\n<p>OKE 能够自动处理以下 3 种形式的章节：</p>\n<ol>\n<li>输入文件为  <code>.m2ts</code> ，且保持了原盘目录结构，OKE 会自动查找对应的 mpls，并提取章节封入成品。</li>\n<li>输入文件为  <code>.mkv</code> ，且其中内封了章节，OKE 会自动提取章节并封入成品。</li>\n<li>外挂同名  <code>.txt</code>  章节文件，比如输入文件为  <code>00001.m2ts</code> ，同目录下有同名章节  <code>00001.txt</code> ，OKE 会自动提取章节并封入成品。</li>\n</ol>\n<p>当某些情况同时成立时，外挂章节的优先级更高。</p>\n<p>除了以上基础功能，OKE 还支持：指定章节语言、重命名章节标题、根据章节设置关键帧。</p>\n<h3 id=\"1-指定章节语言\"><a class=\"anchor\" href=\"#1-指定章节语言\">#</a> (1). 指定章节语言</h3>\n<p>默认情况下，OKE 总是设置章节语言为 eng。有时我们会手动填写章节日文标题，此时需要设置语言为 jpn。可以通过给外挂 txt 字幕添加语言后缀来实现，比如输入文件为  <code>00001.m2ts</code> ，同目录下章节命名为  <code>00001.jpn.txt</code> ，这样 OKE 就会读取语言标签，并在封装时设置为 jpn。</p>\n<h3 id=\"2-重命名章节标题\"><a class=\"anchor\" href=\"#2-重命名章节标题\">#</a> (2). 重命名章节标题</h3>\n<p>对于连体盘，经切割后，除了第一部分，后面部分的章节标题都不是从  <code>Chapter 01</code>  开始的。OKE 支持重命名章节标题，通过  <code>RenumberChapters</code>  来设置。在设置为 true 时，所给章节会从  <code>Chapter 01</code>  开始重新命名。</p>\n<h3 id=\"3-根据章节设置关键帧\"><a class=\"anchor\" href=\"#3-根据章节设置关键帧\">#</a> (3). 根据章节设置关键帧</h3>\n<p>OKE 会利用章节在各个章节点处设置关键帧。具体方式为，根据章节确定章节点的帧号，生成 qpfile 给编码器，指定章节点为关键帧。</p>\n<p>注意，这个功能会复写 qpfile 参数，因此自己在编码参数中设置的 qpfile 参数实际上无效。由于 qpfile 依赖于章节，需要特别注意章节的正确性，原则上必须在压制前修改章节，而不能在压制后修改。</p>\n<h2 id=\"5-vfr功能\"><a class=\"anchor\" href=\"#5-vfr功能\">#</a> 5. VFR 功能</h2>\n<p>OKE 支持动态帧率（VFR）视频的压制。在压制 VFR 时，不再需要指定帧率，但是需要设置  <code>TimeCode</code>  为 true 来开启 VFR 功能。</p>\n<p>开启 VFR 压制时，OKE 需要获取时间码文件  <code>.tcfile</code> ，并在封装时写入时间码。与外挂章节文件类似，将时间码文件放到输入文件同目录并改名匹配。比如输入文件为  <code>00001.m2ts</code> ，同目录下时间码文件命名为  <code>00001.tcfile</code> 。</p>\n<p>事实上，由于 OKE 的压制流程中，在实际压制前会先运行  <code>vspipe -i</code>  来获取信息，我们可以在 vpy 脚本中实时生成 tcfile。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#OKE:INPUTFILE</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>a<span class=\"token operator\">=</span><span class=\"token string\">\"00000.m2ts\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># VFR splice</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> pathlib</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>path <span class=\"token operator\">=</span> pathlib<span class=\"token punctuation\">.</span>Path<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>VFRSplice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>res_a<span class=\"token punctuation\">,</span> res_b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> tcfile<span class=\"token operator\">=</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">.</span>with_suffix<span class=\"token punctuation\">(</span><span class=\"token string\">'.tcfile'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure>",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%88%9D%E7%AD%8930fps%E5%A4%84%E7%90%86/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%88%9D%E7%AD%8930fps%E5%A4%84%E7%90%86/",
            "title": "第十章初等30fps处理",
            "date_published": "2024-03-16T15:14:34.000Z",
            "content_html": "<h1 id=\"第十章-初等-30-fps-处理\"><a class=\"anchor\" href=\"#第十章-初等-30-fps-处理\">#</a> 第十章 初等 30 fps 处理</h1>\n<h2 id=\"1-什么是隔行扫描\"><a class=\"anchor\" href=\"#1-什么是隔行扫描\">#</a> 1. 什么是隔行扫描</h2>\n<p>要解释这个概念，要先从电视广播制式说起，世界上最常见的两种便是 NTSC 和 PAL，这些标准的制定与使用一定程度上受不同地区的家用交流电频率影响。</p>\n<ul>\n<li>NTSC：1 秒 30 帧或 60 场，主要由家用交流电频率为 60 Hz 的北美与日本使用</li>\n<li>PAL： 1 秒 25 帧或 50 场，主要由家用交流电频率为 50 Hz 的其他大部分国家地区使用，如大多数欧洲国家和中国</li>\n</ul>\n<p><em>由于我们主要说明的是日本动画等在日本播出的节目，所以下面如无特殊说明，介绍的均为 NTSC，两种制式的分别（如色彩）不再细说。</em></p>\n<p>「场（field）」这个名词已经在前面的教程中出现过，而它正是因隔行扫描产生的概念。让我们回到 NTSC 制定的时代，那时的显示器大多使用的是 CRT（阴极射线管），它的显像原理简单来说就是电子束打到荧光粉来发亮，且受到了交流电频率的影响。<br />\n为什么没有使用逐行扫描呢？这是因为显像用的荧光粉的亮度会衰减。逐行扫描是从左到右从上到下地逐步点亮，人眼看起来有闪烁感。所以先从上至下扫描奇数行组成一场，再从上至下扫描偶数行组成一场的方式，光暗交叉看起来要好上很多，1 秒内要显示的从 30 帧变为了 60 场，这种扫描方式便是隔行扫描（如下图所示）。随着技术的发展，CRT 也被 LCD  代替，现在已经很少见到，但隔行扫描的视频却仍然常见。</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/CRT_image_creation_animation-954ba38f564574dd19a970c32f15cb8b.gif\" alt=\"img\" /></p>\n<p>我们将奇数场称之为上半场（Top Field），偶数场称之为下半场（Bottom  Field），显示上高度为正常帧高度的一半，即在同等带宽（无压缩）下，以空间分辨率（spatial  resolution）减半，换取时间分辨率（temporal resolution）加倍。虽然在展现上，上下半场可以合并为 1  帧，但扫描时间并不相同，时间差为  1/59.94s，所以在两场合并的帧上可能会出现交错条纹，或者说拉丝（如下图），也就是交错（Comb），这也是隔行扫描的典型特征。</p>\n<p><em>注：请点开原图查看以获得正确的观看效果</em></p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/interlaced-bc8181396f07002579b9670ebb0287a0.jpg\" alt=\"img\" /></p>\n<p><em>为什么 1 场是 1/59.94s 而不是 1/60s，这是因为在引入色彩时发生了 0.1% 的偏移，PAL 不存在这种现象。</em></p>\n<p>由于历史影响，日本制作生产的大部分节目帧率还是 24/1.001、30/1.001、60/1.001，为了简化讨论我们依次称之为 24fps、30fps、60fps，24/1 称之为 24.00fps，依次类推。</p>\n<h2 id=\"2-隔行扫描视频的种类\"><a class=\"anchor\" href=\"#2-隔行扫描视频的种类\">#</a> 2. 隔行扫描视频的种类</h2>\n<h3 id=\"1-样例\"><a class=\"anchor\" href=\"#1-样例\">#</a> (1). 样例</h3>\n<p>在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZjYi1zL2d1aWRlcy9yZWxlYXNlcy90YWcvJTIzMTA=\">release</span> 的  <code>30fps_sample.7z</code>  中有 4 个不同的视频，可以下载后与下面对照查看。</p>\n<p><em>如果使用 Vapoursynth 查看，可以先阅读下面的 隔行扫描视频的读取 - LWLibavSource 部分。</em></p>\n<h4 id=\"sample1\"><a class=\"anchor\" href=\"#sample1\">#</a> sample1</h4>\n<p>其实是逐行扫描，偶尔看到的类似于交错的痕迹是缟缟，缟缟是对交错内容进行了错误处理导致的一种瑕疵。由于 Blu-ray 规范中只有 1920×1080 29.97i 而不允许 29.97p，所以在视频的信息标注上也是  29.97i，也就是伪装为隔行扫描视频的逐行扫描，一般我们称之为 30p。</p>\n<h4 id=\"sample2\"><a class=\"anchor\" href=\"#sample2\">#</a> sample2</h4>\n<p>帧帧交错的隔行扫描，我们一般称之为 30i。</p>\n<h4 id=\"sample3\"><a class=\"anchor\" href=\"#sample3\">#</a> sample3</h4>\n<p>大部分动画的帧率都是 24fps，但是会在帧率为 30fps 的电视广播中播出，在此中间便经过了一种名为 Telecine（胶卷过带）的处理，最常见的就是 3:2 pulldown（其实是 2:3 pulldown），具体做法如下图所示：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/23pulldown-8255e5193cc25caefe9f3a8a8afe6462.png\" alt=\"img\" /></p>\n<p>结果上看就是每 5 帧有 2 帧是交错的，即 PIIPP（3:2 pattern），又称作五烂二，每 3:2 个场的时间点相同，虽然仍避免不了卡顿但还算流畅。我们一般称之为 24t（24 telecine）。</p>\n<h4 id=\"sample4\"><a class=\"anchor\" href=\"#sample4\">#</a> sample4</h4>\n<p>承接上文，还有一种 Telecine 的处理方式，就是每 4 帧重复 1 帧，这样 24fps 就转换为了 30fps。结果上看就是每 5 帧有 1  帧是重复的，每 2:2:2:4 / 1:1:1:2 个场的时间点相同，称之为 2:2:2:4 pulldown，这样的卡顿感比 24t  更甚，我们一般称之为 24d（24 duplicate）。</p>\n<h3 id=\"2-总结\"><a class=\"anchor\" href=\"#2-总结\">#</a> (2). 总结</h3>\n<p>本节前文中的种类命名参考了 mawen1250 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubm1tLWhkLm9yZy9uZXdiYnMvdmlld3RvcGljLnBocD9mPTcmYW1wO3Q9MTM2Nw==\">ivtc_txt60mc 使用教程 - 对于 24t/24d+30i/30p 混合源的处理</span>，在学术上也许不严谨，但可以方便讨论。虽然有的未在样例中出现，但大概总结一下：</p>\n<ul>\n<li>24p：逐行扫描，每秒 24/1.001 帧，每帧无交错</li>\n<li>60p：逐行扫描，每秒 60/1.001 帧，每帧无交错</li>\n<li>60i：隔行扫描，每秒 60/1.001 场，每帧不一定有交错，下面提到的几种均为此种的细分类型</li>\n<li>30p：每帧无交错，可能是 30/1.001 帧的逐行扫描，也可能是每帧无交错的 60i，本篇讨论的多为后者</li>\n<li>30i：每帧都是交错的 60i</li>\n<li>24t（24 telecine）：60i 中每 5 帧有 2 帧是交错的，即 PIIPP（3:2 pattern）</li>\n<li>24d（24 duplicate）：60i 中每帧无交错，每秒 30/1.001 帧，但每 5 帧有 1 帧是重复的</li>\n</ul>\n<h2 id=\"3-24p-的视频是怎么播放的\"><a class=\"anchor\" href=\"#3-24p-的视频是怎么播放的\">#</a> 3. 24p 的视频是怎么播放的</h2>\n<p>标准的制定来自于实践，但反过来，标准也会影响产业链。</p>\n<p>相信大家已经知道，常见的日本动画帧率便是受到 NTSC 影响的 24p（24/1.001）。可能不太清楚的是如今电影放映的基本标准也是  24p（24/1），这一标准的制定受到人体本身、放映技术等层面的影响，而且电影行业标准的制定要远早于电视广播制式的制定，感兴趣的人可以去自行搜索电影放映速度及行业标准的变化，此处便不再赘述。然而电影实际制作的时候，选用的可能也是 NTSC 的 24p（24/1.001）。</p>\n<p>视频是要用来看的，可能是电视广播，也可能是借助于 DVD / Blu-ray 这种碟片载体，也可能是电脑上的文件。为了使 24p 的视频能在不同设备上播放，业界也有很多技术对其进行处理。大概有下面几种：</p>\n<ol>\n<li>将 24p 重编码为 24t / 24d 在 NTSC 设备上播放</li>\n<li>将 24p 加速在 PAL 设备上播放</li>\n<li>给 24p 的视频添加 pulldown flags，使 NTSC 设备在播放时进行转换</li>\n<li>60Hz 显示器播放 24p 视频时，在每次屏幕刷新时重复显示视频的同一帧，直到下一帧的时间戳已经晚于屏幕刷新再显示下一帧，类似于 3:2 pulldown，这时出现的动态卡顿感也被称为 3:2 pulldown judder</li>\n</ol>\n<h3 id=\"1-soft-pulldown\"><a class=\"anchor\" href=\"#1-soft-pulldown\">#</a> (1). soft pulldown</h3>\n<p>第 1 种方式之前已经介绍过，我们着重说一下第 3 种方式，这种方式名为 soft telecine，又被称作 soft pulldown，与其相对应的重编码方法可以称作 hard telecine。</p>\n<p>在视频的 24p 帧上添加一个 RFF（Repeat First Field）的 flag，播放设备在读取到这个 flag 的时候便会重复首场（TFF 时为顶场），一个正确的 repeat 如下表所示：</p>\n<p><em>注：此处应按照 PTS 顺序</em></p>\n<p><em>TFF flag = top_field_first; RFF flag = repeat_first_field</em></p>\n<table>\n<thead>\n<tr>\n<th>Source Frame</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TFF flag</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>RFF flag</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Field</td>\n<td>0t</td>\n<td>0b</td>\n<td>1t</td>\n<td>1b</td>\n<td>1t_r</td>\n<td>2b</td>\n<td>2t</td>\n<td>3b</td>\n<td>3t</td>\n<td>3b_r</td>\n</tr>\n<tr>\n<td>Present Frame</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>相较于 hard telecine，此种方法是无损的，而且可以节省传输的流量。由于 pulldown flag 可以只添加在视频流的一部分帧，所以真实的视频流帧率可能是变化的（vfr）而非恒定的（cfr）。</p>\n<p><em>但是实际情况与标准不同，flag 错误、pulldown 错误都屡见不鲜，正确地分辨与处理就要仔细检查和积累经验。</em></p>\n<h2 id=\"4-隔行扫描视频的读取\"><a class=\"anchor\" href=\"#4-隔行扫描视频的读取\">#</a> 4. 隔行扫描视频的读取</h2>\n<p>我们在处理隔行扫描视频之前，首先要先学会如何正确地读取。</p>\n<h3 id=\"1-dgmpgdec\"><a class=\"anchor\" href=\"#1-dgmpgdec\">#</a> (1). DGMPGDec</h3>\n<p>首先先看一套有点「老」的软件 DGMPGDec，这是 Donald A. Graft 基于 DVD2AVI 开发的自由软件。可以从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmF0aW9uYWxxbS51cy9kZ21wZ2RlYy9kZ21wZ2RlYy5odG1s\">https://www.rationalqm.us/dgmpgdec/dgmpgdec.html</span> 获取源代码和相应配套组件。仅适用于 MPEG-1 和 MPEG-2，主要是后者，常见的大多是 DVD 和 Transport Stream。</p>\n<p><em>以下基于 v2.0.0.8</em></p>\n<p>包内对 vs 有用的只有 DGIndex 和 DGDecode，这里也只介绍我们可能会用到的 DGIndex 功能。</p>\n<h4 id=\"dgindex\"><a class=\"anchor\" href=\"#dgindex\">#</a> DGIndex</h4>\n<p>DGIndex 有一个 gui，基本操作是  <code>File - Open (F2)</code> ，然后把需要加载的单个或多个文件  <code>ADD</code>  或拖拽上去，默认设置下  <code>File - Save Project (F4)</code>  会弹出 Information 窗口，显示结束后即可在源目录得到一个  <code>.d2v</code>  文件和 demux 的  <code>xxx DELAY xxxms.aac</code> 。</p>\n<ul>\n<li><code>.d2v</code>  中记录的源文件名是绝对路径</li>\n<li>音频文件名上标注了需要 delay 的时间，mux 时可能会用到</li>\n</ul>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/dg_00-e840bc3a822bc05070f64c0150eea00c.jpg\" alt=\"img\" /></p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/dg_01-638a88fc6d0f4e0cab53dee08573651f.jpg\" alt=\"img\" /></p>\n<p>之所以会 demux 音轨是因为  <code>Audio - Output Method</code>  默认是  <code>Demux All Tracks</code> ，可以选择  <code>Disable</code>  不 demux 音轨（对应的是同目录配置文件  <code>DGIndex.ini</code>  中的  <code>Output_Method=0</code> ）。</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/dg_02-6fcea7d9a0c5989bca4ee5bf80f30a20.jpg\" alt=\"img\" /></p>\n<p>还有一个可能用到的重要选项  <code>Video - Field Operation</code> ，它只对含有 pulldown flags 的视频有意义。</p>\n<p>在介绍这个选项之前，需要先说明几个 DGMPGDec 中的概念：</p>\n<ul>\n<li>Film：相当于 24p，通常表现为 24t</li>\n<li>NTSC Video：可略称为 Video，相当于 30p，通常表现为 30i、30p</li>\n<li>Hybrid：film 与 video 的混合，可能是时间上的也可能是空间上的</li>\n</ul>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/dg_03-900bb006ccac9cf0607dbf158000c991.jpg\" alt=\"img\" /></p>\n<p>回到  <code>Field Operation</code> ：</p>\n<ol>\n<li>Honor Pulldown Flags (Default)：模拟播放设备对标有 RFF 的场进行 repeat，返回 30fps clip。</li>\n<li>Ignore Pulldown Flags：忽略 RFF，返回原始 clip（会记录在 d2v 文件中但不会处理），24fps 的视频被标注为 30fps 的帧率。</li>\n<li>Force Film：将 24d 转换为 24p 并返回。</li>\n</ol>\n<p>设置 Field Operation 的工作流程一般是这样的，先使用  <code>Honor Pulldown Flags</code> ，观察 Information 中的  <code>Video Type</code></p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/dg_04-a3ef7774c8dd881c4d3afd101d541fb8.jpg\" alt=\"img\" /></p>\n<ol>\n<li>如果显示 NTSC 或 PAL 说明没有 pulldown flags，应继续使用之前生成的 d2v</li>\n<li>如果显示 Film 达到 95% 及以上（100% 也可被称为 Pure Film，此时无百分比显示）就可以使用  <code>Force Film</code>  得到 24p 的 clip，重新生成 d2v</li>\n<li>如果显示 Film 低于 95% 或显示 Video，应继续使用之前生成的 d2v</li>\n</ol>\n<p>其实 DGIndex 也提供了 cli，示例：</p>\n<pre><code>DGIndex.exe -i &quot;xx.ts&quot; -o &quot;xx&quot; -fo 0 -om 0\n</code></pre>\n<ul>\n<li><code>-i</code> ：指定输入的文件路径</li>\n<li><code>-o</code> ：指定输出的文件路径（包括文件名不包括文件扩展名）</li>\n<li><code>-fo</code> ：Field Operation， 0、1、2 依次对应 Honor Pulldown Flags、Force Film、Ignore Pulldown Flags</li>\n<li><code>-om</code> ：Output Method，0 - Disable、2 - Demux All Tracks</li>\n</ul>\n<h4 id=\"读取-d2v-文件\"><a class=\"anchor\" href=\"#读取-d2v-文件\">#</a> 读取 d2v 文件</h4>\n<p>d2v 文件类似于 lsmas 的 lwi，这也是一个纯文本文件，可以打开看下。</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/dg_05-4d65157bf25e0d2362f5d999919d2f94.jpg\" alt=\"img\" /></p>\n<p>它记录的视频名是绝对路径，所以索引完就不要改变视频位置，要不然它会找不到。具体结构可以从  <code>DGIndexManual.html</code>  中看，不再说明，主要说下怎么从 Vapoursynth 中加载  <code>.d2v</code> ，有两种方法，一种是最近 port 的自带的  <code>dgdecode.MPEG2Source</code> ，另一种是  <code>d2v.Source</code> 。</p>\n<p>DGIndex 的现代化替代品是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2R1YmhhdGVyL0QyVldpdGNo\">D2VWitch</span>，与  <code>d2v.Source</code>  配套。</p>\n<p>两个滤镜使用都很常规，指定 d2v 路径即可。只是对于 Force Film 生成的 d2v， <code>d2v.Source</code>  需要指定  <code>rff=False</code>  否则会得到一个帧率正确帧数错误的 clip。</p>\n<p>如果你想使用  <code>dgdecode</code>  却不想把它放到默认加载的路径，可以使用  <code>LoadPlugin</code> ：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>LoadPlugin<span class=\"token punctuation\">(</span><span class=\"token string\">\"DGDecode.dll\"</span><span class=\"token punctuation\">,</span> forcens<span class=\"token operator\">=</span><span class=\"token string\">\"dgdecode\"</span><span class=\"token punctuation\">,</span> forceid<span class=\"token operator\">=</span><span class=\"token string\">\"dgdecode\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>如果无法预览，可能是缺少 frameprops，可以使用  <code>std.SetFrameProps</code>  指定。d2vsource 则会添加需要的 frameprops 和 IPB 帧 type。</p>\n<p><em>注： <code>dgdecode.MPEG2Source</code>  现在会在 clip 顶部与底部错误地各加 4px</em></p>\n<h4 id=\"其他\"><a class=\"anchor\" href=\"#其他\">#</a> 其他</h4>\n<p>他还有一款与其类似的免费软件（原收费软件）<span class=\"exturl\" data-url=\"aHR0cDovL3JhdGlvbmFscW0udXMvZGdkZWNudi9kZ2RlY252Lmh0bWw=\">DGDecNV</span>，除 MPEG-2 外还支持 AVC、HEVC 等现代常用的编码格式。但仅支持 NVIDIA 显卡，且不太适合 MPEG-2 源的处理。</p>\n<h3 id=\"2-lwlibavsource\"><a class=\"anchor\" href=\"#2-lwlibavsource\">#</a> (2). LWLibavSource</h3>\n<p>在实际流程中，我们用到 DGMPGDec 的时候有点少，一是 OKE 没有支持，二是只能读取 MPEG-2。一般使用的还是在基础滤镜篇章源滤镜部分提到的  LWLibavSource，DGMPGDec 更多时候是用于验证与比对。主要是对于 LWLibavSource 参数  <code>repeat</code>  的使用，其他与加载常规视频源相同。 <code>repeat</code>  只对含有 pulldown flags 的视频生效，也就是说如果视频中不含有 pulldown flags， <code>repeat</code>  的值无论为多少都会返回原本的视频。下面是不同  <code>repeat</code>  值对 soft pulldown 视频的处理。</p>\n<ol>\n<li>值为  <code>False</code>  或  <code>0</code>  时，不做任何处理，返回源视频，即\n<ul>\n<li>如果源是 24fps 和 30fps 混合返回帧率不明的 vfr clip</li>\n<li>如果源全是 24fps（也就是 pure film）返回 24p clip（与 DGIndex 的  <code>Force Film</code>  行为相同），但帧率不一定正确，可能需要  <code>std.AssumeFPS(fpsnum=24000, fpsden=1001)</code></li>\n</ul>\n</li>\n<li>其他值时，像播放器一样根据 pulldown flags 对需要重复的场进行 repeat，如果成功则返回一个 30fps 的 clip（与 DGIndex 的  <code>Honor Pulldown Flags</code>  行为相同，但结果更为可靠），如果失败：\n<ul>\n<li>若值为  <code>True</code>  或  <code>1</code> ，显式报错</li>\n<li>若值为  <code>2</code> ，与  <code>0</code>  时相同，返回帧率不明的 vfr clip</li>\n</ul>\n</li>\n</ol>\n<p>pulldown flags 处理失败，可能是因为视频流破损、后期剪辑失误、超出 lsmas 处理能力等。<br />\n对于返回的 vfr clip 也需要仔细检查，看起来正常但不一定正确。<br />\n而且哪怕是  <code>repeat=1</code>  成功返回了 cfr clip，也要仔细检查帧顺序是否正确，如果出现问题可以从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FrYXJpblZTL0wtU01BU0gtV29ya3MvaXNzdWVz\">Github repo issues</span> 回报。</p>\n<p>在启用  <code>repeat</code>  时可以通过 frameprops  <code>_EncodedFrameBottom</code>  和  <code>_EncodedFrameTop</code>  来查看当前帧由哪两场组成。同时  <code>.lwi</code>  文件中也记录了 rff 的信息， <code>Repeat=1</code>  为无 rff， <code>Repeat=2</code>  为 rff。</p>\n<p>总之，处理中一般应使用更为严格安全的  <code>repeat=1</code> （默认值），repeat 失败再使用  <code>repeat=0</code> 。如果是查看老一些的脚本或使用旧版本的滤镜（vA.2 之前版本）时，你可能会发现  <code>repeat</code>  只有 True 与 False 两种，旧有的 True 就是现在的  <code>repeat=2</code> 。再老一些， <code>repeat</code>  默认是 false，现在  <code>repeat</code>  默认是 1…</p>\n<h4 id=\"检测是否为全程-soft-pulldownpure-film\"><a class=\"anchor\" href=\"#检测是否为全程-soft-pulldownpure-film\">#</a> 检测是否为全程 soft pulldown（pure film）</h4>\n<p>可以使用 DGIndex，也可以用以下方法。</p>\n<p>假设 repeat = 1 / 2 / True 时，读取到的视频帧数为 x，repeat = 0 / False 时读取到的视频帧数为 y，如果符合  <code>| 0.8 * x – y| &lt; 1</code>  则可以认为源视频是全程 soft pulldown，可以使用  <code>repeat=0</code>  得到 24p 的视频进行后处理，否则必须要开启  <code>repeat=1</code> 。~~ 当然就算是完美的 soft pulldown，开启  <code>repeat=1</code>  读取后再进行 IVTC 也没有问题。~~ 示例脚本：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>source_file <span class=\"token operator\">=</span> <span class=\"token string\">\"a.ts\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">isSoftPulldown</span><span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> debug<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> vs<span class=\"token punctuation\">.</span>VideoNode<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    a <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>source_file<span class=\"token punctuation\">,</span> repeat<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    b <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>source_file<span class=\"token punctuation\">,</span> repeat<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">if</span> debug<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">return</span> b</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">return</span> a <span class=\"token keyword\">if</span> <span class=\"token builtin\">abs</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>num_frames <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span> <span class=\"token operator\">-</span> a<span class=\"token punctuation\">.</span>num_frames<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span> <span class=\"token keyword\">else</span> b</pre></td></tr></table></figure><h2 id=\"5-隔行扫描视频的常规处理\"><a class=\"anchor\" href=\"#5-隔行扫描视频的常规处理\">#</a> 5. 隔行扫描视频的常规处理</h2>\n<p>正常情况下，我们要将隔行扫描视频正确地处理回逐行视频再进行后续的处理，下面就说下如何处理，顺序还是依照上面 sample 的顺序。</p>\n<h3 id=\"1-指定-fieldbased30p\"><a class=\"anchor\" href=\"#1-指定-fieldbased30p\">#</a> (1). 指定 FieldBased（30p）</h3>\n<p>因为只是标记为 60i，视频本身仍为逐行扫描，所以只需要使用  <code>core.std.SetFieldBased(src, 0)</code>  将 Frameprops 中的  <code>_FieldBased</code>  标记为 0（Progressive）即可，通常在将隔行扫描的视频处理为逐行扫描的视频后都要如此操作，因为这样可以避免后续处理的滤镜读取到错误的 Frameprops 进行了错误的处理。</p>\n<p>缟缟的处理放到后面。</p>\n<h3 id=\"2-deint30i\"><a class=\"anchor\" href=\"#2-deint30i\">#</a> (2). deint（30i）</h3>\n<p>需要对源视频进行「反交错（deinterlace /deint）」。一些常见的 deint 滤镜有：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvVmFwb3VyU3ludGgtRUVESTI=\">EEDI2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvVmFwb3VyU3ludGgtRUVESTM=\">EEDI3mod</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Nla3JpdC10d2Mvem5lZGkz\">znedi3</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hvbWVPZlZhcG91clN5bnRoRXZvbHV0aW9uL1ZhcG91clN5bnRoLVREZWludE1vZA==\">TDeintMod</span></li>\n</ul>\n<p>最简单的便是半场反交错，如  <code>core.znedi3.nnedi3(src, field=1)</code> ，直接扔掉下半场，只用上半场插补出整帧，这样帧率保持不变，变为场率的一半。但这种直接没了一半信息的做法实在过于粗暴，所以我们可以先进行分场，再对每场进行插补，如下所示：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>field_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>SeparateFields<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> tff<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>znedi3<span class=\"token punctuation\">.</span>nnedi3<span class=\"token punctuation\">(</span>field_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>现在帧率与场率相同了，但由于上下半场基线本就不同，所以必然会上下抖动。对此我们可以使用 havsfunc 中的一个 function QTGMC，它的原型是 TempGaussMC，是进行了时域的运动补偿，详细内容会在后面篇章说明。我们先简单使用一下它：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> havsfunc <span class=\"token keyword\">as</span> haf</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>src <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>source_file<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>res <span class=\"token operator\">=</span> haf<span class=\"token punctuation\">.</span>QTGMC<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> TFF<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> Preset<span class=\"token operator\">=</span><span class=\"token string\">\"Slower\"</span><span class=\"token punctuation\">,</span> FPSDivisor<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><code>Preset</code>  是速度和质量相关的预设； <code>FPSDivisor=2</code>  会在全部处理后抽出奇数帧输出，最终结果为 30p，某种意义上可以减少编码帧数，加快编码速度和降低码率。</p>\n<p>通常保持帧率不变的处理成为 deint，帧率翻倍的处理为 bob。</p>\n<h3 id=\"3-ivtc24t-与-24d\"><a class=\"anchor\" href=\"#3-ivtc24t-与-24d\">#</a> (3). ivtc（24t 与 24d）</h3>\n<p>3:2 pulldown 上文已经说过，24t  的场排序为（1 上，1 下）、（2 上，2 下）、（2 上，3 下）、（3 上，4 下）、（4 上，4 下）。要想将其还原回 24p，就需要先进行场匹配（Frame Match）转换为  24d，即固定上半场不变，按规则与相邻帧的下半场进行组合，选择成品画面中拉丝最少的作为最终结果，变成了（1 上，1 下）、（2 上，2 下）、（2 上，2 下）、（3 上，3 下）、（4 上，4 下），最后以 5 帧为循环抽取并删除重复的一帧，转换为 24p。这套流程就叫做 IVTC（inverse telecine），一些常见的 IVTC 滤镜有：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2R1YmhhdGVyL3ZhcG91cnN5bnRoLXRpdnRj\">TIVTC</span>：tritical 开发的一款 Avisynth 滤镜，后来由 dubhater 于 2021 年移植到 Vapoursynth</li>\n<li>VIVTC：VS 内置滤镜之一，是由 VS 开发者当年重写的 TIVTC，相比少了一些功能，同样参数的效果也会有一些不同</li>\n<li>a60224：Avisynth 滤镜，目前没有 VS 移植</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hvbWVPZlZhcG91clN5bnRoRXZvbHV0aW9uL1ZhcG91clN5bnRoLUlU\">IT</span></li>\n</ul>\n<p>在这先简单介绍下 vivtc，tivtc 的参数可以自行查阅 <span class=\"exturl\" data-url=\"aHR0cDovL2F2aXN5bnRoLm5sL2luZGV4LnBocC9USVZUQw==\">Avisynth 的文档</span>。</p>\n<ol>\n<li>\n<p>场匹配（vfm）</p>\n<p><code>matched = core.vivtc.VFM(src, mode=1)</code></p>\n<ul>\n<li>vfm 只支持 8-bit 输入</li>\n<li>mode：决定场匹配的方式和强度，范围 0-5。<br />\n强度随数字变大逐步增大，越小越安全，但可能匹配不上，开大了也有可能会匹配错误</li>\n</ul>\n</li>\n<li>\n<p>删除重复帧（vdecimate）</p>\n<p><code>res = core.vivtc.VDecimate(matched)</code></p>\n<ul>\n<li>vdecimate 支持 8-16 bit 输入</li>\n</ul>\n</li>\n<li>\n<p>后处理</p>\n<p>场匹配不可能完美，但 vfm 会给无法匹配的帧添加  <code>_Combed=1</code>  的 frameprop，于是可以自己做 deint 来处理这些帧</p>\n</li>\n</ol>\n<p>以下为一种简单的处理方式：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> havsfunc <span class=\"token keyword\">as</span> haf</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> functools</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">pp</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">,</span> deinterlaced<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token keyword\">if</span> f<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">[</span><span class=\"token string\">'_Combed'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>      <span class=\"token keyword\">return</span> deinterlaced</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>      <span class=\"token keyword\">return</span> clip</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>src <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>source_file<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>matched <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>vivtc<span class=\"token punctuation\">.</span>VFM<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>deint <span class=\"token operator\">=</span> haf<span class=\"token punctuation\">.</span>QTGMC<span class=\"token punctuation\">(</span>matched<span class=\"token punctuation\">,</span> TFF<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> FPSDivisor<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>pp_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>FrameEval<span class=\"token punctuation\">(</span>matched<span class=\"token punctuation\">,</span> functools<span class=\"token punctuation\">.</span>partial<span class=\"token punctuation\">(</span>pp<span class=\"token punctuation\">,</span> clip<span class=\"token operator\">=</span>matched<span class=\"token punctuation\">,</span> deinterlaced<span class=\"token operator\">=</span>deint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> prop_src<span class=\"token operator\">=</span>matched<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>vivtc<span class=\"token punctuation\">.</span>VDecimate<span class=\"token punctuation\">(</span>pp_clip<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>24d 就是从第 2 步开始，不再赘述。</p>\n<h3 id=\"4-vfr\"><a class=\"anchor\" href=\"#4-vfr\">#</a> (4). vfr</h3>\n<p>如前文 soft pulldown 部分所说，实际视频流中的 fps 不一定是恒定的，可能是时间上的多种类型的混合。也就是看起来是 60i  的视频，其中可能是 24d、30i、30p、24d  按时间的混合，这种时候应该对不同类型进行分别处理，最后再合并起来得到一个可变帧率（vfr）的视频。</p>\n<h4 id=\"timecode\"><a class=\"anchor\" href=\"#timecode\">#</a> timecode</h4>\n<p>之前介绍过，播放端通过读取视频容器内的 timestamp 来渲染帧，而 timecode 文件正是一种封装在容器中记录帧时间的文本文件，常见的格式有 v1、v2 两种。v1 只是简单记录每个帧数区间的帧率，v2 则会详细记录每一帧的时间戳。</p>\n<p>皆是以 0 帧作为起始帧，空格会被忽略。</p>\n<h5 id=\"timecode-v1\"><a class=\"anchor\" href=\"#timecode-v1\">#</a> timecode v1</h5>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># timecode format v1</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>assume 25</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>800,1000,23.97</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>1500,1700,29.970</pre></td></tr></table></figure><ul>\n<li>首行记录格式版本</li>\n<li>次行记录未指定范围的帧率，帧率为浮点数</li>\n<li>依次记录起止两端闭合区间及帧率</li>\n</ul>\n<p>这种格式更易于人类书写与查看。</p>\n<h5 id=\"timecode-v2\"><a class=\"anchor\" href=\"#timecode-v2\">#</a> timecode v2</h5>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre># timestamp format v2</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>40</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>80</pre></td></tr></table></figure><ul>\n<li>首行记录格式版本</li>\n<li>各行依次是顺序各帧的时间戳，时间戳精度为毫秒，浮点数</li>\n</ul>\n<h4 id=\"vs-生成-timecode-文件\"><a class=\"anchor\" href=\"#vs-生成-timecode-文件\">#</a> vs 生成 timecode 文件</h4>\n<p>示例： <code>res = mvsfunc.VFRSplice([30i_clip, 30p_clip, 24t_clip], tcfile=&quot;foobar.tcfile&quot;, v2=True)</code></p>\n<ul>\n<li>第一个参数是做完了 ivtc、deint 等的 clip 按照顺序组成的 list</li>\n<li>tcfile 指定生成的 tcfile 的输出路径</li>\n<li>v2 输入布尔值，决定输出的 tcfile 是 v1 还是 v2</li>\n</ul>\n<p>最后得到一个由 list 里的 clip 连接起来的 vfr clip 和一个 timecode file。</p>\n<h4 id=\"怎样预览和输出-vfr\"><a class=\"anchor\" href=\"#怎样预览和输出-vfr\">#</a> 怎样预览和输出 vfr</h4>\n<p>上节我们得到了一个 vfr clip 和一个 tcfile。</p>\n<h5 id=\"使用-vs-预览-vfr\"><a class=\"anchor\" href=\"#使用-vs-预览-vfr\">#</a> 使用 VS 预览 vfr</h5>\n<p>先用 vseditor 来预览一下这个 vfr clip，可以发现标注的 fps 为  <code>0/0</code> 。再换成 vspreview 预览，发现会弹出报错，因为 vspreview 无法处理 fps 为 0 的情况，那可以在 vfr clip 后追加一个  <code>AssumeFPS</code>  再  <code>set_output</code> 。如下示例：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># …</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vfr_clip <span class=\"token operator\">=</span> mvsfunc<span class=\"token punctuation\">.</span>VFRSplice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>clip1<span class=\"token punctuation\">,</span> clip2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> tcfile<span class=\"token operator\">=</span><span class=\"token string\">\"foobar.tcfile\"</span><span class=\"token punctuation\">,</span> v2<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># simple</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>res1 <span class=\"token operator\">=</span> vfr_clip<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>AssumeFPS<span class=\"token punctuation\">(</span>fpsnum<span class=\"token operator\">=</span><span class=\"token number\">30000</span><span class=\"token punctuation\">,</span> fpsden<span class=\"token operator\">=</span><span class=\"token number\">1001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># safe</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>res2 <span class=\"token operator\">=</span> vfr_clip<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>AssumeFPS<span class=\"token punctuation\">(</span>fpsnum<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>clip1<span class=\"token punctuation\">.</span>num_frames <span class=\"token operator\">+</span> clip2<span class=\"token punctuation\">.</span>num_frames<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> fpsden<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>clip1<span class=\"token punctuation\">.</span>num_frames<span class=\"token operator\">/</span>clip1<span class=\"token punctuation\">.</span>fps<span class=\"token operator\">+</span>clip2<span class=\"token punctuation\">.</span>num_frames<span class=\"token operator\">/</span>clip2<span class=\"token punctuation\">.</span>fps<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">1001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h5 id=\"从-vfr-视频中提取-timecode\"><a class=\"anchor\" href=\"#从-vfr-视频中提取-timecode\">#</a> 从 vfr 视频中提取 timecode</h5>\n<pre><code>ffms2.Source(timecodes=&quot;tcfile.txt&quot;)\n</code></pre>\n<h5 id=\"编码器编码-vfr\"><a class=\"anchor\" href=\"#编码器编码-vfr\">#</a> 编码器编码 vfr</h5>\n<ol>\n<li>x264 可以直接使用参数指定  <code>--tcfile-in &quot;foobar.tcfile&quot;</code></li>\n<li>x265 没有 vfr 支持，但可以输入输出 cfr 视频，再在封装时指定 timecode</li>\n</ol>\n<h5 id=\"封装-vfr\"><a class=\"anchor\" href=\"#封装-vfr\">#</a> 封装 vfr</h5>\n<ol>\n<li>\n<p>l-smash</p>\n<ul>\n<li>gui 可以直接指定 timecode file</li>\n<li>cli 需要先按正常流程封装 mp4，再使用  <code>timelineeditor</code>  重新封装： <code>.\\timelineeditor.exe --timecode &quot;foobar.tcfile&quot; cfr.mp4 vfr.mp4</code></li>\n</ul>\n</li>\n<li>\n<p>mkvmerge</p>\n<p>看 doc</p>\n</li>\n<li>\n<p>oke</p>\n<p>在配置文件中，指定 TimeCode 项为 True，便会启用 vfr 输出，且不再检查 fps 信息，封装 mkv 时将输入文件同路径下的同名 tcfile 封装进去</p>\n</li>\n</ol>\n<h2 id=\"6-被错误处理的隔行视频\"><a class=\"anchor\" href=\"#6-被错误处理的隔行视频\">#</a> 6. 被错误处理的隔行视频</h2>\n<h3 id=\"1-缟缟\"><a class=\"anchor\" href=\"#1-缟缟\">#</a> (1). 缟缟</h3>\n<p>重新打开 sample1，可以看到像下图一样有一些很像交错特征，实际上又不是的东西：</p>\n<p><img data-src=\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCACoARMDASIAAhEBAxEB/8QAGwABAAMBAQEBAAAAAAAAAAAAAAECAwQFBgf/xAAaAQEBAQEBAQEAAAAAAAAAAAAAAQIDBAUG/9oADAMBAAIQAxAAAAH4p31nt4nXS8+eN6655L1uITFyCAAAAAABQQAAFAelMT4f0MEkBISqlNePXmxUt3+VZW2oXvOmLSqVTFyJshIgUEgAAUB6Q8P6EUubxlTXm1rS2vPTm7MdefmnTtb5OnaefvgZ9CJFa6GeevU1y46d7XPzo9GLz89203x5XRneeay86jWQPTrXHy/YvVXfz0J1xm8ZzdueNjTprbl9eBOgQAAAAAAJr2/V19fp4fzXm9Hkx6ed0LnlnO/T5aa1Z0nnou2G3VO3B0dGU7X046TfoODSdOyMdc9pDYQAAAAmJNtOSaQQBxZehn1+fyX6JM9rTj1BnsAiVmeXTN58OfoxeHBrvlc3046Hoz52k6dsYa57WJnSEwJiSEiCSEiAK2WZRsvPLSM02YyuqJnQFCApEkzy6V5cFPSi8fP13yvPS/HSvRnztJ19T6X5H6Kb8XK1M+ggkiUAABWy5xjeLjPStE2nntLqiXQJQBJAEWWY49kXlwZ+nGuHnX65Z43cdJHP1gAAAAAKaLMI6IvPHWMmd557TWqtnQFkQAAIJQqJ83p15eqInHpBQAAAAJQAFbxc4R0LzyshEWLWusmLaTBuOd0jyB3+Lp1GPTvJy+rME0AAAAAAAkIAAFkQXnAuAP/EACUQAAICAgEDBAMBAAAAAAAAAAABERICAxMQMEAEICEiBTFQFf/aAAgBAQABBQL+HBRHGjjONlGQ/wCJBVDwQ/4WefWeixbONlGR48liWZSxqOq1ti1pe2EURxo4yjKs+e9JL9r/AFhjYWCXeqiiOM4ijKsh+2SWz9E9F0ZkzXjC8P0vo+U2/jUsNulY58aOJDcdLP2tjykww8Rfv8ftxWO/1GHH6jK2zsPM+WL4FtLonw8dmWJlvzy9kkkli58sx1ixSKo40PWfZF8kLaciJ8TJSQyjFrFqKr31Q9SONkZIu0cotiE/AgofKLd2qZxHGyMkXyQtotiJ78IqTki5PcgojiONn2Rdi2i2IsuuvC+f+cuLZjXPsQVPsi5Pdgoh6jjZ8ouxbTV6imX+nOvLKzJXaqih8ouT3oKI4h62RkizLZFcu7UoTki5Pfgoiq8GCh9kXJ/hVRQnJCzJ7s+LVFCckLMsi6LouXLl2Tkfc+4s2jHYT41SiKoqiCOwsmjHZJPlyWRKJR//xAAoEQACAQIFAwQDAQAAAAAAAAAAAQIDEQQSEzFREDBBFCAhMiNAYVL/2gAIAQMBAT8BeDY8LMdGaMj/AErIracUP56KjNjpTXgyvtOSW5PEpbDxEmVJNlLDuZDDRiJWLDpxY8PBjwcR4Lhjwc0OhNDhJFulWtkJ1XI+WbEYub+CnDJG3ZsVJS1LJGlF+D08CTu/nonwQw857io1Kf1NecfshYmHkVSL7c8N8kaEPJClBbdbEqMGPC8MyVYbGvUjuiOLj5FUi+w4pmnwXmhVF5L+yyZKhBjwn+WZK0NmeoqR3RHFx8mrm+r6Zl7cqZp8F5oVVeS9/a0mSoQZLCcCoVOT0v8Aew4pmlwXnEVVeRNP3XKeJjLcTv2XFM0uD8h+QtPkyT5NN8ml/elGrJMg7ruuTM7M7P/EAB8RAAICAQUBAQAAAAAAAAAAAAABERIwAhATICExQP/aAAgBAgEBPwHlORF0SvxqRElkWRONaSoh6oHq3ll2cjOU5UXRZE7JEb/BvEvhZl30sWTIRUjHYsNvpJYlEIqRhnaO1mWJTKooRgnaO9mXLIthnaMD045PDw8PCSdmh5YIIP/EAB8QAAEEAgIDAAAAAAAAAAAAAAARITFQATBAcBIgYP/aAAgBAQAGPwLqSKmCKJyBNj8bJmhYnotBRNTcdTxF2tTNTNTNTN7wQR8V/8QAIRABAQACAQUBAAMAAAAAAAAAAQARQSEQMDFRYUAgUHH/2gAIAQEAAT8h/o8Z9Ex/qdHTS8lh9f0WCwdXzgliPEOf6BQLI4Og9A2gvpI2XpsY/Mgk66Y3S9ALeY8dIDHXBZp9M18snfOwNu84yk/7ZIZeLzWVaix3MFk1fOSzw4euse38UFoeLMcugzY6MjguQ/GHNnZwxNUHiRIvj1Fy8sAYOoXg6LcCz8wMfj4CFZYXJqy465y5/hiyEWugl8kHqG3Afx+dMZhU8vUw4bCwkytdNXltJKamlPDY98U9pCbgu7P4xWTzc2LLLBAeD+WJbVoSXi+mLHtJhd2TvpdXDxfLMHfEI9tD1OpI1JT7kU9kjcF3Z7uJbU48ji2DMDcB7mDKakakfFj2Qe5NkohLJ0YjuS5TOLLenZS6nHyxZ8hmBAe6h1K6g1J2NbA7k3YncnjHyYs/7Wb6dnEpcOVZ83MD/IPeQy+p9GFzfRB7bN4sm3uodTh5YtkzA3xAe9ixn1wWrH4Eupw8ks+TmBviA/0OJTyXHybY5h3xAe5mA/lU8k7rFt8w74vtfTpY3+1l72Ta+FmY9i2EL5gP5cSHofK+VjYWCwerBcXH8NHygP6slj7vpfa+1//aAAwDAQACAAMAAAAQ5HQ22/8A/wD/AP8A/wD3/wD/APfa+65K6uu+tuMvP/8A/wB9/wDZ3aqSXULvWOPdu/fjexb26aP/AP8A/v8A/wAw9IHUrd1UBRvT/wD/AP8A+uh753Xxrb3lvhiB/LfvYoP7x2QXHz/yw3K9HQ0gD/8A++t8ojAG/wC/4NmIzPv/AP8A/ufQEjj88CzD2wWX/wD/AP8A/wDz/wAXklRwgTAAJ5//AP8A/wD/AP8A4/8A/wA88+//xAAgEQEAAgICAwADAAAAAAAAAAABABEhMRBBIDBhQFFx/9oACAEDAQE/EB6YKdJEdkp/X4CRbZFlGY7WQFhNhNhCGyU8V5k5TCCdjGbWZPqH25YAoiXc2BOkjNPGaBjlVNoRRKYYo3MtctJgZlZggHppBjElbMfGKrBRE0JkMCZyCIdjCatgjrzo5dtDcEFBRwh3NiQ91TvLhLJwKmvYN6lcVK52BGmXU7OZ8SAcj4O4TZkI6I9whFI0qKRVBHuffxdgjXLqdnM0MIDRh4bQnSwO9QTWkt6GwI0y6grOSaAqaR5riyUmMwYAs9O2Iky6hTHC/gL9x/aDKIMa59iwXP8A/8QAHxEBAQEAAQUBAQEAAAAAAAAAAQARECAhMDFRYUFA/9oACAECAQE/EARQ0N/bT/Btrbs892ZKGsW+EFtbBDIIrLtrBQEBChIaEgNpbwSzOFxaPhHIHdYcAdrLPsgv6Jb0y7ZZ168kVwt4IZH3ae7b1LlHgG/V2eGdGwEfcS09SrJ7ss6Rv1dnhnSKQEfXBjwDl+rs8c6cslJM8Ox9cmzZn5zKGeQIECxf/8QAJRABAAICAQMFAQEBAQAAAAAAAQARITFBUWGRECAwcYFAobHB/9oACAEBAAE/EK7PiVhgMp9lf2Y6Qr6i26RnFRPC8wm1kp4GL5Yntn5OIf2/k49LNkTUintFuPiLFAI0juVP7OPUQlyUis2Os2ykqrn1lvDNAg6s30Jx9xOSlSMsgXKZUr+BxuBWpNArFNAQNKBEldTEQoFjw4RlUt7wRglSh3O0eI7geIocPEQYx9RoZLgGEYiK/wC4kzDJsT8lsz8V1DsbehAN0SnNv2BFVC6SrCPIwHFoHM0Q8QAUfDROJR0l2KPERIjxFOMaUUjWcvEpOGUtWfqOS0/UU+pY8z99DbWNnIimhbES6lzoJiZi70S2lUIq9+jL+OvWiVLaEQy/CXrpbUJbh6RQ0jbuEKvMULG4iopwx1KiJqFYIAZYhliYX5AFEI/wVGIesGQKhJVtcQ6lV8Q9M95vUuyAyusBcQ2pKyZy7cL+S4+UhKGk/wDPQTCSzr/E7hHZmD5VVcSyqvf1PgJiFOyV8kNxcTpKRwsQNPSGYENyX8jBoqZeW4PlMYqy3CdJuqQ7AgHmWfNcuX6N8H0mktgCLcsLvJCaDxADXpfpiolwkzqPEQ3hHrlRryjVKw+DcE3macQTmYnHu5nHuHyPEQlaMEW6O0u8neaR9H1IeyhinNocifEc5f5Nc/kRsK9lmIta6xTBmPoM14f2Aq7JftJWIeypSb0XMpaNQ4gOSNasPeaBl9/ioYgpCpfYeI8XBl66R6F9TFqfuGlkzT3huEg3Mu5WJlUf4K/7Ml3avS/cgmoPkMtKi+4cEnSWabHuTQIz9h8eAQy9uVCqmMtf5HjH1OffsOYXAAoSKoLgsdtWZQ5nW+ASiQhsPEUlBOOp2ZzfIiOSCPT2nuqVBMh4m9N/UPaeJg2Y5FHzOln3Ne03tnd+Shm7HiIrVdOICfEjtFdGA4ZiGZXw1iVEO4phCohus1I8QBivlPSh3N+IitToMNdXtBtFU1iZh9/Pz/DR4mrPEUrAjjLKeFe0oUbd5rGCdvd+wr0uX3lOs0DBv+GvRB3M6DEGyukAYU7ROCroxD0Snl8RpavxO1Pz00wiF+qyzSH3L8/7MbwvMw+LCbEYP8iHibsH8gLqBcIBwgPBOweCdqYtPEOhKgPRrmaZa+4EFR/7AcJ/JUz7L7xLkiJp5nYesn//2Q==\" alt=\"img\" /></p>\n<p>简单的缟缟处理非常简单，使用  <code>havsfunc.daa()</code>  即可。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%88%9D%E7%BA%A7%E8%A7%86%E9%A2%91%E7%91%95%E7%96%B5%E4%BF%AE%E5%A4%8D/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%88%9D%E7%BA%A7%E8%A7%86%E9%A2%91%E7%91%95%E7%96%B5%E4%BF%AE%E5%A4%8D/",
            "title": "第九章初级视频瑕疵修复",
            "date_published": "2024-03-16T15:12:46.000Z",
            "content_html": "<h1 id=\"第九章-初级视频瑕疵修复\"><a class=\"anchor\" href=\"#第九章-初级视频瑕疵修复\">#</a> 第九章 初级视频瑕疵修复</h1>\n<p>瑕疵处理是视频压制的一个核心课题。不论是 vcbs 还是其他压制者，很多会在发布页上写一点吐槽，说明自己做了些什么处理。然而，为什么压制者需要处理瑕疵呢？</p>\n<p>首先是观感的影响。“瑕疵” 是一个很直觉的感受，我们即使不从一个科学的角度定义，也可以判断片源是否具有瑕疵。同样的，我们也能直觉地比较瑕疵 “修复前” 和 “修复后” 的改善。</p>\n<p>其次是编码的问题。假如 “瑕疵” 无法被肉眼在播放时察觉，我们是否应该修复呢？站在压制者的角度上，这个问题的答案通常是  Yes。原因是压制的本质是二次压缩，对于在第一次编码时引入的瑕疵，在第二次编码时会被当做输入来处理。结果就是瑕疵通常占用了不必要的空间，又或者在二次压缩时遭到强化。</p>\n<p>瑕疵修复是必定有副作用的。为了消除瑕疵，可以对画质做出多大的牺牲呢？</p>\n<p>这个问题并没有一个标准答案。画质的牺牲和瑕疵处理的完全度是一个取舍的关系。取舍的程度实际上就是每位压制者的核心烦恼。而瑕疵处理手段则决定了取舍的效率。本章会带大家了解多种瑕疵处理手段的效果和副作用，相信大家学完本章后会对这个问题有更深的体会。</p>\n<h2 id=\"1-降噪-denoise\"><a class=\"anchor\" href=\"#1-降噪-denoise\">#</a> 1. 降噪 Denoise</h2>\n<h3 id=\"1-addnoise\"><a class=\"anchor\" href=\"#1-addnoise\">#</a> (1). addnoise</h3>\n<p>在讲降噪 denoise 之前，先讲一下加噪 addnoise。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>blank16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>BlankClip<span class=\"token punctuation\">(</span>width<span class=\"token operator\">=</span><span class=\"token number\">1920</span><span class=\"token punctuation\">,</span> height<span class=\"token operator\">=</span><span class=\"token number\">1080</span><span class=\"token punctuation\">,</span> color<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">32768</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">format</span><span class=\"token operator\">=</span>vs<span class=\"token punctuation\">.</span>GRAY16<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>blank16<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>addnoise16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>grain<span class=\"token punctuation\">.</span>Add<span class=\"token punctuation\">(</span>blank16<span class=\"token punctuation\">,</span> var<span class=\"token operator\">=</span><span class=\"token number\">10.0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>addnoise16<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>addconstnoise16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>grain<span class=\"token punctuation\">.</span>Add<span class=\"token punctuation\">(</span>blank16<span class=\"token punctuation\">,</span> var<span class=\"token operator\">=</span><span class=\"token number\">10.0</span><span class=\"token punctuation\">,</span> constant<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>addconstnoise16<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>我们最常用的加噪滤镜叫  <code>core.grain.Add</code> 。<br />\n在实际使用上，我们基本只会更改  <code>var</code>  和  <code>constant</code>  这两个参数。</p>\n<p>在上面这段代码里， <code>0</code>  号输出时一个灰色的空白片段。<br />\n大家尝试播放一下  <code>1</code>  号和  <code>2</code>  号输出。</p>\n<p><code>1</code>  号的  <code>constant</code>  的预设值为  <code>false</code> ，所以  <code>grain.Add</code>  预设是生成动态噪点的。<br />\n当设为  <code>true</code>  时则生成静态噪点。</p>\n<p>参数  <code>var</code>  则定义了噪点的强度，这里设成  <code>10</code>  是为了让噪点比较容易目视。<br />\n当我们为 bdrip 加噪保护细节的时候，通常  <code>var</code>  会设置在  <code>0.5</code>  左右。<br />\n静态噪点也不常用，因为容易造成毛玻璃的感觉。</p>\n<h3 id=\"2-rg20\"><a class=\"anchor\" href=\"#2-rg20\">#</a> (2). RG20</h3>\n<p>本章所需的样例视频放在 Release 的 sample.7z 中，如无特殊说明，后续示例脚本的视频源均取自这里，请在运行时修改为你本地的实际路径。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">R\"Z:\\00007.m2ts\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> bits<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>src8<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>nr16A <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>RemoveGrain<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> mode<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>noise16A <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> nr16A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'32768'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>nr16A<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>noise16A<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>运行上述脚本，切换至第 1466 帧，我们用这帧作为例子解说。<br />\n观察一下  <code>0</code>  号输出和  <code>1</code>  号输出，有需要的话可以放大一点看。</p>\n<p>可以看到，这是一段制作很烂的 BDMV 片源，细看可以发现的部分有噪点，然后整体有色带，色带部分我们先无视。<br />\nRG20 可以移除噪点，但是有让线条变糊的副作用，如果切换到输出  <code>2</code> ，会显示的更为清楚。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1466_0.png\" alt=\"img\" /></p>\n<p>对降噪前后的画面进行 diff 后我们得到噪点层 (grain layer /noise layer)。<br />\n在脚本里面，我们通常用 nr16 代表降噪后的输出，noise16 代表噪点层，16 代表 bit depth。</p>\n<p>这里我们加了一句  <code>.std.Expr(['x 32768 - 10 * 32768 +','32768'])</code>  来选择性增强和观看 Y 平面的噪点。<br />\n观察这副噪点层的话，我们可以有几个观察：</p>\n<ol>\n<li>RG20 的确将噪点分离了，在平面上我们可以清楚看到噪点的模样。</li>\n<li>噪点层出现很明显的线条轮廓，这代表 RG20 将线条的 “锐度” 分离了出来，并加到噪点层去。这个现象明显是不理想的。</li>\n<li>如果比对输出  <code>0</code>  和  <code>1</code>  是比较难察觉的，后面的森林的一些纹理细节也被分离到噪点层了。在左上角，我们可以看到隐约树和光点的轮廓。</li>\n</ol>\n<p>总的来说，观察 2. 和 3. 属于 RG20 的副作用。其副作用之大，相信大家都能判断 RG20 不可能直接用于降噪。</p>\n<p>那么这里问大家一个问题：如果是一个理想的 denoiser, 它的噪点层看起来会是怎样的呢？是不是应该跟 addgrain 的效果很相近呢？</p>\n<p>假设图像的噪声是均匀的话，是的。理想的 denoiser 不应该看到任何轮廓，而是只提取出图像的噪声部分。大家评价降噪效果的好坏可以从尝试这一点入手。</p>\n<h3 id=\"3-bilateral\"><a class=\"anchor\" href=\"#3-bilateral\">#</a> (3). Bilateral</h3>\n<p>接下来我们用下一个降噪滤镜，Bilateral Filter。</p>\n<p>Bilateral Filter 是一个很经典的滤镜了，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlsYXRlcmFsX2ZpbHRlcg==\">wiki</span> 上有详细的描述。早期也曾经被用在 BDRip 上。</p>\n<p>请往下追加这段代码：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>nr16B <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>bilateral<span class=\"token punctuation\">.</span>Bilateral<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> sigmaS<span class=\"token operator\">=</span><span class=\"token number\">3.0</span><span class=\"token punctuation\">,</span> sigmaR<span class=\"token operator\">=</span><span class=\"token number\">0.02</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>noise16B <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> nr16B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'32768'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>nr16B<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>noise16B<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里我们先选用预设的参数， <code>sigmaS=3.0, sigmaR=0.02</code> ，<br />\n大家可以观察一下噪点层，看看比起 RG20 有没有什么改进的地方。</p>\n<blockquote>\n<p>实际操作，你可以快速切换  <code>1</code> / <code>3</code> ,  <code>2</code> / <code>4</code>  号输出来比对</p>\n</blockquote>\n<p>首先第一个发现，线条的锐利度 Bilateral 的确保留得更好。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1466_1.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1466_1_Bilateral.jpg\" alt=\"img\" /></p>\n<p>然而，Bilateral 对纹理的细节保护不好，而这种弱线条是一个很好的例子。</p>\n<p>除了这两点以外，我们还能看到右上角树的轮廓更清晰了。</p>\n<p>然后就是平面上，大家应该能看到 Bilateral 分离出来的噪点要比 RG20 “多” 或者 “强”。</p>\n<blockquote>\n<p>这点大家可以放大到 400%，切换  <code>2</code> 、 <code>4</code>  来看</p>\n</blockquote>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1466_2.jpg\" alt=\"img\" /></p>\n<p>而最后一个有趣的发现是这里。比对一下源和 Bilateral 的话，大家会发现线条变锐利了。</p>\n<p>这是 Bilateral 的一个算法上的缺陷。（这个缺陷对应 staircase effect 或者 gradient reversal 的其中一个，详细就不讲了）</p>\n<p>大家可以尝试改一下  <code>sigmaR=0.02</code>  这个参数，改成  <code>0.01</code>  或者  <code>0.03</code>  试试。</p>\n<blockquote>\n<pre><code>sigmaR=0.01\n</code></pre>\n</blockquote>\n<blockquote>\n<pre><code>sigmaR=0.03\n</code></pre>\n</blockquote>\n<p>在降噪滤镜里，用 <em>sigma</em> 开头的参数通常<strong>控制降噪的力度</strong>。</p>\n<p>Bilateral 比较关键的是  <code>sigmaR</code> 。<br />\n大家如果比较  <code>0.01</code>  和  <code>0.03</code>  的话，会发现平面噪点的强度是差不多的，但是线条轮廓的强度差别很大。</p>\n<p>这里反映一个关于降噪滤镜调参的要点：<strong>sigma 参数是需要调节的</strong>。</p>\n<ol>\n<li>太小的 sigma 无法完全分离噪点层，</li>\n<li>很高的 sigma 虽然可以完全分离早点，但副作用会不成比例的提升。</li>\n</ol>\n<p>所以需要摸索一个刚好不大不小的。这个最佳的大小是按照源的噪点的强度来定义。</p>\n<p>因为 Bilateral 对纹理的损伤大，所以有更好的替代品后，我们就不再用它降噪了。</p>\n<p>不过由于 Bilateral 能够选择性糊掉纹理而不怎么动线条，我们可能会在其他地方用到它。</p>\n<h3 id=\"4-dfttest\"><a class=\"anchor\" href=\"#4-dfttest\">#</a> (4). dfttest</h3>\n<p>接下来要讲的是两个实际压制会用得上的降噪滤镜： <code>dfttest</code>  和  <code>nlmeans</code> 。</p>\n<p>先讲的是 dfttest，文档在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hvbWVPZlZhcG91clN5bnRoRXZvbHV0aW9uL1ZhcG91clN5bnRoLURGVFRlc3Q=\">这里</span>。</p>\n<p>请往下追加这段代码：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>nr16C <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>dfttest<span class=\"token punctuation\">.</span>DFTTest<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> sigma<span class=\"token operator\">=</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span> tbsize<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>noise16C <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> nr16C<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'32768'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>nr16C<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>noise16C<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>由于它的实现涉及到 dft, 参数非常多，复杂，长，难以理解。<br />\n基础的使用上只需要调整 sigma 就可以了。</p>\n<p>我们这里选用预设的  <code>sigma=8</code> , 另外设  <code>tbsize=1</code> , 关闭 dfttest 的时域降噪功能。</p>\n<p>实际使用上建议维持  <code>tbsize=1</code> ，因为 dfttest 的时域降噪有些特殊情況。</p>\n<p>观察一下输出  <code>5</code>  和  <code>6</code> ，噪点层（输出  <code>6</code> ）会隐约看到头发的线条轮廓，但是其他纹理就几乎看不到了。</p>\n<p>而且如果切换回 nr16（ <code>5</code>  号输出）和源（ <code>0</code>  号输出）之间对比，线条的锐度差异就已经是很微小的差别了。</p>\n<p>重要的是，假如我们丢弃了这个分离出来的噪点层，对 nr16 进行一点点补偿性锐化，那么在肉眼看来，我们就是成功的移除了噪点瑕疵，而保留了线条锐度和纹理细节。</p>\n<p>然后，大家可以试着切换不同的帧看看。<br />\n举个例子，可以看 1988 帧，一个夕阳下的场景。</p>\n<p>比对 Bilateral 的  <code>4</code>  号输出和 dfttest 的  <code>6</code>  号输出，你会发现 dfttest 的噪点层仿佛保留了所有噪点，但是排除了近乎所有的纹理线条细节。</p>\n<blockquote>\n<pre><code>Bilateral\n</code></pre>\n</blockquote>\n<blockquote>\n<pre><code>dfttest\n</code></pre>\n</blockquote>\n<p>接下来切换到另一个场景，2060 帧。<br />\n这个是一个天空和云的画面，可以观察一下蓝天的噪点和白云的噪点，看起来有什么差别。</p>\n<p>从 dfttest 的噪点层（ <code>6</code>  号输出）可以看到：蓝天的噪点比较粗糙，两者噪点有点粗细不同的感觉。</p>\n<p>同一个画面下，其实噪点模样通常是不一致的。<br />\n在 2060 里，有些噪点比较细致，有些比较粗造（看起来像一堆重叠的方块，不是一个个独立的点）</p>\n<p>如果切换回 1988，这里的分别就更明显了。可以看到噪点呈大方格装的感觉，根本不是 “噪点”。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1988_1.jpg\" alt=\"img\" /></p>\n<p>这个观察反映出另一个要点：在我们接触到的大部分压制源上，<strong>噪点（噪声）跟 addgrain 的差别非常远</strong>。</p>\n<p>这证明了 denoise 并不是 addgrain 的一个逆操作。</p>\n<p>我们通常可以这样假设：<br />\n制作方使用了类似 addgrain 的操作，在经过第一次编码后，噪点丧失了原有的形态。<br />\n我们在压制处理时，就需要移除这些 “残留物”，以防他们影响观感，或者占用码率。</p>\n<p>现在 dfttest 我们选用了  <code>sigma=8</code> ，而作为课后练习，大家可以试试 sigma 取多少才更适合这份素材。</p>\n<h3 id=\"5-nlmeans\"><a class=\"anchor\" href=\"#5-nlmeans\">#</a> (5). nlmeans</h3>\n<p>接下来，我们来尝试本章要介绍的最后一个降噪滤镜，nlmeans。</p>\n<p>这里选用的是  <code>nlm_ispc</code> , 由 vcbs 总监 Mu 写的一个 nlmeans 算法的实现: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdnMtbmxtLWlzcGM=\">vs-nlm-ispc</span>。<br />\n详细的调参可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0toYW5hdHRpbGEvS05MTWVhbnNDTC93aWtpL0ZpbHRlci1kZXNjcmlwdGlvbg==\">这里</span>。</p>\n<p>请往下追加这段代码：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>nr16D <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>nlm_ispc<span class=\"token punctuation\">.</span>NLMeans<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> d<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> wmode<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> h<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>noise16D <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> nr16D<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'32768'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>nr16D<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>noise16D<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里相比预设更改了几个参数：</p>\n<ul>\n<li><code>d=0</code>  代表关闭时域降噪。</li>\n<li><code>wmode=3</code>  比预设的  <code>wmode=0</code>  效果更好，建议用  <code>3</code> 。</li>\n<li><code>h</code>  是降噪的力度（虽然没有 sigma 在名字里），预设的  <code>1.2</code>  太弱，为了适配这片子这里加到  <code>3</code> 。<br />\n大家初期使用的话，只更改  <code>h</code>  就差不多了。</li>\n</ul>\n<p>按照上面，大家可以比对一下 dfttest 和 nlmeans 的输出（主要看噪点层，输出  <code>6</code>  和  <code>8</code> ）。</p>\n<blockquote>\n<p>提示一个对比的方法， <code>core.std.MakeDiff(noise16C, noise16D).set_output(9)</code></p>\n</blockquote>\n<p>nlmeans 大体上是一个比 dfttest 更能保护纹理线条的 denoiser。</p>\n<p>我们继续以 1466 帧为例子，比如说在这发亮的轮廓部分，nlmeans 甚至选择了完全不降噪（噪点层数值为  <code>128</code> ）。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1466_4.png\" alt=\"img\" /></p>\n<p>比起 dfttest，nlmeans 也避开了一下低频，像波浪般的细节，只是移除了更细的噪点部分。</p>\n<blockquote>\n<p>在刚才的  <code>9</code>  号输出可以看得更清楚</p>\n</blockquote>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1466_5.jpg\" alt=\"img\" /></p>\n<p>所以在实际操作上，特别是 webrip，有很多总监喜欢用 nlmeans。</p>\n<p>初阶的降噪技巧就到这里，总结一下，我们提到了：</p>\n<ol>\n<li>RG，Bilateral, dfttest, nlmeans 这 4 种循序渐进的 denoiser</li>\n<li>如何透过观察噪点层判断降噪效果的好坏</li>\n<li>理解到在实际片段中，噪点的形态不止一种，也跟 addgrain 的模样大相径庭</li>\n</ol>\n<p>实际应用中还有更先进的降噪算法，比如目前广泛使用的 BM3D、甚至一些 AI 降噪滤镜，不过这些属于高级降噪内容，就不在本章的范围之内了。</p>\n<p>Bilateral, DFTTest 和 nlmeans 都有 GPU 加速实现：<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dvbGZyYW1SaG9kaXVtL1ZhcG91clN5bnRoLUJpbGF0ZXJhbEdQVQ==\">https://github.com/WolframRhodium/VapourSynth-BilateralGPU</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdnMtZGZ0dGVzdDI=\">https://github.com/AmusementClub/vs-dfttest2</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdnMtbmxtLWN1ZGE=\">https://github.com/AmusementClub/vs-nlm-cuda</span></p>\n<p>nlmeans 还有一个更老的实现 KNLMeansCL，不过由于 openCL 环境的可用性难以保障，现在更推荐用 vs-nlm-cuda 或者 vs-nlm-ispc 进行替代。<br />\n调参可以仍然参考 KNLMeansCL 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0toYW5hdHRpbGEvS05MTWVhbnNDTC93aWtpL0ZpbHRlci1kZXNjcmlwdGlvbg==\">Wiki</span>。</p>\n<h2 id=\"2-去色带-deband\"><a class=\"anchor\" href=\"#2-去色带-deband\">#</a> 2. 去色带 Deband</h2>\n<h3 id=\"1-重温色带\"><a class=\"anchor\" href=\"#1-重温色带\">#</a> (1). 重温色带</h3>\n<p>首先重温一下色带的现象，我们一般容易在一些低位深源的暗场颜色过渡区域看到色带。</p>\n<p>这里有两个要素，第一个是颜色过渡，第二个是低位深源。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/banding_colour.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/banding_image.jpg\" alt=\"img\" /></p>\n<p>在有颜色渐变的地方，无论亮场和暗场都容易出现色带。</p>\n<p>如果用图来显示，一个渐变区域可以画成这样：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/graph_00.jpg\" alt=\"img\" /></p>\n<p>X 轴是空间，而 Y 轴是像素的亮度。</p>\n<p>但是由于源的位深有限制，在编码后这条斜线会变成阶梯状：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/graph_01.jpg\" alt=\"img\" /></p>\n<p>每个阶梯对应一个整数的像素亮度。<br />\n当位深越低，阶梯之间的间隔就越大。<br />\n在达到某一个大的间隔后，人眼就能察觉并辨认为色带了。</p>\n<p>既然低位深容易产生色带，那么位深要到多少才不容易 / 不会有色带呢？<br />\n有人可能会说 10bit 是被认为是不容易出色带的，但是为什么呢？</p>\n<p>实际上这是个陷阱题。<br />\n8bit 容易出色带，10bit 不容易是基于经验的观察。<br />\n实际上无论位深有多高，阶梯是必定会出现的，只是间距会有差别。</p>\n<p>我们关注的纯粹是 “以一般人类视觉而言，不容易察觉到色带的状况”。</p>\n<p>在 bt.709 色域下，工程师总结出 10bit-YUV 不容易产生人眼能察觉的色带。<br />\n而如果我们换成 HDR 色域的话，由于颜色范围的增大，通常被认为需要 12bit-YUV 才足够。</p>\n<blockquote>\n<p>位深不变的话，数量还是那么多，但范围大了，精度就变差了，所以可能需要提高位深来弥补。</p>\n</blockquote>\n<p>所以这里是第一个重点：<strong>色带处理的目标实际上是要骗过人的眼睛</strong>。<br />\n小色带是必定会存在的，只要无法被肉眼察觉就可以。</p>\n<p>接下来，我们说一下在维持位深不变的情况下，防止色带的原理。<br />\n这个方法我们统称为 <em>dithering</em> (抖动)。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/graph_02.jpg\" alt=\"img\" /></p>\n<p>如果在刚才的图上面表示，dither 大概看起来像这样。<br />\n透过在阶梯的两侧加入一些 “上下抖动” 的变化，我们让肉眼误认这是一段连续的颜色变化。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/banding_colour.png\" alt=\"img\" /></p>\n<p>实际效果就如上面红黑色的图一般。</p>\n<p>然而，加入抖动的副作用是，抖动本身看起来就像一些噪声，会让图像看起来有些粗糙。<br />\n这个可以用下图很好地说明。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/gif_22_07_25_00.gif\" alt=\"img\" /></p>\n<p>在这张 gif 里面，可以观察一下肉色的部分。<br />\n我们可以隐约看到三种肉色的变化，但是由于抖动的存在，看上去就像是连续的渐变色 + 上面有很重的动噪。<br />\n这种 dithering 有一个统称，叫 <em>random dithering</em>，意思是加进去的抖动有随机性，看起来像是噪声。</p>\n<p>而在下一幅 gif, 这里加入的是另一种形式的抖动，叫 <em>ordered dithering</em>。<br />\n大家会察觉到有一层难看的网格状噪点，这就是 ordered dither 的特色。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/gif_22_08_28_00.gif\" alt=\"img\" /></p>\n<p>原则来说，由于网格辣眼睛，我们会尽量选择 random dithering 作为去色带的手段。</p>\n<p>最后一幅的 gif，是用来说明我们日常会看到色带的情况。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/gif_23_01_03_00.gif\" alt=\"img\" /></p>\n<p>观察左上角这里，我们会看到虽然色带附近有抖动，但抖动似乎只存在于色带的边缘部分，并没有覆盖整个颜色变化区域。</p>\n<p>实际上，这种现象广泛出现在各种（BD）源里：</p>\n<ul>\n<li>尽管制作方即使加入了一点抖动，但是由于强度不足或者编码器不听话，抖动最终不足以掩盖色带。</li>\n<li>另一方面，色带的边缘也不会是很漂亮的，有连贯性的边缘。</li>\n</ul>\n<h3 id=\"2-f3kdb\"><a class=\"anchor\" href=\"#2-f3kdb\">#</a> (2). f3kdb</h3>\n<p>下面我们进入实操，新开一个 vpy，使用前面的  <code>00007.m2ts</code>  视频源，运行下面代码。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> mvsfunc <span class=\"token keyword\">as</span> mvf</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">R\"Z:\\00007.m2ts\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> bits<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>src8<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>nr16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>nlm_ispc<span class=\"token punctuation\">.</span>NLMeans<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> d<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> wmode<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> h<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>nr16<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>nr16U <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>nr16U<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\"># https://f3kdb.readthedocs.io/en/stable/usage.html</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>dbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> <span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">96</span><span class=\"token punctuation\">,</span> cb<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> cr<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> grainy<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> grainc<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>dbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>dbed<span class=\"token punctuation\">,</span> <span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">72</span><span class=\"token punctuation\">,</span> cb<span class=\"token operator\">=</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> cr<span class=\"token operator\">=</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> grainy<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> grainc<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>dbdiff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> dbed<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>dbed<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>dbdiff<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 20 * 32768 +'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>运行后切换到 777 帧，比对一下  <code>0</code> ,  <code>1</code>  和  <code>3</code>  号输出，观察一下有什么变化。</p>\n<p>经过观察可以看出来， <code>1</code>  号是降噪过的 nr16，我们用了 NLMeans 对画面进行降噪。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>nr16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>nlm_ispc<span class=\"token punctuation\">.</span>NLMeans<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> d<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> wmode<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> h<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>nr16<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>然后我们对降噪后的输入进行了强力的 deband。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>dbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> <span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">96</span><span class=\"token punctuation\">,</span> cb<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> cr<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> grainy<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> grainc<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>dbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>dbed<span class=\"token punctuation\">,</span> <span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">72</span><span class=\"token punctuation\">,</span> cb<span class=\"token operator\">=</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> cr<span class=\"token operator\">=</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> grainy<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> grainc<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>我们最常用的 deband 滤镜叫做 f3kdb。<br />\n当中需要调参的参数有 4 个： <code>range</code> ,  <code>y</code> ,  <code>cb</code>  和  <code>cr</code> 。<br />\n <code>y</code> ,  <code>cb</code>  和  <code>cr</code>  分别对应 YUV 三个平面的去色带力度，而  <code>range</code>  是一个比较特殊的参数。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/graph_01.jpg\" alt=\"img\" /></p>\n<p>在这幅图，我们可以看到阶梯除了有高度（像素亮度）外，还有宽度。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/gif_23_01_03_00.gif\" alt=\"img\" /></p>\n<p>而从这幅图，我们吸取到的教训是抖动需要覆盖整个阶梯才行。</p>\n<p><code>range</code>  所决定的，简单来说就是抖动需要覆盖的范围。<br />\n视乎色带的宽度，我们会动态地调整  <code>range</code>  的大小。</p>\n<p>另一方面，连续进行两次 f3kdb 是我们的一个惯例。<br />\n这方法有两个好处，第一个是可以涵盖不同大小的色带，另一个是在处理大色带的时候，可以让效果看起来比较均匀。</p>\n<p>两次的 f3kdb 通常是  <code>range</code>  小的先行，大的在后；小的去色带力度给的较强，大的去色带力度给的较弱。<br />\n常见的  <code>range</code>  的配搭有  <code>8</code> + <code>16</code> ,  <code>12</code> + <code>24</code> , 或者  <code>16</code> + <code>31</code> , 选哪个视乎色带的形态。</p>\n<p>而去色带力度的话，通常较弱的 deband 我们会给  <code>40</code> / <code>30</code> ，最强的话不会超过  <code>100</code> 。</p>\n<p>在实操上，由于 deband 对一些元素的破坏力很强，我们需要很小心调节 deband 的力度。</p>\n<p>除了弱线条外，deband 还有一些副作用，眩光 / 光柱特效是常见的重灾区。</p>\n<p>可以切换到 986 帧观察一下，可以看见伸进海里的光柱被削弱削短了。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_986_0.jpg\" alt=\"img\" /></p>\n<p>整体来说，deband 通常对夜晚的云彩，光柱特效，弱线条这些大范围但是变化小的低频信息影响最大。</p>\n<h3 id=\"3-deband-后处理\"><a class=\"anchor\" href=\"#3-deband-后处理\">#</a> (3). Deband 后处理</h3>\n<p>接着上一节的脚本，我们回到第 777 帧，尝试把 f3kdb 的参数改成如下，看看有什么差别。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">64</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">48</span></pre></td></tr></table></figure><p>应该能看到弱线条被保留了一部分，相反头发上多了一点粗糙感，比如原本快被磨光了的头发中间的一条线又能看见一点了。</p>\n<p>然而，作为削弱 deband 的代价，头发下方的颜色比较深的部分似乎也有一点点色带残留。</p>\n<p>除了调整 f3kdb 的参数外，我们还有另一个方法去限制 deband 的力度 —— 利用 LimitFilter。</p>\n<p>请往脚本里追加这段代码：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>limitdbed <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>LimitFilter<span class=\"token punctuation\">(</span>dbed<span class=\"token punctuation\">,</span> nr16<span class=\"token punctuation\">,</span> thr<span class=\"token operator\">=</span><span class=\"token number\">0.55</span><span class=\"token punctuation\">,</span> elast<span class=\"token operator\">=</span><span class=\"token number\">1.6</span><span class=\"token punctuation\">,</span> planes<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>limitdbdiff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> limitdbed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 20 * 32768 +'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>limitdbed<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>limitdbdiff<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>当 LimitFilter 的  <code>thr</code>  设置为  <code>0.45</code> - <code>0.55</code> ,  <code>elast</code>  在  <code>1.5</code>  左右的时候，它的曲线是适合用来限制 deband 效果的。</p>\n<p>比对一下输出  <code>4</code>  和  <code>6</code> ，它们的 dbdiff, 即是 deband 前后的差。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_986_dbdiff.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_986_limitdbdiff.png\" alt=\"img\" /></p>\n<ol>\n<li>变化强烈的地方得到抑制，</li>\n<li>变化没那么大（特别是颜色）被保留下来。</li>\n</ol>\n<p>这反映了 LimitFilter 的一个工作原理：对小的变化保留，对大的变化抑制。</p>\n<p>我们会选  <code>0.55</code>  的主要原因，是因为在 8-bit 下，色带两个 “梯级” 的差别不会超过 1。<br />\n所以梯级两面分别给大概  <code>0.5</code>  的抖动，理论上就能很好的掩盖色带。</p>\n<p>如果抖动的幅度大幅超过了 0.5，那证明它并不是在消除色带，而是被误判为色带的一些细节。</p>\n<p>大家可以尝试把  <code>thr</code>  调到  <code>1</code>  左右，这样的话，LimitFilter 就几乎完全失去作用了。</p>\n<h3 id=\"4-deband-预处理\"><a class=\"anchor\" href=\"#4-deband-预处理\">#</a> (4). Deband 预处理</h3>\n<p>为什么我们大多数情况要先 denoise, 然后才 deband 呢？</p>\n<p>其中一个原因是，以 f3kdb 为例的 deband 滤镜会使用 dither 避免 banding，但 denoise 这个行为会破坏抖动。<br />\n因此 deband 后我们通常不能对画面进行 denoise 之类的低通滤镜，以免破坏 f3kdb 加入的 dither。</p>\n<blockquote>\n<p>不加 dither 而直接在高位深将色带平滑掉的方法叫 GradFun3，这个会在后文提到。</p>\n</blockquote>\n<p>另一个原因是，保留噪点的话可能会干扰 deband 的效果，这点我们用接下来的例子说明。</p>\n<p>请大家把输入改成这个源，并切换到 1637 帧。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a = R\"Z:\\CRIMEEDGE1_00002.m2ts\"</pre></td></tr></table></figure><p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1637_0.jpg\" alt=\"img\" /></p>\n<p>在这个圆形部分有很强烈的色带。</p>\n<p>接下来，将上面脚本的 f3kdb 参数换为 12,64,48,48 + 24,48,32,32，切换到  <code>3</code>  号输出，观察一下色带是否清除干净了。</p>\n<p>可以看到，基本上都清理干净了，除了下图部分细看有点略微的残留。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1637_1.png\" alt=\"img\" /></p>\n<p>接下来，再追加下面这段代码：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>srcdbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">64</span><span class=\"token punctuation\">,</span> cb<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> cr<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> grainy<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> grainc<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>srcdbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>srcdbed<span class=\"token punctuation\">,</span> <span class=\"token builtin\">range</span><span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> cb<span class=\"token operator\">=</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> cr<span class=\"token operator\">=</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> grainy<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> grainc<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>srcdbdiff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> srcdbed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 20 * 32768 +'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>srcdbed<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>srcdbdiff<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里我们选用了 src16 而不是 nr16 作为输入，其余的参数设定都是一样的。</p>\n<p>比对一下  <code>0</code>  号和  <code>7</code>  号输出，看看色带有没有被清除掉。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1637_2.jpg\" alt=\"img\" /></p>\n<p>有色带的大概是这 3 个部分。应该可以看到色带约莫是少了一点点，但整体还在，跟先 denoise 再 deband 的效果相差很远。</p>\n<p>如果观看  <code>4</code>  号和  <code>8</code>  号的 dbdiff, 会更加明显。</p>\n<p>denoise-deband 的 dbdiff 可以看到有一些波浪形态的变化；而 source-deband 的 dbdiff 就只能看到噪点，没有波浪形的变化。</p>\n<p>而波浪形的变化，实际上就是 f3kdb 抵消掉色带的效果。</p>\n<p>这部片的特色是制作方加入了很强的静噪，看上去就像有毛玻璃一样，然而这静噪下面隐藏着色带。<br />\n这份静噪也干扰了 f3kdb 辨认噪点的能力，导致必须要先 denoise 才可以 deband。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1637_dbed.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1637_srcdbed.png\" alt=\"img\" /></p>\n<p>我们总结一下:</p>\n<p>去色带处理的基本方式是：先 denoise，然后 2pass-f3kdb deband。<br />\n这个流程我们通常称为  <code>nr-deband</code> ，nr 是 noise removal 的简写。</p>\n<p>降噪基本对于色带处理是利多于弊的。</p>\n<p>然而 deband 处理通常会波及纹理细节，所以在调参上，deband 通常是最花时间的一个步骤，也是压制者最需要在细节和瑕疵移除之间取舍的一个处理。</p>\n<h3 id=\"5-高强度-deband-gradfun3\"><a class=\"anchor\" href=\"#5-高强度-deband-gradfun3\">#</a> (5). 高强度 Deband —— GradFun3</h3>\n<p>本小节请大家先开一个新的 vpy，然后载入  <code>MINORI2_00004.m2ts</code> ，用 474 帧作为例子。</p>\n<p>在开始前先请大家思考一个问题，这草地看上去像色带吗？<br />\n这个问题的回答先暂时放一边，后续再来解释为什么要这样问。</p>\n<p>本小节介绍一个比 f3kdb 更强力的 deband 方法叫， <code>GradFun3</code> 。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> muvsfunc</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>dbed <span class=\"token operator\">=</span> muvsfunc<span class=\"token punctuation\">.</span>GradFun3<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>dbdiff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> dbed<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>dbed<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>dbdiff<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'x 32768 - 20 * 32768 +'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>GradFun3 本身并不是一个 “滤镜”，而是一个 vsfunc，由多个小的滤镜组合。<br />\n源码可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dvbGZyYW1SaG9kaXVtL211dnNmdW5jL2Jsb2IvNjIwM2E3MWNjNWFhOGJiYTJmNGY5NWFmZTNmNjE1OTVmOWVhMGQ4NC9tdXZzZnVuYy5weSNMNTAwLUw2Njk=\">这里</span>。</p>\n<p>GradFun3 的调参主要依靠  <code>thr</code>  和  <code>elast</code>  两个参数。</p>\n<p>这不是一个巧合，GradFun3 是利用了 LimitFilter 来调整 deband 效果大小。<br />\n由于源码比较复杂，而且大部分内容这里没有涉及，所以我们这里就不详细分析了。</p>\n<p>简化地说，GradFun3 是先利用 Bilateral 或者 DFTTest 对画面做一个模糊，然后做一个 detail/edge mask（遮罩）尝试保护纹理和线条。</p>\n<p>那么，默参的 GradFun3 能清干净 474 帧的色带吗？<br />\n观察后可以发现，不行。所以我们要增强一下 GradFun3 的威力。</p>\n<p>可以看到，它的默认参数是  <code>thr=0.35, elast=3.0</code> ，那么试试填一个更强的参数？</p>\n<p>我们回顾一下 LimitFilter 的内容，LimitFilter 的特性主要是由 thr 和 thr*elast 来定义的。</p>\n<ul>\n<li>thr 定义什么值开始有削弱效果</li>\n<li>thr*elast 定义最大允许的变化值</li>\n</ul>\n<p>所以在调参的时候，你可以尝试：</p>\n<ol>\n<li>固定 thr*elast, 然后提高 thr</li>\n<li>固定 thr 和 elast 的相对比例，两个一起提升</li>\n</ol>\n<p>在 deband 的状况下，可能第一个状况比较贴合。不需要调整最大值，只需要调低 LimitFilter 的削弱效果。</p>\n<p>所以我们先试试用  <code>thr=0.7, elast=1.5</code>  的组合，再观察一下草地的变化。<br />\n可以看到，现在色带变得稍微不明显了一点，平滑了点，但好像还不太够。</p>\n<p>那么再提高点 elast, 比如说  <code>thr=0.7, elast=3.0</code>  呢？</p>\n<p>细心的同学可以看到，草坪和校舍的木纹都差不多要磨平了，但是草地中间这个分界线还是有点明显。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_474_0.png\" alt=\"img\" /></p>\n<p>然后切换到 1224 帧。<br />\n在 100% 缩放下，可以发现衣服上的（光照效果导致的）色带差不多已经擦干净了，但是放大仔细看还是有点残留。</p>\n<p>一个简单的总结，GradFun3 总而言之是比较难调参的。<br />\nthr 控制了 deband 最小的力度，thr*elast 控制了 deband 最大可以抹些什么。<br />\n另外其他可以改的参数都比较多。</p>\n<p>GradFun3 的出场通常是要牺牲大量细节也得抹色带的状况。它的最大效果就如同上一节降噪里，单独用 bilateral 轰纹理的状况。</p>\n<p>而另一方面，这个 MINORI 源是一个很好的参考例子，可以播一下这个片，你会发现大部分前景都是类似水彩的触感。</p>\n<p>比如说 321 帧，这个暗一点的地面，它上面的纹理可以说是水彩的笔触，也可以说是位深不足导致类似 GIF 的色带。因此要不要 deband 就成为一个两难问题了。</p>\n<p>这就回到了本小节开头的提问，对于这类水彩质感背景的画面，是否需要 deband 以及 deband 手段的强弱，是实际压制中需要仔细权衡的点。</p>\n<h2 id=\"3-抗锯齿-anti-aliasing\"><a class=\"anchor\" href=\"#3-抗锯齿-anti-aliasing\">#</a> 3. 抗锯齿 Anti-Aliasing</h2>\n<p>锯齿（aliasing）这个现象想必大家都不陌生，用一个简单的图解的话，就是在斜线区域，因为像素呈方形，所以看上去像一些阶梯。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/aliasing.jpg\" alt=\"img\" /></p>\n<p>要解决锯齿需要抗锯齿（Anti-Aliasing）处理。</p>\n<p>Anti-Aliasing 的本质就是给梯级之间填充一些灰色，好让它在远处看起来是顺滑的，而不是一个锯子。</p>\n<blockquote>\n<p>细心的同学会发现，其实色带和锯齿是很类似的现象，两者都是一个平滑斜线的信息，因为分辨率或者位深有限，而变成的阶梯状。而修正的方法是给阶梯之间填充一些 “过渡性” 的信息。</p>\n</blockquote>\n<h3 id=\"1-aa-效果\"><a class=\"anchor\" href=\"#1-aa-效果\">#</a> (1). AA 效果</h3>\n<p>请开一个新的 vpy，运行下面这段代码，切换到 882 帧。<br />\n观察一下  <code>0</code>  号输出，源画面什么地方有锯齿出现？</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> mvsfunc <span class=\"token keyword\">as</span> mvf</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">R\"Z:\\CLOCKWORK1_00007.m2ts\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> bits<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>src8<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">aa_process_eedi2</span><span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    w <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>width</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    h <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>height</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mthresh<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> lthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> vthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> maxd<span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> nt<span class=\"token operator\">=</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mthresh<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> lthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> vthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> maxd<span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> nt<span class=\"token operator\">=</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>aa_clip<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aaed<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">return</span> aaed</pre></td></tr><tr><td data-num=\"22\"></td><td><pre> </pre></td></tr><tr><td data-num=\"23\"></td><td><pre>eedi2_aa <span class=\"token operator\">=</span> aa_process_eedi2<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>eedi2_aa_diff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> eedi2_aa<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>eedi2_aa<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>eedi2_aa_diff<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这画面最明显有锯齿的是书页侧面的部分：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_882_0.jpg\" alt=\"img\" /></p>\n<p>其余的玩偶轮廓，还有小女孩，整体都是有一个锯齿的感觉。</p>\n<p>会有这种感觉，主要是因为制作方并非完全没有 Anti-Aliasing。<br />\n他们做出来的效果介乎于完全没有和做好之间（就像色带那样）。<br />\n所以才会有 “锯齿感”，但又不是完全锯齿的感觉。</p>\n<p>然后，我们切换到输出  <code>3</code> ，可以看到锯齿几乎都消失了。</p>\n<p>比如说书页顺滑了不少。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_882_1.jpg\" alt=\"img\" /></p>\n<p>不过，作为抗锯齿的代价，我们会觉得线条变糊了一点，少了一点锐利度。</p>\n<p>如果切换到  <code>4</code>  号输出，对比抗锯齿前后的  <code>aa_diff</code> ，我们还能留意到在平面上有一点点噪点的存在。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_882_2.jpg\" alt=\"img\" /></p>\n<p>总而言之，抗锯齿的基本副作用就是：</p>\n<ol>\n<li>会抹除一点点高频信息</li>\n<li>会让线条的锐利度下降</li>\n</ol>\n<p>这两点整体来说是不难处理的：<br />\n1 的话，可以通过先降噪，来避免 AA 损伤高频信息。<br />\n2 的话，可以通过补偿性锐化，来补足线条失去的锐利度（而不还原锯齿）。</p>\n<p>再延伸一下，AA 在特性上是一个很弱的 blur，或者说是一个低通滤镜。他会糊掉一点点的噪点，但是大部分的噪点和纹理细节等它都不会动。</p>\n<p>所以在一般情况下，如果需要保留噪点的话，那就先 denoise，然后 aa，最后将噪点层 mergediff 回去便是。在丢弃噪点层（如 webrip）的状况下，AA 的副作用基本可以无视。</p>\n<h3 id=\"2-aa-原理\"><a class=\"anchor\" href=\"#2-aa-原理\">#</a> (2). AA 原理</h3>\n<p>正如上面所讲，AA 需要给两个阶梯中间补足一点过渡的信息。</p>\n<p>于是很久以前的压制者想到利用 <em>deinterlacing</em> (反交错) 滤镜来实现这个功能。</p>\n<p>交错源的特性是画面宽度不变，但是高度减少一半。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/interlacing.jpg\" alt=\"img\" /></p>\n<p>反交错滤镜的工作就是想办法把缺失的一半补回来，所以反交错滤镜的本质也是一个倍高的滤镜。</p>\n<p>而反交错滤镜，比起普通的 resizer 有一个额外的功能，就是它会尝试做一个 “连线” 的动作。</p>\n<p>我们假设画面有一条斜线，中间缺失的部分，是因为进行 interlacing 的时候被丢弃了。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/deint_00.jpg\" alt=\"img\" /></p>\n<p>如果是普通的 resize 的话，它会尝试延长上下的直线，导致接合的地方有一个断裂。<br />\n这个是我们不想看到的。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/deint_01.jpg\" alt=\"img\" /></p>\n<p>相反，如果是 deinterlacer 的话，它会尝试将黑线断开的部分连接，尝试还原一个连续的线条。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/deint_02.jpg\" alt=\"img\" /></p>\n<p>所以我们可以这样利用 deinterlacer：<br />\n假设中间有个空隙，强行让 deinterlacer 补上。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/deint_03.jpg\" alt=\"img\" /></p>\n<p>最后再缩回原分辨率，获得一个比之前少一点锯齿感的输出。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/deint_04.jpg\" alt=\"img\" /></p>\n<p>我们说完原理，接下来就可以看代码了。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">aa_process_eedi2</span><span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    w <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>width</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    h <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>height</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mthresh<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> lthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> vthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> maxd<span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> nt<span class=\"token operator\">=</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> mthresh<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> lthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> vthresh<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> maxd<span class=\"token operator\">=</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span> nt<span class=\"token operator\">=</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>aa_clip<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aaed<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> aaed</pre></td></tr></table></figure><p><code>aa_clip = core.std.ShufflePlanes(clip, 0, vs.GRAY)</code> <br />\n 首先，我们只提取 Y 平面进行 AA 处理。</p>\n<p>这点非常重要：<strong>不要随便对色度平面进行 AA 处理</strong>。</p>\n<p><code>aa_clip = core.eedi2.EEDI2(aa_clip, field=1, mthresh=10, lthresh=20, vthresh=20, maxd=24, nt=50)</code> <br />\n 然后我们用一个叫 EEDI2 的滤镜进行一个倍高的处理。</p>\n<p>EEDI2 的全称是 Enhanced Edge Directed Interpolation 2。<br />\n它的历史比较长，性能不适合用作处理交错源，但是用作 AA 的话就非常适合。</p>\n<p><code>aa_clip = core.fmtc.resample(aa_clip, w, h, 0, -0.5)</code> <br />\n 然后，我们将倍高后的画面缩回原始分辨率。</p>\n<p><code>w</code>  和  <code>h</code>  我们已经提取了，是源的分辨率。</p>\n<p>这里 fmtc.resmple 如果写全的话，可以写成  <code>core.fmtc.resample(aa_clip, w=1920, h=1080, sx=0, sy=-0.5)</code></p>\n<p>这里跟普通的缩放不一样，我们给  <code>sy</code>  设了  <code>-0.5</code> ，这是为了处理 deinterlacer 带来的像素偏移问题。<br />\n详细原理我们放在下一小节讨论。</p>\n<p>在缩放后，我们接了一个  <code>.std.Transpose()</code> ，将画面转置。</p>\n<p>因为第一次的 EEDI2 -&gt; fmtc.resample 只能对画面的 Y 轴进行 AA 处理，所以我们需要转置再对 X 轴进行同样的处理。</p>\n<p><code>aaed = core.std.ShufflePlanes([aa_clip, clip], [0, 1, 2], vs.YUV)</code> <br />\n 在处理完毕以后，我们将 AA 好的 Y 平面和原来的 UV 平面组合起来。</p>\n<p><code>aaed = core.rgvs.Repair(aaed, clip, 2)</code> <br />\n 最后用一个  <code>rgvs.Repair(2)</code> , 限制一下错误 AA 的可能性。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hvbWVPZlZhcG91clN5bnRoRXZvbHV0aW9uL1ZhcG91clN5bnRoLUVFREky\">EEDI2</span> 可调的参数比较多，上面范例用的是一个祖传的特化 AA 效果的参数组，如今也已经是滤镜的默认值。大家可以直接应用，或者在这基础上修改。</p>\n<h3 id=\"3-deint-滤镜的像素偏移\"><a class=\"anchor\" href=\"#3-deint-滤镜的像素偏移\">#</a> (3). deint 滤镜的像素偏移</h3>\n<p>为什么 EEDI 缩小的时候需要加个  <code>sy=-0.5</code>  呢？<br />\n在回答这个问题前，我们先来探讨一下倍高滤镜的工作原理。</p>\n<p>我们先在 vs 里随便打开一个源，转成 src16，然后加下面一段代码。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>double <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>double<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>resized <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">1920</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2160</span><span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">'lanczos'</span><span class=\"token punctuation\">,</span> taps<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>resized<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>观察一下输出有什么不同，建议挑一些线条比较多的帧来观察。</p>\n<p>放大仔细观察，会发现两个画面虽然分辨率一样（都是 1920*2160），但是有一个次像素的偏移。</p>\n<p>为什么会存在这样的差别，我们需要介绍一下倍高滤镜的基本原理。<br />\n这里提前插入一点交错相关的知识，如果你觉得难以理解，可以提前看下第 10 章的开头部分。</p>\n<p>倍高滤镜的目标输入是交错源，而交错源虽然仍然以帧的方式存储，但实际最小单位却是场。顶场由第 0,2,4,6... 行组成，底场由第 1,3,5,7,... 行组成。</p>\n<p>倍高滤镜的目标，就是将这些只有一半分辨率的场，倍高扩展成完整分辨率的帧。</p>\n<p>在 EEDI2 (field=1) 的情况下，它就认为输入的都是顶场，然后给我们补上底场的画面。</p>\n<p>这一过程如下面所示：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>0             0</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>              1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>2      ->     2</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>              3</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>4             4</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>              5</pre></td></tr></table></figure><p>不难发现这一过程中，图像的中心从最开始的 2 变成了 2.5，也就是画面整体向下偏移了 0.5px。</p>\n<p>而对于常规的 resizer，放大过程图像中心是不变的。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>-0.5</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>0</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>              0.5</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>              1.5</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>2      -></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>              2.5</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>              3.5</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>4</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>              4.5</pre></td></tr></table></figure><p>因此，如果我们想要将倍高后的画面修正到中心对齐，就需要加上一个  <code>sy=-0.5</code> 。</p>\n<p>上面所说都是对于单平面而言，而如果我们同时对三个平面进行 AA，那么 sy 又该如何给呢？<br />\n可能有同学会说，AA 过程都是独立的，当然是都给  <code>sy=-0.5</code>  就行。</p>\n<p>这个说法只对了一半，确实 AA 过程是平面独立的，每个平面都应该各自移动 0.5px。但是注意到在调用 resizer 时，所给的 shift 参数的像素距离是以 Y 平面为准的。</p>\n<p>这意味着在 YUV420 时，虽然 UV 平面也需要移动 0.5px，但转换到 Y 平面的像素距离时，数值就发生了一定的变化，这时应该给到  <code>sy=[-0.5, -1.0]</code> 。</p>\n<p>相应的，如果是 YUV444 的情况，三个平面的像素距离是相同的，就应该给到  <code>sy=[-0.5]</code> 。</p>\n<h3 id=\"4-调整-aa-效果\"><a class=\"anchor\" href=\"#4-调整-aa-效果\">#</a> (4). 调整 AA 效果</h3>\n<p>心细的同学可以发现，上面所说的 AA 流程是完全没有可调的部分的。<br />\n不像 deband 和 denoise，我们不能更改 AA 的力度。</p>\n<p>而 EEDI2 的参数更多的是更改连线算法的特性，而不是 AA 本身。<br />\n所以以前的压制者们想到通过更改 deinterlacer 来变更 AA 的效果。</p>\n<p>除了 EEDI2 外，常用的 deint 算法还有 EEDI3、NNEDI3、以及 Sangnom（Sangnom 放在最后说）。</p>\n<p>我们在之前的 EEDI2-AA 示例代码后面加上下面这段代码。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">aa_process_eedi3</span><span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    w <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>width</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    h <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>height</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi3m<span class=\"token punctuation\">.</span>EEDI3<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> alpha<span class=\"token operator\">=</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> beta<span class=\"token operator\">=</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> gamma<span class=\"token operator\">=</span><span class=\"token number\">20.0</span><span class=\"token punctuation\">,</span> nrad<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> mdis<span class=\"token operator\">=</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi3m<span class=\"token punctuation\">.</span>EEDI3<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> alpha<span class=\"token operator\">=</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> beta<span class=\"token operator\">=</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> gamma<span class=\"token operator\">=</span><span class=\"token number\">20.0</span><span class=\"token punctuation\">,</span> nrad<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> mdis<span class=\"token operator\">=</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>aa_clip<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aaed<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> aaed</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">aa_process_nnedi3</span><span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    w <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>width</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    h <span class=\"token operator\">=</span> clip<span class=\"token punctuation\">.</span>height</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>znedi3<span class=\"token punctuation\">.</span>nnedi3<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> nsize<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> nns<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> qual<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>znedi3<span class=\"token punctuation\">.</span>nnedi3<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> nsize<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> nns<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> qual<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>aa_clip<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    aaed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aaed<span class=\"token punctuation\">,</span> clip<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">return</span> aaed</pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>eedi3_aa <span class=\"token operator\">=</span> aa_process_eedi3<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>eedi3_aa_diff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> eedi3_aa<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>eedi3_aa<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>eedi3_aa_diff<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>nnedi3_aa <span class=\"token operator\">=</span> aa_process_nnedi3<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>nnedi3_aa_diff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> nnedi3_aa<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>nnedi3_aa<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>nnedi3_aa_diff<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Expr<span class=\"token punctuation\">(</span><span class=\"token string\">'x 32768 - 10 * 32768 +'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>代码的逻辑跟 eedi2-aa 没有大变化，纯粹是将 eedi2 平替为 eedi3 和 nnedi3 而已。</p>\n<p>大家可以比对一下  <code>3</code> ,  <code>5</code> ,  <code>7</code>  这三个输出，看看有什么差别。<br />\n有需要的话，也可以用  <code>4</code> ,  <code>6</code> ,  <code>8</code>  这几个 aadiff 辅助。</p>\n<p>由于 deint 滤镜本身的特性，eedi2-aa 效果通常是最糊的；<br />\nnnedi3 出来的效果最锐，但是 aa 的力度也最弱；<br />\needi3 的性质在这个源中比较难体现出来，它的效果介乎两者之间。</p>\n<p>实际上 eedi3 的连线能力最强，针对下图左边这种完全没有 AA 过的线条（我们称为<em>二值化线条</em>）的效果最好。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/aliasing.jpg\" alt=\"img\" /></p>\n<p>所以在实际使用上，比较糊的源我们会选用 eedi2-aa；作画分辨率比较高的我们会选 nnedi3-aa；而特殊情况我们会选用 eedi3-aa。</p>\n<p>最后我们讨论下 AA 滤镜的弱点：</p>\n<p>第一个可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMuYWNncmlwLmNvbS90aHJlYWQtODQxMy0xLTEuaHRtbA==\">这里</span>，正如观众提醒的，灯子旁边的下水道花了。</p>\n<p>我们知道 deint 滤镜会有连线的作用，所以在密集的斜线中，偶然会有错连的情况出现。</p>\n<p>AA 操作最后接的 repair (2) 主要是为了修复、弱化这种错误连线的视觉效果。</p>\n<p>而另一个弱点的话，大家可以移动到 2159 帧，然后放大到 400%，比对一下源和 nnedi3-aa 的效果。</p>\n<p>就算是效果最弱的 nnedi3-aa, 也对细节有明显的破坏，而且并不是什么 AA 效果，大多是变糊，变灰之类的副作用。</p>\n<p>主要原因是，deint-AA 处理出现当初，针对的都是一些比较糊的源，原生分辨率最高可能也就 720。</p>\n<p>但是近年多了很多作画精细的番，示例中的 clockwork planet 我们认为它是接近 1080p 的原生分辨率。</p>\n<p>所以一开始说到，AA 处理会带有一点点 blur 的副作用，在这里就显示的很明显了。<br />\n虽然在 100% 下差别不算大。</p>\n<p>因此在遇到高作画精度的番时，有时候会考虑完全不做 AA，抗锯齿的代价太大，补偿性锐化也不能将上述的细节还原。</p>\n<h3 id=\"5-高强度-aa-sangnom\"><a class=\"anchor\" href=\"#5-高强度-aa-sangnom\">#</a> (5). 高强度 AA —— SangNom</h3>\n<p>先载入源  <code>MINORI2_00004.m2ts</code> ，然后切换到 1224 帧，观察一下画面有什么瑕疵。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1224_0.png\" alt=\"img\" /></p>\n<p>有很难看的锯齿，还有色带。</p>\n<p>锯齿的话，大家可以试试用上面教过的 eedi2-aa。<br />\n可以发现锯齿消除不完全，小的锯齿没了，但是大的还在。</p>\n<p>eedi2，eedi3 和 nnedi3 对于强锯齿效果有限。<br />\n对付强锯齿，我们可以用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2R1YmhhdGVyL3ZhcG91cnN5bnRoLXNhbmdub20=\">SangNom</span>。</p>\n<p>SangNom 本质上也是一个 deinterlacer，会用到的参数有两个。</p>\n<p><code>aa</code> , 默认是  <code>aa=48</code> , 这个我们通常不用动。<br />\n <code>dh</code> ，默认是  <code>dh=False</code> 。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> src16</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>aa_clip<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>观察一下输出画面的分辨率和线条的变化。<br />\n正常的话，会感觉到有 AA 效果，但还是有锯齿残留。</p>\n<p>一来我们只对 Y 轴进行了 AA；二来呢，大家能注意到分辨率还是  <code>1920*1080</code>  吧，不是之前用了 EEDI2 后的  <code>1920*2160</code> 。</p>\n<p>deinterlacer 普遍都会有一个  <code>dh</code>  的参数，<em>dh</em> = <em>double height</em>。<br />\n <code>dh = True</code>  的时候，原始数据当做上半场，插值出下半场，<br />\n而  <code>dh=False</code>  的时候呢，deint 的作用是这样的。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>0    0    0</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    1         1*</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    2 -> 2 -> 2</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    3         3*</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    4    4    4</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    5         5*</pre></td></tr></table></figure><p>首先把源分为上半和下半场，然后丢弃下半场，最后重新插值出下半场（1*, 3*, 5*）。</p>\n<p>由于丢弃了一半的数据之后重新 “制造”，所以会有抗锯齿的效果。<br />\n但是同样的，错误插值的部分会有明显瑕疵。</p>\n<p>大家可以试试完整版的 SangNom (dh=False) AA。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> src16</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> src16<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>aa_clip<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-09/image_1224_1.jpg\" alt=\"img\" /></p>\n<p>可以看到整体有抗锯齿效果，但是球和手指有一些难以描述的瑕疵。</p>\n<p>为了能让 sangnom 能用，我们需要有方法去限制他的瑕疵。</p>\n<p>第一个方案是以前 avs 时代就流传下来的：</p>\n<ul>\n<li>先利用 eedi2/nnedi3 放大到 1.5 x 1.5 倍大小</li>\n<li>然后做 SangNom AA</li>\n<li>最后缩回原始分辨率</li>\n</ul>\n<p>大家运行一下看看效果如何。<br />\n正常的话，可以看到瑕疵少了，手那里比之前表现好。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>w <span class=\"token operator\">=</span> <span class=\"token number\">1920</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>h <span class=\"token operator\">=</span> <span class=\"token number\">1080</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>uw <span class=\"token operator\">=</span> w <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uh <span class=\"token operator\">=</span> h <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> uh<span class=\"token punctuation\">,</span> sy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> uh<span class=\"token punctuation\">,</span> uw<span class=\"token punctuation\">,</span> sy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>bits<span class=\"token operator\">=</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> <span class=\"token number\">1920</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1080</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> src16<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里简单介绍一下代码：</p>\n<p><code>uw = w * 3 // 2</code> <br />\n <code>uh = h * 3 // 2</code> <br />\n <code>uw</code> ,  <code>uh</code>  这里指定了放大的幅度，正如前面说的，我们先设 1.5 倍。</p>\n<p><code>aa_clip = core.eedi2.EEDI2(src16, field=1)</code> <br />\n <code>aa_clip = core.fmtc.resample(aa_clip, w, uh, sy = [-0.5, -1]).std.Transpose()</code> <br />\n <code>aa_clip = core.eedi2.EEDI2(aa_clip, field=1)</code> <br />\n <code>aa_clip = core.fmtc.resample(aa_clip, uh, uw, sy = [-0.5, -1])</code> <br />\n 这里的四行跟前面说的有点类似。</p>\n<p>都是先用 EEDI2 (或者 nnedi3) 倍高，然后缩回去目标的分辨率（1.5x）并且修正偏移。</p>\n<p><code>.fmtc.bitdepth(bits=8)</code> <br />\n 是一个优化步骤。</p>\n<p>大多数 deint 滤镜是设计给 8bit 输入用的，给 16bit 输入除了拖慢以外，不会有什么画质上的帮助。<br />\n另一方面 AA 不太受位深精度影响。</p>\n<p><code>aa_clip = core.sangnom.SangNom(aa_clip, aa=48, dh=False).std.Transpose()</code> <br />\n <code>aa_clip = core.sangnom.SangNom(aa_clip, aa=48, dh=False)</code>  接下来的就跟之前一样。</p>\n<p><code>aa_clip = core.fmtc.resample(aa_clip, 1920, 1080)</code> <br />\n 再缩回去原分辨率。</p>\n<p>这里思考一个问题，为什么不需要给  <code>sy=-0.5</code>  呢？</p>\n<details class=\"details_lb9f isBrowser_bmU9 alert alert--info details_b_Ee\" data-collapsed=\"true\"><summary>参考答案</summary></details>\n<p>事实上只有 dh=True 倍高的时候才会引入像素偏移，在 dh=False 丢弃半场再插回半场的情况下，并不会改变最终分辨率，也不会引入偏移。</p>\n<p>这个 SangNom 的使用例子，能够调节的参数是  <code>uw</code> ,  <code>uh</code> 。</p>\n<p>作为一个基本规则：<br />\nAA 处理的<strong>输入分辨率越高</strong>，<br />\nAA 效果的<strong>强度越弱</strong>。</p>\n<p>假如我们将  <code>uw</code>  设为  <code>w*2</code> ，放大 2 倍的话，可以观察到 AA 效果变弱了一点，但还是基本足够消除这画面的锯齿。</p>\n<p>而另一方面，SangNom (dh=False) 的瑕疵主要来自丢弃半场的特性，所以可以透过放大来缓解一部分瑕疵。<br />\n因为可以让下半场的信息 “复制” 到邻接的两行里，避免了下半场信息的完全丢失。</p>\n<p>既然多了调整分辨率这个操作，大家想象一下，有什么方法可以增强 SangNom 的 AA 效果吗？</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>w <span class=\"token operator\">=</span> <span class=\"token number\">1920</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>h <span class=\"token operator\">=</span> <span class=\"token number\">1080</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>uw <span class=\"token operator\">=</span> w <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uh <span class=\"token operator\">=</span> h <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">//</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>dw <span class=\"token operator\">=</span> w <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">//</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>dh <span class=\"token operator\">=</span> h <span class=\"token operator\">*</span> <span class=\"token number\">3</span> <span class=\"token operator\">//</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> dw<span class=\"token punctuation\">,</span> dh<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> uh<span class=\"token punctuation\">,</span> sy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>eedi2<span class=\"token punctuation\">.</span>EEDI2<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> uh<span class=\"token punctuation\">,</span> uw<span class=\"token punctuation\">,</span> sy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>bits<span class=\"token operator\">=</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Transpose<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>sangnom<span class=\"token punctuation\">.</span>SangNom<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> aa<span class=\"token operator\">=</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> <span class=\"token number\">1920</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1080</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>aa_clip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>aa_clip<span class=\"token punctuation\">,</span> src16<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>aa_clip<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>其实可以先缩小一下源，然后再用 EEDI2 来放大，接 SangNom AA 的步骤。</p>\n<p>这里先将源缩小到 dw * dh，比如说 0.75 倍，然后用 EEDI2 放大到 1.5 倍，就能获得比先前更强的 AA 效果。</p>\n<p>当然除非做一些老番，强力 AA 是不会怎么用上的。<br />\n我们讲 SangNom 是因为偶然会遇到这种，低分辨率强行 upconv 到 BD 1080P 的烂源。</p>\n<p>那么，我们可以连续做两次 AA 来增强 AA 的效果吗？</p>\n<p>连续多次 AA 是可以的，不过每 AA 一次，线也会更糊一些，瑕疵也更容易累积。</p>\n<p>所以要用的小心（比如说较小的文字，书本报章之类的，很容易受到多次 AA 的摧残）。</p>\n<h2 id=\"4-瑕疵修复流程\"><a class=\"anchor\" href=\"#4-瑕疵修复流程\">#</a> 4. 瑕疵修复流程</h2>\n<p>比起独立的瑕疵处理步骤，一个完整脚本还需要考虑各个步骤的先后次序和连接。</p>\n<p>按照本章学到的内容，deband, denoise 和 AA 应该按什么次序处理呢？</p>\n<p>AA -&gt; denoise -&gt; deband ?<br />\ndenoise -&gt; deband -&gt; AA ?</p>\n<p>deband 如同前面说的，要放在 denoise 之后，但是 AA 就有点尴尬了。</p>\n<p>AA 放在 denoise 前的话，可能会影响被噪点干扰（AA 有微弱的 blur 效果）。<br />\n放在 deband 后面的话，又怕 AA 会不会干扰 deband 的 dither 效果（dither 也是一种噪声）。</p>\n<p>所以这里更推荐先 denoise，然后分别对 nr16 进行 deband 和 AA，最后找个办法将 AA 和 Deband 两者融合回来。<br />\n毕竟 Deband 应该只作用于平面，AA 只作用于线条，两者之间没有依赖关系。</p>\n<blockquote>\n<p>在高阶处理中，就不再限于这样的顺序，因为可以通过 mask 等手段只对希望的部分进行处理。</p>\n</blockquote>\n<p>这里分享一个 webrip 的范例脚本 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL2Fzc2V0cy9maWxlcy9leGFtcGxlLWFkNzBiZDlhNWNlYmUzODJhYzQxMjJkOTNkMmYyNWUwLnZweQ==\">example.vpy</span>。</p>\n<p>Line 1-26 都是已经教过的内容。<br />\ndenoise, 2pass-nr-deband（Y 比较强，UV 弱一些）+ LimitFilter 限制效果。<br />\n然后是一个 Y 平面的 EEDI2-AA，后接一个 repair 保底。</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># Merge AA and Deband</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>dbedY <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>dbed<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mergedY <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>LimitFilter<span class=\"token punctuation\">(</span>dbedY<span class=\"token punctuation\">,</span> aaedY<span class=\"token punctuation\">,</span> thr<span class=\"token operator\">=</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> elast<span class=\"token operator\">=</span><span class=\"token number\">1.5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>merged <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>mergedY<span class=\"token punctuation\">,</span> dbed<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>新加的内容是这部分。</p>\n<p>我们先抽出 deband 后的 Y 平面，然后用 LimitFilter 对两者 dbedY 和 aaedY 做一个融合。</p>\n<p>这其实就是上一章提到的 LimitFilter 融合线条与非线条的用法，其中 dbedY 对应 non-edge, aaedY 对应 edge。</p>\n<p><code>thr=1.0, elast=1.5</code>  是一个参考的参数，可以将大部分 AA 效果融合到 dbedY 身上，根据实际情况也可以微调一下。</p>\n<p>最后 ShufflePlanes 将融合好的 Y 和 UV 组合回来，完工。</p>\n<p>脚本最后几行是配合 OKEGui 使用的代码，大家可以在后面的章节学到。</p>\n<p>这里留一个思考题，这个范例脚本并没有加上之前教过的补偿锐化和 dering 步骤，大家可以想想看加在哪里合适。</p>\n<p>最后，我们回顾一下本章开头问大家的问题。</p>\n<blockquote>\n<p>处理瑕疵是必定有副作用的。<br />\n为了消除瑕疵，可以对画质做出多大的牺牲呢？</p>\n</blockquote>\n<p>目标是肉眼不容易察觉程度的牺牲的话，那么始终会遇到一些让人进退两难的烂源。<br />\n回答不能有牺牲的话，要实现这点可能就要靠研发更好的滤镜和魔法了。</p>\n<p>另外就是，接受瑕疵存在，不强行操作，只确保二次压缩不会更加恶化问题也是一个需要考虑的选项。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%85%AB%E7%AB%A0VS%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%85%AB%E7%AB%A0VS%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/",
            "title": "第八章VS视频处理基础",
            "date_published": "2024-03-16T15:11:37.000Z",
            "content_html": "<h1 id=\"第八章-vs视频处理基础\"><a class=\"anchor\" href=\"#第八章-vs视频处理基础\">#</a> 第八章 VS 视频处理基础</h1>\n<p>这一章，我们将会用一些基本工具对画面进行一些简单操作，并且利用他们的组合初步领会预处理的思路。</p>\n<h2 id=\"1-resizer应用\"><a class=\"anchor\" href=\"#1-resizer应用\">#</a> 1. Resizer 应用</h2>\n<p>首先登场的是两位老朋友：<a href=\"https://amusementclub.github.io/fmtconv/doc/fmtconv.html\"> <code>fmtconv</code> </a> 和 <a href=\"https://amusementclub.github.io/doc/functions/video/resize.html?highlight=resize#resize\"> <code>zimg</code> </a>，复习一下，调用他们分别使用 <code>vs.core.fmtc.xxx</code>  和 <code>vs.core.resize.xxx</code> 。</p>\n<h3 id=\"1-平移和裁剪shift-crop\"><a class=\"anchor\" href=\"#1-平移和裁剪shift-crop\">#</a> (1). 平移和裁剪（shift &amp; crop）</h3>\n<p>此处我们使用到的参数有以下几个： <code>zimg</code>  对应的参数是 <code>src_left</code> / <code>src_top</code> / <code>src_width</code> / <code>src_height</code> 。 <code>fmtconv</code>  中对应的函数是 <code>fmtc.resample</code> ，参数分别对应 <code>sx</code> / <code>sy</code> / <code>sh</code> / <code>sw</code> 。这四个参数表示，输出结果对应着原图中的这样一个长方形区域 —— 它左上顶点坐标是 (src_left,src_top)(src_left,src_top)，宽为 src_widthsrc_width，高为 src_heightsrc_height。如下图所示：</p>\n<p>![Sampling Zone](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA4L0ZpZ3VyZQ==\">https://guides.vcb-s.com/media/basic-guide-08/Figure</span> 1.png) 采样区域图示</p>\n<p>图中较大的长方形框是原始图像，较小的长方形框 —— 也即<strong>采样区域</strong>，对应结果图像。<br />\n所以，如果想将图像向右平移 10.5 个像素，同时向下平移 20 个像素 —— 此时我们的小方框顶点应该位于 (−10.5,−20)(−10.5,−20)，所以对应的写法是 <code>resize.Spline36(src_left=-10.5, src_top=-20)</code> 。同样的，我们还可以使用这个方法进行裁切，比如原图是 1920×10801920×1080，我想上切 10 像素，下切 20 像素，那么就是 <code>resize.Spline36(src_top=10, src_height=1050)</code> 。</p>\n<p>那么，假如 “小方框” 的某一条边落在 “大方框” 之外（所以前者其实可以比后者大，图中的 “大” “小” 只是为了便于理解）会怎么样呢？这里两个滤镜的行为出现了差别，超出边缘的像素， <code>zimg</code>  会以图像的边缘作为对称轴，镜像补全；而 <code>fmtconv</code>  会重复边缘的像素来补全。</p>\n<h3 id=\"2-尺寸变换resize\"><a class=\"anchor\" href=\"#2-尺寸变换resize\">#</a> (2). 尺寸变换（resize）</h3>\n<p>此即图像的放大和缩小，或者说改变采样点（像素）的数量。滤镜依旧是上面所说的两个， <code>zimg</code>  使用 <code>width</code> / <code>height</code>  指定输出图像的尺寸， <code>fmtconv</code>  对应的是 <code>w</code> / <code>h</code> 。该操作将上面提到的<strong>采样区域</strong>（即由 <code>src_left</code> / <code>src_top</code> / <code>src_width</code> / <code>src_height</code>  指定的）缩放到 <code>width</code> x <code>height</code>  大小。</p>\n<h3 id=\"3-fmtconv的逐平面处理\"><a class=\"anchor\" href=\"#3-fmtconv的逐平面处理\">#</a> (3).  <code>fmtconv</code>  的逐平面处理</h3>\n<p>在使用 <code>fmtc.resample</code>  时， <code>sx</code> / <code>sy</code> / <code>sh</code> / <code>sw</code>  可以传一个数组进去，数组依次指定指定 3 个平面的参数，例如 <code>fmtc.resample(sx=[-1,0,1])</code> 。假如数组长度为 2，比如 <code>sx=[-1,0]</code> ，那么第 2、3 平面共用数组内第二个参数。</p>\n<p>除此之外， <code>fmtconv</code>  还有 <code>planes</code>  这个参数，也是传一个数组，具体含义 doc 里有写：</p>\n<blockquote>\n<p>This array decribes how each plane should be processed. It’s similar to the y, u and v parameters in Masktools 2.</p>\n<ul>\n<li>−65535 to +0.5: All the pixels of the plane will be set to −x (the opposite of  the specified value). The range depends on the output data type.  Remember, in floating-point YUV, the chroma planes range from −0.5 to  +0.5.</li>\n<li>1:\tThe plane will not be processed. This means that the content of the output plane is pure garbage.</li>\n<li>2: The plane of the input clip will be copied and possibly cropped. Areas  out of the input picture are left unprocessed (garbage). Range (full or  TV) conversions are ignored.</li>\n<li>3:\tThe plane will be processed (default).</li>\n</ul>\n</blockquote>\n<p>所以，假如你发现一个视频有 chroma shift，又不想把平面都拆出来，处理完再拼回去，那么你可以用 <code>fmtc.resample(sx=0.3, plane=[2,3,3])</code>  来仅仅处理色度平面。</p>\n<h3 id=\"4-matrix转换\"><a class=\"anchor\" href=\"#4-matrix转换\">#</a> (4). Matrix 转换</h3>\n<p>这个其实没啥好说的， <code>fmtconv</code>  用 <code>fmtc.matrix</code>  和 <code>fmtc.matrix2020cl</code> ，参数的意义在 doc 里写得都挺明白。 <code>zimg</code>  则是整合到了各个采样滤镜中，用 <code>matrix_in</code> / <code>matrix</code>  来指定输入和输出，不过这俩参数只能传数字，更推荐的写法是用 <code>_s</code>  结尾的参数 <code>matrix_in_s</code> / <code>matrix_s</code>  传入字符串，看得更加清晰。</p>\n<h3 id=\"5-transfer转换\"><a class=\"anchor\" href=\"#5-transfer转换\">#</a> (5). Transfer 转换</h3>\n<p>除了 <code>fmconv</code>  用 <code>fmtc.transfer</code>  之外，用法和上面没啥区别。。。但是有几个需要注意的地方：</p>\n<ul>\n<li><code>zimg</code>  的 <code>709</code>  实际上是 <code>bt1886</code> ，和 <code>fmtconv.transfer</code>  中的 <code>1886</code>  对应，而不是 <code>709</code> 。</li>\n<li><strong>注意 range</strong>，这一点要特别注意，因为 <code>fmtconv</code>  中默认输入输出都是  <code>full range</code> 。于是假如你传进去一个 <code>limited range</code>  的 Y 平面，然后没指定 <code>fulls=False</code> ，结果就错了。</li>\n</ul>\n<h3 id=\"6-gamma-awara-resize\"><a class=\"anchor\" href=\"#6-gamma-awara-resize\">#</a> (6). Gamma awara-resize</h3>\n<p>下图是一些 Transer 的曲线，这里我们从图上直观地理解一下：横轴代表计算机里储存的数，纵轴代表实际的显示亮度，可以很明显地发现：</p>\n<ul>\n<li>这些曲线都不是线性的（废话）。</li>\n<li>他们都是下凹的，也就是说暗场给了更多的数字来表示。</li>\n</ul>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA4L0ZpZ3VyZQ==\">https://guides.vcb-s.com/media/basic-guide-08/Figure</span> 2.jpeg)</p>\n<p>那么我们想象一下，假如说我们在用双线性算法缩小图像的时候，在  <code>full range 8bit</code>  下，有两个像素：0 和 255，那么在他们中点插值的像素值将会是 128，我们姑且认为我们将这两个像素合并成了一个，那么按理说，视觉上应该是得到中性灰。但是由于 transfer 曲线将 0-255 中更多的数字给了暗场，所以得到的 128 会比中性灰更暗。其他的 kernel  大同小异。这么做的后果是图像的对比度会下降，比如这张图：</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA4L0ZpZ3VyZQ==\">https://guides.vcb-s.com/media/basic-guide-08/Figure</span> 3.png)</p>\n<p>直接缩到 1/4 大小，会得到：</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA4L0ZpZ3VyZQ==\">https://guides.vcb-s.com/media/basic-guide-08/Figure</span> 4.png)</p>\n<p>可以明显感觉灯光的对比度低了。诚然，resizer 自带的 low-pass 效应是一点，tranfer 压缩是另一点。</p>\n<p>那么怎么办呢？我们可以将图像转到线性光下，再做 resize，然后转回 transfer 压缩的效果。还是那张图，如果在线性光下做：</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA4L0ZpZ3VyZQ==\">https://guides.vcb-s.com/media/basic-guide-08/Figure</span> 5.png)</p>\n<p>vs 中，可以这样写：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gray <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> colorfamily<span class=\"token operator\">=</span>vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>gray <span class=\"token operator\">=</span> gray<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>transfer<span class=\"token punctuation\">(</span>transs<span class=\"token operator\">=</span><span class=\"token string\">\"709\"</span><span class=\"token punctuation\">,</span> transd<span class=\"token operator\">=</span><span class=\"token string\">\"linear\"</span><span class=\"token punctuation\">,</span> fulls<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> fulld<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>gray <span class=\"token operator\">=</span> gray<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span><span class=\"token number\">1280</span><span class=\"token punctuation\">,</span><span class=\"token number\">720</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>gray <span class=\"token operator\">=</span> gray<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>transfer<span class=\"token punctuation\">(</span>transs<span class=\"token operator\">=</span><span class=\"token string\">\"linear\"</span><span class=\"token punctuation\">,</span> transd<span class=\"token operator\">=</span><span class=\"token string\">\"709\"</span><span class=\"token punctuation\">,</span>fulls<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> fulld<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>UV <span class=\"token operator\">=</span> src16<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span><span class=\"token number\">1280</span><span class=\"token punctuation\">,</span><span class=\"token number\">720</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>down <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>gray<span class=\"token punctuation\">,</span>UV<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>我们来一句句看：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gray <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> colorfamily<span class=\"token operator\">=</span>vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>gray <span class=\"token operator\">=</span> gray<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>transfer<span class=\"token punctuation\">(</span>transs<span class=\"token operator\">=</span><span class=\"token string\">\"709\"</span><span class=\"token punctuation\">,</span> transd<span class=\"token operator\">=</span><span class=\"token string\">\"linear\"</span><span class=\"token punctuation\">,</span> fulls<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> fulld<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这是把源的 Y 平面拿出来，再丢给 fmtc.transfer，从 709 的 transfer 压缩，转为线性光。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gray <span class=\"token operator\">=</span> gray<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span><span class=\"token number\">1280</span><span class=\"token punctuation\">,</span><span class=\"token number\">720</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>gray <span class=\"token operator\">=</span> gray<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>transfer<span class=\"token punctuation\">(</span>transs<span class=\"token operator\">=</span><span class=\"token string\">\"linear\"</span><span class=\"token punctuation\">,</span> transd<span class=\"token operator\">=</span><span class=\"token string\">\"709\"</span><span class=\"token punctuation\">,</span>fulls<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span> fulld<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>在线性光下做好缩放后，再转回带 transfer 压缩的效果。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>UV <span class=\"token operator\">=</span> src16<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span><span class=\"token number\">1280</span><span class=\"token punctuation\">,</span><span class=\"token number\">720</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>down <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>gray<span class=\"token punctuation\">,</span>UV<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>正常缩放 UV，跟处理后的 Y 平面混合。</p>\n<p>实际上 709 的 tansfer 压缩是在 RGB 下做的，受到 YCbCr 矩阵影响，chroma 上其实还是有部分 Luma 信息  ，只用 Y' 做转换不太准确。你可以看到 UV 计算，是基于 transfer 压缩后的 RGB。如果 RGB 本身是未压缩的线性光，UV 的值会有改变；虽然 YUV 的机制保证了它改变的不大。理想的 YUV 机制，应该完全消除掉亮度在 UV 平面的影响，也就是对亮度进行统一的变换。UV 的值不应该改变（注意它是亮度做差）。这是理想中情况，现实中很难做到。</p>\n<h3 id=\"7-chroma-subsample-与-chroma-placement\"><a class=\"anchor\" href=\"#7-chroma-subsample-与-chroma-placement\">#</a> (7). Chroma subsample 与 Chroma placement</h3>\n<p>前文提到过，YUV 空间下的色度平面中心可能会出现和亮度平面不一致的情况（Chroma subsample），利用 resizer 可以对这些不同的采样进行转换。如果是无脑调用滤镜的话， <code>zimg</code>  用 <code>format</code>  参数指定输出的格式（同时也就指定了色度采样类型）， <code>fmtconv</code>  则使用 <code>css</code>  单独表示输出的色度采样类型。即使有这些看上去很方便的工具，但我们还是要打开黑匣子 —— 如果给你一个 YUV420 的视频，让你手动放大 UV，转成 YUV444，你要怎么操作？</p>\n<p>上文所提到的两个 resizer，默认是中心对齐的放大，例如：</p>\n<p>原本的 3 个像素采样位置是 [2,4,6][2,4,6]，中点为 4；放大后采样位置变成了 [1,2,3,4,5,6,7][1,2,3,4,5,6,7]，中点还是 4。</p>\n<p>如果 YUV420 是 MPEG1 的 cplace。那么你直接可以将 UV 放大到两倍：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">\"xxx.jpg\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Y <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>U <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Lanczos2<span class=\"token punctuation\">(</span>Y<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> Y<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>V <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Lanczos2<span class=\"token punctuation\">(</span>Y<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> Y<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>Y<span class=\"token punctuation\">,</span> U<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>那么如果是 MPEG2 的 cplace 呢？Y 和 UV 是左端对齐：</p>\n<p>Y 的采样位置 —— [1,2,3,4,5,6][1,2,3,4,5,6]，中点是 3.5；</p>\n<p>UV 的采样位置 —— [1,3,5][1,3,5]，中点是 3。 此时，如果我们还是按照中心对齐，将 UV 放大到 2x，那么 UV 的采样位置变成了 [0.5,1.5,2.5,3.5,4.5,5.5][0.5,1.5,2.5,3.5,4.5,5.5]（中点还是 3）。 那么该怎么办呢？</p>\n<p>来看下面这张图：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/YUV_420_chroma_place_MPEG-2-e32ce4d576f99e56549c00b28389bf20.png\" alt=\"Figure 5\" /></p>\n<p>所有黑点，是 Y 的采样位置；蓝色的点，是 MPEG2 下，UV 的采样位置；红色的是 MPEG1 下的位置；我们希望调整到红色。那么就需要把 UV，向右移动 Y 的尺度下的 0.5 像素，这 0.5 像素就是红点和蓝点之间的距离；那么在 UV 的尺度下，这 0.5 就变成了 0.25。所以如果是 MPEG2 的 cplace，在 resize 的时候：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">\"xxx.jpg\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Y <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>U <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Lanczos<span class=\"token punctuation\">(</span>Y<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> Y<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">,</span> src_left<span class=\"token operator\">=</span><span class=\"token number\">0.25</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>V <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Lanczos<span class=\"token punctuation\">(</span>Y<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">,</span> Y<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">,</span> src_left<span class=\"token operator\">=</span><span class=\"token number\">0.25</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>Y<span class=\"token punctuation\">,</span> U<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>与此类似地，我们不仅可以把 UV 拉上来，还可以把 Y 降下去：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Y <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> src16<span class=\"token punctuation\">.</span>width<span class=\"token operator\">/</span><span class=\"token number\">2</span> <span class=\"token punctuation\">,</span> src16<span class=\"token punctuation\">.</span>height<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> sx<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>down <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>Y<span class=\"token punctuation\">,</span>src16<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>上面这两行，如果活用 <code>fmtconv</code>  的话可以变成一行：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>down = core.fmtc.resample(src16, 960, 540, sx=-0.5, planes=[3,2,2], css=\"444\")</pre></td></tr></table></figure><p>以上就是 Chroma subplace 转换的基本方法，计算平移参数的技巧以后还会反复使用。</p>\n<h2 id=\"2-blurring\"><a class=\"anchor\" href=\"#2-blurring\">#</a> 2. Blurring</h2>\n<h3 id=\"1-removegrain\"><a class=\"anchor\" href=\"#1-removegrain\">#</a> (1). RemoveGrain</h3>\n<p>Blurring，意为模糊，这里介绍一个新的基础滤镜 —— <code>RemoveGrain</code> ，调用它的方式是 <code>vs.core.rgvs.RemoveGrain()</code> ，他是 avs 的 <code>RgTools</code>  在 vs 中的移植，可以在<span class=\"exturl\" data-url=\"aHR0cDovL2F2aXN5bnRoLm5sL2luZGV4LnBocC9SZ1Rvb2xz\">这里</span>找到他和其他同样在 <code>RgTools</code>  里的滤镜 doc。下面来讲讲模糊的基本方法。</p>\n<h4 id=\"平均值模糊average-blur\"><a class=\"anchor\" href=\"#平均值模糊average-blur\">#</a> 平均值模糊（Average Blur）</h4>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Noise_graph-cb8998cb565c1afd7e6093c3699e06d4.png\" alt=\"Figure 6\" /></p>\n<p>上面这些起起伏伏可以看作是噪点，所谓降噪，就是要把它抹平，那么最简单的，把所有点的值做个平均填回去：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Average_deblur-45d1aaf28b8b9fa801a4bc58e45fd70a.png\" alt=\"Figure 7\" /></p>\n<p>好，非常平，马赛克大概就是这么做的，把某一区域所有像素的值取个平均。我们在 vs 中也可以做类似的事情， <code>core.rgvs.RemoveGrain(src, 20)</code> 。它做的是：把某个像素取值变成 它和周围 8 个像素的平均值，这里一共有 9 个像素参与了计算。比如极端一点的情况，某个像素是 10，周围 8 个像素是 1，那么经过 <code>RemoveGrain(20)之后，这个像素就变成了2</code> 。</p>\n<p>这种操作太糊了，我们想要一个稍微弱一点的模糊。最简单的想法：我把中间那个像素的权重提高一点，这就是 <code>RemoveGrain(11)</code> 。具体权重的取值是：</p>\n<p>[1161811618141811618116]⎣</p>\n<p>⎡1618116181418116181161⎦</p>\n<p>⎤</p>\n<p>就是说中间的像素乘以 1/4、加上中心十字的四个像素乘以 1/8、加上四个角的四个像素乘以 1/16。 把权重加起来是 1，说明这是个 unbiased 的操作。可以用 vs 试试 <code>RemoveGrain(11)</code> ，看看是不是要比 20 清晰一点。类似的还有: <code>RemoveGrain(19)</code> ： 权重是：</p>\n<p>[18181818018181818]⎣</p>\n<p>⎡81818181081818181⎦</p>\n<p>⎤</p>\n<p>可以想见这个会比 20 还要糊。 以上三种，叫 Average Blur，用平均值进行模糊。既然可以用平均值，我们不难想到另一个经常和平均值一起出现的中位数。</p>\n<h4 id=\"中位数模糊median-blur\"><a class=\"anchor\" href=\"#中位数模糊median-blur\">#</a> 中位数模糊（Median Blur）</h4>\n<p>中位数，同样的，我们可以取一个像素和周围八个像素总计 9 个像素的中位数。这就是 RemoveGrain (4)。另外还有三个采用这种思路的模糊滤镜，分别是 1，2，3。首先我们把周围 8 个像素的值排序，我们把 mode 的值叫做 a，要是中间像素的值在排序中，比第 a 大的值还要大，就把它换成这个第 a 大的值；如果比第 a 小的值还要小，就把他换成这个第 a 小的值。 比如：</p>\n<p>[593726148]⎣</p>\n<p>⎡571924368⎦</p>\n<p>⎤</p>\n<p>然后我们的 mode 设置为 1，2 并不比 1 小也不比 9 大，什么都不会发生。mode 为 2，2 正好是第 2 小的，什么都不会发生。mode 为 3，2 终于比 3 要小了，所以中间 2 会变成 3。变成：</p>\n<p>[593736148]⎣</p>\n<p>⎡571934368⎦</p>\n<p>⎤</p>\n<p>同理，那么 <code>mode</code>  为 4，2 就会变成 5。然后不难证明，假如 <code>mode</code>  是 4，中间那个像素永远会变成中央加周边总共 9 个像素的中位数。从刚才这个流程里我们可以看到，随着 <code>mode</code>  从 1 到 4，原来在 9 个像素里面比较小的 2 逐渐变大了，也就是说模糊的效果逐渐加强了。</p>\n<p>然后， <code>RemoveGran</code>  的 <code>mode</code>  参数是可以接受数组的，最多不超过 <code>src</code>  的平面数目，假如不足 <code>src</code>  的平面数目的话，那么滤镜会自动把 <code>mode</code>  扩展成一个长度为 3 的数组。例如 <code>src</code>  有三个平面， <code>mode</code>  是 1，那么滤镜会自动把 <code>mode</code>  扩展成一个长度为 3 的数组 <code>[1,1,1]</code> ，假如 <code>mode</code>  是 <code>[20, 1]</code>  那么滤镜会会把它变成 <code>[20,1,1]</code> ，总而言之就是重复的是数组最后一个数。这三个数对应着 <code>RemoveGrain</code>  会用什么样的 <code>mode</code>  去对 <code>src</code>  的三个平面做模糊。例如 <code>[20, 1, 1]</code> ，就意味着对 Y 平面用 20，对 UV 平面用 1。</p>\n<h4 id=\"中值模糊-vs-中位数模糊\"><a class=\"anchor\" href=\"#中值模糊-vs-中位数模糊\">#</a> 中值模糊 vs 中位数模糊</h4>\n<p>Average Blur &amp; Median Blur 这两大类的滤镜的适用范围不太一样。比如下面这个极端情况：</p>\n<p>[00001000000]⎣</p>\n<p>⎡00001000000⎦</p>\n<p>⎤</p>\n<p>用 RG4 会把中间的 100 直接变成 0；用 RG20 则会把中间变成 11。</p>\n<p>再比如这里有一根线：</p>\n<p>[010001000100]⎣</p>\n<p>⎡000101010000⎦</p>\n<p>⎤</p>\n<p>假如用 RG4 的话，中间会变成 0，表现为特别细的线会直接被抹掉，这也就是中位数模糊不太适用的场景。</p>\n<p>还有一种很特殊的噪声，称为椒盐噪声，像这样 <s>撒盐图中差可拟</s>：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Salt-and-pepper_noise-bf6c8d834f8743b7b5659a941df44b66.jpg\" alt=\"Figure 8\" /></p>\n<p>RG4 会直接把它抹平，RG20 还会残留一点。而这种情况下我们一般倾向于抹平，所以中位数模糊是很合适的：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Median_blur_for_Salt-and-pepper_noise-d8472f472072d0ed03d6e97fb6748790.jpg\" alt=\"Figure 9\" /></p>\n<p>假如用平均值模糊的话，会变成这样：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Average_blur_for_Salt-and-pepper_noise-ad2d28811f2ea73ca246d70b1a04823d.jpg\" alt=\"Figure 10\" /></p>\n<p>比较丑陋。</p>\n<p>但就像刚才提到，在普通的图像中中位数模糊对于画面的破坏是比较大的，因此总的还是突出一个综合考虑。然后<a href=\"https://github.com/HomeOfVapourSynthEvolution/havsfunc\"> <code>havsfunc</code> </a> 里面，就有这么一个综合考虑的滤镜， <code>MinBlur</code> ，会选取两种方式中破坏较小的那种，并跟上一些后处理，具体可以看其中的代码。</p>\n<h4 id=\"自定义平均权重\"><a class=\"anchor\" href=\"#自定义平均权重\">#</a> 自定义平均权重</h4>\n<p>对于以上提到的平均值模糊，对图像处理熟悉的同学会发现其实就是用一个 3×33×3 的核（kernel）进行卷积，如果我们想自己设定权重该怎么办呢？可以用<a href=\"https://amusementclub.github.io/doc/functions/video/convolution.html?highlight=conv#std.Convolution\"> <code>vs.core.std.Convolution()</code> </a>，用 <code>matrix</code>  参数传入卷积核，会比 <code>rgvs</code>  快一些。</p>\n<h3 id=\"2-usmunsharp-mask\"><a class=\"anchor\" href=\"#2-usmunsharp-mask\">#</a> (2). USM（Unsharp Mask）</h3>\n<h4 id=\"clip的简单运算\"><a class=\"anchor\" href=\"#clip的简单运算\">#</a> clip 的简单运算</h4>\n<p>我们可以对两个 clip 进行一些简单的运算：拥有相同帧序号的相同平面之间，进行逐像素的运算 —— 这自然要求两个 clip 之间的格式和分辨率要是相同的。这里举一些滤镜来实现：</p>\n<h5 id=\"vscorestdmergeclipa-clipb-weight\"><a class=\"anchor\" href=\"#vscorestdmergeclipa-clipb-weight\">#</a> <a href=\"https://amusementclub.github.io/doc/functions/video/merge.html?\"> <code>vs.core.std.Merge(clipa, clipb, weight)</code> </a>：</h5>\n<p>这里表示对 <code>clipa</code>  和 <code>clipb</code>  进行线性的融合，结果可以表示成 (1−weight)×clipa+weight×clipb (1−weight)×clipa+weight×clipb 。比如 <code>weight=0</code>  时，结果就是 <code>clipa</code> ； <code>weight=1</code>  时，结果就是 <code>clipb</code> ；</p>\n<h5 id=\"vscorestdmakediffclipa-clipb\"><a class=\"anchor\" href=\"#vscorestdmakediffclipa-clipb\">#</a> <a href=\"https://amusementclub.github.io/doc/functions/video/makediff.html\"> <code>vs.core.std.MakeDiff(clipa, clipb)</code> </a> 以及<a href=\"https://amusementclub.github.io/doc/functions/video/mergediff.html\"> <code>vs.core.std.Mergediff(clipa, clipb)</code> </a>：</h5>\n<p>这两个滤镜分别表示 clipa−clipbclipa−clipb 和 clipa+clipbclipa+clipb，注意，和 <code>std.Merge()</code>  不同，这里相加减可能会超出整数的范围。所以假如你传入的是整数类型的 clip，做减法的时候 <code>std.MakeDiff()</code>  会加上一个中点的偏置，比如 8bit 视频会加上 128；做加法的时候 <code>std.MergeDiff()</code>  会减去一个中点的偏置，比如 8bit 视频会减去 128。当然这并不能完全解决超出范围的问题，不过好在我们直接做差的视频一般是比较相似的，所以一般没事，如果你实在不放心，可以转成浮点再做。</p>\n<h4 id=\"分离噪点层\"><a class=\"anchor\" href=\"#分离噪点层\">#</a> 分离噪点层</h4>\n<p>会对 clip 进行简单的运算后，我们来进行一组操作：首先对 src 进行一个 RG11 , 可以想见，结果比较糊、噪点比较少，就叫 blur；然后用 <code>MakeDiff</code>  做 src−blursrc−blur ，就得到了噪点层 —— blur 和 src 的差异。</p>\n<h4 id=\"unsharp-mask\"><a class=\"anchor\" href=\"#unsharp-mask\">#</a> Unsharp Mask</h4>\n<p>然后，我们将这个噪点层 —— 它包含了原图比较多的高频信息，用 <code>MergeDiff</code>  加到 src 上，这就是最简单且副作用爆炸的锐化：Unsharp  Mask。这玩意儿的副作用包括但不限于：ringing，aliasing，爆炸的噪点。这玩意儿就是 photoshop 的 usm。但也是有好处的，黑色的线条看起来更黑了，纹理更清晰了，这也是我们后续所有锐化手段的基础。我们需要对它做各种限制，希望尽量保留下它的锐化效果又能消除多余的 ringing 之类的东西。</p>\n<h3 id=\"3-sbr\"><a class=\"anchor\" href=\"#3-sbr\">#</a> (3). SBR</h3>\n<p>现在手上有一张重噪点的图：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Heavy_noise_flower-2e5630207c969f9b1cb1151185d57945.jpg\" alt=\"Figure 11\" /></p>\n<p>画面中还有一朵看起来比较清晰的花，现在我们对它 RemoveGrain，得到 blur：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Removegrain_flower-f16ec869bc441f1ba31cf3a584e7c3f4.jpg\" alt=\"Figure 12\" /></p>\n<p>噪点看起来平滑了很多，但是花也被搞糊掉了，我们用这两张图做一个 usm：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Usm-800f8aafd5017794bfd7ce2783f7e489.jpg\" alt=\"Figure 13\" /></p>\n<p>出了这么个东西，可以看到，原来花的那个位置有个比较明显的轮廓，然后整体看起来有噪点，那么我们对这个 clip 做一个 RemoveGrain：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Removegrain_usm-e64e92df16e924d1cf9e55bc1cca8f7e.jpg\" alt=\"Figure 14\" /></p>\n<p>看起来噪点减少了，但花的轮廓还在，我们把这个 clip 加回到之前的 blur，最后得到的是这样一张图:</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/Limited_blur-968e2680b556b314455262d80639bd5a.jpg\" alt=\"Figure 15\" /></p>\n<p>可以看到整体的模糊效果减小了，这就是最基础的限制 blur 滤镜强度的一个方法。然后因为是限制 blur 滤镜的，实际上也意味着在用 usm 做锐化的时候，我们也可以限制锐化的强度了。</p>\n<h2 id=\"3-repair\"><a class=\"anchor\" href=\"#3-repair\">#</a> 3. Repair</h2>\n<p>这一节要引进一个新的滤镜 ——<a href=\"http://avisynth.nl/index.php/RgTools/Repair\"> <code>vs.core.rgvs.Repair(clip, ref, mode)</code> </a>， 我们一般用 mode 1~4——mode N 表示，clip 的某个像素，倘若超出 ref 对应像素及其周围 8 个像素中 [[第 NN 小，，第 NN 大]]，这个范围，那么就取 ref 中，这九个像素的 第 N 小 / 第 N 大。这个感觉和 <code>RemoveGrain</code>  有点像 ——RG 做的是：每一个像素，相比于自己周边 8 个像素，不要太过分； <code>Repair</code>  做的是，clip 的每一个像素，相比于 ref 的 9 个像素，不要太过分。这种操作经常用于可能引入突兀瑕疵的 clip。</p>\n<h3 id=\"1-deringing\"><a class=\"anchor\" href=\"#1-deringing\">#</a> (1). Deringing</h3>\n<p>知道了 Repair 有这个功能，我们就来看看它为啥可以做 de-ringing。</p>\n<p>一条 2px 宽度的黑色线条，如果周边都是灰色的像素。那么扁平化了看，像素的值是：</p>\n<p>[128,128,128,16,16,128,128][128,128,128,16,16,128,128]</p>\n<p>中间两个 16 是黑色，周边是 128 的灰色。ringing 发生的时候，会变成这样：</p>\n<p>[128,128,160,16,16,160,128][128,128,160,16,16,160,128]</p>\n<p>直观的看就是裹着线条的像素值变得更剧烈了。Repair 做的，就是看 clip 的每个像素，是不是值偏高或者偏低，比如 160，对应源周边的像素，要么是 128 要么是 16，显然已经高了，就把它限制为最高值，如果不超过范围就不处理，跟 RemoveGrain 一样。</p>\n<h3 id=\"2-non-ringing-upscale\"><a class=\"anchor\" href=\"#2-non-ringing-upscale\">#</a> (2). Non-ringing upscale</h3>\n<p>non-ringing 的做法，就是取一个 sharp 的作为 clip ，取一个没有 ringing，soft 的作为 ref ，然后做一个 repair：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>sharp <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>down<span class=\"token punctuation\">,</span> <span class=\"token number\">1920</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1080</span><span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"lanczos\"</span><span class=\"token punctuation\">,</span> a1<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>soft <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>down<span class=\"token punctuation\">,</span> <span class=\"token number\">1920</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1080</span><span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"gauss\"</span><span class=\"token punctuation\">,</span> a1<span class=\"token operator\">=</span><span class=\"token number\">90</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>up <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>sharp<span class=\"token punctuation\">,</span> soft<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>有读者可能会担心，这么做，会不会让 Lanczos 本身锐利的一面被削弱，实际观感更接近 soft 的 Gaussian。这点大家可以试试，实际用起来，取 <code>a1=90</code>  左右，观感是最平衡的。</p>\n<h3 id=\"3-rg-dering\"><a class=\"anchor\" href=\"#3-rg-dering\">#</a> (3). RG Dering</h3>\n<p>resize 的时候可以这样 de-ringing，平时呢？ 拿到一个有 ringing 的源，也只要制造一个 soft，然后 <code>Repair(src, soft)</code>  就行。 这就是 RG Dering:</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>soft <span class=\"token operator\">=</span> RemoveGrain<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Repair<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> soft<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"4-利用repair-限制usm\"><a class=\"anchor\" href=\"#4-利用repair-限制usm\">#</a> (4). 利用 Repair 限制 USM：</h3>\n<p>USM，这东西还有个意想不到的用途：就是编码前用个什么 RG11 这种 light-kernel 给锐化一下，压出来的成品，vmaf 分会高的离谱。也是好事吧，毕竟人眼非常喜欢  usm。最后，千万别对老番烂番直接用。。。因为 USM 会把烂在哪里放大了给你看：它会把很多瑕疵放大，让锯齿、ringing、blocking  显露得非常明显。</p>\n<p>怎么限制它的副效果呢？一个方法就是用 Repair，Repair (sharp, src)。这就是 ModerateSharpening。</p>\n<p>ModerateSharpening 会把 ringing 去掉很多，但是留下的锯齿很明显。所以实际生产也没人用。。。non-the-less 这是一个 Repair 的好用法。</p>\n<h3 id=\"5-contra-sharpen\"><a class=\"anchor\" href=\"#5-contra-sharpen\">#</a> (5). Contra-Sharpen</h3>\n<p>Contra-Sharpen 一般是，做了一些带有 blurring 性质的操作后，比如抗锯齿，比如降噪，画面看起来变模糊了。我们想对画面做一个锐化，补偿一下锐度损失，但是又不希望这个锐化使得画面看上去比源更锐利。如果源是 src，你一番处理后成了 flt，比如做了个高质量降噪。可能多数场景，flt 锐利度比源下降了 5%，少数场景下降了  20%。（比划一下，具体怎么量化我也不知道。。。）你如果一波 USM，雨露均沾的，把锐利度提升了 15%。少数场景的确几乎回到了之前的水准，但是多数场景就比之前还锐利，咋办？我们希望限制一下，锐利度提升，不要超过 flt 比起 src 下降的尺度。也就是，锐化时候，打上去的 diff，不要比 src−fltsrc−flt 还过分。即：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>blur <span class=\"token operator\">=</span> RG<span class=\"token punctuation\">(</span>flt<span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>diff_for_sharp <span class=\"token operator\">=</span> flt <span class=\"token operator\">-</span> blur</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>diff_src_flt <span class=\"token operator\">=</span> src <span class=\"token operator\">-</span> flt</pre></td></tr></table></figure><p>然后我们希望，对于每个像素确保： ∣flt−blur∣&lt;=∣src−flt∣∣flt−blur∣&lt;=∣src−flt∣</p>\n<p>然后： sharp=flt+(flt−blur) sharp=flt+(flt−blur)</p>\n<p>这个思路原原本本实现，需要借助 Expr 做像素级计算，但是用 Repair 可以近似实现： ∣flt−blur∣&lt;=∣src−flt∣(max of 3∗3)∣flt−blur∣&lt;=∣src−flt∣(max of 3∗3)</p>\n<p>这就是 contra-sharp 的思路 。我们结合代码来看：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>nr16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>bilateral<span class=\"token punctuation\">.</span>Bilateral<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> sigmaS<span class=\"token operator\">=</span><span class=\"token number\">1.5</span><span class=\"token punctuation\">,</span>sigmaR<span class=\"token operator\">=</span><span class=\"token number\">0.015</span><span class=\"token punctuation\">,</span> algorithm<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>noise <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span>nr16<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>blur <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>RemoveGrain<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>diff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span>blur<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>diff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>Repair<span class=\"token punctuation\">(</span>diff<span class=\"token punctuation\">,</span>noise<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MergeDiff<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span>diff<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><code>nr16 = core.bilateral.Bilateral(src16, sigmaS=1.5,sigmaR=0.015, algorithm=2)</code>  这是调用 Bilateral 算法（当年 avs 没有好的降噪滤镜用，这是一个还行的工具了）进行高质量降噪；</p>\n<p><code>noise = core.std.MakeDiff(src16,nr16)</code>  这是分离噪点，也就是 src−fltsrc−flt；</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>blur <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>RemoveGrain<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>diff <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>MakeDiff<span class=\"token punctuation\">(</span>nr16<span class=\"token punctuation\">,</span>blur<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ol>\n<li>这是获取锐化用的 diff；</li>\n<li><code>diff = core.rgvs.Repair(diff,noise,1)</code>  这就是确保，锐化用的 diff，每个像素的改动，不要超过 (源 - 锐化) 对应位置 9 个像素的最大改动。近似的可以认为是对应像素位置，降噪而损失的锐利度；</li>\n<li>最后， <code>res = core.std.MergeDiff(nr16,diff)</code> 。把限制过的 diff 层加回去，完成锐化。</li>\n</ol>\n<p>这个实现方式并非严格的保证锐化程度不超过源，而是用了一个近似，允许一定程度放大锐化强度。原则上锐化强度不该超过像素自身损失，现在是允许不超过周边 3x3 像素的损失，即 locally restricted 而非 pixel-wise  restricted。所以这东西说是补偿，其实还是略微在源的基础上放大了一些锐利度，因为早期 TAA（常用的抗锯齿）滤镜最后就给你来这一手，所以经常给人以 “抗锯齿会让线条变得更锐利” 的错觉。</p>\n<h2 id=\"4-limitfilter\"><a class=\"anchor\" href=\"#4-limitfilter\">#</a> 4. LimitFilter</h2>\n<p>上一节提到，Repair 根据周边像素的相对大小来限制 ref 和 src 的区别不能过大。LimitFilter 则是比较像素本体数值，跟一个阈（yù）值，以及允许的弹性程度作比较。最早来自于 avs 的 dither package，现在则是一般用 <code>mvf.LimitFilter</code> 。用法 <code>mvf.LimitFilter(flt, src, thr, elast)</code> 。其中，  <code>flt</code>  是要处理的 clip； <code>src</code>  是原始的 clip； <code>thr</code>  是一个阈值，表示 8bit 下，flt 和 src 可以差别多大。通常取值在 0.5~3.0 左右，表示 8bit 下允许偏移这么多。小数不用担心，内部运算精度是 16bit 的； <code>elast</code> ，是弹性值，我们随后说。</p>\n<p>这里举个简单例子来说明它的作用表现，假设 src 的某个像素是 50, <code>thr=0.5, elast=2.0</code> :</p>\n<ol>\n<li>∣flt−src∣&lt;=thr∣flt−src∣&lt;=thr，直接保留。比如说 flt=49.8 或者 50.4，那么不做调整；</li>\n<li>∣flt−src∣&gt;thr×elast∣flt−src∣&gt;thr×elast，直接取值 src。比如说 flt=48.9 或者 51.7，那么直接设置为 50；</li>\n<li>thr&lt;∣flt−src∣&lt;thr×elastthr&lt;∣flt−src∣&lt;thr×elast ， 结果会被连续地调整到 [src−thr×elast24×(elast−1),src+thr×elast24×(elast−1)][src−thr×4×(elast−1) elast2,src+thr×4×(elast−1) elast2] 之间: final=src+(flt−src)×thr×elast−∣flt−src∣thr×elast−thrfinal=src+(flt−src)×thr×elast−thrthr×elast−∣flt−src∣。</li>\n</ol>\n<p>比如 flt=49.1，调整结果大约为 49.8；flt=50.6，调整结果大约为 50.5。</p>\n<p>综合以上，在 <code>thr=0.5, elast=2.0</code>  时，我们可以画出这个图：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/LimitFilter_0.5_2-945f8a18041ac8e274335a308bf4a78e.png\" alt=\"Figure 16\" /></p>\n<p>可以看到在 <code>thr=0.5, elast=2.0</code>  下。滤镜保证 ∣final−src∣&lt;=0.5∣final−src∣&lt;=0.5。</p>\n<p>elast&lt;=2elast&lt;=2 的时候，有个很巧的结论，就是 ∣final−src∣&lt;=thr∣final−src∣&lt;=thr。如果调整后出现 ∣final−src∣&gt;thr∣final−src∣&gt;thr，则一定是 elast&gt;2elast&gt;2 才会出现。（你可以通过一些简单的计算证明这个结论）</p>\n<p>这里再贴上一些不同参数下的曲线以供比较：</p>\n<p><img data-src=\"https://guides.vcb-s.com/assets/images/LimitFilter_Combined-6fe4588ee81433a7fdac6001d6521194.png\" alt=\"Figure 17\" /></p>\n<p>除此之外，LimitFilter 还有一些例如 <code>ref</code>  的参数，因为一般用不到且原理大差不差，就不交代了，下面给出 <code>mvf.LimitFilter</code>  的完整计算过程。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>## Algorithm for Y/R/G/B plane (for chroma, replace \"thr\" and \"brighten_thr\" with \"thrc\")</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>##     dif = flt - src</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>##     dif_ref = flt - ref</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>##     dif_abs = abs(dif_ref)</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>##     thr_1 = brighten_thr if (dif > 0) else thr</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>##     thr_2 = thr_1 * elast</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>##</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>##     if dif_abs &lt;= thr_1:</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>##         final = flt</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>##     elif dif_abs >= thr_2:</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>##         final = src</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>##     else:</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>##         final = src + dif * (thr_2 - dif_abs) / (thr_2 - thr_1)</pre></td></tr></table></figure><h3 id=\"1-limitfilter-与-usm\"><a class=\"anchor\" href=\"#1-limitfilter-与-usm\">#</a> (1). LimitFilter 与 USM</h3>\n<p>第一个用途，我们可以用 LimitFilter 来限制 USM 的副效果，例如 <code>LimitFilter(thr=3.0, elast=4.0)</code> 。上节提到了 ModerateSharpening—— <code>Repair(usm, src, 1)</code> 。事实上用 LimitFilter  效果更好，可以选择控制的参数也更多。不只是处理锐化，AA、dering，以及很多破坏性处理，它都能处理得很好。Repair 一个缺点是只能处理  flt 比 src 更 “突兀” 的，而 LimitFilter 两个方向都能处理。你既可以用它来限制类似 blurring、debanding 这类  smooth 滤镜的破坏力，也可以用它来限制 sharpening，line-darkening 这种 enhance 滤镜的副效果。</p>\n<h3 id=\"2-limitfilter-与-deband\"><a class=\"anchor\" href=\"#2-limitfilter-与-deband\">#</a> (2). LimitFilter 与 Deband</h3>\n<p>Dither Package 当年引入这个东西，主要是为了做 Deband（去色带） 的。它是一个叫做 GradFun3  滤镜的组成部分。它们处理色带的方法是：用一个强力的，大范围的，高精度的 smooth 滤镜先轰一遍，把色带轰平了，然后用 LimitFilter  抢救细节。因为色带所处的平面，轰一下改变很小，很可能在给定的 thr 之内；但是线条、纹理等细节，轰一下改变就很高了，可以用  LimitFilter 来还原成 src 或者接近 src 的数值，这是当年一种做 deband 的方法。</p>\n<p>另一种，是基于上古滤镜，flash3k_yuv_deband（f3kdb）。f3kdb 没这么多花花肠子，就是找得准，然后轰。有关 Deband 的内容后续会有专门的章节，这里我们仅仅拿出一套参数来充当展示。</p>\n<p><code>dbed = core.neo_f3kdb.Deband(src,8,48,48,48,0,0,output_depth=16)</code>  这是一个使用 f3kdb，进行 Deband 的例子，具体参数的设置和含义先按下不表，我们先认为这个操作去掉了 banding（色带）</p>\n<p>此时 f3kdb 可以看做一个精准的 smoothing kernel，图像经过这么一整变得更加平滑，我们把它跟 LimitFilter 结合起来</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>dbed <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>neo_f3kdb<span class=\"token punctuation\">.</span>Deband<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>output_depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>dbed <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>LimitFilter<span class=\"token punctuation\">(</span>dbed<span class=\"token punctuation\">,</span>pre_db<span class=\"token punctuation\">,</span>thr<span class=\"token operator\">=</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span>thrc<span class=\"token operator\">=</span><span class=\"token number\">0.6</span><span class=\"token punctuation\">,</span>elast<span class=\"token operator\">=</span><span class=\"token number\">1.5</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>注意这里 <code>thrc=0.6</code> ，是 chroma 平面的 thr。一般 Deband 的 thr×elastthr×elast 不超过 2，因为大多数色带就只是 1 级别的差距，不会很大。而如果像 USM 那样，目的是限制线条， thr×elastthr×elast 就会给的很高，比如 3 x 4=12。</p>\n<h3 id=\"3-limitfilter-融合线条与非线条\"><a class=\"anchor\" href=\"#3-limitfilter-融合线条与非线条\">#</a> (3). LimitFilter 融合线条与非线条</h3>\n<p>这个需求最早是 avs 时代，mawen1250 写 nnedi3_resize16 的。天才 mawen1250，早在 madVR 用 nnedi3  拉升之前，就设想出可以用 nnedi3，这个本职为倍高的滤镜，做一个高质量的 upscaler。问题是，nnedi3 当时运算精度为 8bit，8bit 的精度处理线条部分没问题，处理平面部分就很恶心了。低精度的 resize 很容易在平面引入肉眼可见的色带，咋办？两条路：</p>\n<ol>\n<li>用 8bit 精度处理完后接一个 deband；这样可行，但是，deband 本身是个很复杂的操作，参数不太好给；</li>\n<li>线条部分用 8bit，平面部分用 16bit 的常规 resizer（avs 时代已经有 Dither_resize16 做高精度 resize）。反正平面部分拉升，算法好不好都没有啥区别。然后，根据线条框一个 mask（区分线条平面），线条部分采取 8bit 高质量拉升，平面部分采取 16bit 高精度拉升。</li>\n</ol>\n<p>后者是旧版 nnedi3_resize16 的做法。这个做法是没问题的，效果也很好，就是。。。慢。最后，mawen 想到了一招：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>edge <span class=\"token operator\">=</span> nnedi3<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>to_16_bit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>nonedge <span class=\"token operator\">=</span> resize16<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这两个 clip，平面部分虽然精度有差别，但是差别非常小，也就是数值 1 左右的范围。如果两个 clip 差别在 1.0 以内，我认定这块是 nonedge；如果差别在 1.5 以上，我认定这是 edge。区别在这中间，不要紧，只要保证过渡连续性就好。这完全可以用 LimitFilter 实现：</p>\n<pre><code>LimitFilter(nonedge, edge, thr=1.0, elast=1.5)\n</code></pre>\n<p>用了这个方案后性能提升非常多。到了 vs 时代，滤镜内部精度都上浮点数了，这个 trick 自然没有再用的必要。但是这是在 masktools 之前，一个很有用的，对线条，对平面分别处理，然后巧妙的融合两者的做法：</p>\n<p><code>LimitFilter(nonedge, edge, thr=1.0~2.0, elast=1.5~2.0)</code> 。</p>\n<p>事实上，deband 本身可以看做，对平面做 deband（nonedge=dbed），对线条不做处理（edge=src）： <code>LimitFilter(dbed, src, thr=1.0, elast=1.5)</code> 。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%99%A8%E5%9F%BA%E7%A1%80/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B8%83%E7%AB%A0%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E5%99%A8%E5%9F%BA%E7%A1%80/",
            "title": "第七章视频编码器基础",
            "date_published": "2024-03-16T15:10:15.000Z",
            "content_html": "<h1 id=\"第七章-视频编码器基础\"><a class=\"anchor\" href=\"#第七章-视频编码器基础\">#</a> 第七章 视频编码器基础</h1>\n<p>首先，编码器是一项系统工程，其中每一环都可以拿出来当一门大学课程用，也有无数的论文去给视频编码这项技术去增加技术的可能性，所以这里的编码器教学目标是让大家能听明白，知道编码器的参数是干什么的，我想要怎么做的时候去改什么参数。</p>\n<p>教程内容会涉及到不少概念，大家不需要特别深入去理解，在这个阶段会修改编码器参数，知道怎么用就行了。</p>\n<p>首先，大家一定先要弄清楚一个概念，x264 和 H264，x265 和 H265 的关系。</p>\n<p>H26x 是<strong>标准</strong>，x26x 是<strong>实现</strong>。</p>\n<p>标准定义了视频流的结构，数据流的存放等框架性内容。<br />\n实现则是你我都在用的编码器程序。</p>\n<p>任何符合 H26x 规范的编码器实现，它输出的视频流一定能够被任何符合 H26x 规范的解码器解码。</p>\n<p>所以今后请务必区分 H264，x264 等的区别，以及接下来讲的时候也别搞混了。</p>\n<h2 id=\"1-基本概念\"><a class=\"anchor\" href=\"#1-基本概念\">#</a> 1. 基本概念</h2>\n<h3 id=\"1-帧内编码-intra-frame-coding\"><a class=\"anchor\" href=\"#1-帧内编码-intra-frame-coding\">#</a> (1). 帧内编码 (Intra-frame coding)</h3>\n<p>其实讲视频编码，实际上还是得从 I, P, B 帧说起，这三种帧是如今普及率最高的 H264 所使用的帧类型。</p>\n<p>视频编码一切的一切，基础的基础，所有东西都引用它，我们从 I 帧讲起。</p>\n<p>实际上 I 帧就是存储的一张完整的图片。</p>\n<p>由于在视频编码过程中需要对一张完整的图片进行编码。<br />\n于是乎也出现了 HEIF, AVIF 等规范，他们就是利用了 HEVC，AV1 所规定的<em>帧内编码</em>技术带来的提升，从而做到极高的压缩率。</p>\n<p>但是我们还是追根溯源，从单张图片的老祖宗说起，JPEG。</p>\n<p>JPEG 干的事情，现在的编码器对画面处理的时候全都会做。</p>\n<p>首先，*** 色度半采样 *** 大家也都知道了，我们通过将 RGB 转换成 YUV，直接去掉了大量的信息。<br />\n这里的信息，是指最基础概念的，0 和 1。</p>\n<p>然后，JPEG 将图片分为了无数个 8x8 的小块。<br />\n每一块都是 64 个像素。</p>\n<p>我们对 JPEG 做了一个操作 - *<strong>DCT*</strong>：*<strong> 离散余弦变换 *</strong><br />\nDCT 干啥的可以不用理解，也可以理解为空间换时间的傅里叶变换，将离散的输入变到频域空间。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/DCT_00.png\" alt=\"img\" /></p>\n<p>我们通过这张表，可以将任何 8x8 的小块，通过记录每个格子用了多少次，来获得一个 8x8 的矩阵，这个矩阵能拿来重建一切 8x8 的像素。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/DCT_01.png\" alt=\"img\" /></p>\n<p>然后我们获得了一个包含一个 8x8 格子的 dct 结果。</p>\n<p>我们将结果通过除以另一个表格，这个表格叫做<em>量化表</em>。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/Quantization-Table.png\" alt=\"img\" /></p>\n<p>就能获得一个 *<strong> 量化 *</strong> 后的矩阵。</p>\n<p>这时候可以发现左上角有数字，右下角没有数字，因为我们通过<em>量化</em>去除了高频数据。</p>\n<p>这时候在使用<em>霍夫曼编码</em>，<em>熵编码</em>等方式，我们就能将 8x8 的一个格子变得非常小，成为简短的很小的一段数据。</p>\n<p>这就是 <em>色度半采样</em> - <em>变换</em> - <em>量化</em></p>\n<p>过程中，我们去除了高频数据，留下了低频数据。</p>\n<p>但是，所有的过程都围绕 8x8 的格子展开，当<em>量化表</em>非常激进，我们去除了大量的数据之后，每个 8x8 格子之间的差异就会被拉大。</p>\n<p>于是，我们就看到了低码率视频最常见的一种 Artifact: <strong>Blocking</strong></p>\n<p>其实如果你搞过一些 Hi-Fi 的话，纠结无损音频是不是真无损，也是看频谱图的高频有没有被保留，原理是相似的。</p>\n<p>实际上我们做的事情，就是把人对这些不是很敏感的高频数据给全抹了。<br />\n运用这项技术，再加上<em>运动侦测</em>。</p>\n<p>我们就有了最基础的，视频编码器。</p>\n<h3 id=\"2-帧间编码-inter-frame-coding\"><a class=\"anchor\" href=\"#2-帧间编码-inter-frame-coding\">#</a> (2). 帧间编码 (Inter-frame coding)</h3>\n<p>作为视频编码器，我们需要在时域上，寻找相似的地方，并且把这些相似的地方标记出来，去找别的帧引用。</p>\n<p>怎么分割动与静，怎么将画面细节拿出来，方案一直在进化，标准一直在提升。</p>\n<p>当初的 MPEG2，分割是最无脑的分割。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/MPEG2.png\" alt=\"img\" /></p>\n<p>也就是，纯分块。</p>\n<p>每一个最小的小方格，大小就是 8x8。</p>\n<p>这样无脑分块是无法有效寻找动态内容的。<br />\n效果较为一般，但是符合当时的算力水平。</p>\n<p>进化到 H264 时代，就多了一点点细节。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/H264.png\" alt=\"img\" /></p>\n<p>我们可以分 8x8，也可以分 4x4。<br />\n与此同时，我们还可以对每一个 16x16 的块，单独给一个 <em>qp</em>。</p>\n<blockquote>\n<p>QP - Quantization Parameter</p>\n</blockquote>\n<p><em>qp</em> 是啥，量化值，还记得 JPEG 的<em>量化表</em>么？<br />\n其实就是差不多的东西。</p>\n<p>给的 <em>qp</em> 越<strong>高</strong>，被抹掉的高频信息就越多。<br />\n也意味着更可能出现视频编码的 Artifact，包括了模糊，Blocking 等。</p>\n<p>而再次进化到 H265，</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/H265.png\" alt=\"img\" /></p>\n<p>块的分割变得更加自由，最小单位也变得灵活，出现了  <code>Rect</code> ， <code>Amp</code>  这样的分割</p>\n<blockquote>\n<p><code>rect</code>  - rectangular motion partitions<br />\n <code>amp</code>  - asymmetric motion partitions</p>\n</blockquote>\n<p>（上图没有开  <code>amp</code> ）</p>\n<p>详细的分块，使得寻找动和静的分割变得更容易。</p>\n<p>同时，H265 的最小变换单元变成了 <em>TU</em>，它的大小是可变的。</p>\n<blockquote>\n<p>TU - Transform Unit</p>\n</blockquote>\n<p>也就是说，</p>\n<ol>\n<li>我们能对 4x8，8x8 等一系列大小块，动态分配 <em>qp</em>，</li>\n<li>我们能将画面分割更碎，给每个 <em>TU</em> 一个 <em>qp</em>，也意味着计算量将变得非常地可怕。</li>\n</ol>\n<blockquote>\n<p>PS: MPEG2 里，你看到的整个视频基本上所有的块都是一个 qp 值</p>\n</blockquote>\n<p>对于 H264 来说，最大的一个格子，叫做一个<em>宏块</em> (Macroblock)，大小是定死的 16x16。</p>\n<p>而 H265 中，它可以是 16x16, 32x32, 64x64。</p>\n<p>所以，帧内编码，是所有视频编码器的<strong>底力</strong>之一，<br />\n而帧间编码，则是视频编码器的另一个<strong>底力</strong>。</p>\n<h2 id=\"2-x264-参数解析\"><a class=\"anchor\" href=\"#2-x264-参数解析\">#</a> 2. x264 参数解析</h2>\n<p>接下来我们开始讲 x264 的命令行参数时，会从 <strong>底力</strong> - <strong>骗力</strong> - <strong>预算</strong> - <strong>杂项</strong> 四个方面来讲</p>\n<p>如果大家有 MeGUI 的话，可以打开，在 x264 configuration 里，拥有一个 GUI 的配置界面，里面囊括了几乎所有 x264 编码器可以调整的参数。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/megui_00.png\" alt=\"img\" /></p>\n<blockquote>\n<p>记得勾选 Show Advanced Settings</p>\n</blockquote>\n<h3 id=\"1-基础参数\"><a class=\"anchor\" href=\"#1-基础参数\">#</a> (1). 基础参数</h3>\n<p>打开的第一页，其实就涵盖了最简单的，<strong>预算</strong>，<strong>底力</strong>，<strong>骗力</strong>设置</p>\n<ul>\n<li>\n<p>底力</p>\n<p>什么是底力？</p>\n<p><code>--preset &lt;string&gt;</code></p>\n<p>x264 /x265 都有这样的 preset，它决定了你愿意花多大力气，去做<em>帧内编码</em>，<em>帧间搜索</em>，<em>率失真优化</em>。<br />\n当然，开的越高，边际收益也越低。</p>\n<p>尽管已经 2023 年了， <code>veryslow</code>  也已经是随便跑的参数了，但是也没人会想去开那个  <code>placebo</code> 。</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXYuYmVhbmRvZy5vcmcveDI2NF9wcmVzZXRfcmVmZXJlbmNlLmh0bWw=\">Encoding presets for x264</span></p>\n</blockquote>\n<p>这是每个 preset 对应的，编码器底力部分设置值。</p>\n</li>\n<li>\n<p>骗力</p>\n<p>而骗力，就有些微妙了。</p>\n<p>因为有损压缩这事情，无时无刻都在追求一件事， 骗你它是无损的，你看不出。</p>\n<p>怎么把有限的预算分配在合理的区间，让你尽可能的看不出，就是骗力。</p>\n<p>但是骗力并不是全自动的，不同的视频类型需要的参数也非常不一样。</p>\n<p><code>--tune &lt;string&gt;</code></p>\n<p>尽管 x264, x265 都有名曰  <code>Animation</code>  的 <em>tuning</em>，但是它是为古早制作的美漫准备的。</p>\n<p>特点就是线条少，大面积纯色，这和我们编码的日本动画差距极其巨大。</p>\n<p>所以用这样的骗力预设，可能会把所有码率预算用在不该用的地方，导致看起来非常糟糕。</p>\n<p>所以当时非常普遍使用的，是类似  <code>film</code>  这样万金油的 <em>tuning</em>。</p>\n</li>\n<li>\n<p>预算</p>\n<p>再然后，就是预算了：</p>\n<p>这告诉编码器，我有多少预算，视频可以多大</p>\n<p>这些不同模式的背后都一套复杂的算法，例如  <code>crf</code>  的目标是，给每帧分配一个固定的质量目标，每帧的 <em>qp</em> 目标都会有所不同。 它结合了人的视觉心理学，估算一个代表视频质量的指标。</p>\n<p>而下面的  <code>1pass</code>   <code>2pass</code>   <code>3pass</code> ，</p>\n<p>则是  <code>VBR</code>  ，我指定一个总的码率预算多少。</p>\n<p><code>2pass</code>  的意义是，编码器先对原视频进行一次分析， 并且根据分析给出大致的 <em>qp</em> 参考，并且在第二次的时候去详细计算。 保证我能够在总预算帽里，实现时域上的预算分配合理。</p>\n<p><code>ABR</code>  呢，额。。。总之，别用。 只有一次编码，通过经验估算下一帧大概要多少 <em>qp</em>，给一个毛估估的 <em>qp</em>。</p>\n<p>当<em>量化</em>变得不精准时，你就知道，你搞砸了。 因为，无论是 I, P, B，都记录着，<em>变换</em> - <em>量化</em>过的，<strong>块</strong></p>\n<p><strong>块</strong>是所有编码器的核心，<strong>块</strong>的好坏，很大程度上决定了视频的好坏。</p>\n</li>\n<li>\n<p>杂项</p>\n<p>而页面上的这部分，则是属于编码器的杂项部分，之一（</p>\n<p>这部分和解码相关，以前有为了兼容 psp 之类的设备特意出的版本。<br />\n当然了，2023 年了，这块可以无视了。</p>\n</li>\n</ul>\n<p>这是最笼统的介绍 x264 的参数大概能干什么， 下面我们继续深入来看。</p>\n<h3 id=\"2-参数细项\"><a class=\"anchor\" href=\"#2-参数细项\">#</a> (2). 参数细项</h3>\n<h4 id=\"frame-type\"><a class=\"anchor\" href=\"#frame-type\">#</a> Frame-Type</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/x264-frame-type.png\" alt=\"img\" /></p>\n<ul>\n<li>\n<p>GOP Size</p>\n<p>我们先来看这一段</p>\n<p>因为前面的教程讲过 GOP 的概念，这里就不深入了。</p>\n<p>其实这里只需要注意下面的  <code>Maximum GOP Size</code> 。 它指的其实是 x264 命令行中的  <code>--keyint</code> ， 代表多少帧之后要强制插 IDR 帧，它是一种特殊的 I 帧。 这样能保证你调戏进度条的时候，起码不会卡半天。</p>\n<p>试想如果一个视频是一个超大的 GOP，那你拖到任意一个地方，都需要从头开始解码。</p>\n<p>曾经的 b 站，有不少视频都是不能调戏进度条的，就是因为他们设置了超大的  <code>keyint</code> ， 导致你拖视频进度条要卡很久或者跳到老远的地方开始播放。</p>\n<p>针对番剧，我们一般给 10 秒，也就是 240 帧， 所以就是  <code>--keyint 240</code> 。</p>\n<p>但是这个  <code>240</code>  不可能不变的， 如果视频长度 11 秒，你给个  <code>240</code> ，那其实也挺幽默的。</p>\n<p>所以，请根据视频长度自己给一个合适的值。</p>\n<p>而  <code>--min-keyint</code>  则是决定了两个 IDR 帧之间最小值，一般我们给  <code>1</code> 。 如果图像一帧一大变，我们允许一帧一个 IDR。</p>\n<p>我们随便找个 x265 的编码最后统计结果。</p>\n<p>I 帧很贵，而  <code>keyint</code>  又不能太大也不能太小，这是我们要平衡的地方。</p>\n</li>\n<li>\n<p>Deblocking &amp; CABAC</p>\n<p>先看 deblocking</p>\n<p><code>-f, --deblock &lt;alpha:beta&gt;</code>  它分为两个值，它们是<em>平滑强度</em>和<em>搜索阈值</em></p>\n<p>x264 /x265 都有对应的设置，虽然在我们 bdrip 的时候，几乎不会出现 blocking，<br />\n我们才会默认给 <code>-1:-1</code>  这样的保底参数。</p>\n<p>但是在 高 crf / 低码率 下，还是需要开到  <code>0:0</code>  甚至  <code>1:0</code> 。</p>\n<p>deblock 本身的效果其实是由<strong>阈值</strong>和<strong>强度</strong>两块组成。</p>\n<p>而这个<strong>阈值</strong>，并不是我们花大力气去计算原始帧和编码后结果的差，<br />\n而是取巧去算<strong>块</strong>与<strong>块</strong>之间的 <em>qp</em> 差。</p>\n<p><em>运动向量</em>的<em>编码单元</em>参数如果差很多，那就有 block 的可能</p>\n<blockquote>\n<p>运动向量 （mv - motion vector）<br />\n编码单元 （cu - coding unit）</p>\n</blockquote>\n<p>差越多，平滑强度越强，<br />\n一般不推荐第二个值给到  <code>-1</code>  及更小，因为这样可能我们会漏掉出块的地方。</p>\n<p>而  <code>CABAC</code>  则是 x264 /x265 都在用的，最好用的二进制算术编码，<br />\n它是将每个<em>块</em> <em>变换</em> -<em> 量化</em> 后的结果做压缩的技术。<br />\n具体不展开，是针对纯 0 和 1 数据做的压缩，和视频无关（</p>\n</li>\n<li>\n<p>B-Frames</p>\n<p>接下来我们看到这一块</p>\n<p>首先上面的打勾，是  <code>--weightb</code> ，<br />\n通过进行加权预测，降低渐入渐出中块之间的误参考。<br />\n一般都是开的。</p>\n<p><code>Number of B-frames</code>  对应  <code>--bframes</code> ，设置了连续最多的 B 帧数量，<br />\n对于动画来说，动静分离的很开，很容易 B 帧占比异常大。</p>\n<p>但是连续的 B 帧，会导致块的参考次数非常的多。<br />\n一层一层参考下来，就有网络图片一次次压缩出现包浆的意味。<br />\n但是开小了，压缩率就不理想了，<br />\n所以我们一般给  <code>10</code>  上下。</p>\n<p><code>Adaptive B-Frames</code>  对应了  <code>--b-adapt</code> 。<br />\n是设立 B 帧算法，值为  <code>0</code> （不设 B 帧）， <code>1</code> ， <code>2</code> 。<br />\n数字越大算法越慢效果越好，<br />\n所以我们就开  <code>2</code> （</p>\n<p><code>B-Pyramid</code>  是一种给左右参考的 B 帧，<br />\n实际上是特殊的 B 帧，它能够帮助我们实现更长的 B 帧，所以一般也得开。</p>\n</li>\n<li>\n<p>Other</p>\n<p>再看这里，涉及到了<em>动态搜索</em>时，参考的帧的数量。</p>\n<p>这玩意儿其实也决定了 H264 视频的解码难度，<br />\n曾经这玩意儿一旦开高，大量设备没法硬解。</p>\n<blockquote>\n<p>当然现在是 2023 年（</p>\n</blockquote>\n<p>而实际上  <code>--ref</code>  给到  <code>6</code> - <code>8</code> ，就已经完全足够了。<br />\n如果开太高，可能会出现错误的搜索结果，取了错误的块导致编码质量下降。<br />\n同时，开的高，计算量也会线性增加，效果又不是特别大。</p>\n<p><code>Number of extra i-frames</code>  对应了  <code>--scenecut</code>  是 x264 判断场景变化灵敏度的，这个其实说法很多，一般默认设置不会引起画面问题，那就别动。</p>\n<p><code>P-frame Weighted Prediction</code> <br />\n 也就是  <code>--weightp</code> ，和  <code>--weightb</code>  类似，一般都是拉满。</p>\n<p><code>interlace</code>  和  <code>pulldown</code> ，这是其他部分会讲到的内容，这里只是说一下，这是对交错源的设定，用了这个会给视频加上标记，播放的时候能够当交错片源播放。</p>\n<p><code>Adaptive I-Frame Decision</code> ，其实是要不要开启  <code>Adaptive I-Frame Decision</code>  的开关，没有关掉的理由，我们需要更准确的渐变场景搜索。 关掉的话就是对应  <code>--no-scenecut</code> 。</p>\n</li>\n</ul>\n<h4 id=\"rate-control\"><a class=\"anchor\" href=\"#rate-control\">#</a> Rate Control</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/x264-Rate-Control-tab.png\" alt=\"img\" /></p>\n<p><code>rate-control</code>  其实顾名思义，控制视频码率的地方。<br />\n而视频码率，又是量化程度决定的。<br />\n还记得最开始说的么，如果你给个超夸张量化，满屏幕全是块，码率当然会低。</p>\n<ul>\n<li>\n<p>Quantizers</p>\n<p>量化部分就决定了怎么取量化，</p>\n<p><code>Min/Max/Delta</code> ，分别决定了整个视频 <em>qp</em> 的最低 / 最高 / 帧间 <em>qp</em> 最大插值。<br />\n如果我们给的比较高  <code>crf</code> ，又怕出现真烂帧，会考虑压低  <code>--qpmax</code> 。</p>\n<blockquote>\n<p>对应  <code>--qpmin</code>  /  <code>--qpmax</code>  /  <code>--qpstep</code></p>\n</blockquote>\n<p>下面的  <code>ratio</code> ，分别是  <code>--ipratio</code>  和  <code>--pbratio</code> ，<br />\n他们代表了，P 帧对 I 帧，B 帧对 P 帧，<em>qp</em> 值的变化。<br />\n因为有帧间块引用的存在，所以我们可以给 B 和 P 帧整体一个较高的 <em>qp</em> 目标，也不影响整体画面。<br />\n但是，如果出现了连续的 B 帧，B 帧又自己引用自己，<br />\n同时被引用的 B 帧 <em>qp</em> 值也很高的话，连续 B 帧就会出现肉眼可见的劣化。<br />\n而动画特性又决定了连续 B 帧机会非常多，<br />\n所以做动画相关的内容时，我们会压低这个比例，高质量编码会给  <code>pbratio</code>   <code>1.2</code> ， <code>ipratio</code>   <code>1.3</code> 。<br />\n顺带默认  <code>ipratio</code>  是  <code>1.4</code> ,  <code>pbratio</code>  是  <code>1.3</code> 。</p>\n<p><code>Chroma QP Offset</code>  就比较有意思，这个值代表 UV 平面相对 Y 平面，<em>qp</em> 值的 offset。</p>\n<blockquote>\n<p>对应  <code>--chroma-qp-offset</code></p>\n</blockquote>\n<p>本来 UV 就已经被大砍一刀（指色度采样），你还给加把火不太合适。<br />\n当然，如果你在编码 YUV444 的视频源的时候，你大可以给个  <code>2</code> - <code>4</code> 。<br />\n420 就算了，x265 也有类似的设置，我们一般都给  <code>-2</code> 。</p>\n</li>\n<li>\n<p>Rate-Control</p>\n<p><code>VBV</code>  两个码率，是用来限制最高码率的。</p>\n<blockquote>\n<p>对应  <code>--vbv-maxrate</code>   <code>--vbv-bufsize</code></p>\n</blockquote>\n<p>如果你压的动画有大量屑特效，<br />\n类似高密度头皮屑噪点，里氏 9 级地震级别镜头摇晃，<br />\n如果你不加限制，这些屑场景能轻松吃掉你码率预算的非常大一块。</p>\n<blockquote>\n<p>比如一部叫后街女孩的屑番（</p>\n</blockquote>\n<p>这些场景，大可不必追求 “暂停画质”，给个上限非常有必要，<br />\n毕竟你也看不清。<br />\n当然，如果给的太低，出现超长噪点回忆杀，再叠加 B 帧连续参考劣化，<br />\n大家看视频都见过画面一开始还行越放越烂， 就是因为连续参考还超高 <em>qp</em>。<br />\n所以还是慎重，看情况行事。</p>\n<p>而  <code>VBV Initial Buffer</code>  就不用动。</p>\n<blockquote>\n<p>对应  <code>--vbv-init</code></p>\n</blockquote>\n<p><code>Quantizer Compression</code>  则是又一个很重要的东西，但是解释清楚也需要重达几公斤的参考资料。<br />\n简单来说，通过一系列迭代算法形成一个 <em>qp</em> 值的曲线缩放， <code>--qcomp</code>  给的越高，x264 越倾向于 <em>qp</em> 选择一视同仁，无论动静一律给差不多的 <em>qp</em> 值。<br />\n但是人眼，在大自然进化的过程中，天生就对动态的东西极为敏感，<br />\n静态的东西只要他不动，基本就当看不见。</p>\n<p><code>qcomp</code>  越低，x264 会给高动态场景越高的 <em>qp</em> 值，让动态画面烂完。<br />\n这个值的取值，任然是看你，默认给的  <code>0.6</code> 。<br />\n如果做什么打斗多的番，<br />\n可能还是给高一点，战斗场景不容易烂。<br />\n反过来日常废萌番给个默认值完全够了。<br />\n当然就是，你觉得重要那就多给点咯， <code>0.7</code> ， <code>0.75</code>  都是可以给的。</p>\n</li>\n<li>\n<p>MB-tree</p>\n<p>又到了 x264 的重头戏环节， <code>MB Tree</code> 。</p>\n<blockquote>\n<p>关掉的话对应  <code>--no-mbtree</code></p>\n</blockquote>\n<p>x264 的块，叫做 <em>MacroBlock</em>，<br />\n在一个时间范围内，会有不同的帧可以被引用到某个块上，<br />\n也有可能是块引用块，<br />\n数据结构上就变成了一棵树。</p>\n<p>为了防止反复参考导致的问题，树越靠上的节点可以让  <code>qp</code>  值稍微低一些，<br />\n上梁正了下梁不太可能歪， <code>qp</code>  值就可以给高一些。<br />\n块被参考的越多，那它的 <code>qp</code>  就越低。</p>\n<p>当然这是 <em>MB tree</em> 最笼统的解释。<br />\n反映了好钢用在刀刃的思想，被引用的越多，那本体质量越高引用的质量就越高。</p>\n<p>但是，好钢容易生锈，在低  <code>crf</code>  下，大家的质量都很高了，这时候你去开这个，反而会导致画面问题。</p>\n<p>在  <code>crf 16</code>  朝上， <code>mbtree</code>  效果就不错，因为码率这时候还是比较吃紧的。<br />\n总之如果码率预算非常高，我们就不需要它。</p>\n<p>当然，现在 x264 的使用基本就是字幕组的内嵌了，<br />\n内封外挂也已经使用 hevc。<br />\n可能不会遇到真的需要 x264 做编码的情况。</p>\n</li>\n<li>\n<p>lookahead</p>\n<p>这个则是  <code>--rc-lookahead</code> ，一般来说是编码往前看多少帧，来查未来开销。<br />\n这是判断  <code>vbv</code> ,  <code>MB Tree</code> , IBP 帧的参数。</p>\n<p>不能低，但是开太高也没啥用。<br />\n一般给  <code>80</code>  到  <code>0.5*keyint</code>  左右。</p>\n</li>\n<li>\n<p>Adaptive Quantizers</p>\n<p>这是一个很重要的参数。</p>\n<p><code>aq</code>  是防止平面过度量化的功能，用被量化程度去进行 <em>qp</em> 值的补偿，上面的  <code>mode</code>  中我们有  <code>0</code> - <code>3</code>  四个选项可选，其中  <code>0</code>  为关闭， <code>1</code>  为平面内的简单分配， <code>2</code>  为进行<em>帧间 aq-variance</em> 计算，允许跨帧进行调整，一般我们用的最多的就是  <code>3</code> ，针对暗场做优化，因为人眼对暗场的敏感度比亮场高很多，同时色块和色带也常出现于暗场，低码率下尤为明显。</p>\n<p>所以一般都会给经典的  <code>--aq-mode 3</code>   <code>--aq-strength 0.7</code> 。<br />\n如果整体画面码率充足， <code>crf</code>  开的很低（ <code>15</code>  以下），给  <code>--aq-mode 1</code> ， <code>--aq-strength 0.8</code>  也是不错的选择。</p>\n<p><code>--aq-mode 2</code>  会强调动态和高频部分，平面码率会被削（整体视频码率也就低了），开了很容易平面上出瑕疵，所以如果想开，最好喂视频之前就把平面抹抹干净，并且给  <code>0.9</code>  及以上的  <code>strength</code> 。</p>\n</li>\n</ul>\n<h4 id=\"analysis\"><a class=\"anchor\" href=\"#analysis\">#</a> Analysis</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/x264-Analysis.png\" alt=\"img\" /></p>\n<ul>\n<li>\n<p>Motion Estimation</p>\n<p>Analysis 这一页，正如其名，主要突出的是一个<em>动态分析</em>。</p>\n<p>ME，即 Motion Estimation，顾名思义，就是分析帧间动态信息，并且抽象动态内容，节省码率。</p>\n<p><code>Chroma me</code> ，动态搜索查不查 UV 平面，默认是开启。<br />\n我们希望找到越多越好的匹配。</p>\n<blockquote>\n<p>不启用的话对应  <code>--no-chroma-me</code></p>\n</blockquote>\n<p><code>M.E. Algorithm</code> ，即动态搜索的方式。</p>\n<p>分别对应的是  <code>--me &lt;dia,hex,umh,esa,tesa&gt;</code> 。</p>\n<p>从左到右计算开销逐渐增大，搜索额外收益逐渐递减。 一般只推荐从  <code>umh</code>  (multi hex) 之后的算法 。</p>\n<p>搜索算法细节这里不详述，但是如果你想开 x264 软件编码直播，建议开到最多  <code>hex</code>  或者  <code>umh</code> 。  <code>esa</code>  和  <code>tesa</code>  是偏向暴力搜索的办法。</p>\n<p><code>M.E. Range</code>  这个参数又很有意思，它的取值需要和视频帧率以及分辨率相关。  <code>--merange</code>  在 x264 和 x265 里，都是决定动态搜索算法的搜索范围的。</p>\n<p>如果你的视频分辨率低， <code>merange</code>  可以适当降低； 如果你的视频帧率高， <code>merange</code>  也可以适当降低，因为高帧率视频里帧与帧之间变化小。 理论上 24 和 60 你可以给砍半  <code>merange</code>  都没问题。</p>\n<p>同时，我们习惯 1080p 给  <code>32</code> ，720p 给  <code>24</code> ，这个参数开越高越慢的同时，也会有找不到更优的动态向量，寻找错向量的可能性。 所以开大也是没啥必要的。</p>\n<p>当然了，画面动态大的打斗片，多给点总是没错的。</p>\n<p><code>Subpixel Refinement</code>  也就是  <code>--subme &lt;integer&gt;</code>  则是另一个话题，在动态的画面里，任何东西的移动是不太可能是整数像素移动的。 同时，你也不可能拿矩形的像素去显示完美的圆。 这就是子像素存在的意义。</p>\n<blockquote>\n<p>毕竟像素并不真的是一个个矩形，而是一个个固定间隔的无限小的采样点</p>\n</blockquote>\n<p>所以，我们会使用 SATD 等算法，去计算参考块和参考源的差异，计算子像素级别的块内区别。 但是细节不表，这玩意儿也是个开越大算法越狠效果越好但收益越少的东西。 遵循已经 2023 年 cpu 算力提升大到一定程度的原则， 怕就别开，开就开满，我们给  <code>10</code>  完事（</p>\n</li>\n<li>\n<p>Extra</p>\n<p>接下来两个参数非常重要。</p>\n<p>这是  <code>--psy-rd &lt;float:float&gt;</code>  的参数，它们被称为 “心理学优化参数”。<br />\n也就是骗力的大头。<br />\n之一（</p>\n<p>第一个参数是心理学优化的强度，开高能保留画面纹理；<br />\n第二个参数可以相对多保留噪点细节。</p>\n<p>但是这部分，都是 “感性” 的认知，它影响了 x264 中宏块 <em>qp</em> 值的分配，达到骗过你的眼睛的效果。<br />\n这背后具体的算法和公式又是几公斤参考材料才能解释明白的了。</p>\n<p>顾名思义，关闭  <code>psy</code> 。<br />\n除非你在做无损编码或者超低  <code>crf</code> ，<br />\n不然还是开着  <code>psy</code>  好。</p>\n<p><code>--no-fast-pskip</code>  根据官方的说明，可以防止高 <em>qp</em> 下出现色带，<br />\n默认我们要给开了。</p>\n<p><code>No Dct Decimation</code>  按照官方文档，是影响 dct 量化精度的玩意儿，我们一般不要去动它。</p>\n<blockquote>\n<p>对应  <code>--no-dct-decimate</code></p>\n</blockquote>\n<p><code>No Mixed Referenced Frames</code> ，是关闭混合溯块，按字面意思是不会在一帧里同时出现向前和向后参考，但是实际上什么效果还没有人具体验证。<br />\n但是关闭之后，一定会增加误参考的概率，所以这是个速度换质量的设置，没事也没必要开。</p>\n<blockquote>\n<p>对应  <code>--no-mixed-refs</code></p>\n</blockquote>\n</li>\n<li>\n<p>Macroblocks</p>\n<p>这里没什么可选的，因为不同大小的宏块编码器能不能用，是定义在 profile 里了，同样的，2023 年了，解码 H264 视频早就不是问题了。</p>\n</li>\n</ul>\n<h4 id=\"misc\"><a class=\"anchor\" href=\"#misc\">#</a> Misc</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/x264-misc.png\" alt=\"img\" /></p>\n<p>misc 就是杂项，你想加点额外参数不想去用 gui 调可以直接这里 (Custom Command Line) 打，会覆盖 gui 的东西。</p>\n<ul>\n<li>\n<p>Files</p>\n<p><code>logfile</code>  是 2pass 的时候记录 pass 信息的。</p>\n<blockquote>\n<p>对应  <code>--log-file &lt;string&gt;</code></p>\n</blockquote>\n<p><code>use qp file</code>  则是你可以用一种叫 qp file 的东西，告诉编码器我想要哪一帧，这一帧你就得给我编码成 I/B/P 帧，<br />\n并且可以告诉编码器这一帧我的 <em>qp</em> 目标是多少。<br />\n注意的是，这里是帧的 <em>qp</em> 目标。它影响的，是一帧里每个<strong>块</strong>的 <em>qb</em> 分配</p>\n<blockquote>\n<p>对应  <code>--qpfile &lt;string&gt;</code></p>\n</blockquote>\n</li>\n<li>\n<p>VUI</p>\n<p>VUI 是搞色彩转换的，实际上编码器啥都不会做，就给你最后输出视频打个 tag，播放器读到了会按照 tag 办事。</p>\n<p>这一块标准和规范其实前面的教程也讲了，就不多说了。<br />\n动漫新番和蓝光的编码，基本可以无脑  <code>--range tv --colorprim bt709 --transfer bt709 --colormatrix bt709</code></p>\n<p>但是如果你遇到了 DVD，尤其是什么 BD 特典送的 DVD 之类的。<br />\n小心……</p>\n</li>\n</ul>\n<h3 id=\"3-总结\"><a class=\"anchor\" href=\"#3-总结\">#</a> (3). 总结</h3>\n<p>其实讲到这里，x264 的 <em>底力</em> - <em>骗力</em> - <em>预算</em> - <em>杂项</em> 参数都讲的差不多了。</p>\n<p><em>底力</em>部分，包括了动态搜索的算法  <code>--me</code> ，搜索范围  <code>--merange</code> ，以及  <code>--b-pyramid</code>  等的开关。<br />\n代表你愿意花多少算力去增强搜索，块的本体压缩能力。</p>\n<p><em>骗力</em>部分，包括了  <code>aq</code> ， <code>psy</code>  等失真优化算法。<br />\n用以在有限的预算内，将<strong>块</strong>的量化程度控制在合理的水平，<br />\n保证好钢用在刀刃上。</p>\n<p><em>预算</em>部分，包含了  <code>crf</code> ， <code>vbr 2pass</code>  等控制码率的手段，也包含了  <code>qcomp</code>  这种是否为了动态场景调整 <em>qp</em> 的选项，也有  <code>vbv</code>  等给每帧一个预算帽的设置。<br />\n可以解构的说，视频编码器在 x264 这里，就是有较合理切分块，合理分配块的量化水平骗过人眼，通过动态搜索在帧间引用块和添加新块信息的一整套系统。</p>\n<p>对于常用的 webrip 编码来说，我们会给：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>--preset veryslow --crf 21 --deblock 0:-1 --keyint 240 --min-keyint 1 --bframes 8 --ref 8 --qcomp 0.7 --rc-lookahead 70 --aq-strength 0.7 --me tesa --psy-rd 0.6:0.15 --no-fast-pskip --colormatrix bt709 --aq-mode 3</pre></td></tr></table></figure><p>这只是一个通用的参数，但是如果要用 x26x 去做 bdrip，没有最完美什么番都能用的参数，只有最合适的参数。</p>\n<p>需要注意的是，今天我一直在说，<strong>块</strong>，<em>量化</em>，直到如今这仍然是主流编码器的所谓 “三板斧”，接下来的 x265，我们会迎来更多的<strong>块</strong>的讲解。</p>\n<p>编码器的参数调试及研究至今，从感性的认识每一个参数干什么，到科学的明白背后的公式和含义，是一项不小的进步，深入理解参数的意义能够帮助我们更准确的去调整参数达到想要的目的。</p>\n<p>但是，编码器的参数，是相互制衡的，你不可能不给驴吃饭还让驴猛跑，我们最终需要调试出的，是文件体积，画面分配，压制速度上的平衡，拿捏那个平衡的点异常重要。</p>\n<p>编码器的参数其实讲起来很空，随便挑个动画选个 10 秒 240 帧用不同参数压，就能有更深刻的体会。</p>\n<p>多上手是更推荐的选择。</p>\n<h2 id=\"a-拓展阅读\"><a class=\"anchor\" href=\"#a-拓展阅读\">#</a> A. 拓展阅读</h2>\n<p>JPEG DCT, Discrete Cosine Transform (JPEG Pt2)- Computerphile<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1RMmFFemVNREhNQQ==\">https://www.youtube.com/watch?v=Q2aEzeMDHMA</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTd2NDExcDdnVg==\">https://www.bilibili.com/video/BV17v411p7gV</span></p>\n<p>How are Images Compressed? [46MB ↘↘ 4.07MB] JPEG In Depth<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1LdjFIaXYzb3g4SQ==\">https://www.youtube.com/watch?v=Kv1Hiv3ox8I</span><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVRaNHkxUzdpRw==\">https://www.bilibili.com/video/BV1TZ4y1S7iG</span></p>\n<p>在开始讲 x265 之前，建议大家先看看拓展阅读的部分。</p>\n<h2 id=\"3-基本概念-2\"><a class=\"anchor\" href=\"#3-基本概念-2\">#</a> 3. 基本概念 2</h2>\n<p>接下来大家可以判断一下，这张图里，哪些是高频部分，哪些是低频部分，还有哪些可以被称为中频部分？</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/spatial-frq_00.jpg\" alt=\"img\" /></p>\n<details class=\"details_lb9f isBrowser_bmU9 alert alert--info details_b_Ee\" data-collapsed=\"true\"><summary>参考答案</summary></details>\n<p>在从 MPEG2 到 H264 再到 H265，其实最大的核心提升是增加了动静分割的能力。</p>\n<p>也就是，科学划块。</p>\n<p>同时也科学地分割了高低频的内容，<br />\n使得帧内和帧间的块参考变得更容易。</p>\n<p>相对于 x264 简单的分割，并且每个<em>宏块</em>有一个单独的 <em>qp</em> 来说，<br />\nH265 提供了 <em>CTU</em>-<em>CU</em> 的划分，并且在 <em>CU</em> 中，出现了 <em>PU</em> 和 <em>TU</em> 两个概念。</p>\n<blockquote>\n<p>CTU - Coding Tree Unit<br />\nCU - Coding Unit<br />\nPU - Prediction Unit<br />\nTU - Transform Unit</p>\n</blockquote>\n<p><em>CTU</em> 就如同 H264 中的 <em>Macroblock</em>，是视频编码的最大单元。</p>\n<p><em>cu</em> 则是经过算法搜索之后进行分割的单元。</p>\n<p>H265 提供了远比 H264 规范多的多的划分大小，同时出现了 <em>rect</em> 和 <em>amp</em>。</p>\n<blockquote>\n<p>rect - rectangular motion partitions<br />\namp - asymmetric motion partitions</p>\n</blockquote>\n<p><em>pu</em> 是最小的单元，叫做<em>预测单元</em>，是编码完成后可以用作参考的<em>块</em>。<br />\n<em>pu</em> 的划分使得<em>帧内</em>与<em>帧间</em>参考更容易发现相似内容。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/h265-pu.png\" alt=\"img\" /></p>\n<p>而 <em>TU</em>，是<em>变换单元</em>，是<em>量化</em>过程中的最小单元。<br />\n<em>TU</em> 的划分不与 <em>PU</em> 对齐，也就是说，<em>TU</em> 可以跨多个 <em>PU</em>。</p>\n<p>这也使得 H265 能够将 <em>qp</em> 值的分配，也精确到了高低频，动与静。</p>\n<p>细粒度使得我们能将预算更合理的分配，骗术的增强也使得合适底力下目视效果更好。</p>\n<h2 id=\"4-x265-参数解析\"><a class=\"anchor\" href=\"#4-x265-参数解析\">#</a> 4. x265 参数解析</h2>\n<blockquote>\n<p>x265 完整参数选项可以直接  <code>--fullhelp</code>  查看，不同版本的编码器可能有各自不同的选项。这里按 x265 Kyouko 3.5 给。<br />\n其次参考 x265 官方 master 分支的<span class=\"exturl\" data-url=\"aHR0cHM6Ly94MjY1LnJlYWR0aGVkb2NzLmlvL2VuL21hc3Rlci9jbGkuaHRtbA==\">说明文档</span>。</p>\n</blockquote>\n<h3 id=\"1-分块\"><a class=\"anchor\" href=\"#1-分块\">#</a> (1). 分块</h3>\n<ul>\n<li>\n<p><code>--ctu, -s &lt;64|32|16&gt;</code></p>\n<p>在 x265 中，控制最大单元的参数是  <code>--ctu</code> ，它决定了最外层的这个格子是 64x64，32x32 或者 16x16。</p>\n<p>ctu 开的越大，平面的涂抹也越严重，速度也越慢，但是有损压缩效率越高， 值得一提的是， x265 的默认 preset，其实是偏向 4k 级别高分辨率视频给的<br />\n所以  <code>ctu 64</code>  对于 4k 视频完全没问题，是非常必要的。</p>\n<p>但是做 1080p 无论 bdrip 还是 webrip，我们都会给  <code>32</code> 。<br />\n <code>ctu 64</code>  下，cu 的划分会耗费更多计算量，并且 cu 更倾向于变得更大。<br />\n这使得给 cu 下更大 TU 的 <em>qp</em> 值给的不是很精确，看起来就是糊。</p>\n</li>\n<li>\n<p><code>--min-cu-size &lt;64|32|16|8&gt;</code></p>\n<p>同时又有一个  <code>--min-cu-size</code> ，限制了最小 cu 大小。<br />\n默认是  <code>8</code> ，建议不要动，如果为了速度才会给更大。</p>\n<p>它限制了最小 cu 大小，简化了 cu 划分的计算步骤，但是让 pu /tu 划分变更大。</p>\n</li>\n<li>\n<p><code>--rect</code>  /  <code>--amp</code></p>\n<p>x265 的速度黑洞。<br />\n他们决定了 pu 的不对称划分，用很<sub>多</sub>计算量去换码率和画质的参数。</p>\n<p>一般来说，画面复杂，离子特效多，我们会考虑开 rect，利用它提供的更好的分割能力使得我们能找到潜在的匹配块。<br />\n但是还是那样，如果是没啥经费，日常废萌番，不开总是没错的。</p>\n</li>\n</ul>\n<h3 id=\"2-分块量化\"><a class=\"anchor\" href=\"#2-分块量化\">#</a> (2). 分块量化</h3>\n<ul>\n<li>\n<p><code>--limit-tu &lt;0..4&gt;</code></p>\n<p>然后到了量化部分，有 <code>--limit-tu</code> ，它控制了早退 tu 分块的算法。<br />\n取值  <code>0</code> - <code>4</code> ，分别是越来越强的早退算法。</p>\n<p>tu 分块如果不精确，那么画面可能会出现量化涂抹，<br />\n因为高频 pu 如果被划进了一个大 tu 统一做量化，你可以想象到你会有损失。<br />\n但是这玩意儿对速度影响也很大。</p>\n<p>压 webrip，开个  <code>3</code>  完全没问题，如果你电脑烂，开到  <code>4</code>  也行，<br />\n但是 bdrip，建议开  <code>0</code>  吧。</p>\n</li>\n<li>\n<p><code>--rdpenalty &lt;0..2&gt;</code></p>\n<p>这个参数，则是另一面，取值是  <code>0</code> - <code>2</code> 。</p>\n<p>它强制 tu 分块，保留细节，降低涂抹。<br />\n如果你用了  <code>limit-tu 3</code> / <code>4</code> ，可以考虑开  <code>--rdpenalty 2</code> 。</p>\n<p>同样的，噪点多容易被抹，也可以考虑开这个。<br />\n但是，分 tu 更细不代表我们能把码率控制更低，相反的，动这些参数可能会反而提高码率，具体情况还是根据片源不同自己测试。</p>\n</li>\n<li>\n<p><code>--tu-intra-depth &lt;1..4&gt;</code> ,  <code>--tu-inter-depth &lt;1..4&gt;</code></p>\n<p>这俩参数，是空域 / 时域内，tu 分裂次数的上限。<br />\n如果压 webrip，可以考虑开  <code>2</code> ，正常 bdrip 就  <code>3</code>  或者更多就直接开  <code>4</code> 。</p>\n</li>\n<li>\n<p><code>--max-tu-size &lt;32|16|8|4&gt;</code></p>\n<p>默认是  <code>32</code> ，更大的 tu 大小能提高压缩率。<br />\n一般不会去动，不如直接改  <code>ctu</code> 。</p>\n</li>\n</ul>\n<p>H265 引入的更详细的分块，x265 里也提供了相应的参数设置，这些参数一定程度上决定了分块上的底力</p>\n<h3 id=\"3-帧间编码搜索\"><a class=\"anchor\" href=\"#3-帧间编码搜索\">#</a> (3). 帧间编码搜索</h3>\n<ul>\n<li>\n<p><code>--subme, -m &lt;0..7&gt;</code></p>\n<p>和 x264 一样，x265 也有子像素运动补偿， <code>--subme</code>  也是速度黑洞<br />\n由于 x265 本身计算量更大，所以一般动画我们给  <code>4</code> ，想拥有更好的线条表现可以考虑开  <code>5</code> 。</p>\n</li>\n<li>\n<p><code>--ref &lt;1..16&gt;</code></p>\n<p>动态搜索方面， <code>--ref</code>  一般我们都会给  <code>3</code> - <code>4</code> 。</p>\n<p>由于 x265 的分割和块的溯源搜索能力更强，<br />\n我们不需要开很高的  <code>ref</code> ，就能溯到很多块。</p>\n<p>这也是速度黑洞，对动画来说  <code>4</code> - <code>5</code>  完全足够，<br />\n如果是大量一图流的视频，你给  <code>1</code>  完全 OK。</p>\n</li>\n<li>\n<p><code>--max-merge &lt;1..5&gt;</code></p>\n<p>决定溯块向量搜索中一种搜索算法的被选数量。<br />\n用很多时间换溯块成功率，也就是反映到压缩率上的参数。</p>\n<p>如果你 cpu 很阔，或者体积预算吃紧，你可以给  <code>4</code> 。<br />\n默认  <code>2</code>  完全足够，开个  <code>3</code>  意思意思也不是不行（</p>\n</li>\n<li>\n<p><code>--early-skip</code></p>\n<p>加速开关，影响的溯块中不同算法的先后顺序，一般不会去开。</p>\n</li>\n<li>\n<p><code>--me &lt;integer|string&gt;</code></p>\n<table>\n<thead>\n<tr>\n<th>int</th>\n<th>str</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>dia</td>\n</tr>\n<tr>\n<td>1</td>\n<td>hex</td>\n</tr>\n<tr>\n<td>2</td>\n<td>umh</td>\n</tr>\n<tr>\n<td>3</td>\n<td>star</td>\n</tr>\n<tr>\n<td>4</td>\n<td>sea</td>\n</tr>\n<tr>\n<td>5</td>\n<td>full</td>\n</tr>\n</tbody>\n</table>\n<p>决定了帧间动态搜索的算法，一些 x264 有的 x265 也有。</p>\n<p>追求快就用  <code>umh</code> ，一般只会开  <code>star</code> 。<br />\n <code>sea</code> ， <code>full</code>  都是暴力穷举类型的算法，开了纯属冬天太冷想要取暖用的。</p>\n</li>\n<li>\n<p><code>--merange &lt;integer&gt;</code></p>\n<p>和 x264 类似，1080p 下  <code>32</code>  足矣，4k 下可以考虑给到像 x265 preset 默认的  <code>57</code> 。</p>\n<p>同样的，开太大可能会降低压缩率，因为大的  <code>merange</code>  搜索范围可能会搜索到错误的参考。</p>\n</li>\n<li>\n<p><code>--analyze-src-pics</code></p>\n<p>允许动态搜索查找片源帧，也是属于电费开关，实际效果并不显著。<br />\n不建议开。</p>\n</li>\n</ul>\n<h3 id=\"4-帧内编码搜索\"><a class=\"anchor\" href=\"#4-帧内编码搜索\">#</a> (4). 帧内编码搜索</h3>\n<p>帧间编码搜索部分讲完了，来讲讲帧内编码。</p>\n<p>相比 H264，H265 规范在帧内编码上下足了功夫，<br />\n新增了大量的搜索算法。<br />\n所以我们才会看到 HEIF 逐渐成为了现在很多设备使用的图片压缩算法。</p>\n<p>这块算法非常复杂，就不详述了。</p>\n<ul>\n<li>\n<p><code>--fast-intra</code></p>\n<p>能控制这些算法的参数，首先是  <code>--fast-intra</code></p>\n<p>这个选项默认在  <code>rd</code>  &lt;=  <code>4</code>  时开启。<br />\n是涉及帧内编码时，判断夹角模式进行跳过，搜索更少的角度。</p>\n<p>一般咱不动，靠修改  <code>rd</code>  去控制。</p>\n</li>\n<li>\n<p><code>--b-intra</code></p>\n<p>是让 B 帧中的一个大编码单元 <em>Slice</em> 也在帧内进行查找的模式。</p>\n<p>很慢，但是如果追求压缩率可以开。</p>\n</li>\n<li>\n<p><code>--no-strong-intra-smoothing</code></p>\n<p>这个参数，其实对画面影响很低，因为触发帧内搜索时强力平滑的条件很苛刻。<br />\n推荐带上这个参数，使得编码器使用其他方法去进行平滑操作。</p>\n</li>\n</ul>\n<p>x265 可控制的底力部分差不多就是这么多，大部分都是影响分块精度，搜索精度，很多参数都会和编码速度息息相关。</p>\n<h3 id=\"5-率失真优化\"><a class=\"anchor\" href=\"#5-率失真优化\">#</a> (5). 率失真优化</h3>\n<p>说到骗力， x265 的率失真优化其实和 x264 一脉相传。</p>\n<ul>\n<li>\n<p><code>--psy-rd &lt;0..5.0&gt;</code></p>\n<p>就是类似 x264 中 psy 的第一个参数。<br />\n一般视动画纹理，给  <code>1</code>  -  <code>2.5</code> 。</p>\n</li>\n<li>\n<p><code>--psy-rdoq &lt;0..50.0&gt;</code></p>\n<p>这个有些复杂，因为它和 psy 的效果是有一些联动影响。</p>\n<p>其实这玩意儿，可以理解为你想保留的细节大小，<br />\n你想保留的越小，就给更高。</p>\n<blockquote>\n<p>preset slow, slower, veryslow 的默认值为 1.0</p>\n</blockquote>\n</li>\n<li>\n<p><code>--rdoq-level &lt;0|1|2&gt;</code></p>\n<p><code>rdoq-level</code>  则是总体控制<em>率失真优化</em>影响量化分块的深度。<br />\n设为  <code>2</code>  的时候，<em>率失真优化</em>会影响到最小 4x4 单元的量化计算。</p>\n<p>一般都会给  <code>2</code> ，比较慢，但对纹理和细节比较友好。<br />\n因为对细节的量化把握更为细致。</p>\n<p>但是反过来，这同时也会影响平面的表现，<br />\n所以有的时候  <code>rdoq-level</code>  也会给  <code>1</code> 。</p>\n</li>\n<li>\n<p><code>--aq-mode &lt;0|1|2|3|4|5&gt;</code> ,  <code>--aq-strength &lt;0..3.0&gt;</code></p>\n<p>其实和 x264 一模一样，直接参考 x264 就行</p>\n<p>x265 的  <code>aq-mode 4</code>  其实现在 x264 也有了，这个 aq 模式简单来说，会摧毁平面，但会给更多码率线条和纹理和暗场。<br />\n除非你追求压缩率，喂给编码器的东西也有针对性处理防止出现 Artifact，不然别开（</p>\n<blockquote>\n<p>x265 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIveDI2NS9yZWxlYXNlcy90YWcvS3lvdWtvLTMuNS1BQw==\">Kyouko mod</span> 3.5-AC 版本开始比起官方多了一个 5</p>\n</blockquote>\n</li>\n<li>\n<p><code>--hevc-aq</code></p>\n<p>这个新加的参数还是玄学 aq，我们的试验比较少。</p>\n<p>同时新版本 x265 还有  <code>--aq-motion</code> ，根据动态信息结合 aq 去调整 aq 的强度<br />\n也是新参数，大家可以试验一下。</p>\n</li>\n<li>\n<p><code>--qg-size &lt;64|32|16|8&gt;</code></p>\n<p>是支持自适应量化的最小 cu，默认  <code>64</code>  速度很快，但是会影响量化精度。</p>\n<p>我们自适应量化不就是为了更好的分配量化的值嘛，<br />\n所以一般给  <code>16</code>  或者  <code>8</code> 。</p>\n</li>\n<li>\n<p><code>--cbqpoffs &lt;-12..12&gt;</code> ,  <code>--crqpoffs &lt;-12..12&gt;</code></p>\n<p>这俩，其实就是调整色度平面的量化 qp offset。</p>\n<p>同样的，一般给  <code>-2</code>  或者  <code>-3</code> ，因为色度半采样之后本来就已经很惨了。</p>\n</li>\n<li>\n<p><code>--rd &lt;1..6&gt;</code></p>\n<p>x265 引入了 rd、模式决策、整合搜索信息还加一道重新分配分块、参考、跳过、量化方案。</p>\n<p>而  <code>--rd</code>  决定了<em>率失真优化</em>参与模式决策的程度。</p>\n<p>给  <code>4</code>  足够， <code>5</code>  会非常慢，但是影响一些帧内编码参数等原因，成品码率会变小，画面也不会有太大的问题。</p>\n<p>bdrip 给  <code>5</code> , webrip 给  <code>4</code> 。<br />\nbdrip 也可以给  <code>4</code> ，因为  <code>5</code>  真的很慢。<br />\n压制的电费也是电费（</p>\n</li>\n<li>\n<p><code>--limit-modes</code></p>\n<p>和帧内编码有关，会大幅削弱  <code>rect</code>  和  <code>amp</code>  效果，开了  <code>rect</code> / <code>amp</code>  可以开这个，但是会微微降低画质。</p>\n<p>毕竟你都开了  <code>rect</code> ，心都一横了还给你个后悔药吃，<br />\n多少不太地道（</p>\n</li>\n<li>\n<p><code>--limit-refs &lt;0|1|2|3&gt;</code></p>\n<p>是限制分块参考性，默认  <code>3</code>  就不要动了。<br />\n主要影响分块。</p>\n</li>\n<li>\n<p><code>--rskip &lt;0|1|2&gt;</code></p>\n<p>比较微妙，判断分 cu 后要不要继续分块，一般不会动。</p>\n<p>实际上大家可以自己去试试  <code>0</code>  和  <code>1</code>  在噪点高的源和干净源里的差距。</p>\n</li>\n<li>\n<p><code>--tskip-fast</code></p>\n<p>跳过 4x4 tu 变换过程中的一些算法，对画质影响其实不大。<br />\n可以考虑开一开。</p>\n</li>\n</ul>\n<p>率失真优化的部分，影响了块的 <em>qp</em> 分配，以及影响了画面的分块，这一块对我们画质的影响很大。</p>\n<h3 id=\"6-码率控制\"><a class=\"anchor\" href=\"#6-码率控制\">#</a> (6). 码率控制</h3>\n<p>接下来讲预算部分吧。</p>\n<ul>\n<li>\n<p><code>--crf &lt;0..51.0&gt;</code></p>\n<p>和 x264 一样，webrip 其实  <code>18</code> - <code>21</code>  都能给。</p>\n</li>\n<li>\n<p><code>--qpmin &lt;integer&gt;</code>   <code>--qpmax &lt;integer&gt;</code></p>\n<p>和 x264 一模一样。</p>\n</li>\n<li>\n<p><code>--rc-grain</code></p>\n<p>这个参数，是在重噪点源里防止 <em>qp</em> 判断被超高噪点带偏导致体积问题的。<br />\n如果你想保留噪点，那这玩意儿效果不高。</p>\n</li>\n<li>\n<p><code>--qcomp &lt;0.5..1.0&gt;</code></p>\n<p>和 x264 近似，同时它也受 x265 版 <em>mbtree</em> —— <em>cutree</em> 的影响。<br />\n用法也和 x264 以及 x264 的 <em>mbtree</em> 是否开关差不多。</p>\n<p>一般给  <code>0.65</code> ，打架番给个  <code>0.7</code> 。</p>\n</li>\n<li>\n<p><code>--rc-lookahead &lt;integer&gt;</code></p>\n<p>和 x264 的  <code>lookahead</code>  类似，给  <code>80</code>  足够，多给会慢，但是效果又不会好很多。</p>\n</li>\n<li>\n<p><code>--no-cutree</code></p>\n<p>这个，和隔壁关 <em>mbtree</em> 差不多，<br />\n低  <code>crf</code>  下可以考虑开， <code>15</code>  以下。</p>\n</li>\n<li>\n<p><code>--ipratio &lt;float&gt;</code>  /  <code>--pbratio &lt;float&gt;</code></p>\n<p>同 x264 ，这里也不说了。</p>\n</li>\n<li>\n<p><code>--vbv-bufsize &lt;integer&gt;</code>  /  <code>--vbv-maxrate &lt;integer&gt;</code></p>\n<p>限码，和 x264 也是相似。</p>\n<p>一般都是给  <code>bufsize</code>  稍小于  <code>maxrate</code> 。</p>\n</li>\n<li>\n<p><code>--lossless</code></p>\n<p>x265 也有提供无损压缩的方式，跳过分块，动 / 帧 / 参搜索，量 / 自适量化，体积非常大，想用基本就是  <code>--preset ultrafast --lossless</code> 。</p>\n<p>毕竟你都 lossless 体积超大了，用  <code>ultrafast</code>  也无所谓，反正都不要压缩率了。</p>\n</li>\n</ul>\n<p>abr /vbr 就跳过了，和 x264 基本一致。</p>\n<h3 id=\"7-杂项\"><a class=\"anchor\" href=\"#7-杂项\">#</a> (7). 杂项</h3>\n<p>杂项这里，其实就是不好分类的参数就都在这讲吧。</p>\n<ul>\n<li>\n<p><code>--sao</code> ,  <code>--limit-sao</code> ,  <code>--no-sao</code></p>\n<p>x265 里引入了一项新的补偿画面劣化的算法，他就是  <code>sao</code> 。</p>\n<p>针对<strong>强量化</strong>，高  <code>crf</code> ，低码率的预算里，建议开  <code>--sao</code> <br />\n <code>crf 21</code>  以上可以开。</p>\n<p><code>21</code> - <code>18</code> ，可以开  <code>--limit-sao</code> 。</p>\n<p><code>17</code>  及以下建议  <code>--no-sao</code> 。<br />\n <code>sao</code>  对较低  <code>crf</code>  时反而会让画面变糊，引入更多问题。</p>\n</li>\n<li>\n<p><code>--deblock &lt;int&gt;:&lt;int&gt;</code></p>\n<p>和 x264 一样，bdrip 给  <code>-1:-1</code> ，webrip 给  <code>0:-1</code>  或者  <code>0:0</code> 。</p>\n</li>\n<li>\n<p><code>--bframes, -b &lt;0..16&gt;</code></p>\n<p>和 x264 一样，我们给个  <code>8</code> - <code>10</code> 。</p>\n</li>\n<li>\n<p><code>--min-keyint &lt;integer&gt;</code>  /  <code>--keyint &lt;integer&gt;</code></p>\n<p>也和 x264 一样，决定 IDR 帧的插入。</p>\n</li>\n<li>\n<p><code>--no-open-gop</code></p>\n<p>前面的教程也说过，为了兼容性还是开它。</p>\n</li>\n<li>\n<p><code>--scenecut &lt;integer&gt;</code></p>\n<p>和 x264 一样，默认就行。</p>\n</li>\n<li>\n<p><code>--hist-scenecut</code></p>\n<p>这个新加的参数，我自己试下来对于转场判断是效果挺好的。<br />\n这个参数我建议开着。</p>\n</li>\n<li>\n<p><code>--pools &lt;integer,...&gt;</code></p>\n<p>由于 x265 更吃性能了，这里多讲一句  <code>--pools</code> ，<br />\n实际上和 x264 的  <code>--threads</code>  一样。</p>\n<p>由于 x265 的分块更灵活，可并行能力更大，基本上能吃满整个 cpu，不像 x264 基本吃不满我的 5950x。<br />\n如果你有 epyc / 多路系统，那可能要在使用的时候在这个设置上注意一下（<br />\n由于家境贫寒我还没用上过。</p>\n</li>\n<li>\n<p><code>--pmode</code></p>\n<p>使用帧内平行搜索，能更大程度吃满 cpu，但是会导致搜索线程之前信息不共享之类的问题降低画质。</p>\n<p><strong>别开</strong></p>\n</li>\n<li>\n<p><code>--pme</code></p>\n<p>平行动态搜索，其实如果核心大于 16 可以考虑开。</p>\n<blockquote>\n<p><code>pmode</code>  和  <code>pme</code>  不管影响不影响画质，但是其用于多线程协同的开销分分钟比增加的效率还大，跑不满最好多开而不是开这两个选项。</p>\n</blockquote>\n</li>\n<li>\n<p><code>--colorprim &lt;integer|string&gt;</code>   <code>--colormatrix &lt;integer|string&gt;</code>   <code>--transfer &lt;integer|string&gt;</code>   <code>--range &lt;full|limited&gt;</code></p>\n<p>和隔壁 x264 一样，也就是输出的时候打个标签，<br />\n动漫新番和蓝光的编码，基本可以无脑  <code>--colorprim bt709 --colormatrix bt709 --transfer bt709 --range limited</code></p>\n<blockquote>\n<p>详细选项看  <code>--help</code></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"5-一些调参思路\"><a class=\"anchor\" href=\"#5-一些调参思路\">#</a> 5. 一些调参思路</h2>\n<p>这里提供 x265 的 preset 表</p>\n<blockquote>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/x265-preset.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-07/x265-preset-table.png\" alt=\"img\" /><span class=\"exturl\" data-url=\"aHR0cHM6Ly94MjY1LnJlYWR0aGVkb2NzLmlvL2VuL21hc3Rlci9wcmVzZXRzLmh0bWw=\">https://x265.readthedocs.io/en/master/presets.html</span></p>\n</blockquote>\n<p>可以看到 x265 其实非常面向高分辨率视频去做适配， <code>preset</code>  的  <code>merange</code>  都给的超大。</p>\n<p>并且  <code>preset</code>  都是以压缩率为优先的，我们一定会去做更多修改。</p>\n<p>发个做某番 bdrip 的参数吧。<br />\n <code>--preset veryslow --crf 14 --qcomp 0.72 --qg-size 16 --rect --amp  --ctu 32 --rskip 0 --limit-tu 0 --tu-intra-depth 4 --tu-inter-depth 4  --me star --subme 5 --no-rc-grain --b-intra --merange 32 --no-open-gop  --min-keyint 1 --ref 5 --keyint 240 --ipratio 1.2 --pbratio 1.3  --bframes 8 --aq-mode 3 --aq-strength 0.7 --rd 5 --deblock -1:-1  --colormatrix bt709 --rc-lookahead 80 --range limited --psy-rdoq 0.5  --rdoq-level 1 --psy-rd 2.0 --cbqpoffs -3 --crqpoffs -3  --no-strong-intra-smoothing --no-sao</code></p>\n<p>分块方面的开销做到了非常高，由于这番预算不少，画面复杂，并且有电影感，为了保留画面噪点做了一些更改<br />\n当然，上面的参数真的非常，非常慢。。</p>\n<p>再丢个通用点的 bdrip 参数：</p>\n<pre><code>--deblock  -1:-1 --preset slower --limit-tu 0 --rskip 0 --ctu 32 --crf 16 --pbratio 1.2 --cbqpoffs -3 --crqpoffs -3 --no-sao --max-tu-size 16 --qg-size 16  --me 3 --subme 5 --merange 32 --b-intra --no-amp --ref 5 --weightb  --keyint 240 --min-keyint 1 --bframes 8 --aq-mode 3 --aq-strength 0.8  --rd 5 --psy-rd 1.7 --psy-rdoq 0.8 --rdoq-level 1 --rc-lookahead 80  --scenecut 40 --qcomp 0.65 --no-open-gop --vbv-bufsize 42000  --vbv-maxrate 35000 --no-strong-intra-smoothing --transfer bt709  --colorprim bt709 --colormatrix bt709 --range limited\n</code></pre>\n<p>再丢个 webrip 的：<br />\n <code>--preset veryslow --crf 18.5 --qcomp 0.65 --qg-size 16 --no-rect  --no-amp --ctu 32 --limit-tu 3 --tu-intra-depth 3 --tu-inter-depth 3  --me star --subme 4 --no-rc-grain --merange 32 --no-open-gop  --min-keyint 1 --ref 5 --keyint 240 --ipratio 1.2 --pbratio 1.3  --bframes 10 --aq-mode 1 --aq-strength 0.75 --rd 5 --deblock -1:-1  --colormatrix bt709 --rc-lookahead 80 --range limited --psy-rdoq 0.5  --rdoq-level 2 --psy-rd 1.5 --cbqpoffs -2 --crqpoffs -2  --no-strong-intra-smoothing --no-sao</code></p>\n<p>要注意的是，这个 webrip 的也是番剧有一些特色，同时我个人习惯 webrip 不留噪点，抹的比较干净丢编码器。</p>\n<p>实际上，在写脚本调试过程中，我们经常会遇到预览时候：嗯，很不错，这波稳了。<br />\n丢进 x265 之后，成品却表现十分糟糕。</p>\n<p>所以匹配输入预处理和编码器参数也是很重要的，只不过这个就有点看经验了。</p>\n<p>最后，编码器的参数，通用的参数只是通用，只有结合自己对参数的理解，多实践操作，多试错，才会做出最好的 bdrip 结果。</p>\n<h2 id=\"6-总结\"><a class=\"anchor\" href=\"#6-总结\">#</a> 6. 总结</h2>\n<p>回顾整个编码器的部分，我们要首先知道的是编码器的变换量化搜索大概原理，熟悉底力 - 骗力 - 预算的参数设定。</p>\n<p>同时，认清画面的低频 - 中频 - 高频部分，<br />\n也就是动画里色块，纹理，线条和其他高频成分。</p>\n<p>知道如果编码器吐出来的东西哪里压的不行，该怎么去调整，从参数到预处理。</p>\n<p>编码器的理解与认识，随着一代一代人压制经验的完善以及对原理理解的深入，已经到了较为完善的地步。</p>\n<p>所以希望大家在做 bdrip /webrip 压制时，能想起调整大概会要调哪块，多多试验多多测试，更重要的是，要结合自己对画面的理解去合理分配码率，找出体积和画面的平衡点。</p>\n<p>能看出画面问题的火眼金睛也要多锻炼多做番才行。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%85%AD%E7%AB%A0VS%E5%9F%BA%E7%A1%80%E6%BB%A4%E9%95%9C/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%85%AD%E7%AB%A0VS%E5%9F%BA%E7%A1%80%E6%BB%A4%E9%95%9C/",
            "title": "第六章VS基础滤镜",
            "date_published": "2024-03-16T15:09:01.000Z",
            "content_html": "<h1 id=\"第六章-vs基础滤镜\"><a class=\"anchor\" href=\"#第六章-vs基础滤镜\">#</a> 第六章 VS 基础滤镜</h1>\n<p>本章在上一章的基础上，讲解常用的 VS 基础滤镜。</p>\n<h2 id=\"1-源滤镜\"><a class=\"anchor\" href=\"#1-源滤镜\">#</a> 1. 源滤镜</h2>\n<p>源滤镜是读取视频源文件并进行解码的滤镜。源滤镜非常重要，其准确性直接关系到整个视频处理流程的可靠与否。</p>\n<h3 id=\"1-lsmas\"><a class=\"anchor\" href=\"#1-lsmas\">#</a> (1). lsmas</h3>\n<p>lsmas 全称 L-SMASH-Works，是目前最准确的源滤镜。其 VS 版本的文档在：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FrYXJpblZTL0wtU01BU0gtV29ya3MvdHJlZS9tYXN0ZXIvVmFwb3VyU3ludGglRTMlODAlODI=\">https://github.com/AkarinVS/L-SMASH-Works/tree/master/VapourSynth。</span></p>\n<p>lsmas 目前提供了两个滤镜： <code>LibavSMASHSource</code>  和  <code>LWLibavSource</code> 。最常用的是  <code>LWLibavSource</code> ，支持各种类型的输入，在第一次读取时会生成  <code>lwi</code>  文件。其次是  <code>LibavSMASHSource</code> ，只支持 mp4 输入，但不需要生成  <code>lwi</code>  文件。</p>\n<p>LWLibavSource 有诸多参数，但大多数情况只会用到第一个  <code>source</code> ，指定输入文件路径。 <code>format</code>  参数可以将源转为指定的像素格式，但一般不会使用，都是交给专门的滤镜处理像素格式转换。 <code>fpsnum</code>  和  <code>fpsden</code>  参数可以将源转为指定的帧率而保持视频长度不变，在输入源帧率与目标不匹配时，会进行抽帧和插入重复帧。这在处理一些帧率混乱的源，比如来路不明的 web 流媒体源时可能有用，当然前提是视频平均帧率和目标帧率相差不大。 <code>repeat</code>  用于交错源，将在后续章节中介绍。 <code>prefer_hw</code>  可以使用硬件解码，但任何时候都不要使用这一功能，一是硬解不可靠，二是软解速度大于硬解速度。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-06/image01.png\" alt=\"img\" /></p>\n<p>lwi 文件需要我们特别关注，这是一个文本文件，记录了各帧的信息，便于准确快速 seek 解码。</p>\n<p>每一帧的信息为以下格式：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Index=0,POS=343715,PTS=625,DTS=375,EDI=0</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Key=1,Pic=1,POC=15,Repeat=1,Field=0</pre></td></tr></table></figure><p><code>PTS</code>  呈现时间戳，即帧呈现到屏幕上的时间； <code>DTS</code>  解码时间戳，即解码器必须解码这一帧的时间。这两者的单位取决于 lwi 开头部分的 TimeBase 参数，1/1000 表示单位为 1 毫秒，因此你可以通过 PTS 和视频帧率，算出每一帧对应的帧号。lwi 中各帧按照 DTS 从小到大排列。<br />\n <code>KEY</code>  表示是否为关键帧 IDR，1 代表是 IDR，可以从这帧开始独立解码。 <code>Pic</code>  表示帧类型，1 代表 I 帧，2 代表 P 帧，3 代表 B 帧。 根据 lwi 的帧信息我们可以判断 GOP，从一个 KEY=1 的 IDR（含）到下一个 KEY=1 的 IDR（不含）就为一个 GOP。</p>\n<p>严格来说 KEY=1 表示 RAP（random access point），比 IDR 更进一步，表示可以从这帧开始完全重新解码。IDR  表示后续的帧不会再依赖前面的帧，但是并不保证不需要前面的数据。实际解码中，除了帧数据还有一些全局或半全局的参数，学名 VPS（video  parameter set）和 SPS（sequence parameter set），它们为编码器提供一些必要的设置参数。lwi 的  key=1 说的是包括了 SPS 的 IDR 帧，因此可能发现有些 IDR 帧是 Key=0。</p>\n<h3 id=\"2-ffms2\"><a class=\"anchor\" href=\"#2-ffms2\">#</a> (2). ffms2</h3>\n<p>ffms2 全称 FFmpeg Source 2，是另一个广泛使用的源滤镜。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0ZGTVMvZmZtczIlRTMlODAlODI=\">https://github.com/FFMS/ffms2。</span></p>\n<p>基本用法如下：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>ffms2<span class=\"token punctuation\">.</span>Source<span class=\"token punctuation\">(</span><span class=\"token string\">\"00001.m2ts\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>我们一般不会使用 ffms2，因为不如 lsmas 准确，只有遇到极少的 lsmas 出错的情况才会使用它进行对照。ffms2 也会生成类似的索引文件，后缀为  <code>ffindex</code> ，但是生成索引时不显示进度条，这是其另一大缺点。</p>\n<h3 id=\"3-imwri\"><a class=\"anchor\" href=\"#3-imwri\">#</a> (3). imwri</h3>\n<p>imwri 全称 ImageMagick Writer-Reader，区别于前两者，imwri 是一个专用于图片的滤镜。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvcGx1Z2lucy9pbXdyaS5odG1sJUUzJTgwJTgy\">https://amusementclub.github.io/doc/plugins/imwri.html。</span></p>\n<p>基本用法如下：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>imwri<span class=\"token punctuation\">.</span>Read<span class=\"token punctuation\">(</span><span class=\"token string\">\"01.png\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>事实上 lsmas 也可以读取图片，并且对于 JPG 这种 YUV 格式的，会保留原始数据，而 imwri 则将输入全转为 RGB。</p>\n<p>但是 lsmas 有一定的局限性，不支持奇数高的 YUV420 格式图片。对于 YUV420  格式的图片，由于色度半采样，理论上是不支持奇数高的，图片制作时一般是增加一个不可见的行使其对齐来编码。lsmas  解码时只输出有效的奇数行，而后续其他滤镜都不支持这种奇特的格式，导致无法预览。</p>\n<p>另外 imwri 还提供了  <code>Write</code>  滤镜，可以简单地批量导出图片。</p>\n<h2 id=\"2-基础视频操作滤镜\"><a class=\"anchor\" href=\"#2-基础视频操作滤镜\">#</a> 2. 基础视频操作滤镜</h2>\n<h3 id=\"1-trim-splice\"><a class=\"anchor\" href=\"#1-trim-splice\">#</a> (1). Trim / Splice</h3>\n<p>视频的分割与合并，在 VS 里通过  <code>Trim</code>  和  <code>Splice</code>  滤镜来完成。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3RyaW0uaHRtbA==\">https://amusementclub.github.io/doc/functions/video/trim.html</span></p>\n<p>Trim 一般通过下面方式使用，指定切割的起始帧和结束帧，区间是左闭右闭。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token punctuation\">.</span>Trim<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> first<span class=\"token punctuation\">,</span> last<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>如果你写  <code>std.Trim(clip, 0, 100)</code> ，那么会切出 0-100 总共 100-0+1=101 帧。</p>\n<p>在 python 里还可以使用  <code>[]</code>  的语法糖来进行切割，写法是  <code>[first: last+1]</code> ，注意这里是左闭右开。<br />\n如果你写  <code>clip[0: 100]</code> ，那么会切出 0-99 总共 100-0=100 帧。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3NwbGljZS5odG1s\">https://amusementclub.github.io/doc/functions/video/splice.html</span></p>\n<p>与切割相对的是合并 Splice，通过下面方式使用。一般要求它们的属性全部一致，包括画面大小，像素类型。帧率可以不一致，不过 VS 处理可变帧率是个麻烦事，后续章节会讲。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token punctuation\">.</span>Splice<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>clip1<span class=\"token punctuation\">,</span> clip2<span class=\"token punctuation\">,</span> clip3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>也有对应的语法糖， <code>clip1 + clip2 + clip3</code> 。简单易懂，因此实际使用更推荐后一种方式。</p>\n<p>如果希望合并多个相同 clip，可以使用乘法。 <code>clip * 3</code> ，就是将视频重复三次。<br />\n这等价于  <code>Loop</code>  滤镜： <code>core.std.Loop(clip, times)</code> 。</p>\n<h3 id=\"2-interleave-selectevery\"><a class=\"anchor\" href=\"#2-interleave-selectevery\">#</a> (2). Interleave / SelectEvery</h3>\n<p><code>Interleave</code>  滤镜，上一章已经讲过，可以将多个视频交替输出。与之相对的是  <code>SelectEvery</code> ，按照一定的步长，选取部分帧。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3NlbGVjdGV2ZXJ5Lmh0bWw=\">https://amusementclub.github.io/doc/functions/video/selectevery.html</span></p>\n<p>选取所有偶数帧：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token punctuation\">.</span>SelectEvery<span class=\"token punctuation\">(</span>clip<span class=\"token operator\">=</span>clip<span class=\"token punctuation\">,</span> cycle<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> offsets<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>选取所有奇数帧：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token punctuation\">.</span>SelectEvery<span class=\"token punctuation\">(</span>clip<span class=\"token operator\">=</span>clip<span class=\"token punctuation\">,</span> cycle<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> offsets<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>也有对应的语法糖： <code>clip[::2]</code>  和  <code>clip[1::2]</code> 。</p>\n<h3 id=\"3-crop-addborders\"><a class=\"anchor\" href=\"#3-crop-addborders\">#</a> (3). Crop / AddBorders</h3>\n<p>视频的裁剪，在 VS 里通过  <code>Crop</code>  滤镜来完成。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL2Nyb3BfY3JvcGFicy5odG1s\">https://amusementclub.github.io/doc/functions/video/crop_cropabs.html</span></p>\n<p>有两种用法：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token punctuation\">.</span>Crop<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">,</span> bottom<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>std<span class=\"token punctuation\">.</span>CropAbs<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><code>Crop</code>  指定左右上下分别裁剪多少像素。 <code>CropAbs</code>  先指定裁剪后视频的宽高，然后指定左上分别裁剪多少像素。</p>\n<p>Crop 一般用于裁剪黑边，比如原生 4:3 的视频，加黑边加到 1920x1080，那么有效部分是 1440x1080。</p>\n<p>用 Crop 可以写为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cropped <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Crop<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> left<span class=\"token operator\">=</span><span class=\"token number\">240</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">=</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>也可以用 CropAbs 写为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cropped <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>CropAbs<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token number\">1440</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1080</span><span class=\"token punctuation\">,</span> left<span class=\"token operator\">=</span><span class=\"token number\">240</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL2FkZGJvcmRlcnMuaHRtbA==\">https://amusementclub.github.io/doc/functions/video/addborders.html</span></p>\n<p>与裁剪相对的，我们也可以使用  <code>AddBorders</code>  来加黑边。</p>\n<p>比如给 1440x1080 的视频加黑边到 1920x1080。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>addborders <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>AddBorders<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> left<span class=\"token operator\">=</span><span class=\"token number\">240</span><span class=\"token punctuation\">,</span> right<span class=\"token operator\">=</span><span class=\"token number\">240</span><span class=\"token punctuation\">,</span> color<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">128</span><span class=\"token punctuation\">,</span> <span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"4-shuffleplanes-splitplanes\"><a class=\"anchor\" href=\"#4-shuffleplanes-splitplanes\">#</a> (4). ShufflePlanes / SplitPlanes</h3>\n<p>对视频平面进行操作，使用的是  <code>ShufflePlanes</code>  和  <code>SplitPlanes</code>  两个滤镜。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3NwbGl0cGxhbmVzLmh0bWw=\">https://amusementclub.github.io/doc/functions/video/splitplanes.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3NodWZmbGVwbGFuZXMuaHRtbA==\">https://amusementclub.github.io/doc/functions/video/shuffleplanes.html</span></p>\n<p>我们知道 YUV 和 RGB 都有三个平面，可以使用 SplitPlanes 将其拆分。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Y<span class=\"token punctuation\">,</span> U<span class=\"token punctuation\">,</span> V <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>SplitPlanes<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这也可以通过 ShufflePlanes 得到。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Y <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>U <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>V <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>观察这些单个平面，会发现它们都以灰度图显示，我们可以通过下述方式观察单个平面的效果。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mid <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>BlankClip<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> color<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">128</span><span class=\"token punctuation\">,</span> <span class=\"token number\">128</span><span class=\"token punctuation\">,</span> <span class=\"token number\">128</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>clipU <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">,</span> U<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>clipV <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>clipU<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>clipV<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这个例子也显示了 ShufflePlanes 的复杂用法， <code>clips</code>  和  <code>planes</code>  两个参数都可以是列表。planes 的元素数量表示了结果 clip 的平面数量，其中第 i 个元素表示从 clips 列表第 i 个 clip 获取平面的序号。<br />\n以  <code>clipU</code>  为例， <code>planes=[0, 0, 2]</code>  表示输出有 3 个平面，第一个平面取自 mid 的 0 平面，第二个平面取自 U 的 0 平面，第三个平面取自 mid 的 2 平面。</p>\n<p>这种用法也允许 clips 的元素数量少于 planes 元素数量，此时 clips 将会由其最后一个元素填充至与 planes 元素数量相等。如下面这个例子中， <code>clips=[Y, mid]</code> ，实际等价于  <code>[Y, mid, mid]</code> 。<br />\n另外，观察这个  <code>clipY</code>  结果会发现与单独预览 Y 的结果一致，因此实际中观察 Y 的效果只需抽取单个平面即可。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>clipY <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>Y<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>YUV<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>clipY<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"3-精度转换\"><a class=\"anchor\" href=\"#3-精度转换\">#</a> 3. 精度转换</h2>\n<h3 id=\"1-高精度与range\"><a class=\"anchor\" href=\"#1-高精度与range\">#</a> (1). 高精度与 Range</h3>\n<h4 id=\"range\"><a class=\"anchor\" href=\"#range\">#</a> Range</h4>\n<p>在第一章我们了解了 range 的概念，即量化像素数据的取值范围。range 可以分为  <code>limited range</code>  和  <code>full range</code> 。RGB 一般总是 full range，而 YUV 一般总是 limited range（除了 jpg 图片、YCgCo）。</p>\n<p>我们知道，8bit 下 limited range 是：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Y  [16, 235]</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>UV [16, 240]</pre></td></tr></table></figure><p>10bit 下 limited range 是：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Y  [16*2^2, 235*2^2] = [64, 940]</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>UV [16*2^2, 240*2^2] = [64, 960]</pre></td></tr></table></figure><p>一般地，range 通过如下方式定义：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>limited:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Y   [16*2^(bit-8), 235*2^(bit-8)]</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>UV  [16*2^(bit-8), 240*2^(bit-8)]</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>full:</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>YUV [0, 2^bit-1]</pre></td></tr></table></figure><p>这样 16bit 下 limited range 是：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Y  [4096, 60160]</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>UV [4096, 61440]</pre></td></tr></table></figure><p>数据在不同精度和不同 range 间以浮点值作为不变量进行转换，可以总结转换公式为：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>dst_value = (src_value - src_zero) / (src_max - src_min) * (dst_max - dst_min) + dst_zero</pre></td></tr></table></figure><p>不难证明，在目的和源的 range 都为 limited 时，可以通过乘 / 除以  <code>2^(dst_bit - src_bit)</code>  来进行转换。</p>\n<h4 id=\"vs精度转换\"><a class=\"anchor\" href=\"#vs精度转换\">#</a> VS 精度转换</h4>\n<p>通常视频都是 8bit 或者 10bit，而在 VS 中经常会使用更高精度比如 16bit 来进行处理。</p>\n<p>VS 中用来转换精度的有 fmtc 和 zimg 两个工具，前者是使用  <code>fmtc.bitdepth</code>  滤镜，后者是使用  <code>resize</code>  系列滤镜。</p>\n<p>fmtc 全名 format conversion tools，文档在这里：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9mbXRjb252L2RvYy9mbXRjb252Lmh0bWwlRTMlODAlODI=\">https://amusementclub.github.io/fmtconv/doc/fmtconv.html。</span></p>\n<p>假设输入源为 8bit，用 fmtc 转为 16bit 的写法为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> bits<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>当然，也可以通过  <code>fulls</code>  和  <code>fulld</code>  参数显式指定输入和输出的 range。如果不指定，输出 range 总是等于输入 range，而输入 range 通过数据类型来猜测，YUV 总是猜测为 limited range。</p>\n<p>resize，VS 的内置滤镜，文档在这里：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3Jlc2l6ZS5odG1sJUUzJTgwJTgy\">https://amusementclub.github.io/doc/functions/video/resize.html。</span></p>\n<p>虽然名字叫 resize，但实际却是 VS 中的瑞士军刀，集成了包含缩放在内的多种功能，这里我们用到的是转换精度的功能。</p>\n<p>同样假设输入源为 8bit，转为 16bit 的写法为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Bicubic<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token builtin\">format</span><span class=\"token operator\">=</span>vs<span class=\"token punctuation\">.</span>YUV420P16<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>resize 可以通过  <code>range</code>  和  <code>range_in</code>  参数显式指定输入和输出的 range。与 fmtc 不同，在未指定 range 时，resize 会优先通过 frameprops 来决定 range。</p>\n<p>顺便一提，在 resize 的参数中，有  <code>_in</code>  后缀的指输入，没有  <code>_in</code>  后缀的都是指输出，这些参数都通过一个 magic number 来指定。同时，resize 还提供了一套  <code>_s</code>  后缀的参数，可以使用字符串来指定。对于 range、matrix 这类需要指定 magic number 的参数，我们都强烈建议使用字符串形式，或者使用 magic number 对应的 enum 来指定，以提高脚本的可读性，防止出错。</p>\n<p>除了直接使用以上两个滤镜，还可以通过  <code>mvf</code>  中的 wrapper 来进行转换。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src16 <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> depth<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>在未显示指定  <code>fulls</code>  和  <code>fulld</code>  时， <code>mvf.Depth</code>  通过输入视频格式来猜测 range，对于 YUV 和 GRAY，总是猜测为 limited，其他格式为 full。</p>\n<h4 id=\"vs中的format表示\"><a class=\"anchor\" href=\"#vs中的format表示\">#</a> VS 中的 format 表示</h4>\n<p>GRAY 和 RGB 都是采用  <code>GRAY+X</code> 、 <code>RGB+X</code>  的形式，这里 X 可以是一个数字，表示整数类型的位宽，也可以是一个字母，表示浮点类型的位宽。H 表示 half，半精度浮点数，fp16。S 表示 single，单精度浮点数，fp32。</p>\n<p>YUV 则有些区别，采用  <code>YUV+css+P+X</code>  的形式。css 表示色度下采样，常见有 444、422、420 等。P 表示三个平面的存放方式为 planar，也就是三个平面分开存放。最后 X 与 GRAY 和 RGB 相同，可以是代表整型位宽的数字，也可以是代表浮点类型的字母。</p>\n<p>需要注意的是，fmtc 和 mvf.Depth 中指定的 bit 数，默认 16 表示 int 16，而 32 表示 float 32。</p>\n<h4 id=\"yuv-overflow-underflow\"><a class=\"anchor\" href=\"#yuv-overflow-underflow\">#</a> YUV overflow / underflow</h4>\n<p>通常我们遇到的 YUV 视频都是 limited range，但如果有这样一个视频，其内容是 full range 的，却被标成了 limited range，会发生什么？<br />\n这时超过 limited range 范围的部分将被截断在 limited range 的极值上，全部变成一种颜色，分辨不出其中的细节了。</p>\n<p>这种现象就被称为 YUV 越界，又叫 YUV overflow /underflow。超过最大值，称为上溢，overflow；超过最小值，称为下溢，underflow。<br />\n实际中上溢和下溢可以同时发生，也可以分别独立发生。一般来说，上溢单独发生的情况要远多于其他情况。</p>\n<p>在 VS 中，我们通常用  <code>core.hist.Levels()</code>  滤镜观察是否发生越界。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>hist<span class=\"token punctuation\">.</span>Levels<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>可以看到，在画面的右侧出现了三个直方图，从上到下分别表示 YUV 三个平面的像素值分布情况。每个直方图的横坐标是像素值，从左到右是 0 到 255；纵坐标是该值对应的像素数量。</p>\n<p>图像中间没有阴影的区域，表示 limited range，两端的阴影区域，表示超过 limited range 的区域。如果我们发现，直方图超出中间而到达两端的区域，就说明发生了越界。</p>\n<p>在原盘的 OP 和 ED 部分，可能会有少量越界，这大多是后期添加的 staff 字幕带来的，白色字幕可能会越界几个像素，到达 240 左右。这种情况一般不需要处理，事实上我们反而会利用字幕颜色越界的特性来框选它们。</p>\n<p>对于现在的新番，YUV 越界很少在动画正片中出现，但是时常在三次元特典中发生，一般习惯拿到三次元特典上来先检查 YUV 范围。如果发现视频中大段出现亮度越界的现象，那就需要提起注意，这个视频很可能有 range 问题。</p>\n<p>判断确实发生了越界，就需要进行处理，将数据范围从 full 压缩到 limited。为了保证这一操作的精度，通常会在 16bit 下进行。在 VS 中， <code>Levels</code>  滤镜专门用来处理越界问题。</p>\n<p>假设一个视频发生了亮度 overflow，可以使用以下方式修复：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>bitdepth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> bits<span class=\"token operator\">=</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>src16 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Levels<span class=\"token punctuation\">(</span>src16<span class=\"token punctuation\">,</span> min_in<span class=\"token operator\">=</span><span class=\"token number\">16</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> max_in<span class=\"token operator\">=</span><span class=\"token number\">255</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> min_out<span class=\"token operator\">=</span><span class=\"token number\">16</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> max_out<span class=\"token operator\">=</span><span class=\"token number\">235</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> planes<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>当然，实际情况中你需要分别判断 overflow 和 underflow 是否发生，并找到它们溢出的最大值、最小值来确定 max_in 和 min_in。</p>\n<h3 id=\"2-降精度与dither\"><a class=\"anchor\" href=\"#2-降精度与dither\">#</a> (2). 降精度与 Dither</h3>\n<p>经过一系列高精度的处理，在最后输出给编码器时，我们需要将精度降为 8bit 或者 10bit。通过之前的转换公式我们知道，从高精度降为低精度时，多个高精度值会被转为同一个低精度值，这样在相邻颜色间就会形成明显的分界线，或者说色带。</p>\n<p>为了效果明显，我们使用 8bit 降为 4bit 来展现这一过程，这里使用 round（四舍五入）来处理。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src4 <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Depth<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> depth<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> dither<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>可以看到降低精度后的图片出现了很多明显的色带，这是我们难以接受的。<br />\n为了解决这种色带问题，很自然的想法是，加点噪声，让相邻颜色之间的台阶看起来没那么陡峭。<br />\n这种引入类似噪声的方法，就称作抖动（dither）。</p>\n<p>最简单的抖动算法， <code>ordered dither</code> ，又叫 Bayer matrix，在 fmtc 和 mvf 里是  <code>dmode=0</code> 。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-06/image04.png\" alt=\"img\" /></p>\n<p>现在我们可以看到，色带问题得到了极大的改善。仔细观察，则会看到画面上充满了规则排列的点状图样。</p>\n<p>这种 dither 过程中引入的丑陋噪点也被叫做 dither pattern，它们在进一步缩放后会更加明显。平时 QQ 聊天中，在那些被压缩过的缩略图上，经常可以看到这种现象。</p>\n<p>ordered dither 虽然丑陋，但有这些好处：<br />\n1. 算起来很快<br />\n 2. 很难被编码器抹平</p>\n<p>我们通常会利用它很难被抹平的特点，将它用在 8bit 低码率成品的暗场中，防止出现色带。</p>\n<p>那么有没有更高质量的 dither 算法呢，当然是有的，最常使用的是  <code>error diffusion</code>  误差扩散。</p>\n<p>fmtc 中提供了很多 error diffusion 的变体，差别不大，一般使用  <code>dmode=3</code> ，最经典的 error diffusion，这也是 fmtc 和 mvf.Depth 的默认算法。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-06/image05.png\" alt=\"img\" /></p>\n<h2 id=\"4-初等resizer\"><a class=\"anchor\" href=\"#4-初等resizer\">#</a> 4. 初等 Resizer</h2>\n<p>Resizer 是滤镜中的瑞士军刀，它能处理多种基础视频操作，也在一些高级处理手段中发挥重要作用，这些我们会在后续章节中逐渐看到。在本章我们仅关注 Resizer 最基本的用法，视频缩放。</p>\n<p>VS 中使用 resizer 有 fmtc 和 zimg 两个工具，前者是使用  <code>fmtc.resample</code>  滤镜，后者是使用 VS 自带的  <code>resize.*</code>  系列滤镜。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL3Jlc2l6ZS5odG1s\">https://amusementclub.github.io/doc/functions/video/resize.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9mbXRjb252L2RvYy9mbXRjb252Lmh0bWwjcmVzYW1wbGU=\">https://amusementclub.github.io/fmtconv/doc/fmtconv.html#resample</span></p>\n<h3 id=\"1-resizer的副作用\"><a class=\"anchor\" href=\"#1-resizer的副作用\">#</a> (1). resizer 的副作用</h3>\n<p>可以看到，这些滤镜里面提供了很多不同的算法，为了更好地使用它们，我们需要了解这些算法的优势和劣势所在。</p>\n<p>大部分 resize 滤镜都逃不过这三种副作用：模糊（blurring）、锯齿（aliasing）、振铃（ringing）。</p>\n<h4 id=\"模糊blurring\"><a class=\"anchor\" href=\"#模糊blurring\">#</a> 模糊（blurring）</h4>\n<p>模糊很好理解，就是缩放后画面变糊了。</p>\n<p>可以通过下面这段代码感受模糊的效果，其中  <code>upscale_0</code>  是使用 nearest 算法，单纯复制原来的像素，锐利度几乎不变，而  <code>upscale_1</code>  使用 bilinear 算法，通过线性插值得到结果，图像有明显的模糊现象。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>upscale_0 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Point<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>width<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>height<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>upscale_1 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Bilinear<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>width<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>height<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>upscale_0<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>upscale_1<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>大部分时候我们总是不希望画面变糊的，但是在放大 UV 平面的时候我们就可以用一些比较糊的滤镜。原因是，UV 平面本就信息量不高，而编码器还会疯狂剥削 UV 平面，导致有时候 UV  平面质量很差。这时候使用一些锐利的放大滤镜，反而会放大 UV 平面的瑕疵，而用一些模糊的滤镜可以 “一糊遮百丑”。</p>\n<p>另一方面，UV 平面的锐利度其实对观看体验的影响不大。观察下面这段代码的结果，对比  <code>u1</code>  和  <code>u2</code>  可以发现色度平面被严重模糊，而对比  <code>res1</code>  和  <code>res2</code>  则发现最后呈现结果区别很小。因此，拉伸 UV 平面基本没必要选用特别锐利的滤镜，区别实在不是很明显。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res1 <span class=\"token operator\">=</span> src8</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res2 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>RemoveGrain<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>u1 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>res1<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>u2 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>ShufflePlanes<span class=\"token punctuation\">(</span>res2<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>GRAY<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>res1<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>res2<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>u1<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>u2<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"锯齿aliasing\"><a class=\"anchor\" href=\"#锯齿aliasing\">#</a> 锯齿（aliasing）</h4>\n<p>锯齿很好观察，使用 nearest 进行非整数的缩放，满屏幕都是锯齿。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>upscale <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Point<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>width<span class=\"token operator\">*</span><span class=\"token number\">1.75</span><span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>height<span class=\"token operator\">*</span><span class=\"token number\">1.75</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>upscale<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"振铃ringing\"><a class=\"anchor\" href=\"#振铃ringing\">#</a> 振铃（ringing）</h4>\n<p>至于 ringing，通常出现在比较锐利的 resizer 中。选用清晰度较高的源，使用 Lanczos 之类锐利的滤镜，可以看到线条周围一圈发亮的东西，就是 ringing。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>upscale <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Lanczos<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>width<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> src8<span class=\"token punctuation\">.</span>height<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> filter_param_a<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>upscale<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"2-图像的缩放\"><a class=\"anchor\" href=\"#2-图像的缩放\">#</a> (2). 图像的缩放</h3>\n<p>通常人们会认为数字图像是由一堆相同大小的正方形像素块组成，这种观念实际上是错误的。实际上，我们应该把图像看做一块连续的平面，而像素是其上没有大小只有坐标的采样点。只要采样的数量足够多，那我们就可以用这些分立的点表示整幅图像。</p>\n<p>缩放图像，则应该理解为图像平面本身没有变化，而只是增加或减少采样点数量，或者说密度。</p>\n<p>以下面这幅图像为例，现在有 4 个像素，坐标分别是： <code>(0,0), (0,1), (1,0), (1,1)</code> 。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-06/image06.png\" alt=\"img\" /></p>\n<p>现在我们希望将图像的宽高都放大两倍，最终有 16 个像素。按照中心对齐，现在这些像素的位置如下图红点所示。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-06/image07.png\" alt=\"img\" /></p>\n<p>可以发现这些新像素在原来坐标系下处于小数坐标的位置，而这些位置是没有准确值的，因此我们只能通过周围已知像素，猜测这些位置的值，这被称为插值（interpolation）。</p>\n<p>插值有两个关键点，一是  <code>taps</code> ，即选取周围多大范围的已知像素；二是  <code>weight</code> ，即这些选中的像素的权重是多少。</p>\n<p><code>taps</code>  很好理解，就是选取范围的半径，选取的周围像素越多，“猜测” 就越可能准确。但同时，涉及的像素越多，计算也就越慢。</p>\n<p><code>weight</code>  也容易理解，比如图上  <code>(1,0)</code>  和  <code>(1,1)</code>  位置的像素到  <code>(0.25, 1.25)</code>  采样点的距离不同，它们所占的比重自然也是不一样的。</p>\n<p>在实际中，我们使用  <code>kernel</code>  来描述以上性质。kernel 是一个曲线，它的横坐标表示已知像素到采样点的距离，纵坐标表示在这个距离上，该像素贡献的权值。taps 也在曲线上有所表现，超过 taps 范围的像素没有贡献，因此曲线恒为 0。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9SZXNhbXBsZUhRL2tlcm5lbHMuaHRtbA==\">https://amusementclub.github.io/ResampleHQ/kernels.html</span></p>\n<p>可以通过这个网页查看各种 kernel 的形状，将鼠标移到曲线下方的 kernel 名字上可以显示对应的 kernel 曲线，同时也可以在最下方的直方图上看到各个  kernel 对应的 blurring、sharpness、ringing 三种性质。不过需要注意的是，这里讲的 kernel  性质是数学上的定义，和我们前面讲的视觉上的概念还有些区别。</p>\n<p>最后，我们通过这张图来形象地说明 2 维图片的插值过程。<br />\n如图所示，先是在横向上进行插值，算出中间点，然后纵向上再利用这些中间点，进一步插值算出目标点。<br />\n这一过程体现出，横向和纵向的插值是完全独立的，事实上，我们甚至可以在两个方向使用完全不同的算法。<br />\n另外，这幅图也展示了，不同 taps 的插值算法会利用到的周围像素范围。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA2L2ltYWdlMDg=\">https://guides.vcb-s.com/media/basic-guide-06/image08</span> interpolation.png)</p>\n<h3 id=\"3-resizer的使用\"><a class=\"anchor\" href=\"#3-resizer的使用\">#</a> (3). resizer 的使用</h3>\n<p>接下来我们就结合 kernel 曲线，依次介绍常见的 resizer。</p>\n<h4 id=\"pointnearest\"><a class=\"anchor\" href=\"#pointnearest\">#</a> Point(Nearest)</h4>\n<p>首先是  <code>nearest</code> ，最常见的算法之一，它可以说没有插值，只是单纯采样最近的像素。这里没有提供它的 kernel 曲线，但根据性质描述应该不难画出。由于它只采样最近的像素，显然是  <code>1-taps</code>  的。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Point<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"point\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"bilinear\"><a class=\"anchor\" href=\"#bilinear\">#</a> Bilinear</h4>\n<p><code>bilinear</code> ，中文名双线性。它分别对 x 和 y 方向各做了一次线性插值，因此得名双线性。观察 kernel 可以看出其线性的性质，同时可以看出它是  <code>1-taps</code>  的。</p>\n<p>双线性特点是计算快，不那么锐利，有些锯齿，没有 ringing，各方面比较平庸。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Bilinear<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"bilinear\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"bicubic\"><a class=\"anchor\" href=\"#bicubic\">#</a> Bicubic</h4>\n<p><code>bicubic</code> ，中文名双立方。区别于 bilinear 的线性插值，bicubic 在每个方向选取最近的四个点，用三次多项式插值计算，因此得名双立方。</p>\n<p>bicubic 有两个专有的参数， <code>b</code>  和  <code>c</code> 。大致可以理解为 b 越大越模糊，c 越大越锐利。这两个参数在 resize 函数里叫  <code>filter_param_a</code>  和  <code>filter_param_b</code> ，在 resample 函数里叫  <code>a1</code>  和  <code>a2</code> 。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Bicubic<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> filter_param_a<span class=\"token operator\">=</span>b<span class=\"token punctuation\">,</span> filter_param_b<span class=\"token operator\">=</span>c<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"bicubic\"</span><span class=\"token punctuation\">,</span> a1<span class=\"token operator\">=</span>b<span class=\"token punctuation\">,</span> a2<span class=\"token operator\">=</span>c<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>bicubic 中不同的 bc 组合有不同的性质。在提出 bicubic 算法的那篇论文里，作者用不同的 bc 参数组合做了很多图，然后让图像处理的专业人士去评价，得到以下结果。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA2L2ltYWdlMDk=\">https://guides.vcb-s.com/media/basic-guide-06/image09</span> bicubic.png)</p>\n<p>blur 和 ringing 我们前面讲过，这里的 anisotropy，各向异性，指的是横竖方向和斜的方向，这个滤镜的效果出现了明显不同，导致看起来会有锯齿的感觉。</p>\n<p>最终，论文作者推荐了  <code>b=1/3, c=1/3</code>  的参数，也就是以两位作者名字命名的  <code>Mitchell-Netravali</code>  算法。</p>\n<p>还有一些比较经典的取值，比如  <code>Catmull-Rom</code> ， <code>b=0.0 c=0.5</code> 。过去经常在处理 chroma 时使用。</p>\n<p><code>softcubic</code> ，指一系列参数，满足  <code>b=x, c=1-x</code> ，就叫  <code>softcubic(100*x)</code> 。其中  <code>softbubic100</code> ， <code>b=1.0 c=0.0</code> ，又称为  <code>b-spline</code> 。</p>\n<h4 id=\"spline\"><a class=\"anchor\" href=\"#spline\">#</a> Spline</h4>\n<p><code>spline</code>  系列，taps 是可调的。它的命名原则是，如果一个 spline 是 n-taps 的那么它叫  <code>spline((2n)^2)</code> 。</p>\n<p>spline16 是 2-taps，spline36 是 3-taps，spline64 是 4-taps。</p>\n<p>spline 系列比较柔和，出 ringing 较少，常用于 downscale。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Spline36<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"spline36\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"lanczos\"><a class=\"anchor\" href=\"#lanczos\">#</a> Lanczos</h4>\n<p><code>lanczos</code>  系列，taps 也是可调的。如果一个 lanczos 是 n-taps 的那么它叫  <code>lanczos(n)</code> 。</p>\n<p>lanczos 较为锐利，通常也会带来比较重的 ringing。过去常用 lanczos4 配合 no-ringing 用于放大。</p>\n<p>在 resize 函数中通过  <code>filter_param_a</code>  指定 taps，在 resample 函数中通过  <code>taps</code>  参数指定 taps。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">.</span>Lanczos<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> filter_param_a<span class=\"token operator\">=</span>n<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"lanczos\"</span><span class=\"token punctuation\">,</span> taps<span class=\"token operator\">=</span>n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"gauss\"><a class=\"anchor\" href=\"#gauss\">#</a> Gauss</h4>\n<p>高斯滤镜，名字来源于其 kernel，这个曲线是按高斯分布（正态分布）画的。</p>\n<p>resample 里可以使用 gauss，resize 则没有该滤镜。滤镜有两个参数， <code>a1</code>  和  <code>taps</code> 。 <code>a1</code>  是 1-100 的实数，与高斯分布的 sigma 相关，越小越模糊。 <code>taps</code>  指定需要采样的像素范围，由于高斯分布曲线是向两端无限延伸的，因此需要确定实际采样的半径。</p>\n<p>gauss 通常用于配合其他滤镜，比如配合 lanczos 做 no-ringing 的放大，这会在后续课程中提到。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>fmtc<span class=\"token punctuation\">.</span>resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> kernel<span class=\"token operator\">=</span><span class=\"token string\">\"gauss\"</span><span class=\"token punctuation\">,</span> a1<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> taps<span class=\"token operator\">=</span>n<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h4 id=\"nnedi3\"><a class=\"anchor\" href=\"#nnedi3\">#</a> nnedi3</h4>\n<p>最后介绍一个实际中广泛使用的神经网络放大滤镜， <code>nnedi3</code> 。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2R1YmhhdGVyL3ZhcG91cnN5bnRoLW5uZWRpMw==\">https://github.com/dubhater/vapoursynth-nnedi3</span></p>\n<p>这个滤镜最开始其实不是用来放大的，而是用于反交错的。它的作用是在每两行像素中插入一行，也就是说，原始版本的 nnedi3 只能把原图的高变成两倍。</p>\n<p>假如想放大宽，那么需要把图竖起来送进 nnedi3，可以利用  <code>std.Transpose()</code>  滤镜。</p>\n<p>在 VS 中，调用 nnedi3 进行倍高是这样：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>znedi3<span class=\"token punctuation\">.</span>nnedi3<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> field<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> dh<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>需要注意的是，手动倍高进行放大会产生 chroma shift 问题，这会在后续课程进行介绍。目前推荐的用法是，使用  <code>nnedi3_resample.py</code>  这个 wrapper，它将 nnedi3 封装成和其他 resizer 类似。在 nnedi3_resample 里面， <code>width</code>  和  <code>height</code>  不再需要是两倍，脚本会将输入用 nnedi3 2/4/8... 倍拉到比较合适的大小后，再调用传统的 resizer 拉到目标尺寸。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> nnedi3_resample <span class=\"token keyword\">as</span> nnrs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>upscale <span class=\"token operator\">=</span> nnrs<span class=\"token punctuation\">.</span>nnedi3_resample<span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> mode<span class=\"token operator\">=</span><span class=\"token string\">\"znedi3\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"5-字幕滤镜\"><a class=\"anchor\" href=\"#5-字幕滤镜\">#</a> 5. 字幕滤镜</h2>\n<p>字幕滤镜按照渲染标准不同分为  <code>VSF</code>  系和  <code>libass</code>  系。前者以 VSFilter 这一经典字幕滤镜为基础，遵循传统的事实标准。libass 则是近年来新起的 ass 标准。</p>\n<p>在压片中具体使用哪个，需要根据具体情况来确定。对于老字幕，只有 VSF 一种选择；而对于较新的字幕，需要询问字幕组，保证和字幕组制作字幕时使用的一致。</p>\n<h3 id=\"1-vsf系字幕滤镜\"><a class=\"anchor\" href=\"#1-vsf系字幕滤镜\">#</a> (1). VSF 系字幕滤镜</h3>\n<p>VSF 系一般使用  <code>xy-VSFilter</code> ，它的 VapourSynth 版本是：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hvbWVPZlZhcG91clN5bnRoRXZvbHV0aW9uL3h5LVZTRmlsdGVyJUUzJTgwJTgyJUU3JTlCJUFFJUU1JTg5JThEJUU1JThDJTg1JUU2JThCJUFDJUU1JThFJTlGJUU3JTg5JTg4JUU1JTkyJThD\">https://github.com/HomeOfVapourSynthEvolution/xy-VSFilter。目前包括原版和</span> VapourSynth 版都不再有人维护，但是不影响我们继续使用。</p>\n<p>使用方法为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>xyvsf<span class=\"token punctuation\">.</span>TextSub<span class=\"token punctuation\">(</span>clip clip<span class=\"token punctuation\">,</span> string <span class=\"token builtin\">file</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> charset<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">float</span> fps<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> string vfr<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>有些字幕会用到复杂特效，需要  <code>VSFilterMod</code> ：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NvcmF5dWtpL1ZTRmlsdGVyTW9kJUUzJTgwJTgy\">https://github.com/sorayuki/VSFilterMod。</span></p>\n<p>这个 VSFilterMod 也可以给播放器使用，但是注意只有少量特效能实时播放。因此你和字幕组合作时，得提前问清有没有需要 VSFilterMod 的特效，如果有，请他们尽量在外挂字幕中去除。一些可以实时播放并且不影响其他字幕滤镜渲染的特效，则可以保留，但是注意在发布时提醒观众。</p>\n<p>一些主攻 Live 的字幕组，可能会大量使用无法实时播放的特效，这时可以选择制作两个版本：无字幕视频 + 外挂去特效字幕，内嵌特效字幕视频。</p>\n<p>使用方法为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vsfm<span class=\"token punctuation\">.</span>TextSubMod<span class=\"token punctuation\">(</span>clip clip<span class=\"token punctuation\">,</span> string <span class=\"token builtin\">file</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> charset<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">float</span> fps<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> string vfr<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> accurate<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"2-libass系字幕滤镜\"><a class=\"anchor\" href=\"#2-libass系字幕滤镜\">#</a> (2). libass 系字幕滤镜</h3>\n<p>libass 系字幕滤镜没得选，只有  <code>assrender</code> ：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvYXNzcmVuZGVyJUUzJTgwJTgy\">https://github.com/AmusementClub/assrender。</span></p>\n<p>使用方法为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>assrender<span class=\"token punctuation\">.</span>TextSub<span class=\"token punctuation\">(</span>clip clip<span class=\"token punctuation\">,</span> string <span class=\"token builtin\">file</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>string vfr<span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> hinting<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">float</span> scale<span class=\"token operator\">=</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">float</span> line_spacing<span class=\"token operator\">=</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">float</span> dar<span class=\"token punctuation\">,</span> <span class=\"token builtin\">float</span> sar<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span> set_default_storage_size<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> top<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> bottom<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> left<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> right<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> string charset<span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span> debuglevel<span class=\"token punctuation\">,</span> string fontdir<span class=\"token operator\">=</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> string srt_font<span class=\"token operator\">=</span><span class=\"token string\">\"sans-serif\"</span><span class=\"token punctuation\">,</span> string colorspace<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>顺带一提，assrender 可以设置  <code>fontdir</code>  参数，从指定目录获取字体，而 VSF 必须安装字体才能渲染。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%BA%94%E7%AB%A0VapourSynth%E5%9F%BA%E7%A1%80/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%BA%94%E7%AB%A0VapourSynth%E5%9F%BA%E7%A1%80/",
            "title": "第五章VapourSynth基础",
            "date_published": "2024-03-16T15:07:59.000Z",
            "content_html": "<h1 id=\"第五章-vapoursynth基础\"><a class=\"anchor\" href=\"#第五章-vapoursynth基础\">#</a> 第五章 VapourSynth 基础</h1>\n<p>BDRip  的核心是预处理（pre-processing），没有经过预处理的画质调教，压片就只是单纯的数据压缩罢了，永远不可能有画质提升。历史上，最流行的预处理软件是 AviSynth（简称 AVS），然而由于年代久远，其许多设计理念和功能都有较多缺陷，现在逐步被新一代的预处理软件  VapourSynth（简称 VS）替代。本章就来讲解 VS 的基本构成，介绍预览工具和脚本，并从中学习 VS 基本语法和功能。</p>\n<h2 id=\"1-vs简介\"><a class=\"anchor\" href=\"#1-vs简介\">#</a> 1. VS 简介</h2>\n<p>VapourSynth，简称 VS，官网是 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmFwb3Vyc3ludGguY29t\">https://www.vapoursynth.com</span>。你可以在 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZhcG91cnN5bnRoL3ZhcG91cnN5bnRoL3JlbGVhc2Vz\">Github</span> 上下载最新版本，包括安装版和便携版。</p>\n<p>VCB-Studio 目前使用的 VS 则是娱乐部版，全称 VapourSynth-Classic，简称 VS-C。你可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdmFwb3Vyc3ludGgtY2xhc3NpYy9yZWxlYXNlcw==\">这里</span>下载最新版。</p>\n<p>VS-C 源于 VS 社区的一次重大分裂。VS 项目开发者在 R55 引入了全新的 API4，这导致了严重的兼容性问题：API4 的 VS  虽然能够同时支持新的 API4 滤镜和旧的 API3 滤镜，但却不支持 API3 脚本。而这些多年传承的脚本才是 VS  发展的精髓，这对于追求稳定生产环境的 VCB-S 来说是不可接受的。</p>\n<p>另一方面，VS 开发者在 API4 还引入了大量破坏性弃用，以迫使用户和滤镜开发者转向 API4。同时还采取先进的 user driven testing，让普通用户积极参与到新版的验证与反馈工作中。</p>\n<p>基于以上复杂情况，总监 Akarin 创立了 VS-C，同时兼容 API3 与 API4 脚本，全力保证生产环境的向后兼容性。此外 VS-C 兼具前后两代 VS 之长，既有 API4 的低内存开销，又有 API3 的高处理速度。</p>\n<p>有了 VS 本体，问题还没有完全解决。上述这些 VS 本体只含有少量的内置滤镜，这显然是远远不够的。收集滤镜和常用工具脚本是一件复杂繁琐的事，这里我们提供了一套打包好的便携版 VS-C，含有大部分常用滤镜和脚本：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdG9vbHMvcmVsZWFzZXMlRTMlODAlODI=\">https://github.com/AmusementClub/tools/releases。</span></p>\n<p>打开 VS 目录，我们可以看到 VS 本体的一堆 dll 和 python 环境。VS 本体和滤镜都是由 C++ 编写，而它暴露给用户的接口则是  python 的。我们可以通过 python 编写 VS 脚本，然后通过 VSPipe 运行脚本获得输出。你可以认为 VS 是 python  的一个库，也可以认为 VS 使用 python 做 dsl (domain specific language) 或者更通俗地讲就是  glue（把滤镜给串联起来）。</p>\n<p><code>vapoursynth64</code>  目录下是 VS 滤镜， <code>coreplugins</code>  是内置滤镜， <code>plugins</code>  是第三方滤镜。对于我们提供的 VS-C 包，AI 滤镜相关的模型和运行环境等也放在  <code>plugins</code>  目录。</p>\n<p>同时，我们提供的包里的 python 还内置了 pip，可以方便地安装额外包。</p>\n<p>将这一整套内容打包为便携包不是一件容易的事，事实上在上古时期，VS 基本都是通过安装来使用，这带来了严重的版本管理问题。</p>\n<p>目前我们使用总监 SaltyChiang 开发的打包工具 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvVmFwb3VyU3ludGgtUG9ydGFibGUtTWFrZXI=\">VapourSynth-Portable-Maker</span> 来完成打包工作，对打包有兴趣的同学可以看看。</p>\n<h2 id=\"2-vs预览\"><a class=\"anchor\" href=\"#2-vs预览\">#</a> 2. VS 预览</h2>\n<p>有了 VSPipe，其实我们就已经可以运行脚本输出处理结果，但我们更希望可以实时修改脚本并看到滤镜的效果，这就需要一个预览器。</p>\n<h3 id=\"1-vapoursynth-editor\"><a class=\"anchor\" href=\"#1-vapoursynth-editor\">#</a> (1). VapourSynth-Editor</h3>\n<p>预览器在很长时间里只有一个， <code>VapourSynth-Editor</code> （简称 vsedit 或 vse），<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvVmFwb3VyU3ludGgtRWRpdG9yJUUzJTgwJTgydnNl\">https://github.com/AmusementClub/VapourSynth-Editor。vse</span> 是一个 IDE，可以在里面编写 VS 脚本，并进行预览、测试、调试等。它提供了少量的高光和代码补完功能，但不是很完善，只对滤镜起作用，对脚本函数则没有作用。vse 也没有提供代码的查找与替换功能，使用起来不太方便。</p>\n<p>vse 需要依赖 VS 运行，而且原版 vse 优先选择注册表中的 VS 而不是用户指定的 VS，当系统中有多个 VS，或者曾经使用过安装版  VS，那你几乎永远无法知道它使用的是哪个 VS。当然目前娱乐部版已经修复了这个问题，它会优先找同目录的 VS，即开即用。</p>\n<p>一般来说，VS 脚本文件都是 python 脚本，为了区分，我们用  <code>vpy</code>  作为后缀名。</p>\n<p>这里有一个简单预览脚本：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> havsfunc <span class=\"token keyword\">as</span> haf</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> mvsfunc <span class=\"token keyword\">as</span> mvf</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">\"00010.m2ts\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>src8<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>先看前四句，熟悉 python 的应该知道，这是在载入库。<br />\n第一句载入 vapoursynth 本体，并简称为  <code>vs</code> 。<br />\n第二句载入  <code>vs</code>  的  <code>core</code> 。 <code>core</code>  的概念比较抽象，不妨认为就是一种固定格式。<br />\n这里可以换为等价的写法：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core <span class=\"token operator\">=</span> vs<span class=\"token punctuation\">.</span>core</pre></td></tr></table></figure><p>一些早期的脚本可能会写成：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core <span class=\"token operator\">=</span> vs<span class=\"token punctuation\">.</span>get_core<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这在 VS-C 中仍然能运行，但  <code>get_core</code>  即将弃用，不要这么写。<br />\n第三四句，载入  <code>mvsfunc</code> （mawen1250 写的工具合集）和  <code>havsfunc</code> （Holy 从 AVS 移植的工具合集），并分别指定别名为  <code>mvf</code>  和  <code>haf</code> ，这是日常做番最常用到的工具。</p>\n<p>再看后三句，这里细节很多，我们一个一个分析。</p>\n<p>首先  <code>a = &quot;00010.m2ts&quot;</code> ，这是指定视频源文件的路径。<br />\n一般写脚本的时候要避免这种单个字母的无脑命名。 但本组约定俗成采用 a 代指输入文件，注意在这之后的 OKE 中会用到。</p>\n<p>这里使用的是相对路径，需要保证 00010.m2ts 和 vpy 脚本在同一目录下。 如果要使用绝对路径，可以这样： <code>a = R&quot;E:\\Anime\\00010.m2ts&quot;</code> 。 这里被 R 引号圈起来的是一个 Raw String，所见即所得，可以避免复杂的转义问题。 不然你就得写： <code>&quot;E:\\\\Anime\\\\00010.m2ts&quot;</code> 。</p>\n<p>第二句  <code>src8 = core.lsmas.LWLibavSource(a)</code> ，这是使用源滤镜  <code>lsmas</code>  载入视频，获取一个在 vs 里称为 clip 的变量，并命名为  <code>src8</code> 。<br />\n除了文件名之外的变量，一般需要有一定意义，方便解读。 通常我们用  <code>src</code>  指代源，8 表示精度，原盘一般都是 8-bit。 而最后的输出结果，则用  <code>res</code>  指代。</p>\n<p>从这一行我们也能看出 vs 滤镜的使用规律，是  <code>core.&lt;package_name&gt;.&lt;filter_name&gt;(...)</code>  的形式。<br />\n这里 lsmas 就是 package_name，而 LWLibavSource 就是 filter_name。<br />\n脚本函数（比如上面提到的 mvf 和 haf）的使用则有些不同，是  <code>&lt;package_name&gt;.&lt;function_name&gt;(...)</code>  的形式，这一点我们会在后面看到。</p>\n<p>最后，使用  <code>set_output()</code>  将读入的视频输出。</p>\n<p>现在我们尝试使用 vsedit 来运行脚本。</p>\n<p>如果你的滤镜载入正确，vsedit 应该可以高亮显示滤镜名称。 在上方工具栏选择  <code>Script - Check script</code> ，或者按  <code>F6</code> ，就可以检查脚本是否能正常输出。 如果是第一次读取某个视频文件，LWLibavSource 会生成一个后缀为  <code>lwi</code>  的索引文件，便于以后再次读取视频。 源文件越大，需要的时间越多，对于好几个 GB 的蓝光原盘需要等待几分钟。SSD 硬盘的话会快很多。</p>\n<p>没有脚本没有问题，可以在 vsedit 下方看到如下信息。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image01.png\" alt=\"img\" /></p>\n<p>否则会告诉你存在什么问题。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image02.png\" alt=\"img\" /></p>\n<p>输出的信息，包括：总帧数、时长、分辨率、帧率、像素格式。</p>\n<p>注意 VS 里帧数是 0-indexed 的，比如这个视频的帧数就是 0-16711，一共 16712 帧。<br />\n帧率 24000/1001=23.976，这个数字要牢记，这是日本动画的典型帧率。<br />\n最后像素格式 YUV420P8，说明这是 YUV 色彩空间，420 下采样，数据位深为 8-bit。</p>\n<p>检查完了这些，就可以用  <code>Script - Preview</code> ，或者按  <code>F5</code>  来预览实际画面。</p>\n<p>它会打开一个预览窗口，其中包含许多方便的功能。<br />\n上方窗口可以拖动浏览整个画面，键盘上的前后键可以调整到上一帧或者下一帧。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image03.png\" alt=\"img\" /></p>\n<p>左下角，可以点击进度条跳转到目标帧，也可以输入帧号定位。按三角形可以播放，旁边可以调整播放帧率。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image04.png\" alt=\"img\" /></p>\n<p>右下角，点击画笔可以开启取色功能。鼠标移到画面上可以在左下角显示像素的 YUV 值以及渲染后的 RGB 值。</p>\n<p>右下角还有放大镜 zoom 的选项，切换到  <code>fixed radio</code>  可以按倍数放大缩小，方便观察。可以选择缩放算法， <code>Nearest</code>  或者  <code>Bilinear</code> 。<br />\nNearest 是完全没有运算，只是单纯复制粘贴的缩放方法，将原来的 1 个像素变成 4 个，9 个，16 个...<br />\n 注意不要用 Nearest 进行缩小或者非整数倍的放大，锯齿非常恐怖。<br />\nBilinear 是使用插值进行缩放，它是最简单的线性插值，所以一般也不会引入额外的副作用。我们通常都用 Nearest 放大进行观察，除了观察锯齿的时候，可能会用 Bilinear。</p>\n<p>前面取色的时候我们看到，输出的 YUV 实际被渲染为 RGB 呈现，这是 vsedit 自动帮我们做了。但是 vsedit 做的精度不佳，所以我们通常在脚本里手动转为 RGB 进行预览。</p>\n<p>我们把脚本改为：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>ToRGB<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>再预览看看，有什么区别。 可以发现现在格式变为  <code>RGB24</code>  了。 注意这里调用 mvf，跟调用滤镜的区别，前面已经提到过了。</p>\n<p>下面，找一个 10-bit 的视频（比如本组压制的成品），用同样的脚本再预览，看看有啥区别。 可以发现现在格式变为  <code>RGB30</code>  了。<br />\n然后再改为  <code>src8.set_output()</code>  看看，可以发现格式变为  <code>YUV420P10</code> 。 所以 LWILibavSource 读取源的时候，是准确的读取了源的全部精度。</p>\n<p>当然实际上 vsedit 渲染时，还是采用 RGB24，这可以利用取色器看到。 这是合理的，因为大部分人的显示器仍然还是 8-bit。</p>\n<p>因此我们预览输出时，习惯是无论什么精度的源，都输出 8-bit RGB。 这可以通过  <code>res = mvf.ToRGB(src8, depth=8)</code>  或者  <code>res = mvf.Preview(src8)</code>  来实现。 这也是日常截图最标准的方法。</p>\n<h3 id=\"2-vapoursynth-preview\"><a class=\"anchor\" href=\"#2-vapoursynth-preview\">#</a> (2). VapourSynth-Preview</h3>\n<p><code>VapourSynth-Preview</code> （简称 vspreview 或 vsp）是近两年兴起的另一个预览器，区别于 vsedit 的独立程序，vsp 是由 python 编写的模块，因此可以直接集成到 python 环境中。</p>\n<p>vsp 的初始 repo 已经不再维护，因此目前版本繁多。我们使用的娱乐部版（也是 portable 包中集成的版本）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FrYXJpblZTL3ZhcG91cnN5bnRoLXByZXZpZXclRTMlODAlODIlRTUlOEYlQTYlRTQlQjglODAlRTQlQjglQUElRTYlQjQlQkIlRTglQjclODMlRTclOUElODQlRTclODklODglRTYlOUMlQUMlRTYlOTglQUY=\">https://github.com/AkarinVS/vapoursynth-preview。另一个活跃的版本是</span> iew 版：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0lycmF0aW9uYWwtRW5jb2RpbmctV2l6YXJkcnkvdnMtcHJldmlldyVFMyU4MCU4Mg==\">https://github.com/Irrational-Encoding-Wizardry/vs-preview。</span></p>\n<p>注意 iew 版与 VapourSynth-Classic 并不完全兼容，如果你有兴趣尝试一些新功能，可以使用这个兼容 VS-C 的版本：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NhbHR5Q2hpYW5nL3ZzLXByZXZpZXcvdHJlZS9uby12c3Rvb2xzJUUzJTgwJTgy\">https://github.com/SaltyChiang/vs-preview/tree/no-vstools。</span></p>\n<p>vspreview 可以直接通过 pip 安装，参考上述 repo 的说明。目前 portable 包中已经预先安装好，可以通过下述命令使用（注意把  <code>python</code>  换成完整路径）：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>python -m vspreview xxx.vpy</pre></td></tr></table></figure><p>成功的话会弹出类似 vsedit 的预览窗口。</p>\n<p>与 vsedit 不同，vsp 本体只是一个预览器，而不是一个 IDE，因此只能预览脚本，而无法编写脚本。为了方便使用，通常需要配合其他文本编辑器或者 IDE，下面介绍一个基于  <code>VSCode</code>  的开发环境搭建方案。</p>\n<h4 id=\"vscode\"><a class=\"anchor\" href=\"#vscode\">#</a> VSCode</h4>\n<ol>\n<li>安装  <code>VSCode</code> ，并在扩展商店里安装  <code>Python</code>  和  <code>Pylance</code>  扩展。</li>\n<li>将本章  <code>.vscode</code>  目录的文件复制到 VSCode 用户配置目录  <code>%APPDATA%\\Code\\User\\</code> 。如果用户配置目录已经有同名文件，不要覆盖，将相应内容复制到原有文件中。</li>\n<li>修改  <code>settings.json</code>  中的 python 路径，改为你的 VapourSynth 对应的 python 路径。</li>\n</ol>\n<h4 id=\"vapoursynth\"><a class=\"anchor\" href=\"#vapoursynth\">#</a> VapourSynth</h4>\n<ol>\n<li>安装 VapourSynth-Preview。可参考上述 repo 的说明，如果使用我们的 portable 包则不必再安装。</li>\n<li>安装 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NhbHR5Q2hpYW5nL1ZhcG91clN5bnRoLVBsdWdpbnMtU3R1Yi1HZW5lcmF0b3IvdHJlZS9SNTdDbGFzc2lj\">VapourSynth-Plugins-Stub-Generator</span>。这是由总监 SaltyChiang 开发的小工具，用于在 VSCode 里支持代码补全。同样，portable 包中已经集成，不必再安装。 如果首次安装，运行  <code>python -m vsstubs install</code> ，如果使用 portable 包，运行  <code>python -m vsstubs update</code> 。注意以后每次增加滤镜都需要重新 update。</li>\n</ol>\n<p>以上，我们就配置好了全部所需内容。现在使用 VSCode 打开 vpy 脚本（或者所在文件夹），如果配置成功，可以看到脚本高亮和语法补全信息。接下来可以使用  <code>Ctrl+F6/Ctrl+F5</code>  进行类似 vsedit 的 F6/F5 的脚本检查 / 预览。不过这里的脚本检查只检查是否正常运行，不提供 vsedit 那样的 clip 信息。</p>\n<p>我们的配置还提供了额外两个功能： <code>Ctrl+F7</code> ，相当于 vs info，打印输出 clip 的信息； <code>Ctrl+F8</code> ，相当于 vs benchmark，计算输出 clip 的所有帧，可以测试脚本速度。</p>\n<p>vsp 的基本功能与 vsedit 差别不大，但更加易于使用。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image05.png\" alt=\"img\" /></p>\n<p>左下角，最底下一栏显示 clip 信息，与 vsedit 类似，这里多了一个帧类型信息，可以看到这一帧为 P 帧。<br />\n上面一栏，从左开始， <code>output</code>  按钮选择输出节点，后面  <code>sync outputs</code>  选择是否在节点间同步，这个功能我们后面再说。<br />\n第二个按钮指定帧号，第三个指定时间戳，后面 100% 的按钮选择缩放倍率，vsp 里默认是 Nearest 算法。最后  <code>Timeline</code>  可以切换时间轴按时间戳显示还是按帧号显示。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image06.png\" alt=\"img\" /></p>\n<p>右下角 5 个功能，每个功能都可以独立开启或关闭，我们一个一个说。</p>\n<ol>\n<li>Playback</li>\n</ol>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image07.png\" alt=\"img\" /></p>\n<p>就是各种播放选项，中间按钮播放 / 暂停，可以在最后边控制播放速度，选择  <code>Unlimited FPS</code>  可以最高速度播放，实际速度取决于输出 clip 所用滤镜和最后渲染的速度。</p>\n<p>播放键左右依次，一个箭头的是以 1 帧为单位后退 / 前进，两个箭头的是以右边指定的帧数为单位后退 / 前进，三个箭头直接转到第一帧 / 最后一帧。</p>\n<ol>\n<li>Scening</li>\n</ol>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image08.png\" alt=\"img\" /></p>\n<p>在时间轴上做标记，在分段或者采样典型场景的时候会很有用。</p>\n<p><code>List</code>  表示一组标记，时间轴只能同时显示一组标记，但可以在多组之间切换。 <code>Add List</code>  创建一组标记，然后可以在下方一栏添加标记。<br />\n <code>AB</code>  直接标记当前帧，并添加到 List。 <code>A</code>  将当前帧标记为起点， <code>B</code>  将当前帧标记为终点，A、B 联合使用可以标记一段区间，然后点  <code>Add to List</code>  加入到 List 中。</p>\n<p>最右边的按钮可以导出当前 List 的所有标记，可以手动调整导出格式，导出后存放在剪切板里，找个地方粘贴即可。</p>\n<ol>\n<li>Pipette</li>\n</ol>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image09.png\" alt=\"img\" /></p>\n<p>这个功能相当于 vsedit 的取色器，鼠标移到画面上可以在左下角显示像素的 YUV 值以及渲染后的 RGB 值。</p>\n<p>从左到右依次为：坐标  <code>(x, y)</code> ，渲染后 RGB 值，输出 clip 原始像素值。<br />\n视频里的坐标轴以左上角为原点，横向向右为 x 轴正向，竖向向下为 y 轴正向。<br />\n原始和渲染后的像素都有 3 组表示，第一组是 16 进制的量化值，第二组是 10 进制的量化值，第三组是浮点值。</p>\n<p>vsp 采用 vs 滤镜来渲染输出 clip，不像 vse 那样有较大精度问题，因此一般可以直接 set_output 输出，不用转为 RGB。</p>\n<ol>\n<li>Benchmark</li>\n</ol>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image10.png\" alt=\"img\" /></p>\n<p>就是跑测试输出，与之前说的 Ctrl+F8 快捷键相比，可以更精确地指定输出的帧数范围。</p>\n<ol>\n<li>Misc</li>\n</ol>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image11.png\" alt=\"img\" /></p>\n<p><code>Reload Script</code>  如果你更改了脚本，可以按这个重新加载。<br />\n <code>Save</code>  导出 vsp 设置，比如前面提到的部分选项，它可以记忆下来，下次打开直接启用。当然一般不需要这个功能，因为 vsp 会自动保存到脚本所在目录的  <code>.vspreview</code>  目录下。<br />\n <code>Copy Frame</code>  /  <code>Save Frame as</code>  可以复制 / 保存当前帧截图，右边可以设置导出文件名。</p>\n<p>好了，经典版 vsp 的功能就讲这么多，其中一些功能有快捷键：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0VuZGlsbGwvdmFwb3Vyc3ludGgtcHJldmlldy93aWtpL0tleWJvYXJkLVNob3J0Y3V0cyVFMyU4MCU4Mg==\">https://github.com/Endilll/vapoursynth-preview/wiki/Keyboard-Shortcuts。</span></p>\n<p>另外，前面提到的一些改版，有兴趣的话可以自行研究它们的新功能。</p>\n<h3 id=\"3-对比脚本\"><a class=\"anchor\" href=\"#3-对比脚本\">#</a> (3). 对比脚本</h3>\n<p>对比脚本，顾名思义就是用来对比源和压制成品的脚本。</p>\n<p>下面是一个简单的对比脚本：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> vapoursynth <span class=\"token keyword\">as</span> vs</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> vapoursynth <span class=\"token keyword\">import</span> core</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> havsfunc <span class=\"token keyword\">as</span> haf</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> mvsfunc <span class=\"token keyword\">as</span> mvf</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>a <span class=\"token operator\">=</span> <span class=\"token string\">R\"D:\\VCB-Studio Entry Test 2023\\Q4 [E46686C4].m2ts\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>src8 <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>src8 <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Preview<span class=\"token punctuation\">(</span>src8<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>src8<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>b <span class=\"token operator\">=</span> <span class=\"token string\">R\"D:\\VCB-Studio Entry Test 2023\\Q4_AV1 [41A7EDDA].mkv\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>rip <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>rip <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Preview<span class=\"token punctuation\">(</span>rip<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>rip<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>现在用 vse 预览试试，在键盘上按数字 0、1 来切换两个输出。<br />\n如果你试图切换到不存在的节点就会。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image12.png\" alt=\"img\" /></p>\n<p>这里在 set_output 时使用了不同的输出节点。在以前，只有 0 节点（也是不指定输出节点时的默认值）能被预览输出，而 vspipe 始终只能输出 0 节点的 clip。预览器 vsp 首先支持了多节点预览输出，之后 vsedit 也添加了相应功能。</p>\n<p>vsedit 的输出节点与键盘数字是绑定的，也就是最多只能有 0-9 号共 10 个节点可以使用，并且 vsedit 要求必须至少有 0 节点。<br />\n当然，你可以输出到更高数字的节点，脚本仍然可以运行，但无法在 vsedit 中预览到。</p>\n<p>作为多节点输出的开创者，vsp 对这一功能的支持更加完善。<br />\nvsp 的输出节点不与键盘数字绑定，而是按照脚本中 set_output 出现的先后顺序，依次对应到键盘数字：1、2、3... 同时也不要求一定有 0 节点输出。</p>\n<p>不使用键盘数字 0 作为第一个快捷键可以优化没有小键盘时的体验，输出节点数字不绑定快捷键可以避免不停修改节点值。当然 vsp 也不支持过多的节点数，超过 10 个节点只能在左下角的下拉框中切换。不过你可以自行修改 vsp 的配置，因为它是一个 python  module，你可以自由修改其功能，比如绑定节点数字，比如扩展更多键位。</p>\n<p>之前略过的一个按钮， <code>sync outputs</code> ，可以选择让所有输出节点指向同一帧，或者各自维护一个当前帧号。</p>\n<p>在上古时期，没有多节点输出的时候，是用  <code>Interleave</code>  滤镜来进行对比预览的。试着在上述脚本最后加上下面两行，观察结果。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Interleave<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>src8<span class=\"token punctuation\">,</span> rip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>可以发现，视频总时长不变，输出帧数翻倍，帧率也翻倍，变成了 47.952 fps。<br />\n实际上滤镜是在一秒内把源和成品的帧都给塞进去了，偶数帧（0, 2, 4...）来自源，奇数帧（1, 3, 5...）来自成品。这样可以通过前后键，反复观察源和成品的画面区别。</p>\n<p>Interleave 支持输入一个 clip 列表，把里面的 clip 依次交错输出。自然你也可以将多个 clip  一起交错对比，但是多于两个的时候有诸多不便，首先你无法直观从帧号判断这帧来自哪个 clip，其次越过一些帧对比，比如将 1 和 3  进行对比时无法快速切换。<br />\n当然现在是好时代了，可以通过多节点输出自由地进行对比。</p>\n<h2 id=\"3-vs文档阅读和参数传递\"><a class=\"anchor\" href=\"#3-vs文档阅读和参数传递\">#</a> 3. VS 文档阅读和参数传递</h2>\n<h3 id=\"1-文档阅读\"><a class=\"anchor\" href=\"#1-文档阅读\">#</a> (1). 文档阅读</h3>\n<p>今后我们将遇到各种各样的滤镜，虽然代码补全可以帮助我们知道它的参数，但具体每个参数的含义和用法，还是需要查阅相关文档。</p>\n<p>VS-C 的文档链接如下：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvJUUzJTgwJTgy\">https://amusementclub.github.io/doc/。</span></p>\n<p>其中包括 VS 相关的 python 数据结构文档，内置滤镜的文档以及 VSPipe 的用法等。</p>\n<p>第三方滤镜，一般都有单独的 Github repo，你需要善于搜索。一般可以先去娱乐部看一下，大部分常用滤镜都有相应 fork。</p>\n<p>先来看前面提到的  <code>Interleave</code>  滤镜，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvZnVuY3Rpb25zL3ZpZGVvL2ludGVybGVhdmUuaHRtbCVFMyU4MCU4Mg==\">https://amusementclub.github.io/doc/functions/video/interleave.html。</span></p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image13.png\" alt=\"img\" /></p>\n<p>滤镜的包名  <code>std</code> ，说明是标准内置滤镜。 再看滤镜参数，第一个必选参数是  <code>vnode[]</code> ，即多个 clip 组成的列表。后半部分由 [] 扩起来的，是可选参数，包括  <code>extend, mismatch, modify_duration</code> ，都是 bint，也就是 0/1，或者 False/True。它们的功能 doc 里都有说明，不需要掌握，平时根本用不到。</p>\n<h3 id=\"2-参数传递\"><a class=\"anchor\" href=\"#2-参数传递\">#</a> (2). 参数传递</h3>\n<p>VS 中的参数传递有多种方式：关键字传参、位置传参、混合传参。</p>\n<ol>\n<li>关键字传参 keyword argument</li>\n</ol>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Interleave<span class=\"token punctuation\">(</span>clips<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">,</span> rip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> extend<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> modify_duration<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>哪个输入对应哪个参数，直接用参数名写出来。这样可读性很高，也不容易出错。另外，现在有代码补全，也不需要手打参数名。</p>\n<ol>\n<li>位置传参 positional argument</li>\n</ol>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Interleave<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">,</span> rip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>从左到右将输入依次赋给各个参数。写起来最简单，但可读性很差，要翻 doc 才知道各个参数都给的什么值。</p>\n<ol>\n<li>混合传参</li>\n</ol>\n<p>顾名思义就是混合前两种方式。python（和几乎所有编程语言）都规定，函数参数的必选项在前面，可选项在后面。因此习惯前面常用的参数用位置传参，后面不常用的参数使用关键字传参。注意位置传参只能放在前面，不能和关键字交替使用。</p>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Interleave<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">,</span> rip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> modify_duration<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这里需要注意的是，VS 滤镜和 python 函数（比如 mvf 提供的函数）的处理是不一样的。<br />\n对于 VS 滤镜，它会先将所有关键字参数赋值好，然后将位置参数从左到右依次赋给<strong>还未赋值</strong>的参数。</p>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>Interleave<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">,</span> rip<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> extend<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这个调用会先将 extend 赋为 0，然后 [src, rip] 赋给 clips，最后一个参数，按位置将赋给 extend，但发现以前已经赋值过了，因此会赋给第三个参数 mismatch。</p>\n<p>但是 python 函数并不会这么处理，如果关键字传参和位置传参对同一参数赋值，会报出语法错误。</p>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mvf<span class=\"token punctuation\">.</span>ToRGB<span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> matrix<span class=\"token operator\">=</span><span class=\"token string\">\"709\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这个调用会报出对同一位置赋值的错误。</p>\n<ol>\n<li>dict 传参</li>\n</ol>\n<p>这其实是关键字传参的一种变体，用一个 dict 描述关键字，然后用 dict 传入参数。</p>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kwargs <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"depth\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"matrix\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"709\"</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>ToRGB<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ol>\n<li>iterable 传参</li>\n</ol>\n<p>这其实是位置传参的一种变体，用一个 iterable 对象描述待传参数。<br />\n这种传参方式对位置要求严格，要传的参数必须按函数参数列表的位置依次给出。<br />\n实际上这在 VS 里极少出现，也不推荐使用这种方式，一般只会在阅读复杂代码时遇到。</p>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"709\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> vs<span class=\"token punctuation\">.</span>INTEGER<span class=\"token punctuation\">,</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>ToRGB<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ol>\n<li>滤镜串联</li>\n</ol>\n<p>VS 滤镜都是由 clip 作为第一个参数，在连续调用时可以串联，省去输入第一个参数。</p>\n<p>比如：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span><span class=\"token string\">\"00001.m2ts\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>RemoveGrain<span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这等价于：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>src <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span><span class=\"token string\">\"00001.m2ts\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>rgvs<span class=\"token punctuation\">.</span>RemoveGrain<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>串联滤镜可以连接任意多个，除了第一个要写 core，后面的滤镜都不用写，直接跟在前一个滤镜的后面写滤镜名就行。同时，后面串联的滤镜也不用写第一个 clip 参数。</p>\n<p>但是对于 python 函数，mvf 那种，就没有这样的写法，只能老老实实分为多行调用。</p>\n<p>或者像下面这样：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> mvf<span class=\"token punctuation\">.</span>Preview<span class=\"token punctuation\">(</span>core<span class=\"token punctuation\">.</span>lsmas<span class=\"token punctuation\">.</span>LWLibavSource<span class=\"token punctuation\">(</span><span class=\"token string\">\"00001.m2ts\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"4-视频属性和帧属性\"><a class=\"anchor\" href=\"#4-视频属性和帧属性\">#</a> 4. 视频属性和帧属性</h2>\n<h3 id=\"1-视频属性-clip-property\"><a class=\"anchor\" href=\"#1-视频属性-clip-property\">#</a> (1). 视频属性 clip property</h3>\n<p>clip 对象，在 VS 里是 VideoNode 类。 文档在：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvcHl0aG9ucmVmZXJlbmNlLmh0bWwjVmlkZW9Ob2RlJUUzJTgwJTgy\">https://amusementclub.github.io/doc/pythonreference.html#VideoNode。</span></p>\n<p>这里常用的就是前几个属性，包括：视频格式  <code>format</code> ，宽度  <code>width</code> ，高度  <code>height</code> ，总帧数  <code>num_frames</code> ，帧率  <code>fps</code>  或者用两个整数表示的  <code>fps_num</code>  和  <code>fps_den</code> 。</p>\n<p>可以使用</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>clip<span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>运行时在终端里打印这些信息。当然，vsedit 是看不到的。</p>\n<p>我们可以使用  <code>text.ClipInfo</code>  滤镜在画面上打印 clip 信息。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span>ClipInfo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image14.png\" alt=\"img\" /></p>\n<h3 id=\"2-帧属性-frame-property\"><a class=\"anchor\" href=\"#2-帧属性-frame-property\">#</a> (2). 帧属性 frame property</h3>\n<p>除了 clip 对象，还有一个需要关注的，帧对象，在 VS 叫做 VideoFrame 类。 文档在：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2MvcHl0aG9ucmVmZXJlbmNlLmh0bWwjVmlkZW9GcmFtZSVFMyU4MCU4Mg==\">https://amusementclub.github.io/doc/pythonreference.html#VideoFrame。</span></p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image15.png\" alt=\"img\" /></p>\n<p>这里我们主要关注的是  <code>props</code>  属性。<br />\n可以通过  <code>text.FrameProps</code>  滤镜在画面上打印每帧的 props 信息。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span>FrameProps<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res<span class=\"token punctuation\">.</span>set_output<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image16.png\" alt=\"img\" /></p>\n<p>其中重要的属性包括： <code>_PictType, _ChromaLocation, _ColorRange, _Matrix, _Primaries, _Transfer, _FieldBased</code> 。</p>\n<p>根据文档给的链接，我们看到它们的具体定义。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image17.png\" alt=\"img\" /></p>\n<p><code>_PictType</code> ，帧类型，包括  <code>I/B/P</code>  帧。</p>\n<p><code>_ChromaLocation</code> ，色度平面的对齐方式，最常见的，也即是 MPEG-2 标准的左中对齐为  <code>left=0</code> 。</p>\n<p><code>_ColorRange</code> ，数值范围，这里很反直觉的是， <code>full=0</code> ， <code>limited=1</code> 。事实上除了 frame props，其他地方都是  <code>full=1</code> ， <code>limited=0</code> 。另外文档也给出了具体的计算公式。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-05/image18.png\" alt=\"img\" /></p>\n<p><code>_Matrix, _Primaries, _Transfer</code> ，需要记住  <code>&quot;709&quot;=1</code> ， <code>&quot;601&quot;=6</code> ，其他的用到时查文档。</p>\n<p><code>_FieldBased</code> ，场类型，0 逐行，1 底场优先，2 顶场优先。这个属性会在之后的 30 fps 课程中用到。</p>\n<p>在实际操作中，我们可以手动更改这些 frame props。</p>\n<p>设置 / 删除 frame props 的用法如下：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>SetFrameProps<span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> _Matrix<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>res <span class=\"token operator\">=</span> core<span class=\"token punctuation\">.</span>std<span class=\"token punctuation\">.</span>RemoveFrameProps<span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token string\">\"_Matrix\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>实际上我们可以设置任意名字的 frame props，但它们大部分时候并没有用处。而这些由 VS 保留的 frame props 则有重要功能，一些滤镜比如  <code>resize</code>  会读取它们来决定进行何种计算，如果 frame props 指定的不正确就可能产生预料之外的错误结果。</p>\n<p>一般来说，对于 1080p 的视频不需要刻意关注  <code>_Matrix, _Primaries, _Transfer</code>  等等，它们在未指定或者不存在时，滤镜会自动 fallback 到 709 对应的值。但是在制作 DVD 或者 UHD 等特殊分辨率的视频时，就需要特别关注这些 frame props，确保它们符合相应规范。</p>\n<h2 id=\"5-vspipe的使用\"><a class=\"anchor\" href=\"#5-vspipe的使用\">#</a> 5. VSPipe 的使用</h2>\n<p><code>VSPipe</code>  是运行脚本，输出视频的核心工具。 文档在：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9hbXVzZW1lbnRjbHViLmdpdGh1Yi5pby9kb2Mvb3V0cHV0Lmh0bWwlRTMlODAlODI=\">https://amusementclub.github.io/doc/output.html。</span></p>\n<ol>\n<li>输出给 x265 进行压制</li>\n</ol>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vspipe.exe --y4m script.vpy - | x265.exe --y4m -D 10 --output \"output.hevc\" -</pre></td></tr></table></figure><p>注意必须在标准命令行  <code>cmd</code>  里使用上述 pipe 方式， <code>PowerShell</code>  容易出现一些奇怪问题。</p>\n<ol>\n<li>输出 y4m 文件</li>\n</ol>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vspipe.exe --y4m script.vpy output.y4m</pre></td></tr></table></figure><p>当然也可以输出 yuv 文件。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vspipe.exe script.vpy output.yuv</pre></td></tr></table></figure><p>yuv 和 y4m 都是无压缩的视频数据，区别在于后者自带了分辨率、帧率、像素格式等有效信息，而前者就是单纯的数据。<br />\n事实上我们可以计算 yuv 文件的大小。假设目前有一个 35000 帧，分辨率为 1920x1080，像素格式 YUV420P8 的 yuv 视频，那么它的视频体积为：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>35000 * (1920 * 1080 + 2 * (1920 / 2) * (1080 / 2)) * 8 bit = 108,864,000,000 B ~= 101.3875 GiB</pre></td></tr></table></figure><p>如果数据位深为 10-bit 或者 16-bit，那么每个像素分量占据 2 个字节，计算也是类似的。</p>\n<ol>\n<li>只计算各帧但不输出（用于测试脚本速度）</li>\n</ol>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vspipe.exe -p script.vpy .</pre></td></tr></table></figure><h2 id=\"6-练习\"><a class=\"anchor\" href=\"#6-练习\">#</a> 6. 练习</h2>\n<h3 id=\"1\"><a class=\"anchor\" href=\"#1\">#</a> (1)</h3>\n<p>熟悉  <code>vsedit</code> 、 <code>vspreview</code> 、 <code>vspipe</code>  的使用。</p>\n<h3 id=\"2\"><a class=\"anchor\" href=\"#2\">#</a> (2)</h3>\n<p>阅读文档并学习以下滤镜的用法： <code>BlankClip, StackVertical, StackHorizontal, AssumeFPS, Minimum, Maximum, Reverse, Transpose, Turn180</code> 。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AE%A4%E8%AF%86%E7%91%95%E7%96%B5/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AE%A4%E8%AF%86%E7%91%95%E7%96%B5/",
            "title": "第四章认识瑕疵",
            "date_published": "2024-03-16T15:06:52.000Z",
            "content_html": "<h1 id=\"第四章-认识瑕疵\"><a class=\"anchor\" href=\"#第四章-认识瑕疵\">#</a> 第四章 认识瑕疵</h1>\n<p>BDRip 制作的绝大部分时间，实际上是在与各种各样的画质瑕疵进行斗争。而对瑕疵处理的好坏，也决定着一个 Ripper 的水平。对于所有入门压制的新手来说，了解你的 “敌人”，是最重要的第一步。</p>\n<p>对于本章中的所有图片，强烈建议单独打开，以 100% 无缩放进行观察。</p>\n<h2 id=\"1-画面要素\"><a class=\"anchor\" href=\"#1-画面要素\">#</a> 1. 画面要素</h2>\n<p>在介绍画质瑕疵之前，我们首先来简单介绍基本的画面要素。这有助于我们把握画面的重点，有针对性地去寻找瑕疵。</p>\n<h3 id=\"1-空间上的频率划分平面纹理和线条\"><a class=\"anchor\" href=\"#1-空间上的频率划分平面纹理和线条\">#</a> (1). 空间上的频率划分：平面，纹理和线条</h3>\n<p>在视频处理中，空间 (spatial) 的概念指的是一帧图片以内的像素变化。从频率的角度看，任何画面区域都是多种复杂频率的混合体，但其不同区域的各种频率所占比重有明显区别。</p>\n<p>像素变化较快，变动幅度大的区域，高频分量占据主导地位。像素变化缓慢，变化幅度小的区域，低频分量占据主导地位。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDE=\">https://guides.vcb-s.com/media/basic-guide-04/image01</span> spatial.png)</p>\n<h4 id=\"平面\"><a class=\"anchor\" href=\"#平面\">#</a> 平面</h4>\n<p>平面 (flat areas) 是包含大量低频分量的区域，其特点是像素变化非常小。如上图左侧黄框区域。</p>\n<h4 id=\"线条\"><a class=\"anchor\" href=\"#线条\">#</a> 线条</h4>\n<p>线条 (lines) 是包含极端高频分量的区域，其像素有跳跃式的急剧变化。如上图中间红框区域。</p>\n<h4 id=\"纹理\"><a class=\"anchor\" href=\"#纹理\">#</a> 纹理</h4>\n<p>纹理 (texture) 区域较为复杂，其像素在小范围内频繁变化，高低起伏不断。纹理变化剧烈的，称之为强纹理，中高频成分占据主导，其性质接近于线条。如上图左侧蓝框区域。纹理变化平缓的，称之为弱纹理，中低频率成分占据主导，其性质接近于平面。如上图右侧绿框区域。</p>\n<h4 id=\"噪点\"><a class=\"anchor\" href=\"#噪点\">#</a> 噪点</h4>\n<p>噪点 (noise) 是一类特殊的画面要素，表现为随机的像素涨落，它可以叠加到以上任意要素中。噪点的频率构成取决于其种类，白噪声在各个频率的强度完全一致，而一般动画原盘所带的噪点则涵盖低频到中高频，随频率增高而略有下降，最高频部分则基本被砍掉。</p>\n<h3 id=\"2-时间上的频率划分静态和动态\"><a class=\"anchor\" href=\"#2-时间上的频率划分静态和动态\">#</a> (2). 时间上的频率划分：静态和动态</h3>\n<p>在视频处理中，时间 (temporal) 的概念指的是帧与帧之间的像素变化。</p>\n<p>一段视频如果变化剧烈，其时间复杂度较高，时域上的高频信息占比就较多。而如果视频本身变化缓慢，多为静态，其时间复杂度较低，时域上的低频信息占比就较多。</p>\n<p>一般来说，一段视频的时域高频信息多，动态的信息量就大，所需要记录的数据量就越多，编码所需要的运算量也越大。这就是为什么动态高的部分更容易发生欠码。但是另一方面，人眼对高速变化的场景，敏感度不如静态的图片来的高，因为没有时间去仔细观察细节。所以动态场景的优先度可以低于静态场景，高动态镜头的帧稍微烂一点是可以接受的。如何权衡以上两点去分配码率，是实际编码中需要考虑的重点。</p>\n<h2 id=\"2-画面瑕疵\"><a class=\"anchor\" href=\"#2-画面瑕疵\">#</a> 2. 画面瑕疵</h2>\n<h3 id=\"1-色带-banding-color-banding\"><a class=\"anchor\" href=\"#1-色带-banding-color-banding\">#</a> (1). 色带 (banding /color banding)</h3>\n<p>色带是最常见的瑕疵，没有之一。色带产生的本质原因是量化数据的精度不足。目前绝大部分的片源采用 YUV 8bit 编码，然而在 YUV 模型下 8bit  的数据精度范围，不足以达到人眼可分辨精度的极限，这就导致色彩出现可分辨的断层，即色带。另一方面，早期的大部分制作商并没有考虑如何在有限的精度范围内使用额外的手段避免色带，这就导致了色带泛滥成灾。如今这一现象有所改善，部分制作商已经意识到这一问题，并通过加入噪点和抖动的方式来避免色带。</p>\n<p>色带在暗场平面以及渐变颜色的场景最容易观测到。色带通常表现为一系列波浪状、同心环状的阶梯区域。</p>\n<p>色带的处理方式叫做去色带 (deband /de-banding)。</p>\n<p>注意下图中间的头发平面区域。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDI=\">https://guides.vcb-s.com/media/basic-guide-04/image02</span> banding.png)</p>\n<h3 id=\"2-锯齿-aliasing\"><a class=\"anchor\" href=\"#2-锯齿-aliasing\">#</a> (2). 锯齿 (aliasing)</h3>\n<p>锯齿是最典型、最常见的线条瑕疵。锯齿表现为原本应该连续的线条上，发生了线条与平面的交替、毛刺、或者断线。锯齿的类型很多，不同类型的锯齿有不同的产生原因。</p>\n<p>锯齿的处理方式叫做抗锯齿 (anti-aliasing /aa)。</p>\n<h4 id=\"二值化锯齿\"><a class=\"anchor\" href=\"#二值化锯齿\">#</a> 二值化锯齿</h4>\n<p>二值化锯齿是动画制作的二值化过程产生的。对于手绘作画的动画，原画首先被扫描得到二值化的数字图片，之后进行润线来平滑线条。如果扫描性能太差或者润线做得不到位，就会留下凹凸不平的线条。</p>\n<p>注意梗小姐右下角的头发。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDM=\">https://guides.vcb-s.com/media/basic-guide-04/image03</span> aliasing 01.png)</p>\n<h4 id=\"缩放锯齿\"><a class=\"anchor\" href=\"#缩放锯齿\">#</a> 缩放锯齿</h4>\n<p>缩放锯齿是图像在后期处理时被低级的算法拉伸或者缩小而产生的细碎锯齿、毛刺现象，是最常见的锯齿瑕疵。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDQ=\">https://guides.vcb-s.com/media/basic-guide-04/image04</span> aliasing 02.png)</p>\n<h4 id=\"3d-渲染锯齿\"><a class=\"anchor\" href=\"#3d-渲染锯齿\">#</a> 3D 渲染锯齿</h4>\n<p>3D 渲染锯齿一般出现在背景素材上，这些素材由 3D 建模绘制，在渲染时由于算法问题，产生大量锯齿或者断线现象。一般 3D 渲染锯齿的断线过于严重而无法修复。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDU=\">https://guides.vcb-s.com/media/basic-guide-04/image05</span> aliasing 03.png)![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDY=\">https://guides.vcb-s.com/media/basic-guide-04/image06</span> aliasing 04.png)</p>\n<h4 id=\"像素锯齿\"><a class=\"anchor\" href=\"#像素锯齿\">#</a> 像素锯齿</h4>\n<p>像素锯齿一般出现在纯数字作画的场景中，由于线条和平面的交界处过于锐利，没有中间过渡的部分，而形成类似锯齿的形状。一般来说，像素锯齿被认为是一种画风，而不是需要处理的瑕疵。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDc=\">https://guides.vcb-s.com/media/basic-guide-04/image07</span> aliasing 05.png)</p>\n<h4 id=\"画风型断线\"><a class=\"anchor\" href=\"#画风型断线\">#</a> 画风型断线</h4>\n<p>画风型断线表现为线条深浅交替，并且往往不太规则。画风型断线是动画制作中刻意处理的美术风格，一般不需要修复。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDg=\">https://guides.vcb-s.com/media/basic-guide-04/image08</span> aliasing 06.png)</p>\n<h3 id=\"3-振铃晕轮-ringing-haloing\"><a class=\"anchor\" href=\"#3-振铃晕轮-ringing-haloing\">#</a> (3). 振铃 / 晕轮 (ringing /haloing)</h3>\n<p>严格来说，振铃和晕轮是有区别的，振铃的成因是信号的高频成分被破坏（比如有损压缩中在变换域后的量化），而晕轮是来自锐化产生的极端值。但它们在目视结果上都表现为，在图像的主要线条附近，有一圈瑕疵像素的值与周围像素不同，且更接近值域两端的极值。两者可以用相近的手段进行处理，我们一般不刻意区分两者。</p>\n<p>振铃 / 晕轮的处理方式叫做去振铃 / 晕轮 (dering /de-ringing, dehalo /de-haloing)。</p>\n<p>振铃 / 晕轮通常和锯齿是伴生的，这在后期拉伸的片源中尤其常见。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMDk=\">https://guides.vcb-s.com/media/basic-guide-04/image09</span> ringing.png)</p>\n<h3 id=\"4-噪点-noise-grain\"><a class=\"anchor\" href=\"#4-噪点-noise-grain\">#</a> (4). 噪点 (noise /grain)</h3>\n<p>亮度平面的噪点表现为深浅不一的点状图样，而色度平面的噪点则表现为花花绿绿的斑点。</p>\n<p>噪点是否是一种瑕疵，这一话题的争吵多年来从未停止。除去特效噪点，就普通数字噪点而言，我们认为可以分为两部分，画风型噪点和保护型噪点。</p>\n<p>画风型噪点以静噪居多，往往与纹理细节紧密结合，是图像画风的一部分。</p>\n<p>保护型噪点在正常图像比例下几乎不可见，它们主要用于防止产生色带。</p>\n<p>在 10bit 压制下，对于保护型噪点的需求有所降低，可以削去一部分来降低码率。而画风型噪点是组成画面的重要部分，很大程度影响着最终的还原度，需要尽量保留。</p>\n<p>另外视觉心理学优化也应当纳入考量。对于人眼来说，亮场区域的噪点几乎不可见，可以尽量削去。色度噪点对画风的影响基本是恼人的，应该尽可能去掉。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTA=\">https://guides.vcb-s.com/media/basic-guide-04/image10</span> noise.png)</p>\n<h3 id=\"5-色块-blocking\"><a class=\"anchor\" href=\"#5-色块-blocking\">#</a> (5). 色块 (blocking)</h3>\n<p>色块一般是严重欠码或者视频损坏，而导致的一系列方形、网格形的图样。色块在三次元演唱会、各种 web 片源中极其常见。</p>\n<p>色块的处理方式叫做去色块 (deblock /de-blocking)。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTE=\">https://guides.vcb-s.com/media/basic-guide-04/image11</span> blocking.png)</p>\n<h3 id=\"6-烂边蚊噪-dct-ringing-dct-noise\"><a class=\"anchor\" href=\"#6-烂边蚊噪-dct-ringing-dct-noise\">#</a> (6). 烂边 / 蚊噪 (DCT ringing / DCT noise)</h3>\n<p>烂边 / 蚊噪是指画面欠码的时候，线条和平面都出现了很脏的观感。线条周围一圈出现振铃、锯齿、块状噪点等混合瑕疵，而平面有噪点的地方，部分噪点被去掉，部分噪点残留，形成难看的纹路，并通常伴有色块出现。</p>\n<p>这些瑕疵是由视频编码中的 DCT (Discrete Cosine Transform，离散余弦变换) 导致。在码率严重不足的时候，将一些频率一刀切，就会造成这样的后果。</p>\n<p>烂边 / 蚊噪的处理一般需要 deband /deblock/denoise 等多种手段的配合。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTI=\">https://guides.vcb-s.com/media/basic-guide-04/image12</span> DCT ringing.png)</p>\n<h3 id=\"7-亮度越界-luma-overflow-underflow\"><a class=\"anchor\" href=\"#7-亮度越界-luma-overflow-underflow\">#</a> (7). 亮度越界 (luma overflow /underflow)</h3>\n<p>数字图像中的数据在不同标准下有着不同的取值范围，如果把一个标准的范围用到另一个标准下，就可能会发生越界的问题。</p>\n<p>下图中亮度的上界发生了溢出，超过的部分被认为是全白而无法分辨细节。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTM=\">https://guides.vcb-s.com/media/basic-guide-04/image13</span> luma overflow.png)</p>\n<p>注意画面的左上角，修正亮度范围后，终于可以看清其中的纹理细节。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTQ=\">https://guides.vcb-s.com/media/basic-guide-04/image14</span> luma overflow fix.png)</p>\n<p>越界的调整需要对数字图像规范有着专业的了解，同时还得熟知中间的变换公式。</p>\n<p>除了亮度，色度同样可能发生越界，不过一般来讲色度越界的情况非常少见。</p>\n<p>下面部分介绍一些与交错 (interlace) 相关的瑕疵。</p>\n<h3 id=\"8-拉丝横纹-combing\"><a class=\"anchor\" href=\"#8-拉丝横纹-combing\">#</a> (8). 拉丝 / 横纹 (combing)</h3>\n<p>拉丝 / 横纹是指图像中相邻两行错位造成的视觉效果。当隔行扫描的交错（interlaced）片源，没有经过任何处理（或者部分片段漏了处理），然后按照逐行扫描（progressive）的方式进行播放，就会产生这样的现象。</p>\n<p>根据片源类型的不同，处理方式一般有以下几类：</p>\n<p>反交错（de-interlacing）/ 场匹配（field-matching）/ 反交卷过带（inverse telecine，IVTC）</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTU=\">https://guides.vcb-s.com/media/basic-guide-04/image15</span> interlacing.png)</p>\n<h3 id=\"9-缟缟\"><a class=\"anchor\" href=\"#9-缟缟\">#</a> (9). 缟缟</h3>\n<p>此名称有一定争议，不过在我们的教程中，该词指的就是如下的现象。</p>\n<p>缟缟的效果兼具拉丝和锯齿的效果，有非常特殊的线条特征。</p>\n<p>缟缟产生的原因是，隔行扫描的源，没有先转换为逐行扫描，而是在隔行状态下，用逐行扫描的算法放大。</p>\n<p>缟缟按照具体表现及程度有不同的处理方法，统称去缟缟。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTY=\">https://guides.vcb-s.com/media/basic-guide-04/image16</span> combing.png)</p>\n<h3 id=\"10-重复场-duplicate-field\"><a class=\"anchor\" href=\"#10-重复场-duplicate-field\">#</a> (10). 重复场 (duplicate field)</h3>\n<p>重复场表现为一帧里，奇数行和偶数行相同。视觉效果如下（轻音少女横滨演唱会；少数动画中也有，如 K 的剧场版）。</p>\n<p>重复场通常和锯齿难以区分，但是如果把奇数行和偶数行拆开各自组成一幅图，两份图是一样的。</p>\n<p>解决方法是丢掉奇数行或者偶数行，用剩下的缩放到原来高度。处理方式记为 fix duplicate field。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTc=\">https://guides.vcb-s.com/media/basic-guide-04/image17</span> duplicate field.png)</p>\n<h3 id=\"11-鬼影-blending-ghosting\"><a class=\"anchor\" href=\"#11-鬼影-blending-ghosting\">#</a> (11). 鬼影 (blending /ghosting)</h3>\n<p>除去视频本身采用的特效，这里鬼影指的是非正常的帧融合，造成的动态瑕疵，典型的比如孔明的部分镜头、寒蝉的 BD。</p>\n<p>blending 一般是不规范的反交错 / 交卷过带产生，且 / 或者是滥用不可靠的时域处理造成的。</p>\n<p>多数情况下无解，少数有规律可循的，一定手段可以还原。</p>\n<p>处理方式称为 de-blending /ghost-removal。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTg=\">https://guides.vcb-s.com/media/basic-guide-04/image18</span> blending.png)</p>\n<p>下面部分介绍一些与色度平面相关的瑕疵，其中绝大部分的问题是由万恶的色度下采样所致。 实际上它们与亮度平面的问题没有本质区别，但由于色度平面和亮度平面的性质差异，最终在图像中的表现形式有所区别，因此拿出来单独介绍。</p>\n<h3 id=\"12-色度色带-chroma-banding\"><a class=\"anchor\" href=\"#12-色度色带-chroma-banding\">#</a> (12). 色度色带 (chroma banding)</h3>\n<p>色度色带，就是色度平面精度不足而产生的色彩断层。通常在出现亮度平面色带的地方，或多或少也会出现色度色带的问题。</p>\n<p>色度色带在目视表现上，跟一般的色带略有区别，主要表现为本该是一种颜色的区域变为多种颜色区域的混合。</p>\n<p>色度色带一般随着正常色带一起处理，无非加重 UV 平面的处理力度。</p>\n<p>注意下图左侧墙壁平面，以及中间人物衣服的平面区域。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMTk=\">https://guides.vcb-s.com/media/basic-guide-04/image19</span> chroma banding.png)</p>\n<h3 id=\"13-色度锯齿-chroma-aliasing\"><a class=\"anchor\" href=\"#13-色度锯齿-chroma-aliasing\">#</a> (13). 色度锯齿 (chroma aliasing)</h3>\n<p>色度锯齿通常是由于色度平面在下采样时使用了劣质的算法，导致出现明显锯齿。</p>\n<p>色度锯齿在颜色极红或者极蓝处最为明显，表现为线条被平面的颜色入侵，产生不规则的断线状。</p>\n<p>色度锯齿的处理方式一般是拆分 UV 平面进行抗锯齿 (chroma aa)。</p>\n<p>注意图中红色区域的线条。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjA=\">https://guides.vcb-s.com/media/basic-guide-04/image20</span> chroma aliasing.png)</p>\n<h3 id=\"14-色度偏移-chroma-shift\"><a class=\"anchor\" href=\"#14-色度偏移-chroma-shift\">#</a> (14). 色度偏移 (chroma shift)</h3>\n<p>色度偏移，指的是色度平面相对亮度平面的错位。其目视效果通常是，在极红、极蓝等（UV 值极大或极小）平面与线条的交界处，多了一些重影。或者说线条一侧的颜色侵入到另一侧。</p>\n<p>色度偏移通常是由于不正确的 chroma placement (chroma 平面相对 luma 平面的偏移) 处理而导致的。实际中色度偏移通常只有 0.5 个像素，最多 1 个像素，效果非常不明显，一般人很难观察到。</p>\n<p>色度偏移的处理方式叫做 fix chroma shift。</p>\n<p>下图为手动制作的向左偏移 3 个像素的例子，注意图中头发线条部分，颜色发生了严重的错位。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjE=\">https://guides.vcb-s.com/media/basic-guide-04/image21</span> chroma shift 01.png)</p>\n<p>然而实际中一般只有 0.5 个像素左右的偏移，注意下图袖子左右的线条。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjI=\">https://guides.vcb-s.com/media/basic-guide-04/image22</span> chroma shift 02.png)</p>\n<h4 id=\"rgb-shift\"><a class=\"anchor\" href=\"#rgb-shift\">#</a> RGB shift</h4>\n<p>实践中常常有人将 RGB shift 错认为 chroma shift。RGB shift 是在 RGB 空间下，将 R 和 B 平面进行一定偏移处理，主要是为了模拟现实中光线散射的效果。</p>\n<p>由于 RGB 各平面间不存在类似 YUV 那样的偏移，因此 RGB shift 几乎一定是故意制作的特效，并不是一种瑕疵。</p>\n<p>区分 RGB shift 与 chroma shift 最好的方式，一是看是否是单侧偏移，chroma shift  只可能是单侧偏移；二是看白色平面上的黑色线条，由于白色和黑色在 YUV 下的 UV 相同，其分界面不可能产生 chroma  shift，只可能产生 RGB shift。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjM=\">https://guides.vcb-s.com/media/basic-guide-04/image23</span> RGB shift.png)</p>\n<h3 id=\"15-色度溢出-chroma-bleeding\"><a class=\"anchor\" href=\"#15-色度溢出-chroma-bleeding\">#</a> (15). 色度溢出 (chroma bleeding)</h3>\n<p>色度溢出跟色度偏移很像，区别在于色度偏移是有方向的偏移，色度溢出是无方向的扩张。</p>\n<p>色度溢出在颜色强烈的线条出容易观察到，特点是 chroma 平面的线条宽度远大于 luma 平面线条宽度，导致侵蚀了周围的颜色。</p>\n<p>色度溢出的处理方式一般是对 chroma 平面进行收线，将线条控制到与 luma 平面相同，记作 fix chroma bleeding。</p>\n<p>色度溢出的范围一般较小，不易观察，下图实际为特效。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjQ=\">https://guides.vcb-s.com/media/basic-guide-04/image24</span> chroma bleeding.png)</p>\n<p>最后介绍一些在上古动画中会出现，但如今基本见不到的瑕疵。</p>\n<h3 id=\"16-晃动-global-motion-pan\"><a class=\"anchor\" href=\"#16-晃动-global-motion-pan\">#</a> (16). 晃动 (global motion /pan)</h3>\n<p>通常是在老片翻新过程中，因为镜头 / 胶带位置不固定，导致录制的视频，似乎镜头在不断晃动一样。哪怕是应该静止的场景，都有不规律的、小幅晃动。</p>\n<p>修复手段一般称为 depan。</p>\n<h3 id=\"17-彩虹-rainbow\"><a class=\"anchor\" href=\"#17-彩虹-rainbow\">#</a> (17). 彩虹 (rainbow)</h3>\n<p>rainbow 多出现在早期真人视频中，表现为亮度快速变化的地方，UV 似乎像彩虹一般红蓝交织。</p>\n<p>rainbow 的产生是由于 YUV 数据在电磁信号传输过程中，高频的 Y 信号，因为传输介质不理想，影响到了 UV。如果这时候进行进一步转录，就会把这个问题保留。</p>\n<p>修复手段一般称为 de-rainbow。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjY=\">https://guides.vcb-s.com/media/basic-guide-04/image26</span> rainbow.png)</p>\n<h3 id=\"18-点状斑纹-dot-crawl\"><a class=\"anchor\" href=\"#18-点状斑纹-dot-crawl\">#</a> (18). 点状斑纹 (dot-crawl)</h3>\n<p>点状斑纹也是传输 YUV 中，不正确处理导致的问题。</p>\n<p>修复手段一般称为 dot-crawl removal。</p>\n<p>![img](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMudmNiLXMuY29tL21lZGlhL2Jhc2ljLWd1aWRlLTA0L2ltYWdlMjc=\">https://guides.vcb-s.com/media/basic-guide-04/image27</span> crawl.jpg)</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BB%AC/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BB%AC/",
            "title": "第三章神一样的工具们",
            "date_published": "2024-03-16T15:05:44.000Z",
            "content_html": "<h1 id=\"第三章-神一样的工具们\"><a class=\"anchor\" href=\"#第三章-神一样的工具们\">#</a> 第三章 神一样的工具们</h1>\n<p>BDRip 的制作流程，大致上可以概括为：抽流 - 压制 -  封装。在本章节，我们便循着这一流程，展示各个环节所需要的工具，并详细介绍它们的用法。希望通过这一章节的内容，让大家在宏观上理解一个蓝光原盘从着手制作到封装为成品的全部过程，对 BDRip 的制作能有一个全面整体的认识。</p>\n<h2 id=\"0-前期准备\"><a class=\"anchor\" href=\"#0-前期准备\">#</a> 0. 前期准备</h2>\n<p>本章节用到的工具众多，就不在这里一一展示，放到具体小节再详细介绍。你可以先通篇浏览，将需要用到的工具提前下载安装好。</p>\n<p>目前绝大部分的工具都有带图形界面的 Gui 版本，使用上基本不存在障碍。不过我们仍然会介绍其命令行程序的使用方法，因为有时命令行程序更加方便，可以满足一些特殊的需求，并且对于批量处理更加简单高效。如果你还不熟悉命令行的打开方式，赶紧上网百度一下吧。</p>\n<p>我们推荐下载 VCB-Studio 的压制生产力工具 OKEGui，你可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIvdG9vbHMvcmVsZWFzZXM=\">这里</span>下载到已经打包好的版本，解压即用。我们暂时不会介绍 OKEGui 的使用方法，因为它比较复杂，只有熟练掌握压制流程之后才能更好地理解其用法。在 OKEGui\\tools 中集成了许多实用的命令行工具，基本能够满足本章教程的大部分需求。</p>\n<p>我们推荐将所有工具放到一个文件夹下，然后将该文件夹加入到环境变量中，这样可以在命令行中快速调用。你可以在附录中查看设置环境变量的方法。</p>\n<h2 id=\"1-抽流\"><a class=\"anchor\" href=\"#1-抽流\">#</a> 1. 抽流</h2>\n<p>抽流，就是把媒体文件中的视频、音频、字幕、章节等分别提取出来，成为单独的文件，便于之后进行压制等处理。</p>\n<h3 id=\"1-bd的抽流\"><a class=\"anchor\" href=\"#1-bd的抽流\">#</a> (1). BD 的抽流</h3>\n<p>上一章我们讲了 BD 的结构，视频、音频、字幕位于 m2ts 文件中，而章节单独存放在 mpls 文件中。m2ts 的抽流通常使用 eac3to，这是一个由 madshi 编写的命令行小工具，没错就是那个 madVR 的开发者 madshi。</p>\n<p>eac3to 有一个方便的 GUI，叫做 HD DVD/Blu-Ray Stream Extractor，它作为一个工具集成在 MeGUI 中。你可以在这里下载 MeGUI：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvbWVndWkvJUUzJTgwJTgy\">https://sourceforge.net/projects/megui/。</span></p>\n<p>打开 MeGUI，上方菜单选择 【Tools】-【HD Stream Extractor】。</p>\n<p>注意这个 Settings，其实是个按钮，需要勾选上 show encoding option (s)。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image06.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image07.png\" alt=\"img\" /></p>\n<p>在输入部分选择 m2ts，就可以看到能够抽取的轨道。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image08.png\" alt=\"img\" /></p>\n<h4 id=\"视频轨的抽取\"><a class=\"anchor\" href=\"#视频轨的抽取\">#</a> 视频轨的抽取</h4>\n<p>在 Extract As 处可以选择输出格式，视频轨可以抽取为 mkv 或者裸视频流 h264，一般抽取为 h264 即可。实际上，一般我们不需要提取视频轨，因为大多数工具可以直接从 m2ts 文件中获取视频。</p>\n<h4 id=\"音轨的抽取\"><a class=\"anchor\" href=\"#音轨的抽取\">#</a> 音轨的抽取</h4>\n<p>原盘的音轨有 PCM / TrueHD / DTS-HD MA 等无损格式，也有 AC3 / DTS 等有损格式。按照 VCB-Studio 规范，对于无损音轨，提取为 flac 格式；对于有损音轨，提取为原本格式。</p>\n<p>需要注意一点，TrueHD / DTS-HD MA 音轨往往存在一个内嵌的 AC3 / DTS core 有损音轨，这是为了给不兼容 TrueHD / DTS-HD MA 的设备提供向下兼容。这导致很多时候 MediaInfo 只认出一条音轨，而播放器会认出两条。对于这种情况，直接丢弃有损部分即可。</p>\n<h4 id=\"字幕的抽取\"><a class=\"anchor\" href=\"#字幕的抽取\">#</a> 字幕的抽取</h4>\n<p>原盘有时会有 PGS 图形字幕，抽取为 sup 即可。</p>\n<p>需要注意的是，不能使用 ffmpeg 进行抽流。因为 eac3to 会做一些额外的，但是非常有用的检查。</p>\n<p>比如它会检查音轨的真正 bitdepth。有些原盘标注的是 24bit PCM，但是实际的有效精度只有 16bit。这时 eac3to 会抽取为 16bit。</p>\n<p>还比如有些原盘的音轨有延迟（delay），但是部分播放器对 delay 的支持不是很好，为了避免播放出现问题，VCB-Studio 规范要求消去 delay。eac3to 会自动检查 delay，并重新调整为无 delay。</p>\n<h4 id=\"eac3to的命令行操作\"><a class=\"anchor\" href=\"#eac3to的命令行操作\">#</a> eac3to 的命令行操作</h4>\n<p>最后补充一下 eac3to 的命令行用法，命令行会有一些更灵活的用法。</p>\n<p>可以使用这个命令查看 m2ts 的各轨道信息。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to \"path\\\\to\\\\m2ts\" -progressnumbers</pre></td></tr></table></figure><p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image09.png\" alt=\"img\" /></p>\n<p>如果你的 m2ts 保持了原盘目录结构，eac3to 还可以检测到其章节，不过有时即使保持原盘目录也会检测失败。</p>\n<p>当我们确定好需要抽取的轨道后，就可以使用以下命令抽取相应轨道。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to \"path\\\\to\\\\m2ts\" id: \"path\\\\to\\\\outputfile.format\"</pre></td></tr></table></figure><p>其中 id 是要抽取的轨道的编号，后面指定输出文件路径和名称，文件后缀名非常重要，它指定输出格式，不过 eac3to 只支持某些后缀，写错会显示 not supported。</p>\n<p>以上面图片中的 m2ts 为例，抽取视频轨。注意不能写 .avc，会报错。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00000.m2ts 1: 00000.h264</pre></td></tr></table></figure><p>抽取音轨，可以直接抽取为 flac，也可以抽取为 wav。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00000.m2ts 2: 00000.flac</pre></td></tr></table></figure><p>对于 TrueHD / DTS-HD MA 音轨且带有有损 core 时，可以通过如下命令抽取无损部分。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00000.m2ts 2: 00000.thd</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>eac3to 00000.m2ts 2: 00000.dtsma</pre></td></tr></table></figure><p>而有损部分可以通过  <code>-core</code>  参数抽取。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00000.m2ts 2: 00000.ac3 -core</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>eac3to 00000.m2ts 2: 00000.dts -core</pre></td></tr></table></figure><p>抽取字幕，注意 PGS 字幕的后缀为 sup。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00000.m2ts 3: 00000.sup</pre></td></tr></table></figure><p>除了抽取单个 m2ts 的简单用法，eac3to 命令行还有一些高级用法，在后面的小节会进一步介绍。</p>\n<h3 id=\"2-章节的提取\"><a class=\"anchor\" href=\"#2-章节的提取\">#</a> (2). 章节的提取</h3>\n<p>eac3to 虽然可以从 m2ts 检测并抽取章节，但是存在一些问题。我们更推荐使用 ChapterTool 来从 mpls 提取章节。ChapterTool 是 TautCony（本组第二代队长，人称 TC）写的一个小工具。 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RhdXRjb255L0NoYXB0ZXJUb29s\">https://github.com/tautcony/ChapterTool</span></p>\n<p>打开 ChapterTool，把 mpls 拖进去可以看到。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image10.png\" alt=\"img\" /></p>\n<p>注意右上角红框中的信息，它告诉了这个章节对应的 m2ts 编号和章节数量。看到这里你应该明白，m2ts 的编号和 mpls 的编号并没有任何联系。对于含有多个 m2ts 的 mpls，每个 m2ts 都有独立的章节，可以在这里的下拉框进行切换。</p>\n<p>ChapterTool 提供了很多信息，比如说章节的数量、各个章节的时间戳、章节名、帧号。可以看出，这里的帧号是 0-indexed。帧号的计算方法，需要大家掌握。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>对于恒定帧率的视频，帧号 = round(帧率 * 时间戳)</pre></td></tr></table></figure><p>比如这里的 chapter 03，时间戳是 02:31.026，帧率在右上角可以看到，为 24000/1001，那么帧号 = round ((24000 / 1001)  <em>(2</em>  60 + 31.026) ) = round(3621.002997) = 3621</p>\n<p>由于时间戳精度的问题，一般计算出来是个小数，但是会非常接近某个整数。如果你计算出比如在 x.5 附近，那你就要思考一下是不是算错了。</p>\n<p>ChapterTool 给我们的其实是取整后的结果，不勾选右上角的帧数取整就可以看到计算的原始结果。</p>\n<p>ChapterTool 也提供了章节的编辑功能，章节名、时间戳、帧号都是可以直接编辑的，另外也有删除增加章节的功能。偷偷提示，在按钮上右键可以看到一些隐藏功能。</p>\n<p>按照 VCB-Studio 规范，</p>\n<ul>\n<li>如果最后一个章节的时间戳是视频结束，或者离视频结束差一两秒的黑屏，需要删除该章节</li>\n<li>第一个章节的时间戳必须是 00:00:00.000</li>\n<li>如果只有开头的章节，那么该视频不需要附带章节</li>\n<li>章节名可以是从 01 开始按顺序排列的 Chapter xx，也可以填写原盘中的章节名。</li>\n</ul>\n<p>确认章节没有问题后，点击保存，生成用于封装的 txt 格式章节。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image11.png\" alt=\"img\" /></p>\n<p>在保存之前可以通过右上角的 P 按钮，预览将要生成的章节。</p>\n<p>ChapterTool 的功能远不止以上这些，大家可以阅读 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RhdXRjb255L0NoYXB0ZXJUb29sL3dpa2k=\">Wiki</span> 了解更多，后面的教程还会多次提到 ChapterTool。</p>\n<h3 id=\"3-菜单按钮的提取\"><a class=\"anchor\" href=\"#3-菜单按钮的提取\">#</a> (3). 菜单按钮的提取</h3>\n<p>还记得之前那些无法播放的 m2ts 吗，我们当时说它们是菜单的按钮或者动画，这里就来教大家如何提取这些内容。</p>\n<p>我们使用的是这个工具：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1NBUGlrYWNodS9pZ3N0b29scyVFMyU4MCU4Mg==\">https://github.com/SAPikachu/igstools。</span></p>\n<p>这个工具依赖于 python，安装稍微有点麻烦。需要注意的是，它的 readme 很久没更新了，落后于实际功能。</p>\n<p>这里以 portable 版 python 为例，介绍如何安装并使用 igstools，对于安装版的 python  也是类似的。如果你已经下载了本章开头提到的工具包，请找到 OKEGui\\tools\\vapoursynth\\python.exe  的路径；如果你还没有下载工具包，还等什么，赶紧回到本章开头去下载吧。</p>\n<p>通过以下命令安装 igstools：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>\"path\\\\to\\\\python.exe\" -m pip install pypng</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\"path\\\\to\\\\python.exe\" -m pip install https://github.com/SAPikachu/igstools/archive/master.zip</pre></td></tr></table></figure><p>安装好以后，通过以下命令拆包 m2ts：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>\"path\\\\to\\\\python.exe\" -m igstools \"path\\\\to\\\\xxxxx.m2ts\"</pre></td></tr></table></figure><p>拆包成功的话，会在 m2ts 目录下看到一堆 png 图片。通过这些图片可以获取到原盘菜单播放时的一些信息，比如有哪些特典、正片的章节名等等。这样你可以了解原盘的内容，不至于遗漏一些特典，以及可以根据章节名补充完整章节信息。</p>\n<p>一些压制组比如 ANK-Raws 会选择将拆包出的图片打包作为特典附带。而按照 VCB-Studio 规范，菜单按钮的处理完全属于可选内容，直接忽略不管也没有问题。</p>\n<p>原盘中的 Menu 以及其按钮一般有两种情况，Menu 中有文字，按钮提供文字特效、动画效果、以及额外的弹出文字窗口；Menu 中只有背景，其他内容全在按钮中。对于第一种情况，我们建议直接忽略按钮；对于第二种情况，可以选择性地处理。</p>\n<p>如果是一图式的 Menu，可以打开 PS，将按钮直接覆盖到 Menu 上。这个处理不算复杂，提取出的按钮都是与 Menu 分辨率相同的带透明度的图片，PS 里直接覆盖即可。少女歌剧小动画的 Menu 就采用了这种处理。</p>\n<p>如果是动态 Menu，将按钮制作为 PGS 字幕，在播放时切换字幕轨道来展示动画效果。超炮 S3 的 Menu 就采用了这种处理。总监 Akarin 制作了一个方便的工具来制作 PGS 字幕，用法会在后续教程中介绍。</p>\n<p>最后再次强调一遍，菜单按钮完全是可选内容，实际上非常不推荐在这上面花费时间，本节教程的目的是教会大家提取按钮，方便了解原盘视频内容。</p>\n<h3 id=\"4-mkv的抽流\"><a class=\"anchor\" href=\"#4-mkv的抽流\">#</a> (4). mkv 的抽流</h3>\n<p>首先下载安装唯一指定 mkv 处理工具，MKVToolNix。你可以在这里下载最新版：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ta3Z0b29sbml4LmRvd25sb2FkL2Rvd25sb2Fkcy5odG1sI3dpbmRvd3MlRTMlODAlODIlRTUlQTYlODIlRTYlOUUlOUMlRTQlQkQlQTAlRTUlQjclQjIlRTclQkIlOEYlRTglQTMlODUlRTUlQTUlQkQ=\">https://mkvtoolnix.download/downloads.html#windows。如果你已经装好</span> OKEGui，也可以直接使用 tools 中的稳定版 MKVToolNix。</p>\n<p>mkvtoolnix-gui.exe 提供了图形界面的 mkv 处理程序，但是没有包含抽流工具 mkvextract.exe 的功能。因此这里推荐使用第三方的辅助 gui 程序，你可以在这里下载：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvZ21rdmV4dHJhY3RndWkvJUUzJTgwJTgy\">https://sourceforge.net/projects/gmkvextractgui/。</span></p>\n<p>如果你使用的是安装版 MKVToolNix，你可以把 gMKVExtractGUI 解压到任何地方，它会根据注册表找到 MKVToolNix 的位置。如果你使用的是 portable 版 MKVToolNix，那么需要解压到 MKVToolNix 根目录下。</p>\n<p>打开 gMKVExtractGUI，把 mkv 拖进去。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image12.png\" alt=\"img\" /></p>\n<p>gMKVExtractGUI 也支持批量拖入 mkv，拖入之后依次选择要抽取的轨道即可。</p>\n<p>另外，mkv 的视频和音轨也可以用 eac3to 抽取，但是 PGS 字幕不要用 eac3to 抽。</p>\n<p>一般 mkv 中的 PGS 字幕是经过 zlib 压缩过的，而 eac3to 并不会解压，而是直接提取出来塞到 sup 文件里，这样提取出的 sup 文件无法正常播放。</p>\n<p>处理方法有很多，手动解压再封装，或者封装时指定不做压缩。但是最好的方法还是，mkv 里的 PGS 字幕就老老实实用 mkvextract 抽。</p>\n<h3 id=\"5-mp4的抽流\"><a class=\"anchor\" href=\"#5-mp4的抽流\">#</a> (5). mp4 的抽流</h3>\n<ul>\n<li>把 mp4 丢到 MKVToolNix 里</li>\n<li>转成 mkv</li>\n<li>抽 mkv</li>\n</ul>\n<p>不开玩笑，mp4 的抽流没有什么特别好的办法。</p>\n<h2 id=\"2-压制\"><a class=\"anchor\" href=\"#2-压制\">#</a> 2. 压制</h2>\n<p>在抽取完需要的各轨道之后，就需要对视频和音频进行压制，或者更准确一点，编码（encode）。</p>\n<h3 id=\"1-视频的压制\"><a class=\"anchor\" href=\"#1-视频的压制\">#</a> (1). 视频的压制</h3>\n<p>视频，一般都是要经过有损压制。压制过程可以分为预处理（pre-process）和重编码（encode）。</p>\n<p>预处理就是通过 VapourSynth 或者 AviSynth 读取视频，对画面进行各种处理；重编码则是将处理过后的视频画面进行编码、压缩，以将视频体积减小到合适范围。</p>\n<p>以 VapourSynth 为例，整个压制过程靠 VapourSynth 的 vspipe，结合 x265 或者 x264 编码器，通过管道（pipe）连接来完成。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vspipe.exe --y4m \"xxx.vpy\" - | x265.exe --y4m -D 10 --output \"xxx.hevc\" -</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vspipe.exe --y4m \"xxx.vpy\" - | x264.exe --demuxer y4m --output-depth 10 --output \"xxx.h264\" -</pre></td></tr></table></figure><p>y4m 是 YUV4MPEG2 的简称，是一种无压缩的视频格式，它自带了分辨率、帧率、像素格式等有效信息。</p>\n<p>x265 编码器，用  <code>--y4m</code>  表示接收格式为 y4m，-D 10 开启 10bit 压制， <code>--output</code>  指定输出文件名。</p>\n<p>x264 编码器，用  <code>--demuxer y4m</code>  表示接收格式为 y4m， <code>--output-depth 10</code>  表示输出 10bit， <code>--output</code>  指定输出文件名。</p>\n<p>x265 编码器可以从这里获取编译好的：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FtdXNlbWVudENsdWIveDI2NS9yZWxlYXNlcyVFMyU4MCU4Mg==\">https://github.com/AmusementClub/x265/releases。</span></p>\n<p>这个是基于 Yuuki 版，再经过娱乐部优化的版本。</p>\n<p>x264 基本上没得选，基本只能 tmod：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2pwc2RyL3gyNjQvcmVsZWFzZXMlRTMlODAlODI=\">https://github.com/jpsdr/x264/releases。</span></p>\n<p>当然如果你装了 OKEGui，也可以直接使用里面的 x265 和 x264。</p>\n<p>你可能会比较困惑，vpy 脚本以及编码器参数该如何编写，不用着急，后续教程的绝大部分章节都将详细讲述这两方面内容。现在你只需要对这个流程有一个大致了解即可。</p>\n<h3 id=\"2-音频的压制\"><a class=\"anchor\" href=\"#2-音频的压制\">#</a> (2). 音频的压制</h3>\n<p>在压制音频之前，我们需要先做另一件事，音轨检查。</p>\n<p>音轨检查需要检查：1. 是否为空音轨，2. 是否为重复音轨。</p>\n<p>蓝光原盘里有空音轨或者重复音轨这种事情极其常见，并且即使是空音轨，它的码率也和普通音轨完全一样，仅凭外表无法分辨。</p>\n<p>最常见的情况是，部分集数有评论音轨，部分集数没有。早期原盘为了统一格式，所有集都是双音轨，那么没有评论音轨的集数怎么办，要么填一条空音轨，要么重复主音轨。这俩在原盘里码率都是一样，空或者重复对制作商来说没有区别，哪种情况都有可能。</p>\n<p>判断空音轨很容易，在播放器里前后拉一遍，完全没有声音的就是空音轨，当然确保你此时打开了系统声音。</p>\n<p>重复音轨的判断就比较麻烦，因为你不知道是否只有某些地方做了改变，而其他地方完全相同。比较典型的是《魔法少女小圆 叛逆的物语》，晓美焰黑化的那段配音，有正常版，还有个音轨专门换成了病娇版，其他的部分完全一样，你不看介绍都不知道就那么一分钟的配音不同。</p>\n<p>判断两条好像一样的音轨是不是真的重复，以前靠肉眼看频谱，现在已经有自动化工具了，会在后续教程中介绍给大家。</p>\n<p>之后就是对音轨进行编码。</p>\n<p>按照 VCB-Studio 规范，对于不同内容的音轨，有不同的编码要求。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image13.png\" alt=\"img\" /></p>\n<p>更详细的说明可以参考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZjYi1zL1ZDQi1TX0NvbGxhdGlvbi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLm1k\">整理规范</span>。</p>\n<p>简单来说，如果原盘中为无损音轨，正片和特典的主音轨需要 flac 编码，而评论轨和真人特典的音轨需要 aac 编码；如果原盘中为有损音轨，在码率不太高时保留原样，码率较高时转为 aac 编码。</p>\n<p>flac 编码，实际在我们使用 eac3to 抽取时就可以直接抽取并转码为 flac（使用的是最高压缩等级）。如果你抽取为 wav，也可以手动转为 flac。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>flac --compression-level-8 -o output.flac input.wav</pre></td></tr></table></figure><p><code>--compression-level-8</code>  指定压缩等级为最高（8）， <code>-o</code>  指定输出文件名。更详细的命令行参数可以查阅文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly94aXBoLm9yZy9mbGFjL2RvY3VtZW50YXRpb25fdG9vbHNfZmxhYy5odG1sJUUzJTgwJTgy\">https://xiph.org/flac/documentation_tools_flac.html。</span></p>\n<p>aac 的编码，我们选择 qaac 编码器，模式选择 cvbr，码率根据情况选择 192kbps 或者 320kbps。</p>\n<p>为什么选择 cvbr 以及码率为什么选这两个值，并没有什么特别的考虑，只是选择了约定俗成、大家都没有太大异议的一套规范。当然你也可以选用 tvbr。</p>\n<p>qaac 的命令行参数</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>qaac -i -v 192 -q 2 --no-delay -o output.aac input.flac</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>qaac -i -V 127 -q 2 --no-delay --ignorelength -o output.m4a input.wav</pre></td></tr></table></figure><p><code>-v</code>  参数指定 cvbr 模式的目标码率， <code>-V</code>  参数指定 tvbr 模式的目标质量。使用 wav 输入的时候推荐打开   <code>--ignorelength</code> 。</p>\n<p>你可以在这里下载 qaac：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL251Nzc0L3FhYWMvcmVsZWFzZXMlRTMlODAlODI=\">https://github.com/nu774/qaac/releases。</span></p>\n<p>qaac 依赖于 Apple 的 CoreAudioToolbox 组件，所以你需要安装 iTunes，如果你不想安装 iTunes 的话，可以在  qaac.exe/qaac64.exe 的同目录下建立一个 QTfiles / QTfiles64 文件夹，并在其中放置与之匹配的 32 位 / 64 位依赖。QTFiles 的获取可以使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL251Nzc0L21ha2Vwb3J0YWJsZQ==\">makeportable</span>，也可以直接下载别人导出完的：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FuaW1Nb3VzZS9RVEZpbGVzJUUzJTgwJTgy\">https://github.com/AnimMouse/QTFiles。</span></p>\n<p>如果你想让 qaac 支持 flac、WavPack（.wv） 等格式的输入，则需要在根目录放置与 qaac 位数相匹配的依赖，可以参照 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL251Nzc0L3FhYWMvd2lraS9JbnN0YWxsYXRpb24=\">https://github.com/nu774/qaac/wiki/Installation</span> 进行配置。以 flac 为例，你可以去 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmFyZXdhcmVzLm9yZy9sb3NzbGVzcy5waHA=\">https://www.rarewares.org/lossless.php</span> 下载一个 libFLAC 的 dll 文件，以 libFLAC_dynamic.dll 或 libFLAC.dll 命名放置在 qaac 的根目录下。</p>\n<p>最后额外介绍一点 32bit 音轨无损编码内容。</p>\n<p>普通无损音轨位深为 16bit，Hi-Res 常见为 24bit，而一些最新的 Hi-Res 则有 32bit。32bit 又分为 32 位整数和 32 位浮点。幸运的是，目前蓝光原盘里我们还看不到这些烦人的 32bit 音轨。</p>\n<p>flac 虽然有对 32 位整数格式的规范，<sub>但并没有编码器实现</sub> 在 1.4.0 版本之后增加了对 32 位整数的编解码支持，至于 32 位浮点则完全不支持。</p>\n<p>qaac 支持 alac 无损编码，能够支持 32 位整数格式的编解码，编码命令请自行查阅 qaac 文档。</p>\n<p>一个对 32bit 音轨支持较好的格式 / 编码器为 WavPack，同时支持 32 位整数和 32 位浮点。你可以在这里下载并查阅其用法：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2F2cGFjay5jb20vZG93bmxvYWRzLmh0bWwlRTMlODAlODI=\">https://www.wavpack.com/downloads.html。</span></p>\n<h2 id=\"3-封装\"><a class=\"anchor\" href=\"#3-封装\">#</a> 3. 封装</h2>\n<p>压制完了视频，按规范转完了音频，准备好章节和字幕，就可以开始封装（混流）了。</p>\n<h3 id=\"1-mkv的封装\"><a class=\"anchor\" href=\"#1-mkv的封装\">#</a> (1). mkv 的封装</h3>\n<p>封装 mkv 使用的是之前提到过的唯一指定 mkv 处理工具 MKVToolNix。打开 mkvtoolnix-gui.exe，将需要封装的轨道依次拖入，按图中所示操作。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image14.png\" alt=\"img\" /></p>\n<p>拖入第二个输入文件时，会出现以下弹窗，选择【作为输入文件添加到当前混流设置】。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image15.png\" alt=\"img\" /></p>\n<p>有时章节不能直接拖入，可以按以下方法添加章节。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image16.png\" alt=\"img\" /></p>\n<p>按照 VCB-Studio 规范，封装的轨道顺序为：视频轨、主音轨、评论音轨、字幕、章节。其中视频轨无需设置语言，保持为  und（Undetermined）即可。音轨和字幕都需要设置语言，一般为 ja（Japanese）。章节也需要设置语言，如果采用 Chapter xx 形式，设为 eng（English），如果填写了原盘日文章节名，设为 ja（Japanese）。</p>\n<p>视频轨和主音轨的 “默认轨道” 标识设置为 “是”，其他音轨以及字幕设为 “否”。</p>\n<p>外挂音轨的情况也按类似方式封装，输出时后缀名指定为 mka。</p>\n<p>另外需要注意一点，保证各轨道没有延迟（delay）。</p>\n<h4 id=\"mkvmerge的命令行操作\"><a class=\"anchor\" href=\"#mkvmerge的命令行操作\">#</a> mkvmerge 的命令行操作</h4>\n<p>最后补充一下 mkvmerge 的命令行用法，可以更灵活地进行批量封装。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mkvmerge --output &#123;output_file&#125; \\</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>         --language 0:und --default-track 0:yes &#123;hevc_file&#125; \\</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>         --language 0:jpn --default-track 0:yes --track-name \"0:Main Track\" &#123;audio1_file&#125; \\</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>         --language 0:jpn --default-track 0:no --track-name \"0:Audio Commentary\" &#123;audio2_file&#125; \\</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>         --chapters &#123;chapter_file&#125;</pre></td></tr></table></figure><p>其中  <code>--language</code>  设置轨道语言，前面的 0 指定输入文件的轨道 id，这里每个输入文件都是只含有一个轨道，因此只有 0。如果输入文件是 mkv 这样有多条轨道的文件，通过 id 选择需要处理的轨道。 <code>--default-track</code>  设置默认轨道，需要注意的是，新版本的 mkvmerge 默认所有轨道都是默认轨道（旧版本是默认否），因此对于需要设置为否的轨道，也要显式指定为否。 <code>--track-name</code>  设置轨道名称，对于多音轨情况可以选择性地命名来进行区分。</p>\n<p>更多的设置和详细参数请查阅 mkvmerge 文档。</p>\n<h3 id=\"2-mp4的封装\"><a class=\"anchor\" href=\"#2-mp4的封装\">#</a> (2). mp4 的封装</h3>\n<p>mp4 推荐使用 L-SMASH 进行封装，总监 EFS 给它写了一个方便的 GUI，可以在这里下载：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FtZWZzL2xzbWFzaC1tdXhlci1ndWklRTMlODAlODI=\">https://github.com/amefs/lsmash-muxer-gui。</span></p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image17.png\" alt=\"img\" /></p>\n<p>由于 VCB-Studio 制作流程中对于 mp4 的制作规格较低，因此只支持有限的封装方式。</p>\n<p>另外 ffmpeg 或者 MeGUI 的 mp4 封装工具也可以用来封 mp4，不过可靠性较差，一般不建议使用。</p>\n<p>虽然 L-SMASH 比较可靠，但是其对于源的要求也较高，如果源是由 BD 压制出来的，那么 L-SMASH 是一个最好的选择；如果源是 web  或者录播等，那么使用 L-SMASH 反而可能出错。而且 L-SMASH 只支持封装 AVC、HEVC、VC1 的视频编码格式以及  AAC、DTS、E-AC-3、AC-3、MP3 等常规音频编码格式，如果你需要封装 VVC、AV1 等新生编码视频格式或者 OPUS  等音频格式就需要使用其他的 mp4 封装工具了，比如 gpac 的 mp4box，你可以从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmlkZW9oZWxwLmNvbS9zb2Z0d2FyZS9NUDRCb3g=\">https://www.videohelp.com/software/MP4Box</span> 获取。</p>\n<h2 id=\"4-检查\"><a class=\"anchor\" href=\"#4-检查\">#</a> 4. 检查</h2>\n<p>完成封装后，压制工作就完成了大半，不过先别急着上传，还需要做一些最后的检查。</p>\n<h3 id=\"1-花屏检查\"><a class=\"anchor\" href=\"#1-花屏检查\">#</a> (1). 花屏检查</h3>\n<p>压片过程中，由于机器频率过高，或者脚本出现问题，或者遭到来自宇宙的高能粒子打击，成品可能损坏花屏，因此需要对比检查成品画面。</p>\n<p>我们使用的工具是 RPChecker，可以在这里下载：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3ZjYi1zL3JwLWNoZWNrZXIlRTMlODAlODI=\">https://github.com/vcb-s/rp-checker。</span></p>\n<p>首先在上方右键选择【使用 PSNR (VS)】模式，请不要使用默认的 ffmpeg 模式，其结果相当不可靠。VS 模式需要把 vapoursynth  加入环境变量，vapoursynth 已经集成在 OKEGui\\tools 中，加入环境变量的方法可以参考附录。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image18.png\" alt=\"img\" /></p>\n<p>点击【载入】进入载入界面，左边放入对照组（原盘），右边放入压制成品，开始对比。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image19.png\" alt=\"img\" /></p>\n<p>对比完成后，如果全为绿色，则检测通过；如果有红色的帧，则可能存在问题，需要定位到相应位置实际播放检查。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image20.png\" alt=\"img\" /></p>\n<h3 id=\"2-crc32\"><a class=\"anchor\" href=\"#2-crc32\">#</a> (2). CRC32</h3>\n<p>确认视频没有花屏，音频没有错漏，字幕和章节都带上了之后，就可以着手上传，将压制成品递交给整理组。</p>\n<p>我们需要用到 RapidCRC 这个工具，打上 CRC32。</p>\n<p>使用方法比较简单，所有文件拖进去，点击【CRC into Filename】。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image21.png\" alt=\"img\" /></p>\n<p>当你收到一堆打了 CRC 的文件时，也可以把它们拖进来，工具会告诉你是否正确。</p>\n<h2 id=\"5-合并与切割\"><a class=\"anchor\" href=\"#5-合并与切割\">#</a> 5. 合并与切割</h2>\n<p>上面提到的制作流程都是基于原盘里是一个视频对应一个 m2ts 的情况，实际还会遇到两种特殊情况：一个 m2ts 里含有多个视频，称为连体盘；多个 m2ts 组成一个视频，称为肉酱盘。</p>\n<p>连体盘常见于早期蓝光原盘，经常是一卷里的 2 或 3 集正片连体位于同一个 m2ts 中，现在可能会在泡面番的正片或者普通番的 PV 集 CM 集之类的特典中遇到。对于连体盘我们需要进行切割，拆分为每集一个 mkv 文件，然后再按上面的制作流程进行压制。</p>\n<p>肉酱盘也常见于早期蓝光原盘，现在基本上只会在原盘提供有字 / 无字双版本正片时，以及极少数特典中遇到。对于肉酱盘我们需要进行合并，把分散在多个 m2ts 中的内容合为一个 mkv 文件，然后再按上面的制作流程进行压制。</p>\n<h3 id=\"1-肉酱盘的合并\"><a class=\"anchor\" href=\"#1-肉酱盘的合并\">#</a> (1). 肉酱盘的合并</h3>\n<h4 id=\"使用eac3to合并\"><a class=\"anchor\" href=\"#使用eac3to合并\">#</a> 使用 eac3to 合并</h4>\n<p>肉酱盘中一个视频分散在多个 m2ts 里，由 mpls 将他们连接起来。我们可以通过 eac3to 来查看视频都由哪些 m2ts 组成。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to \"path\\\\to\\\\mpls\" -progressnumbers</pre></td></tr></table></figure><p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image22.png\" alt=\"img\" /></p>\n<p>这个 mpls 就是由 00002、00003、00007 这三个 m2ts 依次连接而成。接下来可以按照与抽取单个 m2ts 类似的方式，指定轨道 id 来抽取合并之后的轨道。以抽取音轨为例，使用以下命令：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00001.mpls 3: 00001.flac</pre></td></tr></table></figure><p>eac3to 也支持直接拼接 m2ts，对于上面的情况，如果我们只需要保留 00002 和 00003，而将 00007 丢弃掉，那么可以通过以下命令实现。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eac3to 00002.m2ts+00003.m2ts 3: 00001.flac</pre></td></tr></table></figure><h4 id=\"章节的合并\"><a class=\"anchor\" href=\"#章节的合并\">#</a> 章节的合并</h4>\n<p>eac3to 可以从 mpls 中抽取合并后的章节，不过抽取出的章节的章节名为空，需要手动填写，比较麻烦。因此更推荐使用 ChapterTool 来进行章节和合并。</p>\n<p>打开 ChapterTool，把 mpls 拖进去。对于具有多个 m2ts 的 mpls，可以在右上角下拉框选择各个 m2ts 的章节。右键下拉框，可以看到【合并章节】的选项，点击就可以将各个 m2ts 的章节合并起来，之后保存为 txt 即可。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image23.png\" alt=\"img\" /></p>\n<h4 id=\"使用mkvtoolnix合并\"><a class=\"anchor\" href=\"#使用mkvtoolnix合并\">#</a> 使用 MKVToolNix 合并</h4>\n<p>一些新的研究发现，对于少数情况（比如视频开头有 1s 黑帧并且第一个章节点指示为 1s 时间戳），MKVToolNix 的合并结果更为准确。MKVToolNix  会分析视频位流，并对一些不规范的位流做出修复，因此现在我们更推荐使用 MKVToolNix 进行合并。</p>\n<p>MKVToolNix 合并方法非常简单，将 mpls 直接拖入 MKVToolNix，然后混流为 mkv 即可。</p>\n<p>第一次拖入 mpls 时可能会询问是否扫描其他播放列表，将其设为默认从不扫描即可。</p>\n<p>MKVToolNix 也可以合并章节，不过需要注意，确保这里的章节命名模板设为【Chapter &lt;NUM:2&gt;】，而不是【第 &lt;NUM:2&gt; 章】。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image24.png\" alt=\"img\" /></p>\n<h3 id=\"2-一般的物理合并\"><a class=\"anchor\" href=\"#2-一般的物理合并\">#</a> (2). 一般的物理合并</h3>\n<p>MKVToolNix 也支持一般的物理合并，通过追加合并（append）功能实现。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image25.png\" alt=\"img\" /></p>\n<p>MKVToolNix 添加文件，有三种方法：</p>\n<ul>\n<li>添加文件，指作为独立轨道加入，一般在混流多个轨道时使用。</li>\n<li>追加合并，指把添加的各个文件解封装，合并位流，再重新封装。合并多个 hevc 或者 avc 的 raw 文件，或者合并多个 mkv，都是使用这个功能。</li>\n<li>添加为其余部分，指把添加的各文件的比特流直接前后拼接在一起，只有像 DVD 那样，将视频按固定大小直接切分，每个部分无法独立构成完整视频的情况才会用到。一般不会使用这个功能。</li>\n</ul>\n<p>追加合并这个功能，可以把多个视频和音频连在一起。章节没办法追加，因为章节无法确定总长度。所以一般不勾选章节，或者需要自己提前准备。</p>\n<p>追加合并成功的条件比较苛刻，只能多个 mkv 一起合并，或者多个 raw 文件一起合并，而不能 mkv 和 raw 文件交替合并。另外对于视频和音频的格式，甚至一些编码参数都有要求。</p>\n<p>特别需要注意的是，不要合并 flac，MKVToolNix 无法处理 flac 的文件头，合并出来的音轨会非常奇怪。新版甚至就直接不支持合并 flac 了，会报错。因此对于需要合并 flac 的情况，先抽取出来转为 wav，合并之后再转为 flac。</p>\n<p>当格式不匹配，混流会报错，注意检查。哪怕没有出现报错，也需要手动播放再确认一遍合并的效果。来回拖动进度条，仔细观察连接部分是否有花屏等。</p>\n<h3 id=\"3-连体盘的切割\"><a class=\"anchor\" href=\"#3-连体盘的切割\">#</a> (3). 连体盘的切割</h3>\n<p>连体盘一般使用 MKVToolNix 按章节切割。将连体盘的 mpls 拖入，切换到输出页面，选择切割模式【在章节之前】，将鼠标移到章节编号栏上可以看到说明。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image26.png\" alt=\"img\" /></p>\n<p>这里需要填写作为切点的章节序号，各个切点用逗号分开，章节从 1 开始编号，如果给出 n 个切点，那么会得到 n+1 个输出。</p>\n<p>在切割之前，我们需要播放连体的视频文件，确定每个部分开头的章节序号，早期原盘常见为两集或者三集正片连体，我们需要找到第二集和第三集起始的章节。</p>\n<p>以偶像大师的原盘为例，正片三集连体，这是它的章节。我们播放后发现，第二集开始于章节 07，第三集开始于章节 13。我们在切割的章节编号栏填入：07,13（注意不要有空格）。这样就把 01-06 切分为第一集，07-12  切分为第二集，13 - 最后切分为第三集。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image27.png\" alt=\"img\" /></p>\n<p>这样切出来的第二集和第三集的章节会存在一些问题，需要我们手动修正章节名称。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image28.png\" alt=\"img\" /></p>\n<p>另外需要特别注意的是，如果切割章节点的帧不是关键帧，那么会选择章节点之后最近一个关键帧作为实际切割点，这样切出来的结果和我们预想的就会存在偏差。不过按照蓝光规范，章节点保证为关键帧；同时 VCB-Studio 的成品，也保证章节点为关键帧，可以放心大胆地切。</p>\n<h3 id=\"4-一般的物理切割\"><a class=\"anchor\" href=\"#4-一般的物理切割\">#</a> (4). 一般的物理切割</h3>\n<p>MKVToolNix 除了支持按章节切割，也支持按帧切割。切割模式选择【按帧 / 场编号分段】，分段栏需要输入形如 start-end 的帧号范围。这里的帧号从 1  开始计数，需要在我们通常使用的 0-indexed 帧号上加 1。首尾切点的帧都将包含到输出中。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image27.png\" alt=\"img\" /></p>\n<p>以这个章节为例，如果我们想切出 Chapter 02 到 Chapter 03，那么实际需要的帧为 2638-4794，最后别忘了整体加 1，应该填写 2639-4795。</p>\n<p>与按章节切割类似，如果你指定的首尾帧号不是关键帧，那么会自动移动到最近的关键帧作为实际切点。</p>\n<p>由此我们也可以知道，视频的物理切割，只能精确到关键帧。非关键帧的切割，必须依靠重编码来完成。</p>\n<p>识别关键帧的方法，除了前面提到的按章节点以外，还可以通过 VapourSynth 直接观察每个帧的类型，具体方法等到 VapourSynth 章节再讲述。</p>\n<p>另外需要注意的是，MKVToolNix 不支持对 flac 的切割。遇到音轨是 flac 的情况，先将 flac 抽取出来，转为 wav，再封装成新的 mkv 进行切割。flac 转 wav 可以使用 flac 命令行工具。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>flac -d -o output.wav input.flac</pre></td></tr></table></figure><p>音频的切割并不依赖于关键帧，我们可以使用 ffmpeg 对其进行精准到毫秒（实际是精确到 sample 量级）的切割。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ffmpeg -y -i &#123;input_audio&#125; -map a:0 -ss &#123;trim_begin&#125; -to &#123;trim_end&#125; -acodec copy -y &#123;output_audio&#125;</pre></td></tr></table></figure><p>{trim_begin} 和 {trim_end} 填入起始和结束的时间戳，格式为 hh:mm:ss.mss 或者 ss.mss。</p>\n<p>一些音频编码器，比如 flac、qaac 也支持对输入音频的一部分进行编码而不用提前切割，具体参数设置可以自行查阅文档。</p>\n<p>如果切割 aac 音轨，其最小独立单元不是 1 个 sample 而是 1024 个 sample，因此输出最好选用 mka，以避免切割产生的 delay 造成影响。</p>\n<h2 id=\"6-练习\"><a class=\"anchor\" href=\"#6-练习\">#</a> 6. 练习</h2>\n<p>本章涉及的工具众多，操作复杂，这里提供一些简单的练习，希望大家能熟悉工具的使用。</p>\n<h3 id=\"1\"><a class=\"anchor\" href=\"#1\">#</a> (1)</h3>\n<p>在你手上的原盘中任选一集正片，按照本章流程，抽取视频、音频、章节、字幕（如有），视频不做处理，音频和章节按照规范进行处理，最后封装成 mkv。</p>\n<p>做完这一步，恭喜你，你已经掌握了一种最简单的 BDRip 制作方法，仅仅将原盘的有用信息提取出来而不做其他处理，一般地我们将其称为 BDRemux。</p>\n<h3 id=\"2\"><a class=\"anchor\" href=\"#2\">#</a> (2)</h3>\n<p>一般一集 TV 动画可以分为：OP、A Part、B Part、ED、Preview 等部分。任选一集 VCB-Studio 的成品正片，从 A、B Part 之间切分为两个 mkv。</p>\n<h3 id=\"3\"><a class=\"anchor\" href=\"#3\">#</a> (3)</h3>\n<p>将 (2) 中得到两个 mkv 合并为一个，然后与原始的视频进行 rpc 检查。</p>\n<h2 id=\"附录-设置环境变量\"><a class=\"anchor\" href=\"#附录-设置环境变量\">#</a> 附录 设置环境变量</h2>\n<p>首先，假设我们将工具放在 C 盘下名为 mypath 的文件夹中。当然你也可以将其放在其他盘符其他位置。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image01.png\" alt=\"img\" /></p>\n<p>右键我的电脑，选择【属性】。在打开的设置页面最右侧（某些版本中是最左侧）中选择【高级系统设置】。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image02.png\" alt=\"img\" /></p>\n<p>在弹出的窗口中选择【环境变量】。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image03.png\" alt=\"img\" /></p>\n<p>然后在上方的用户变量中选择【Path】一栏进行编辑，新建一个 C:\\mypath 条目。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image04.png\" alt=\"img\" /><img data-src=\"https://guides.vcb-s.com/media/basic-guide-03/image05.png\" alt=\"img\" /></p>\n<p>最后重新打开命令行，输入 flac 或者 ffmpeg 之类的命令来检测是否生效。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%80%E5%88%87%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86BD/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%80%E5%88%87%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86BD/",
            "title": "第二章一切的起点——认识BD",
            "date_published": "2024-03-16T15:04:09.000Z",
            "content_html": "<h1 id=\"第二章-一切的起点认识bd\"><a class=\"anchor\" href=\"#第二章-一切的起点认识bd\">#</a> 第二章 一切的起点 —— 认识 BD</h1>\n<h2 id=\"0-前期准备\"><a class=\"anchor\" href=\"#0-前期准备\">#</a> 0. 前期准备</h2>\n<p>在学习如何制作 BDRip 之前，我们首先来认识一下 BD 结构。这里我们以 Love Live! Superstar!! 第一季的第二卷原盘作为例子，你可以在这里下载 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ueWFhLnNpL3ZpZXcvMTUwMjgzNyVFMyU4MCU4MiVFNSVCRCU5MyVFNyU4NCVCNiVFNCVCRCVBMCVFNCVCOSU5RiVFNSU4RiVBRiVFNCVCQiVBNSVFNCVCRCVCRiVFNyU5NCVBOCVFNiU4OSU4QiVFOSU4NyU4QyVFNSU4NSVCNiVFNCVCQiU5Ng==\">https://nyaa.si/view/1502837。当然你也可以使用手里其他</span> BD 原盘，他们大同小异，没有本质区别。</p>\n<p>确保你已经安装好 MediaInfo，你可以在这里下载 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpYWFyZWEubmV0L3poLUNOL01lZGlhSW5mby9Eb3dubG9hZC9XaW5kb3dzJUUzJTgwJTgyJUU2JTg4JTkxJUU0JUJCJUFDJUU2JThFJUE4JUU4JThEJTkwJUU0JUJEJUJGJUU3JTk0JUE4JUU1JUFFJTg5JUU4JUEzJTg1JUU3JTg5JTg4JUVGJUJDJThDJUU1JUI5JUI2JUU1JUJDJTgwJUU1JTkwJUFGJUU0JUJCJUE1JUU0JUI4JThCJUU1JThBJTlGJUU4JTgzJUJEJUUzJTgwJTgy\">https://mediaarea.net/zh-CN/MediaInfo/Download/Windows。我们推荐使用安装版，并开启以下功能。</span></p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-02/image01.png\" alt=\"img\" /></p>\n<p>这样把鼠标移动到媒体文件上就可以快速显示其简要信息，帮助我们判断内容。</p>\n<h2 id=\"1-bdmv结构\"><a class=\"anchor\" href=\"#1-bdmv结构\">#</a> 1. BDMV 结构</h2>\n<p>BD 全称 Blu-ray Disc，不法分子通过 MakeMKV 之类的软件将其破解，并抓取成 PC 可以直接读取的形式 ——BDMV。</p>\n<p>通常遇到的原盘，其根目录结构应该如下，包括：BD 根目录 (BDROM)、特典 CD (BONUS CD)、扫图 (SCANS)。其中特典 CD 和扫图可能不存在，也可能合并进 BDROM 目录。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-02/image02.png\" alt=\"img\" /></p>\n<p>BDROM 目录应当包括两个子目录：BDMV、CERTIFICATE。CERTIFICATE 与数字版权以及制作商有关，我们可以直接忽略它。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-02/image03.png\" alt=\"img\" /></p>\n<p>BDMV 则是原盘的主体部分：CLIPINF 以及 bdmv 文件规定了原盘如何播放，BACKUP 是其备份；META 中包括描述原盘信息的 xml  文件以及 logo 图片，由于图片分辨率不高，我们一般弃之不用；PLAYLIST 主要存储章节文件；STREAM 则是蓝光视频所在的地方。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-02/image04.png\" alt=\"img\" /></p>\n<p>另外，有些时候也会见到 AUXDATA、BDJO、JAR 等目录，对蓝光结构感兴趣的同学可以自行进一步研究蓝光规范和工作原理。对我们来说关注的只有两个，一个是 PLAYLIST，还有一个是 STREAM。</p>\n<h2 id=\"2-stream文件夹\"><a class=\"anchor\" href=\"#2-stream文件夹\">#</a> 2. STREAM 文件夹</h2>\n<p>STREAM 文件夹里有各种 m2ts 文件，有可以播放的视频文件，也有无法生成缩略图的文件。这些文件从 00000 开始编号，以不一定连续的数字依次排列。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-02/image05.png\" alt=\"img\" /></p>\n<p>以星团这张原盘为例，这些文件分别是：</p>\n<ul>\n<li>00 Menu（菜单），这是一个比较特殊的特典，每张原盘都有，是原盘播放时的菜单页面。</li>\n<li>05、06 正片，通常一集 24 分钟的正片大小为 7GiB 左右，可以通过体积快速找出正片。</li>\n<li>08 真人特典，这类内容往往体积较大。</li>\n<li>09、10 该系列特殊的 ED 特典。</li>\n<li>07、11、12 版权警告、温馨提示、制作商 logo。</li>\n<li>01、02、03、04 无法播放，利用 mediainfo 快速查看，发现显示为 PGS 字幕。实际上它们并不是 PGS 字幕，而是 IGS，一种比 PGS 更加复杂的东西，用于存储 Menu 的文字画面或者动态效果。</li>\n</ul>\n<h2 id=\"3-有效内容\"><a class=\"anchor\" href=\"#3-有效内容\">#</a> 3. 有效内容</h2>\n<p>并不是 STREAM 文件夹内所有内容都需要制作，只需要制作其中的有效内容。我们这样定义有效内容：跟当前番剧有关联的所有内容。</p>\n<p>按照这个定义，没有出现番剧相关信息的制作商 logo、版权警告（如 07、12）就不属于有效内容，制作时候不用带上。01、02、03、04  没有视频或者音频，无法制作，可以直接舍弃。当然严格意义上它们属于有效内容，丢弃有些可惜。在后续课程中我们将介绍提取并利用这部分内容的方法，在有爱的情况下可以选择性地使用。在通常情况下，直接丢弃也没有问题。剩下的 00、05、06、08、09、10，毫无疑问都属于有效内容范畴，这个比较容易判断。</p>\n<p>现在问题来了，大家判断下，11 这个温馨提示是否属于有效内容？</p>\n<p>我们判断它属于有效内容，原因是：它的背景画面是番剧中的场景。</p>\n<p>所以判定其实很松，只要有一点相符，那就带上。被扔掉的，一般就是，换个其他番剧（哪怕是同一家制作商）带上，也毫无违和感的。</p>\n<p>另外有时也会遇到，一个番剧的原盘里带有另一个番剧的广告之类的特典，这在早期的原盘和非日版的原盘中比较常见。这种情况，我们可以直接丢弃。</p>\n<h2 id=\"4-文件格式\"><a class=\"anchor\" href=\"#4-文件格式\">#</a> 4. 文件格式</h2>\n<p>我们现在把 05 正片拖进 mediainfo 里，选择 视图 - 文本 查看详细信息。</p>\n<p>可以发现视频是 AVC (H.264) YUV420P8 编码，这是最常见的 BD 视频格式。一些上古原盘可能有 MPEG2 格式，最新的 UHD 原盘可能会有 HEVC (H.265) YUV420P10 格式，而杜比视界（Dobly Vision）原盘则可能有双视频轨道。</p>\n<p>再来看音轨，这里是 PCM 格式，常见的还有 DTS-HD MA、TrueHD、DTS、AC3 等。</p>\n<p>另外这个正片还有 PGS 字幕轨，比较少见，如果有字幕轨我们都会带着。</p>\n<h2 id=\"5-playlist文件夹\"><a class=\"anchor\" href=\"#5-playlist文件夹\">#</a> 5. PLAYLIST 文件夹</h2>\n<p>现在我们回到 PLAYLIST 文件夹，会看到一堆 mpls 文件。每个 mpls 文件指明了一个播放单元，每个播放单元可以由 1 或多个 m2ts 文件组合而成。</p>\n<p>用播放器直接打开 mpls 文件，看看会发生什么？potplayer、mpc-be 可以直接播放整个播放单元的内容，mpv 表示无法播放。</p>\n<p>其实 mpv 也是可以播放 mpls 的，不过需要使用命令行操作。</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mpv bd://mpls/&#123;mpls number&#125; --bluray-device=&#123;path to bdrom&#125;</pre></td></tr></table></figure><p>mpls number 指定要播放的 mpls 编号，蓝光原盘的路径指定到 BDROM，即 BDMV 的上一级目录。</p>\n<p>当然，嫌麻烦的同学也可以再装个 mpc 或者 pot 来看 mpls。</p>\n<p>将 mpls 拖到 mediainfo 里可以查看这个播放单元含有的所有 m2ts 的信息。常见的情况是，一张原盘里的两集正片在 mpls 里会连在一起。同时我们也可以看到章节信息，但是这里可能只显示第一个 m2ts 的章节信息。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-02/image06.png\" alt=\"img\" /></p>\n<p>那么如何完整获取章节信息呢，需要用到唯一指定章节处理工具 ——ChapterTool，这将在下一节教程中详细介绍。</p>\n<h2 id=\"6-特殊内容\"><a class=\"anchor\" href=\"#6-特殊内容\">#</a> 6. 特殊内容</h2>\n<p>最后讲一下原盘里比较特殊的内容。首先是 Menu，除了上面例子里这种和一般视频没什么区别的 Menu 之外，还有一帧式的 Menu。</p>\n<p>这种 Menu 只有一张图，播放时一闪而过，容易被当成无效内容而忽视。当存在这种 Menu 时，有可能存在独立的只有音轨的 m2ts，要注意检查。</p>\n<p>这里也提醒大家，一定要用 mediainfo 检查所有 m2ts，确保没有遗漏有效内容。</p>\n<p>总结下，Menu 大概分为这几类：</p>\n<ul>\n<li>(动态画面 + BGM).m2ts</li>\n<li>(静态画面 + BGM).m2ts</li>\n<li>裸图.m2ts</li>\n<li>裸图.m2ts + BGM.m2ts</li>\n</ul>\n<p>这几种我们会有不同的处理方式，将在后续教程中详细介绍。</p>\n<p>还有一个比较特殊的内容是画册，你会看到几十甚至上百个只有一帧的 m2ts，它们是官方提供的一堆色或者不色的图片。Sonny Boy  原盘就是一个典型，里面有数百张图片，当时我们大受震撼。对于这些图片，截取为无损 png，作为特典带着就行，后续教程会给出批量处理的方法。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86%E8%A7%86%E9%A2%91/",
            "url": "https://sakurame.eu.org/2024/03/16/vcbstudio/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86%E8%A7%86%E9%A2%91/",
            "title": "第一章从零开始认识视频",
            "date_published": "2024-03-16T15:01:00.000Z",
            "content_html": "<h1 id=\"第一章-从零开始认识视频\"><a class=\"anchor\" href=\"#第一章-从零开始认识视频\">#</a> 第一章 从零开始认识视频</h1>\n<p>视频已经与我们的日常生活息息相关，无论是在电视、电影院、电脑还是手机上，视频都随处可见。视频文件一般至少由视频轨以及音轨构成。本章将介绍视频轨的基本构成，包括色彩，采样，帧率，扫描方式，编码等方面。这些都是影响最终视频画面的关键因素。同时，本章还将涉及到视频文件的结构，即如何将以上元素整合在一起构建一个完整的视频文件。通过深入了解这些内容，读者将能够更好地理解视频制作和编辑的基本原理，为后续的视频处理工作奠定坚实的基础。</p>\n<h2 id=\"1-颜色\"><a class=\"anchor\" href=\"#1-颜色\">#</a> 1. 颜色</h2>\n<p>视频文件中，颜色主要由色彩空间（color space）、色彩原色（color primaries）、传输特性（transfer characteristics）、矩阵系数（matrix coefficients）以及色彩范围（color range）定义。</p>\n<h3 id=\"1-色彩空间-color-space\"><a class=\"anchor\" href=\"#1-色彩空间-color-space\">#</a> (1). 色彩空间 color space</h3>\n<p>视频的色彩空间是指用来描述视频颜色的一套规则，也可以说是定义视频中颜色的系统。常见的视频色彩空间有 RGB、YUV 和 YCbCr 等。RGB 是指红绿蓝三原色，也就是我们常说的光源的色彩系统；而 YUV 和 YCbCr  是指亮度（Y）和色度（U、V 或者 Cb、Cr）三个分量组成的颜色系统，一般用于描述传输视频信号。在 YUV 和 YCbCr  中，亮度是视频图像中最重要的成分，因为它直接决定了视频画面的明暗度，而色度则描述颜色中的色调和饱和度。</p>\n<h3 id=\"2-色彩原色-color-primaries\"><a class=\"anchor\" href=\"#2-色彩原色-color-primaries\">#</a> (2). 色彩原色 color primaries</h3>\n<h4 id=\"色彩原色的概念\"><a class=\"anchor\" href=\"#色彩原色的概念\">#</a> 色彩原色的概念</h4>\n<p>在色彩学中，色彩原色指的是无法通过任何其他颜色混合而得到的颜色。在不同的色彩空间系统中，有不同的原色组合。可以分为 “叠加型” 和 “消减型” 两种系统。“叠加型” 的颜色系统通过不同颜色的光（原色），在黑暗的背景上产生颜色，一般是以光源投射的形式出现，例如 CRT。这套原色系统常被称为 “RGB 色彩空间”，亦即由红（R）绿（G）蓝（B）所组合出的色彩系统。相对的，“消减型” 的色彩系统是通过从 “白” 光中消去不需要的光谱（原色）。一般来说这种系统在透明或者反射介质上产生颜色，例如印刷品使用的 CMY 或者 CMYK  色彩系统。由于视频是以发光的显示屏作为载体显示的，因此在这里只讨论 RGB 颜色系统。</p>\n<h4 id=\"lms-与-xyz-色彩空间\"><a class=\"anchor\" href=\"#lms-与-xyz-色彩空间\">#</a> LMS 与 XYZ 色彩空间</h4>\n<p>“原色” 并不是物理学中的一个概念，而是一个由人类视觉系统决定的生物学概念。人眼视网膜上有两种对光敏感的细胞：视杆细胞和视锥细胞。其中前者虽然数量庞大，而且对光非常敏感，但是主要负责夜视力，颜色学里面基本忽略；后者敏感度较低（相比前者通常 1 个光子就可以产生响应，后者需要大概 10  个），但是却能区分颜色。具体来讲，不同波长的光会使人眼中的三种视锥细胞产生不同的反应，从而导致我们感受到不同的颜色。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/Cone-fundamentals-with-srgb-spectrum.svg\" alt=\"Normalized response spectra of human cones\" /> 人类视锥细胞对单色光谱刺激的归一化反应光谱，波长为纳米。</p>\n<p>这三种视锥细胞的归一化的频响曲线如上图。所谓频响（频率响应）指的是视锥细胞对各个波长的光的敏感度，也就是光的颜色对于视锥细胞的刺激能力。人眼中共有三种不同类型的视锥细胞，它们对光的波长的反应各不相同。具体来说：</p>\n<ul>\n<li>S 型视锥细胞（short-wavelength cones，也称蓝色光感受器）对可见光的波长最短的部分做出反应，对紫色到蓝色的光较敏感；</li>\n<li>M 型视锥细胞（middle-wavelength cones，也称绿色光感受器）对可见光的波长在中间部分做出反应，对绿色的光较敏感；</li>\n<li>L 型视锥细胞（long-wavelength cones，也称红色光感受器）对可见光的波长最长的部分做出反应，对黄色到红色的光较敏感。</li>\n</ul>\n<p>根据这个我们可以知道，假设每种细胞输出都是标量，那么我们要表示颜色也至少需要三个分量，三个原色。 然后直接用 L/M/S 细胞的输出的数值来表示颜色就已经用非负值表示所有人眼可以区分的颜色了。因此 LMS  颜色系统主要用于描述人类视网膜中的三种不同类型的视锥细胞对不同波长光的敏感度，它可以准确地描述人类视网膜中的颜色感知。在视觉心理学、医学等领域，LMS 系统被广泛应用。</p>\n<p>然而，在色彩科学中，人们更多地使用其他颜色空间，如 CIE XYZ 颜色空间。这是因为 CIE XYZ 颜色空间能够更好地描述光的亮度和色度，并且更符合色彩测量和色彩管理的需求。CIE XYZ  颜色空间是为标准化色彩测量和色彩管理而设计的，可以精确地计算不同颜色之间的差异和色彩变换，因此它在许多领域被广泛应用，如计算机图形学、印刷、电影制作等。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/CIE-XYZ-Color-Space.svg\" alt=\"CIE XYZ color space\" />CIE XYZ 色彩空间</p>\n<p>XYZ 色彩空间是由三个假想的原色 X、Y、Z 定义的，所有可见的颜色都位于一个三维锥状区域内（见图 CIE XYZ 色彩空间  (a)），选择这三种颜色是为了使所有可见的颜色都能被描述为纯正成分的总和（这个色彩空间分布于第一象限），其中 Y  成分对应于一个颜色的感知亮度或明度，它的原点是黑点（a）图中的 S，E 是表示中性（灰色）颜色的轴。如果将 RGB 色彩空间映射到 XYZ  空间则是如（b）图所示的一个立方体。</p>\n<p>如前所述，XYZ 色彩空间的亮度沿 Y 轴增加，从位于坐标原点的黑点 S  开始（X=Y=Z=0）。色相与亮度无关。例如，白色是明亮的颜色，而灰色被认为是不太亮的白色。换句话说，白色和灰色的色度是一样的，而明度不同。因此在 XYZ 色彩空间中，色相与 Y 值无关。为了方便地描述相应的 &quot;纯&quot; 色相和饱和度，CIE 系统还定义了三个色度值：</p>\n<p>x=XX+Y+Zx=X+Y+ZX y=YX+Y+Zy=X+Y+ZY z=ZX+Y+Zz=X+Y+ZZ</p>\n<p>其中 x+y+z=1x+y+z=1。那么在归一化以后，表示某一个颜色只需要两个参数，比如  <code>x</code>  和  <code>y</code> ，且  <code>x</code>  和  <code>y</code>  都是  <code>[0, 1]</code>  范围内，且由于  <code>z &gt;= 0</code>  ，  <code>x + y &lt;= 1</code> 。那么上述的公式就描述了从 X、Y、Z 坐标系到三维平面 X+Y+Z=1X+Y+Z=1 的中心投影，其中原点 S 是投影中心。如下图所示：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/CIE-X-Y-Chromaticity-Diagram.svg\" alt=\"CIE x, y chromaticity diagram\" />CIE x, y 色度图</p>\n<p>因此，对于任意的 XYZ 空间中的色点 A=(Xa,Ya,Za) A=(Xa,Ya,Za)，相应的色度坐标 a=(xa,ya,za) a=(xa,ya,za) 是通过将线 SAˉSAˉ 与  X+Y+Z=1X+Y+Z=1 相交得到的。那么最终 x,y 色度图只需要去除 ZZ 分量 zaza 即可得到，而这个结果就是著名的马蹄形 CIE x, y 色度分布图（见图 (c)）。马蹄形的区域里面表示着所有可见的颜色，其中上边沿一圈是各种波长的单色光对应的点。</p>\n<p>如上图所示 RGB 三种颜色就是色彩原色（color primaries），由这三个点构成的三角形内的色度都可以用三原色的不同配比组成。同理，CMY  三原色框选出来的三角形区域中的颜色也可以用这三原色通过不同配比表示。这是由颜色的可线性叠加的性质造成的，也就是说任意从马蹄形区域中选三个不共线的点，就可以做三原色，表示三点框出来的三角形内的所有颜色。所以三原色是不唯一的。</p>\n<h4 id=\"视频中的色彩原色\"><a class=\"anchor\" href=\"#视频中的色彩原色\">#</a> 视频中的色彩原色</h4>\n<p>由于 CIE XYZ 色彩空间包括了人类视觉系统可以看到的所有颜色，因此在视频标准中使用到的色彩空间也可以在 CIE x,y 色度图中找到对应的范围。</p>\n<h5 id=\"rec-601-标准\"><a class=\"anchor\" href=\"#rec-601-标准\">#</a> Rec. 601 标准</h5>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/CIExy1931_Rec_601.svg\" alt=\"Rec. 601 chromaticity diagram\" />Rec. 601 色度图。625 线（PAL 和 SECAM）显示为黑色；525 线（NTSC SMPTE C primaries）显示为白色</p>\n<p><strong>Rec. 601</strong> 标准，也就是标清 SDTV 用的颜色空间。可以看到，这个标准下，有两组原色，黑色框的顶点是 PAL 制式的原色，而白色框的顶点为 NTSC  制式的原色。对于制作 Rip 来说这个标准通常只会在 DVD 介质遇到。对于动画来说，特别是日本动画，一般是 NTSC 的标准。（注：这里的  NTSC 用的色域是由 Rec. 601 定义的，与下文 Rec. 709 用的 <em>primaries</em> 是一致的。但不同于我们一般说的 NTSC 1953 色域。NTSC 1953 要更古老。）</p>\n<h5 id=\"rec-709-标准\"><a class=\"anchor\" href=\"#rec-709-标准\">#</a> Rec. 709 标准</h5>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/CIExy1931_Rec_709.svg\" alt=\"Rec. 709 chromaticity diagram\" />Rec. 709 色度图</p>\n<p><strong>Rec. 709</strong> 标准，高清 HDTV 用的颜色空间。他的色彩范围如图所示。HDTV 和 SDTV 是这样判断的：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> width <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1024</span> <span class=\"token keyword\">and</span> height <span class=\"token operator\">&lt;=</span> <span class=\"token number\">576</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  SDTV <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">elif</span> width <span class=\"token operator\">&lt;=</span> <span class=\"token number\">2048</span> <span class=\"token keyword\">and</span> height <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1536</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  HDTV <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  UHD <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr></table></figure><p>这里是个比较奇怪的点，HD 的定义是 1024 长 <strong>或者</strong> 576 高以上的，两个条件满足一个即可。也就是 480p 的 DVD 是 SD，用 601 标准；BD 里面 720p 或者 1080p  是 HD，（1080p 又称作 FHD full HD）用 709 标准。 之所以只规定宽和高中的一个，是考虑电影的黑框 1280 宽的电影，由于长宽比超过 16:9，高度一般不足 576。切记不是必须 1024x576 或者以上才算 HD。</p>\n<h5 id=\"rec-2020-标准\"><a class=\"anchor\" href=\"#rec-2020-标准\">#</a> Rec. 2020 标准</h5>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/CIExy1931_Rec_2020.svg\" alt=\"Rec. 2020 chromaticity diagram\" />Rec. 2020 色度图</p>\n<p><strong>Rec. 2020</strong> 标准，超高清 UHDTV 使用的颜色空间。</p>\n<p>如上文所述：只要是 2048 宽或者 1536 高以上，就可以判断为 UHD。Rec. 2020  这个框就明显大得多了，不过可惜目前还没有多少显示设备能完全覆盖这个区域。由于 Rec. 2020 的覆盖面积很大，目前实际上基本还在用 P3  范围，没有用到接近 Rec. 2020 范围边界的颜色。UHD 的标准确定为 Rec. 2020 是为了给将来做好准备。</p>\n<p>不同的标准色彩原色不同，特别是 Rec. 601 本身就有两种，实际运用的时候记得小心区别。</p>\n<p>此外，因为 XYZ 是线性空间，所以不同 <em>primaries</em> 之间可以线性映射，以保证在不同设备下颜色的一致性。</p>\n<h4 id=\"白点\"><a class=\"anchor\" href=\"#白点\">#</a> 白点</h4>\n<p>实际的 <em>primaries</em> 是个四元组，除了三个顶点（原色）的 x,y 坐标之外，还需要指定白点的位置。  形象地说，不同光照下颜色是不同的，而表示着光照条件的就是白点。白点有着不同的标准，比如 E  系列标准照明体，是频谱内全是平的，虽然理想，但是你现实中看电视绝对不是这种光照条件。我们平时常见的的 D 系列是模拟日光下的情况，例如常用的  D65 标准源大约相当于晴天室外正午时的光照，对应色温约为 6504 K。</p>\n<h3 id=\"2-传输特性-transfer-characteristics\"><a class=\"anchor\" href=\"#2-传输特性-transfer-characteristics\">#</a> (2). 传输特性 transfer characteristics</h3>\n<p>前面讨论的 RGB 颜色其实都是用  <code>[0, 1]</code>  范围内的实数表示的。计算机显然不能真的表示实数，虽然浮点数可以近似表示实数，但是用浮点数来表示视频中的颜色效率非常低，我们还是希望用整数来表示。因此需要将连续的实数转化为整数，这个步骤被称为量化（quantization）。</p>\n<p>这个步骤看起来似乎并不是非常复杂。假设人类可以分辨的最低亮度是 1，那么我们直接记录它的倍数来表示更高的亮度。为了提高精度我们甚至可以假设这个能分辨的最低亮度是 10。像这样的量化，我们称之为<em>线性量化</em>。对应的颜色一般叫<em>线性光颜色</em>，表示数值与光的能量成正比（线性）关系。</p>\n<p>不过实际用起来有一个问题，就是人眼可以区分的亮度范围很广，在不同的亮度下的分辨能力却不同，也就是说，人眼对亮度的感受并不是线性的。以 8-bit 视频为例，如果在这么广的范围平分 256  个区间量化为对应的数字，会导致高亮度的区域，相邻亮度级之间区别不大甚至根本没有。低亮度区域则区别过大，丢失了很多本来可以区分的亮度级。</p>\n<p>所以为了更加好地利用可用的数值范围，我们使用非线性量化，低亮度区域相邻数值间的实际亮度差较低，高亮度的则大得多。 在这里描述量化后的数值与实际光的能量之间的对应关系函数就叫 <em>transfer</em>。这个词或许大家觉得陌生， <em>transfer</em> 在 DSP (digital signal processing) 中是传递（函数）的意思，是一个系统的输入和输出之间的数学关系，它描述了输入信号经过系统后产生的输出信号的变化规律。</p>\n<p>熟悉视频的读者可能会对 “gamma 校正” 这个名词更熟悉。早期这种线性与非线性光的映射操作叫 gamma 校正。这是因为在显像管电视时代，输入电压跟输出的亮度之间的关系大概是个 Out=IngammaOut=Ingamma 的关系。当时使用的 gamma 值大约为 2.4，随后工程师发现这样的输入输出关系基本上与人眼感受到的亮度是对应的。所以现在的 transfer 会使用类似的公式，但是具体的参数有所不同。</p>\n<p>综上所述，线性光与非线性光之间的桥梁就是传输特性。</p>\n<p>一般我们做视频处理都是直接用非线性光做，这才是一般大家提的 RGB。为了严谨起见，如果需要特地区分，非线性量化会在对应变量加上  <code>'</code>  表示。比如  <code>R'G'B'</code>  表示非线性量化的 RGB，特点是每个数值之间对人眼来说亮度差异几乎一致。而不带角标的是线性的，跟物理上的能量直接对应。</p>\n<h3 id=\"3-矩阵系数-matrix-coefficients\"><a class=\"anchor\" href=\"#3-矩阵系数-matrix-coefficients\">#</a> (3). 矩阵系数 matrix coefficients</h3>\n<p>视频的 matrix coefficients（矩阵系数）是指在将 RGB（红绿蓝）颜色空间转换为 YUV（亮度、色度）颜色空间时，所使用的转换矩阵系数。</p>\n<h4 id=\"yuv-色彩空间\"><a class=\"anchor\" href=\"#yuv-色彩空间\">#</a> YUV 色彩空间</h4>\n<p>在介绍矩阵系数之前，还需要引出 YUV 色彩空间的概念。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/YUV-sc-dot-grid.png\" alt=\"color assimilation\" /> 视错觉演示图</p>\n<p>当远看这张图时，你会发现它看起来像是一张彩色的图片，但当你近看这张图片就会发现，这张图整体为黑白色，只是在关键的位置加了非常零星的彩色点表示对应区域的颜色。尽管这个点间距极大，人眼依然会倾向于感觉对应的整片区域都是那个颜色。像这样的视错觉现象被称为色彩同化。原因是，人眼对亮度的分辨率异常敏感，相比之下，对颜色的分辨率就低得多。</p>\n<p>如果我们要在有限的文件体积内压缩图片或视频，它的颜色信息就相对不如亮度信息重要。因此在视频编码时，考虑到数据压缩，我们选择用一种可以分离开亮度和 “色度”（或者说颜色）的颜色编码。通过分离亮度和色度信息，就可以尽可能地去保留前者，有选择地通过损失后者的方法做到提高数据的利用率。换句话说就是在保证人能够观察到相同内容的前提下，减少数据量。这个编码就是 YUV，也有叫 YCbCr。</p>\n<h4 id=\"yuv-与-rgb\"><a class=\"anchor\" href=\"#yuv-与-rgb\">#</a> YUV 与 RGB</h4>\n<p>以 Rec. 709 标准为例，是这样一个转换方式:</p>\n<p>[Y′ U V]=[0.21260.71520.0722 −0.1145720.3854280.5 0.5−0.454153−0.045847][R′ G′ B′]⎣</p>\n<p>⎡Y′ U V⎦⎤=⎣⎡0.2126 −0.114572 0.50.71520.385428−0.4541530.07220.5−0.045847⎦⎤⎣⎡R′ G′ B′⎦</p>\n<p>⎤</p>\n<p>这个公式的含义是 YUV 可以通过 RGB 做一个线性操作得到。换句话说，YUV 也是另一种三 “原色”，只不过 YUV 都不对应真实的颜色。Y 表示的人眼可见的亮度信息，而 UV 则表示纯颜色信息。 YUV 也可以通过先行操作转换到 RGB：</p>\n<p>[R′ G′ B′]=[101.5748 1−0.187324−0.468124 11.85560][Y′ U V]⎣</p>\n<p>⎡R′ G′ B′⎦⎤=⎣⎡1 1 10−0.1873241.85561.5748−0.4681240⎦⎤⎣⎡Y′ U V⎦</p>\n<p>⎤</p>\n<p>前文介绍过， RGB 都是 [0, 1] 之间的实数，那么根据 Y'UV 转换到 R'G'B' 的公式可以发现：Y'UV 的数值范围分别是 [0, 1][-0.5, 0.5] [-0.5, 0.5]。对上述公式稍加变换即可得到如下的内容：</p>\n<p>Y′=0.2126R′+0.7152G′+0.0722B′ U=0.5390(B′−Y′) V=0.6350(R′−Y′)Y′ U V=0.2126R′+0.7152G′+0.0722B′=0.5390(B′−Y′)=0.6350(R′−Y′)</p>\n<p>Y' 直接用 R'G'B' 表示，UV 则换了一种等价的表示方式。这里 U 和 V 分别是 B' / R' 与 Y' 的差，最后乘一个系数使得最后范围是 [-0.5, 0.5]。因此 UV 这里也叫色差信号，分别用 U/Cb 表示（B'-Y'），和 V/Cr 表示（R'-Y'）。</p>\n<p>注：在上述表达中，仅出现了  <code>Y'</code>  并没有出现  <code>U'</code>  或者  <code>V'</code> 。这是因为 Y 是亮度，非线性量化的物理值，但 UV 在理论上是与亮度无关的，无需经过 gamma 校正。</p>\n<h4 id=\"matrix\"><a class=\"anchor\" href=\"#matrix\">#</a> matrix</h4>\n<p>可以看到 YUV 和 RGB 互转是通过一个矩阵乘法进行的，这个矩阵就叫 <strong>matrix</strong> 。不同的标准转换矩阵不同，Rec. 601 和 Rec. 709 的差异尤其明显，当你使用了错误的转换矩阵就会发生偏色。RGB 转 YUV 与 YUV 转 RGB 的俩个矩阵互为逆矩阵，所以一般只指定一个，用 <strong>matrix</strong> 统称。</p>\n<h3 id=\"4-色彩范围-color-range\"><a class=\"anchor\" href=\"#4-色彩范围-color-range\">#</a> (4). 色彩范围 color range</h3>\n<p>在前文中提到的 Y'UV 均为浮点数，但是视频却是以整数表示的，色彩范围就是浮点量化成整数时候所用的整数的范围。</p>\n<p>以 8-bit 视频为例，Y 的值以 0-255 对应 [0, 1]。这样的对应关系被称为  <code>full range</code>  或者  <code>PC range</code> 。而视频中更为常用被称为  <code>limited range</code>  的色彩范围。</p>\n<blockquote>\n<p>limited range 还有一个叫法叫 studio range，但在 VS 里面一般是统一称为 limited range。</p>\n</blockquote>\n<p>以 8-bit 为例，在  <code>limited range</code>  中 Y 的实际范围是 [16, 235]， UV 的范围是 [16, 240]。其中 128 是 UV 的中点 0，16 表示 -0.5，240 表示 0.5。</p>\n<h4 id=\"limited-range-的意义\"><a class=\"anchor\" href=\"#limited-range-的意义\">#</a> limited range 的意义</h4>\n<p>有些读者可能会在这里产生疑问：我们用非线性量化是为了尽可能高效利用数值的范围，但这里却 “浪费了” 最高和最低的两段数字。</p>\n<p>在低端不使用的 16 个数字，学名叫  <code>footroom</code> ，高的那段叫  <code>headroom</code></p>\n<blockquote>\n<p>HDI 标准中确实使用这部分不能用的数字表示 sync 信号。</p>\n</blockquote>\n<p>不使用这两段数字的主要理由如下：</p>\n<ol>\n<li>一个实际的传感器输出的信号必然伴随着随机噪声（白噪声），这些噪声（能量）可正可负。如果我们要求输出的 0 点就是 0，就意味着正噪声可以表示，负噪声一律变成了 0（截断）。这意味着平均的噪声不再是 0，0 点实际偏高了。因此  <code>footroom</code>  是必须保留的。</li>\n<li>在数字信号处理过程中，很多处理算法是不能保证输出的范围跟输入匹配的。很有可能在过程中发生  <code>overshoot</code> （过冲，高于输入上限）和  <code>undershoot</code> （低于输入下限）。对于这种情况，通常只需要使用  <code>clamp</code> ，将超过上下限的数值钳位到对应的极值。但是很明显的，这是一个非线性的操作，这就会引入额外的噪声。 <code>footroom</code>  和  <code>headroom</code>  的意义在于可以连续多个处理后一次性做这个  <code>clamp</code>  操作，以此避免多次引入非线性噪声。（这个操作可以近似理解为做四则运算的时候，多保留几位有效数字，最后再通过一次四舍五入得到需要的精度，而不是每做一步都做一次四舍五入）</li>\n</ol>\n<h4 id=\"range-的换算\"><a class=\"anchor\" href=\"#range-的换算\">#</a> Range 的换算</h4>\n<p>虽然 YUV 视频一般是用  <code>limited range</code> ，但是也有例外情况是  <code>full range</code> 。以下是一个基于 8-bit 视频的公式：</p>\n<p>Ylimited=round(219255∗Yfull)+16Ylimited=round(255219∗Yfull)+16</p>\n<p>当然，在实际操作中在进行转换时应当使用更高的精度，那么在转换过程中出现的四舍五入导致的误差才可以被忽略。在 VS 的操作中可以将 8-bit 源先转换成 16-bit 源再进行后续处理。</p>\n<p>对于不同位深度的视频，以 8-bit 转 10-bit 为例：8-bit limited Y [16,235], UV [16,240]，转换到 10-bit limited，Y 就是 [16⋅4, 235⋅4] 或者说 [64, 940]，UV 则是 [64, 960]。</p>\n<blockquote>\n<p>full 和 limited 在提高位宽 k bits 的时候的行为是不同的，limited 直接乘以 2^k 即可，但是 full 则要做一个完整的重映射，比如 8bit full Y 到 10bit full Y，需要做一个  <code>1023 * Y8 / 255</code>  的映射，不是直接乘以 4 了。</p>\n</blockquote>\n<p>UV 从 full range 转换到 limited range 有一个额外的注意点：limited range U/V 有奇数个数，正好 0  点两边是对称的，full range U/V 一共有 256 个数值，刨去 0  之外不是偶数，所以左右不对称了。因此根据选择，这个转换可以拥有两个相似但不等价的公式。而为了避免这个情况，可以在浮点数下运算，再四舍五入。</p>\n<blockquote>\n<p>full range UV 的时候有两种转换方式，因为 128 两侧的数字不一样多，但是 limited 的时候两侧是一样多的，浮点转回去的时候 就是 224*U + 16.</p>\n</blockquote>\n<h3 id=\"5-总结\"><a class=\"anchor\" href=\"#5-总结\">#</a> (5). 总结</h3>\n<p>这里稍微总结一下关键的必须理解的几个有关颜色概念：</p>\n<ol>\n<li>色彩原色（color primaries）：RGB 里面的三原色和白点的位置，决定了可表示的颜色的范围。</li>\n<li>传输特性（transfer characteristics）：线性光和非线性光之间的纽带，形式为 Out=IngammaOut=Ingamma ，所以传统上也叫 gamma 校正。</li>\n<li>矩阵系数（matrix coefficients）：视频编码实际用的 YUV 颜色与显示用的 RGB 之间的转换矩阵。</li>\n<li>色彩范围（color range）：YUV 编码时每个分量所使用的亮度和颜色取值的范围。</li>\n</ol>\n<p>不同的视频标准（比如 SD 的 Rec. 601 和 HD 的 Rec. 709，UHD 使用的 Rec. 2020）会分别指定 primaries /transfer/matrix，我们在做相应的转换的时候可能需要指定所用的标准。</p>\n<h2 id=\"2-视频\"><a class=\"anchor\" href=\"#2-视频\">#</a> 2. 视频</h2>\n<p>一个视频文件的视频轨有很多属性，包括上文详细说明的颜色，帧率（frame rate），帧率模式（frame rate mode），扫描模式（scanning system），色度抽样（chroma  subsampling），编码设置（encoding  settings）等。这些属性对视频最终呈现的效果都有着很大的影响。下文将详细解释帧率 / 帧率模式、扫描模式、色度抽样以及编码的基本概念。</p>\n<h3 id=\"1-帧率与帧率模式\"><a class=\"anchor\" href=\"#1-帧率与帧率模式\">#</a> (1). 帧率与帧率模式</h3>\n<p>视频帧率指的是每秒钟播放的帧数，它是衡量视频流畅度的重要指标之一。通常我们看到的视频帧率为 24 帧 / 秒、30 帧 / 秒、60 帧 / 秒等。</p>\n<p>帧率模式则指的是帧率变化的模式，主要有两种：</p>\n<ol>\n<li>固定帧率（ <code>Constant Frame Rate</code> ，简称  <code>CFR</code> ）：视频的帧率在整个视频中保持不变，这种模式适用于大多数场景。</li>\n<li>可变帧率（ <code>Variable Frame Rate</code> ，简称  <code>VFR</code> ）：视频的帧率会根据内容和需要，发生变化。例如，当视频画面中大部分时间静态不变，只有少数时间段需要高帧率时，就可以采用 VFR 模式。这样可以节省存储空间，同时保证视频画面的流畅。更多有关 VFR 的内容会在 30 fps 相关的教程中展示。</li>\n</ol>\n<h3 id=\"2-扫描模式\"><a class=\"anchor\" href=\"#2-扫描模式\">#</a> (2). 扫描模式</h3>\n<p>视频的扫描模式指的是视频的扫描方式，目前主流的视频扫描模式有两种：隔行扫描（interlaced scan）和逐行扫描（progressive scan）。</p>\n<h4 id=\"隔行interlaced\"><a class=\"anchor\" href=\"#隔行interlaced\">#</a> 隔行（interlaced）</h4>\n<p>隔行扫描也称为交错，它将画面分为奇数行和偶数行两个半场，每个半场称为一个 “场”，奇数行的场称为顶场（top field），偶数行的场称为底场（bottom field）。它会先发送完整的一场（比如先发送  top，但这个先后顺序不是固定的），然后再发送另一场。</p>\n<blockquote>\n<p>先后顺序不是固定的，是指不同视频中，先 top field 还是先 bottom field 不一定，当然一个视频里面切换是很难的，一旦开始传输了，就只能依赖上一个顺序一直传了。不过有例外的情况，也就是孤场的情况，很少见。一般是低劣的剪辑导致的。</p>\n</blockquote>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/progressive-vs-interlaced.jpg\" alt=\"progressive vs interlaced\" /> 逐行扫描与隔行扫描</p>\n<blockquote>\n<p>注：图中的线条顺序可以理解为 CRT 电子枪扫描的轨迹。可以看到右图先扫描了其中一场，扫描完成后再扫描另一场，然后交替往复。</p>\n</blockquote>\n<p>这就导致隔行的视频，我们不用帧率  <code>frame rate</code>  来说，而是场的速度， <code>field rate</code> ，是 “帧率” 的两倍。</p>\n<h4 id=\"逐行progressive\"><a class=\"anchor\" href=\"#逐行progressive\">#</a> 逐行（progressive）</h4>\n<p>如同字面意思，它按照每一行的顺序依次扫描并显示每一行的亮度信息。与逐行扫描相比，它的主要优点在于画面更为清晰、细节更加丰富。但由于数据量更大，传输效率相较逐行扫描要低一些。</p>\n<h4 id=\"表示方式\"><a class=\"anchor\" href=\"#表示方式\">#</a> 表示方式</h4>\n<p>逐行视频用  <code>p</code>  表示，比如常见的  <code>1080p</code>  表示 1080 高度的逐行视频，又比如我们经常用 24p 表示 24 fps 的逐行视频。 隔行视频则是  <code>i</code>  表示， <code>1080i </code> 表示 1080 高度，每场 540 高度的视频。 而如果用帧率表示， <code>i</code>  需要用场的速度来表示，也就是 <code>60i</code> ，表示 60 场每秒或 30 “帧” 每秒的视频。</p>\n<h4 id=\"隔行扫描的特性\"><a class=\"anchor\" href=\"#隔行扫描的特性\">#</a> 隔行扫描的特性</h4>\n<p>从上面的说明来看，似乎隔行视频只是先采集一张图然后分成两场分开传输，但这只是其中一种可能称为 PsF（progressive segment frame）。而实际的隔行或者交错视频，两场的采集时间不同。换句话说，以  <code>60i</code>  为例，每 1/60s 采集一场，这里的采集可以认为是摄像头曝光一次。因此当你遇到一个交错视频时，就会看到拉丝的现象、这是因为物体运动较快，由于采集时间不同，上下场的内容无法对齐。</p>\n<p>隔行视频在早期模拟电视的时候是必须的，当时的黑白电视使用隔行扫描显示画面。由于视觉暂留的存在，其实人在 CRT 上看 60 场每秒的视频比 30fps 的视频要连贯。这是由 CRT 的长余晖特性导致的。</p>\n<h3 id=\"3-色度抽样chroma-subsampling\"><a class=\"anchor\" href=\"#3-色度抽样chroma-subsampling\">#</a> (3). 色度抽样（chroma subsampling）</h3>\n<p>无论图片还是视频中的每一帧，都是一个矩形的像素阵组成的，每个像素用 RGB 或者 YUV 表示其颜色。就像前文对 YUV  的介绍，由于人对亮度的感知比对色度的感知更为敏感，因此用相同的采样数来表示亮度和色度会浪费大量的带宽和存储空间。视频削减 UV 的码率最主要的方式是通过  <code>chroma subsampling</code>  色度抽样（或称为下采样）的技术做的。（UV 统称是  <code>chroma</code> ，Y 则叫  <code>luma</code> ）。换句话说，多个像素共用一个 UV 的值。再换句话说，通过色度抽样技术，让 UV 的分辨率低于 Y 的分辨率，正好对应了人眼的亮度分辨率高于色度分辨率的特性。</p>\n<blockquote>\n<p>VS 里面可能会简称 css</p>\n</blockquote>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/Chroma-subsampling.svg\" alt=\"Chroma subsampling\" /> 色度抽样</p>\n<p>值得注意的是，看这张图的时候，需要想象上中下三行其实叠在一起的。最左边  <code>2x2</code>  的四个像素，分别对应  <code>2x2 R'</code>   <code>2x2 G'</code>   <code>2x2 B'</code>  这是正常的大家熟知的形式，没有做 <code>subsampling</code> 。右边的  <code>YCbCr 444</code>  则是直接把  <code>RGB</code>  转换  <code>YCbCr</code>  但是依然没有下采样。接下去的几种都是下采样的方式。</p>\n<p>这里先说明一下 <code>4:4:4</code>  这种数字的含义： <code>I:J:K</code>  三个数，假设第一行  <code>I</code>  个像素，因为  <code>Y</code>  不会下采样，所以会有  <code>I</code>  个  <code>Y</code> ，第二个  <code>J</code>  表示这一行有多少个  <code>UV</code> ，再下一个  <code>K</code>  表示下面一行  <code>I</code>  个像素又编码了几个  <code>UV</code> 。</p>\n<blockquote>\n<p>注：这里  <code>UV</code>  是以一对为单位的，意思是一个  <code>U</code>  一个  <code>V</code> 。 一个  <code>UV</code> 、一个  <code>UV</code>  对、一对  <code>UV</code> ，描述的是相同的事物。</p>\n</blockquote>\n<ul>\n<li><code>4:4:4</code>  代表 4 个像素的行，第一行编码了 4 个  <code>UV</code> ，第二行也编码了 4 个  <code>UV</code> 。所以这两行  <code>YUV</code>  总共 8 个 Y，8 个  <code>UV</code> ，没有下采样。</li>\n<li><code>4:2:2</code>  表示 4 个像素的行，第一行编码两个  <code>UV</code> ，第二行再编码两个  <code>UV</code> 。相当于假设是 2 个像素的行，第一行共用一个  <code>UV</code>  对，第二行共用一个  <code>UV</code>  对，也就是图里面示意的样子</li>\n<li><code>4:1:1</code>  代表一行 4 个像素，第一行与第二行均为 1 个 <code>UV</code> 。</li>\n<li><code>4:2:0</code>  的意思是一行 4 个像素，第一行 2 个 <code>UV</code> ，第二行没有再编码 <code>UV</code>  了。于是两行共 8 个像素里面 只编码了 2 个 <code>UV</code>  对，换句话说， <code>2x2</code>  的 4 个像素共享一个 <code>UV</code>  对。 <code>4:2:0</code>  并不表示具体  <code>Cb/Cr</code>  采样在哪里，只是表示多少个 <code>Y</code>  对应多少个  <code>Cb</code>  多少个  <code>Cr</code>  而已。图中为了表示多个像素共享一个 <code>Cb/Cr</code> ，所以把对应的框框画大了。</li>\n</ul>\n<p>一般来说，制作 BDRip 只有两个 css 需要遇到，分别是 444 和 420。422 一般只有母带会用。</p>\n<h4 id=\"色度位置chroma-location\"><a class=\"anchor\" href=\"#色度位置chroma-location\">#</a> 色度位置（chroma location）</h4>\n<p>在进行色度抽样时，根据视频帧中的色度分量的放置位置，可以衍生出不同的色度位置。 <code>chroma location</code>  也被称为  <code>chroma placement</code>  ，一般缩写为  <code>chromaloc</code>  或  <code>cplace</code> 。</p>\n<p>如色度抽样的示意图所展示的， <code>4:2:2</code> ， <code>4:1:1</code> ,  <code>4:2:0</code>  中出现的虚线代表  <code>Y</code>  与  <code>UV</code>  的对齐关系。所以同样是  <code>4:2:0</code>   的色度抽样，就存在两种类型的  <code>chroma location</code>  。左侧的是  <code>JPEG/MPEG-1 chroma location</code> ， <code>Cb</code> / <code>Cr</code>  对齐的是 2x2 像素的中点。右边的叫  <code>MPEG-2 chroma location</code> ， <code>Cb</code> / <code>Cr</code>  对齐的是左边一列的中点。可以从名称中发现，第一种色度位置是用于  <code>MPEG-1</code>  和  <code>JPEG</code> ；第二种是  <code>MPEG-2</code>  以及后续的视频编码标准（比如 AVC 和 HEVC）使用的。两种  <code>chroma location</code>  看似差别不大（0.5 像素的偏差），但实际上有着肉眼可见的区别。比如  <code>chroma shift</code>  类的瑕疵就可能是使用了错误的  <code>chroma location</code>  导致的。</p>\n<p>细心的读者可能会发现在  <code>MPEG-1 cplace</code>  中， <code>Cb</code>  中心点与实际下采样之前  <code>2x2</code>  个  <code>Cb</code>  的中心点都不重合；相对的  <code>MPEG-2</code>  的  <code>Cb</code>  中心点其实与原本的第一列的  <code>Cb</code>  的中心点是重合的。当中心点重合时计算量会小一点，因此当进行插值运算将下采样的结果恢复为  <code>4:4:4</code>  时，这种  <code>MPEG-2</code>  的排列方式更好。</p>\n<p>虽然上图的像素表示为一个方框，但理论中的像素可以认为是采样的是中点所在无穷小的点位置的<strong>值</strong>。虽然实际当中， 不管是采集设备还是显示设备，实际像素是有限面积的，但是这都是表示近似的概念。为了更好的理解像素，下采样等概念，下面再举一个例子：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/sample-grid.png\" alt=\"sample grid\" />sampling grid</p>\n<p>我们以扫描为例来说明，你可以认为你有一个标记有均匀排列的 N×MN×M 个点的阵列的透明薄膜， 覆盖在要扫描的图片上，然后你读取每个点底下那个点的颜色值，作为对应的像素的值。实际上我们说的像素，只有红色横线和竖线相交的 16 个点。这里面的采样点就是图中的 16 个整数坐标点，采样点是无穷小的点。</p>\n<p>然后我们再来说  <code>cplace</code> 。以上图为例，假设是 4×44×4 的采样点，那么 Y 的采样点就在红线的交界处。444 下采样的时候， <code>Cb</code>  和  <code>Cr</code>  的采样点也跟  <code>Y</code>  的位置重合。假如是 420 下采样，则一共有 4 对采样点，假设这里考虑 420 JPEG/MPEG-1 下采样，则可以得到如下的  <code>Cb</code>  和  <code>Cr</code>  采样点：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/sample-grid-cbcr.png\" alt=\"sample grid cbcr\" />sampling grid 420 JPEG/MPEG-1</p>\n<p>420 JPEG/MPEG-1 下  <code>Cb</code>   <code>Cr</code>  采样点坐标： (0.5, 0.5), (0.5, 2.5), (2.5, 0.5), (2.5, 2.5)，坐标<strong>并不是整数</strong>。另一种 420（MPEG-2）下  <code>Cb</code>   <code>Cr</code>  采样点坐标： (0, 0.5), (2, 0.5), (0, 2.5), (2, 2.5)。刚才的 X-Y 坐标系就是  <code>sampling grid</code> 。</p>\n<p>有了  <code>sampling grid</code>  的概念之后，很多图像变换就可以用这个概念解释，比如图片放大和缩小，这里不做展开。</p>\n<p>此外，对于这种非整数位置的采样点，其数值是通过函数插值确定的。比如一维函数中最简单的差值 —— 线性插值，即相邻的点中点的值就是与之相邻两点的值的平均值。比如说，(0.5, 0.5) 这个点的值，就可以用相邻四个整数点的值的平均来估计。</p>\n<h3 id=\"4-视频编码的基础概念\"><a class=\"anchor\" href=\"#4-视频编码的基础概念\">#</a> (4). 视频编码的基础概念</h3>\n<p>现在我们来说说视频编码中的基础概念。前面我们讲了视频编码使用 YUV 来存放颜色，这样  <code>css</code>  ( <code>chroma subsampling</code> ) 就可以减少一部分数据量。但是视频中的冗余信息显然不只如此。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/I_P_and_B_frames.svg\" alt=\"I P and B frames\" />I/P/B 帧</p>\n<p>以这个吃豆豆的 4 帧视频为例。豆豆不断从右侧移动进来。</p>\n<ul>\n<li>\n<p>首先黄色的部分每帧都是一模一样的，所以视频后面几帧是可以直接复制前面一帧的内容，这就可以再节约一部分码率。</p>\n</li>\n<li>\n<p>不过对于豆豆来说，这种直接复制前面一帧的对应区域的办法就行不通了。虽然豆豆是一样的，但是相邻帧的位置有变化。对此视频编码一般有运动预测或者运动补偿。也就是后一帧不光可以引用前一帧相同部分的像素，也可以引用其他部分的一个块的值。</p>\n<p>这样第二帧就完美了：白色的背景，黄色的从第一张图直接复制，豆豆是第一张图的虚线区域往左挪一点。这里一帧引用其他帧的内容我们就要  <code>ref</code> （ <code>reference</code> ），被引用的帧就被称作  <code>reference frame</code>  。</p>\n</li>\n<li>\n<p>第三帧问题又来了。屏幕上四个豆豆，前面的帧都只有 3 个。我们假设四个豆子各不相同，那么这第四个是没办法用前面的帧来替换了，我们就束手无策只能在这帧重新编码一下这个内容了么？对于最早期的视频编码标准来说，确实是如此。不过细心的读者可能会发现第四帧就有这第四个豆子。假设我们能未卜先知，是不是可以用第四帧来编码第三帧呢？这就是是第四帧到第三帧的反向的箭头。可能读者会存在疑问：视频是按顺序播放的，我们怎么知道下一帧的内容？这是因为视频虽然按顺序播放，但是不一定是按顺序解码的。我们可以先编码第四帧，然后再编码第三帧，播放时也是先解码第四帧，随后解码第三帧，在播放时，调整显示的顺序。</p>\n<p>这里就引入了两个时间戳的概念，由于这种利用未来预测当下的存在，视频存在两种时间戳  <code>dts</code>  和  <code>pts</code> 。 <code>dts</code>  -  <code>decode timestamp</code> ； <code>pts</code>  -  <code>presentation timestamp</code> 。 <code>dts</code>  是解码器必须解码一帧的时间，这里图中第四帧的时间在第三帧之前。 <code>pts</code>  是一帧需要展现到屏幕的时间戳，1、2、3、4，是依次递增的。</p>\n</li>\n</ul>\n<h4 id=\"ipb-帧\"><a class=\"anchor\" href=\"#ipb-帧\">#</a> I/P/B 帧</h4>\n<ul>\n<li>图中这四帧，第一帧是完整编码的，我们称之为  <code>I帧</code> ， <code>intra-coded frame</code>  ，又称作  <code>key 帧</code> 。表示这帧不依赖其他帧，可以独立解码。</li>\n<li>第二帧只依赖过去的帧的内容，我们叫  <code>P 帧</code> ， <code>predicated frame</code> 。如前文所说，这早期的视频编码只有这一种预测帧，所以 P 就被占用了。</li>\n<li>按照前文的叙述，第三帧这种同时依赖前面第二帧和后面第四帧也一样是通过预测得到的，但是无奈 P 这种类型已经占用，为了区别于前文所提的仅向前预测的帧，所以发明了一个新词，叫  <code>B 帧</code> ，双向预测帧  <code>bipredicated frame</code>  。这就是 I/P/B 帧的概念。</li>\n</ul>\n<h4 id=\"gop-idr\"><a class=\"anchor\" href=\"#gop-idr\">#</a> GOP &amp; IDR</h4>\n<p>就像前文所说，I 帧总是可以被独立解码，而 P/B 帧必须参考其他帧。除非转场，由于视频的帧之间都会存在可以互相引用的内容，这些 P/B 帧可能会引用 I  帧以前的内容。这在顺序播放时并不会成为障碍，但如果需要跳转，则需要从这一帧所参考到的 I  帧开始逐级解码，很容易引起无法拖动进度条的现象。为了解决这个问题，视频编码器会在适当的时候插入一个可以用来开始解码的特殊的 I 帧，这种帧叫  <code>IDR</code>  ,  <code>instantaneous decoder fresh</code> 。</p>\n<p>在遇到  <code>IDR</code>  帧时，解码器可以立即丢弃前面已经解码的所有帧，直接从该  <code>IDR</code>  帧开始解码。这是因为  <code>IDR</code>  帧代表在该帧以后的内容不会引用该  <code>IDR</code>  之前的帧。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/GOP-Structure.svg\" alt=\"GOP Structure\" />GOP 结构 IBBPBBPBB</p>\n<p>两个 I 帧之间的这些帧，包含第一个 I 帧，但不包含第二个，我们称之为  <code>GOP</code>  （ <code>Group of pictures</code> ）。上图是一个可以表示为  <code>IBBPBBPBB</code>  的 GOP 结构，箭头表示参考关系。从图中可以看出，在第 6 帧（P 帧）以后的两个 B 帧均参考了第 9 帧（I 帧），这种 GOP 中的帧可以参考其他 GOP 的情况被称为 <code>open GOP</code> 。相对的，如果这两个 I 帧均为 IDR，则由于 IDR 帧的特殊性， GOP 中的帧既不能向第一个 IDR 帧以前的内容参考，也不可以向下一个 IDR 帧以后的内容参考，那么这个 GOP 就被称为  <code>closed GOP</code> 。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/GOP-Structure-Transmission.svg\" alt=\"GOP Structure Transmission\" />GOP 结构传输</p>\n<p>上图是 GOP 的实际传输情况。第一个 GOP 的最后两个 B 帧是在第二个 GOP 的 I  帧之后传输的。对于这种情况，解码器如果从第二个 GOP 开始解码，会忽略中间的两个 B 帧（他们甚至可能无法解码，因为是 B 帧，可能依赖上一个  GOP 的帧）。此外，细心的读者可能会注意到：第二个条中表示一帧的方块的长度其实表示了帧的数据的相对尺寸的，可以看到 I 远大于 P ， P  远大于 B。所以一般视频里 I 的数量最少，P 其次，B 最多。</p>\n<p>根据上文提出的概念， <code>closed GOP</code>  内的帧只能互相参照，不能参照这个区间之外的内容，这就是可以完整切割并保证播放的最⼩单元。所以，在不重新编码的前提下，视频的切割（⽐如 mkvtoolnix），⼀定是从⼀个 IDR 开始切割，切割到另⼀个 IDR 之前⼀帧，或者末尾。</p>\n<h2 id=\"3-视频文件\"><a class=\"anchor\" href=\"#3-视频文件\">#</a> 3. 视频文件</h2>\n<p>这一节将会剖析视频文件，分析其构成。</p>\n<h3 id=\"1-容器\"><a class=\"anchor\" href=\"#1-容器\">#</a> (1). 容器</h3>\n<p>看过<span class=\"exturl\" data-url=\"aHR0cHM6Ly92Y2Itcy5jb20vYXJjaGl2ZXMvMjcyNg==\">科普</span>的应该了解到<strong>容器</strong>的概念了，现在一定明白  <code>mkv</code>  比  <code>mp4</code>  画质好这种说法非常荒谬。</p>\n<p>现实中我们遇到的视频，一般是  <code>mp4</code> 、 <code>mkv/webm</code> 、 <code>mov </code> 甚至  <code>avi</code> 、 <code>wmv</code>  这些后缀的文件，对于这些文件格式，我们称为<strong>容器 (container)</strong>，意为承载其他东西的文件。</p>\n<p>为什么需要容器呢？因为视频 raw 一般无法独立使用，绝大多数情况要搭配声音播放。以 VCB-S 的 BDRip 为例，多条音轨也很常见，主音轨之外可能还有评论音轨。有些甚至还有字幕轨道。这些复杂性就意味着需要一个足够灵活的 “容器” 来承载这些轨道。</p>\n<h3 id=\"2-轨道\"><a class=\"anchor\" href=\"#2-轨道\">#</a> (2). 轨道</h3>\n<p>一般我们将容器中承载的数据分为轨道，比如<strong>视频轨</strong>，<strong>音频轨</strong> ，<strong>字幕轨</strong>（章节信息不是轨道，是独立的。）</p>\n<h3 id=\"3-结构\"><a class=\"anchor\" href=\"#3-结构\">#</a> (3). 结构</h3>\n<p>以最常用的  <code>mkv</code>  格式为例，具体剖析视频文件的构成。 <code>mkv</code>  文件可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ta3Z0b29sbml4LmRvd25sb2FkLw==\">mkvtoolnix-gui</span> 的  <code>info tool</code>  工具来看视频文件结构。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-info-tool.png\" alt=\"mkv info tool\" />mkv info tool</p>\n<p>顺带一说  <code>Matroska</code>  容器，这个名字来源是  <code>Matryoshka doll</code> ，也就是俄罗斯套娃，或许也在暗示这个格式的特性。</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-structure.png\" alt=\"mkv structure\" />mkv 结构</p>\n<p>一个 mkv 的结构大致如图所示，上文说过  <code>mkv</code>  名字来源于俄罗斯套娃，其实一个 mkv 里面分  <code>segment</code> ，每个  <code>segment</code>  才包括  <code>track</code> 。 <code>segment</code>  才是我们一般意义上说的一个视频（包括音频视频等等），因此可以发现，mkv 就是在做这样的套娃操作。其中  <code>segment info</code>  和  <code>tracks</code>  就是最重要的  <code>metadata</code>  了。</p>\n<h4 id=\"segment-information\"><a class=\"anchor\" href=\"#segment-information\">#</a> Segment information</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-segment-info.png\" alt=\"mkv segment information\" />mkv segment information</p>\n<p><code>Segment info</code>  主要包括一些在  <code>mediainfo</code>  里看到的应用程序的名字版本 / 混流的时间戳等等。</p>\n<p><code>timestamp scale</code> ，它表示了 mkv 里面时间戳的精度，单位是 ns。这里的数字是 1M 对吧，说明 mkv 里面时间戳精度只有 1 ms。这就解释了为什么比如说 ass  特效，也只有 ms 级别的时间精度。当然理论上 scale 是可以改的，从单位 ns 也可以看出标准是非常灵活的，但是实际上  mkvtoolnix 默认值就是 1M scale。</p>\n<p><code>segment UID </code> 是个 UUID，用于唯一标志一个  <code>segment</code> ，这个如果你要用 mkv 的高级用法 (e.g. <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubm1tLWhkLm9yZy9iYnMvdGhyZWFkLTExNzgtMS0xLmh0bWw=\">Ordered Chapter</span>) 可能会遇到。</p>\n<blockquote>\n<p>虽然 mkv 的标准中保留了多个 segments 的可能性，但正常的视频文件仅含有单个 segment。</p>\n</blockquote>\n<h4 id=\"track\"><a class=\"anchor\" href=\"#track\">#</a> Track</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-track-info.png\" alt=\"mkv track information\" />mkv track information</p>\n<p><code>Tracks</code>  里面包含这个文件里面的视频轨音频轨的信息。</p>\n<p><code>Track number</code>  这里注意，有个从 0 开始还是从 1 开始的问题，这里也列出来了工具用 0 开始的 <code>track number</code> 。</p>\n<h4 id=\"cluster\"><a class=\"anchor\" href=\"#cluster\">#</a> Cluster</h4>\n<p>mkv 的核心数据被记录在这里：</p>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-cluster-info.png\" alt=\"mkv cluster information\" />mkv cluster information</p>\n<p>这里可以观察到：</p>\n<ol>\n<li>\n<p>mkv 里面不同  <code>track</code>  的数据是交错在一起存储的，一个  <code>cluster</code>  表示一小段时间对应的所有轨道的数据， <code>cluster</code>  一般是 mkv seek 的目标。也就是最不济也可以根据时间戳 seek 到对应的 cluster。</p>\n<p>这里面概念较多，其中  <code>discardable</code>  这个概念不是很重要，不被引用的帧都是  <code>discardable</code> 。这是表示如果播放器在定位到一个 <code>cluster</code>  之后，然后想通过逐帧解码来定位到某个具体的帧， <code>discardable</code>  的帧可以不解码直接跳过。 <code>key</code>  表示是前文提过的 I 帧。</p>\n</li>\n<li>\n<p>这里可以看出  <code>track1</code> （视频）、 <code>track2</code> （音频）都是分  <code>frame</code>  存放的。然后你有时候用  <code>mkvmerge</code>  切割时会发现，pcm 音频明明是可以完美按照  <code>sample</code>  切割的，但切割后却会出现 audio delay？就是这里的  <code>frame</code>  在作怪。 <code>mkvmerge</code>  只能按照整数个  <code>frame</code>  来切割（音视频都是如此），即使是  <code>pcm</code>  音频。</p>\n</li>\n</ol>\n<blockquote>\n<p>这里会发现部分 timestamp 并不是按照顺序出现的，这个就是因为 GOP 在传输过程中不同帧解码顺序的需求造成的，具体内容参见 GOP 节。</p>\n<p><code>framing</code>  与视频的帧（frame）不是一个概念，是通信协议上的  <code>frame</code> 。所有音视频编码都是分  <code>frame</code>  来编码的，比如视频是帧为单位，音频则是以几十到一百多 ms 为单位做一个  <code>audio frame</code>  来压缩，目前暂时可以认为是能够独立解码的最小单位。</p>\n</blockquote>\n<h4 id=\"cues\"><a class=\"anchor\" href=\"#cues\">#</a> Cues</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-cues-info.png\" alt=\"mkv cues information\" />mkv cues information</p>\n<p>在一堆  <code>clusters</code>  之后是  <code>cues</code> 。这个是帮助播放器  <code>seek</code>  的。给出了若干时间对应到  <code>segment</code>  的文件起始偏移量的数据。播放器加载了这个表格，对着  <code>timestamp</code>  做个二分搜索，找到最近的之前一个时间戳所在的  <code>cue</code> ，然后就定位到了对应的  <code>cluster</code> 。这就解释了为什么  <code>raw</code>  视频（直接通过 x264/265 等编码器编码生成的文件）是不能  <code>seek</code>  的。但是  <code>mkv</code>  却可以快速地任意  <code>seek</code> 。</p>\n<h4 id=\"tags\"><a class=\"anchor\" href=\"#tags\">#</a> Tags</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-tags-info.png\" alt=\"mkv tags information\" />mkv tags information</p>\n<p>mkv 的最末尾有一个  <code>Tags</code>  段，这里面记录了  <code>mediainfo</code> ，可以看到总时长、帧数、BPS（bits per second）之类的信息。mkv 的 tag 系统比 mp3 等的强大得多，有兴趣的可以自行阅读 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWF0cm9za2Eub3JnL3RlY2huaWNhbC90YWdnaW5nLmh0bWw=\">MKV Spec</span> 和 mkvmerge 的文档。</p>\n<h4 id=\"chapter\"><a class=\"anchor\" href=\"#chapter\">#</a> Chapter</h4>\n<p><img data-src=\"https://guides.vcb-s.com/media/basic-guide-01/mkv-chapter-info.png\" alt=\"mkv chapter information\" />mkv chapter information</p>\n<p>Chapter 记录了章节的时间，名称，语言等信息，这些内容可以与  <code>mediainfo</code>  中看到的章节信息一一对应。</p>\n",
            "tags": [
                "视频压制技术系列教程"
            ]
        }
    ]
}