{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sakura • All posts by \"游戏引擎实践\" category",
    "description": "一个专注于技术和思考分享的博客",
    "home_page_url": "https://sakurame.eu.org",
    "items": [
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89/",
            "title": "games104系列笔记（二二）",
            "date_published": "2023-06-28T15:13:16.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍 GPU 驱动的几何管线与 Nanite 技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<h3 id=\"traditional-rendering-pipeline\"><a class=\"anchor\" href=\"#traditional-rendering-pipeline\">#</a> Traditional Rendering Pipeline</h3>\n<p>Nanite 是虚幻 5 引擎中提出的虚拟几何系统用来实现渲染超高精度的网格。要理解 Nanite 首先要回顾一下经典渲染管线：当我们从 CPU 端发出渲染指令时会首先由 CPU 来准备各种渲染所需的资源，然后 GPU 会接收这些数据并计算实际的着色。这种模式的缺陷在于 CPU 可能无法跟上 GPU 的计算速度，而且 CPU 的算力会浪费在准备渲染素材这一过程中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rAwzzPc.png\" width=\"80%\">\n</div>\n<p>随着渲染场景的复杂度逐渐提升，CPU 端的计算开销会成为整个渲染过程的瓶颈。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SBDI6x7.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/y1HYP0E.png\" width=\"80%\">\n</div>\n<h3 id=\"compute-shader\"><a class=\"anchor\" href=\"#compute-shader\">#</a> Compute Shader</h3>\n<p>为了提升渲染效率人们开发出了<strong> compute shader</strong> 这样的技术，其核心在于把过去只能在 CPU 端执行的通用计算转移的 GPU 端，从而节约掉大量的 CPU 到 GPU 端的通信开销。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/29Cc3Kd.png\" width=\"80%\">\n</div>\n<h3 id=\"graphics-api\"><a class=\"anchor\" href=\"#graphics-api\">#</a> Graphics API</h3>\n<p>在图形 API 层面上过去只能一次绘制一个网格，而现代图形 API 则支持在一次 DrawCall 中同时绘制多个网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5Kx1jQi.png\" width=\"80%\">\n</div>\n<h3 id=\"gpu-driven-rendering-pipeline\"><a class=\"anchor\" href=\"#gpu-driven-rendering-pipeline\">#</a> GPU Driven Rendering Pipeline</h3>\n<p>总结一下，现代 GPU 驱动的渲染管线核心思想在于把 CPU 端的计算直接移动到 GPU 端，同时渲染所需的数据也会直接由 GPU 进行加载。在理想情况下 CPU 端只负责发出绘制指令，一切渲染数据加载和计算都在 GPU 端直接完成。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JRByllG.png\" width=\"80%\">\n</div>\n<h2 id=\"gpu-driven-pipeline-in-assassins-creed\"><a class=\"anchor\" href=\"#gpu-driven-pipeline-in-assassins-creed\">#</a> GPU Driven Pipeline in Assassins Creed</h2>\n<p>游戏工业对 GPU 驱动渲染管线的大规模应用可以追溯到《刺客信条：大革命》。在游戏中我们可以看到大量的拥有真实细节的建筑和场景，如何渲染这些极其复杂的几何对象是整个渲染管线的巨大挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Qhjqe2v.png\" width=\"80%\">\n</div>\n<p>游戏开发团队提出了<strong> mesh cluster rendering</strong> 的技术来提升渲染效率。mesh cluster rendering 的思想在于对同一物体上的面片进行聚类，在渲染时首先根据 cluster 来判断面片的可见性</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YJCDc7C.png\" width=\"80%\">\n</div>\n<p>整个游戏的渲染管线如下图所示。通过 clustering 的方法可以去除掉大量不可见的对象以及三角形，从而极大地缓解了 GPU 的渲染压力。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WiPViGX.png\" width=\"80%\">\n</div>\n<p>而在 CPU 端只负责非常少量的视锥剔除等工作，初步过滤掉不可见的物体。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A3WLRd7.png\" width=\"80%\">\n</div>\n<p>然后 GPU 端会把过滤后物体上的 cluster 拓展为 chunk，每个 instance 可以属于不同的 chunk 而每个 chunk 可以包含不同的 cluster。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bAOPhdZ.png\" width=\"80%\">\n</div>\n<p>GPU 端进行实际的可见性剔除时会先检查 chunk 的可见性然后计算 cluster 的可见性。除了利用 bounding box 进行剔除外，还会同时结合三角形的朝向进行过滤，最后得到所有可见的三角形编号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2LVkUkv.png\" width=\"80%\">\n</div>\n<p>所有可见三角形的编号会存储在一个事先申请的巨大 buffer 中。写入过程是原子化的，因此可以利用 GPU 并行计算来高效处理。而在进行渲染时可以利用这个 buffer 来并行处理所有的三角形，从而实现对场景的渲染。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GPO6E5H.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4WIFxjq.png\" width=\"80%\">\n</div>\n<h2 id=\"occlusion-culling-for-camera-and-shadow\"><a class=\"anchor\" href=\"#occlusion-culling-for-camera-and-shadow\">#</a> Occlusion Culling for Camera and Shadow</h2>\n<p>为了进一步提升渲染效率，除了剔除掉视野外的三角形外我们还希望能够把被遮挡住的三角形也同时剔除掉，这一过程称为<strong> occlusion culling</strong>。当相机在场景中的运动比较光滑时可以把前一帧的深度图投影到当前相机位置上，再结合 hierarchy z-buffer 就可以估计哪些 cluster 和三角形是可见的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ocIeFet.png\" width=\"80%\">\n</div>\n<h3 id=\"two-phase-occlusion-culling\"><a class=\"anchor\" href=\"#two-phase-occlusion-culling\">#</a> Two-Phase Occlusion Culling</h3>\n<p>更现代的 occlusion culling 方法是使用上一帧和这一帧的两个 z-buffer 来实现。首先利用前一帧的 z-buffer 来快速选取可能可见的物体，然后使用这些物体来渲染新的 z-buffer。显然此时的深度图会有非常多的洞等待填充，而且很多像素的深度可能是错误的。为了修正这个问题还需要再利用这一帧的深度图来测试前面过滤掉的其它物体。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sZUdyeI.png\" width=\"80%\">\n</div>\n<p>这种 two-phase occlusion culling 方法对于非常复杂的场景以及动态物体都有很好的性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vda6izO.png\" width=\"80%\">\n</div>\n<p>而对于阴影的问题也可以复用前一帧阴影的深度图并结合 hierarchy z-buffer 来进行剔除。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/y5ue2E6.png\" width=\"80%\">\n</div>\n<p>要进一步提升阴影的渲染效率还可以结合相机的可见性，把所有相机方向不可见的物体全部剔除掉。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sJYPHs2.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cDuOqst.png\" width=\"80%\">\n</div>\n<h2 id=\"visibility-buffer\"><a class=\"anchor\" href=\"#visibility-buffer\">#</a> Visibility Buffer</h2>\n<p>和 Nanite 相关的另一个技术是课程前面提到过的 G-buffer 和<a href=\"/2022/04/27/GAMES104-NOTES-07.html#deferred-rendering\">延迟渲染</a>，我们可以把场景中的各种几何信息记录在 G-buffer 中从而方便渲染时的计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wov9xPG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CUOYeUE.png\" width=\"80%\">\n</div>\n<p>显然这样的 G-buffer 会占用非常多的显存，这在画面高分辨率或是复杂场景的情况下读取数据的效率会变得极其低下。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/62WhFDS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KumHdNk.png\" width=\"80%\">\n</div>\n<p><a href=\"/2022/04/27/GAMES104-NOTES-07.html#visibility-buffer\">V-buffer</a> 是为了提升数据读取效率和缓存利用率而提出的一种技术。V-buffer 中不会记录太多的几何信息，一般只保存像素上物体的各种编号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QihTZh5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1vQb4ww.png\" width=\"80%\">\n</div>\n<p>在进行着色时对每个像素需要先获取该处对应的三角形信息，然后通过插值来得到像素上相应的各种几何材质数据。这种渲染方式的优势在于计算量只与分辨率有关，而与场景的几何复杂度无关，因此拥有非常高的计算效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BgzLawZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pWqosMI.png\" width=\"80%\">\n</div>\n<p>V-buffer 可以很容易地和延迟渲染管线进行结合。我们只需要利用 V-buffer 中可见物体的编号来重新写入 G-buffer 就可以完美融入延迟渲染管线中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5JF3umZ.png\" width=\"80%\">\n</div>\n<p>当然 V-buffer 在实际使用时还有很多的细节要处理，比如说如何考虑纹理的梯度、如何选取合适的 mip-map 等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gk2CKEo.png\" width=\"80%\">\n</div>\n<p>使用 V-buffer 可以极大地提升具有复杂几何场景的渲染效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/L4zoV4i.png\" width=\"80%\">\n</div>\n<h2 id=\"virtual-geometry-nanite\"><a class=\"anchor\" href=\"#virtual-geometry-nanite\">#</a> Virtual Geometry - Nanite</h2>\n<h3 id=\"overview\"><a class=\"anchor\" href=\"#overview\">#</a> Overview</h3>\n<p>Nanite 的核心任务是实现实时电影级高精度几何模型的渲染，我们希望能够尽可能还原有着无限细节的真实世界。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XGHH8dn.jpg\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fAhmUQX.jpg\" width=\"80%\">\n</div>\n<p>回忆基于<a href=\"/2022/04/19/GAMES104-NOTES-06.html#terrain-texture\"> virtual texture</a> 的技术我们可以为物体不同 LoD 的纹理烘焙在固定大小的纹理贴图上，在渲染时根据相机的位置和实际需要加载所需的纹理。这种材质表达可以提升缓存利用率以及数据加载效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1lNUuu2.png\" width=\"80%\">\n</div>\n<p>Nanite 的思想与 virtual texture 非常相似，不过 Nanite 更关心的是如何建立虚拟的几何表示。当然几何数据本身要比纹理贴图要复杂得多，如何建立规范的几何表示至今仍然是一个难题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qz43Qo0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tdktBkz.png\" width=\"80%\">\n</div>\n<p>以体素化表示为例，尽管体素本身是相对规范的但由于其巨大的数据量我们很难在游戏引擎中来直接使用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eht0dfS.png\" width=\"80%\">\n</div>\n<p>另一种流行的几何表示方法是<strong>曲面细分 (surface subdivision)</strong>，基于这样的技术我们可以把粗略的几何表面细分为高精度包含各种细节的曲面。然而曲面细分的一个缺陷在于很难对曲面进行降采样，即从高精度曲面来获得低精度表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3aPSJ7m.png\" width=\"80%\">\n</div>\n<p>其它的几何表达方式包括 displacement map 或是点云也都无法满足我们的需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MYgaLIN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Xs0Yktl.png\" width=\"80%\">\n</div>\n<p>因此在 Nanite 中还是选择了三角网格来表示，然后设计了一套非常复杂的算法流程来表达几何信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/R26rVZf.png\" width=\"80%\">\n</div>\n<h3 id=\"geometry-representation\"><a class=\"anchor\" href=\"#geometry-representation\">#</a> Geometry Representation</h3>\n<p>Nanite 的一个重要想法是利用屏幕的精度来控制渲染时所需计算三角形的数量。尽管三角形的数量可以随着模型精度的提高不断增长，但只要屏幕分辨率不变所需绘制的三角形数量应该是比较稳定的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pY4vb1l.png\" width=\"80%\">\n</div>\n<p>因此可以结合前面介绍过的<a href=\"/2022/12/12/GAMES104-NOTES-22.html#gpu-driven-pipeline-in-assassins-creed\"> mesh cluster</a> 来控制模型的细节。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jc22ggv.png\" width=\"80%\">\n</div>\n<p>然后根据相机与模型的相对远近关系来生成 cluster 在不同 LoD 下的几何表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p8Ie2bS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1SoPn2N.png\" width=\"80%\">\n</div>\n<p>在选择 cluster 的 LoD 时需要考虑它投影到屏幕上产生的误差。一种直观的选取方法是当误差小于 1px 时选择当前层的 LoD，否则选取下一层的 LoD。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FH9VXqO.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bsoQaRX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/W9BRyUf.png\" width=\"80%\">\n</div>\n<p>但是在合并 cluster 时需要考虑不同 LoD 的 cluster 之间可能会出现缝隙。当然我们可以把 cluster 的边锁住，这样不管是使用哪一层的 LoD 都会有一致的边界。不过这样的处理并不是一个非常好的办法，可能会产生严重的 artifact。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ahamxF3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5BthesF.png\" width=\"80%\">\n</div>\n<p>Nanite 中提出了<strong> cluster group</strong> 的概念来处理 cluster 之间的缝隙。cluster group 之间的边界会被锁住，而内部的 cluster 会在生成 LoD 时一起进行简化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/C3yJ6e5.png\" width=\"80%\">\n</div>\n<p>整个 cluster 简化的过程如下。需要注意的是简化后的 cluster 与原始 cluster 之间并不是一对多的关系，而是多对多的关系。即不同的简化后的 cluster 可以对应同一个原始 cluster。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2H5phIm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EgDve8F.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dq0mgB3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZbmOcOt.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nkaKgXK.png\" width=\"80%\">\n</div>\n<p>随着 LoD 的提高不同 cluster group 的边界也会发生相应的变化，这样可以避免出现高频噪声。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MbMxqOu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UikvI0u.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/u3fPCuP.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ql8fElv.png\" width=\"80%\">\n</div>\n<p>实际上这样的简化 cluster 过程可以表示为一张 DAG，每个 cluster 在上一层 LoD 会有多个指向。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5uUx5BU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mW9eKLE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8aqT38W.png\" width=\"80%\">\n</div>\n<p>而网格本身的简化则可以使用经典的 QEM 等简化算法来实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/O4dXQ3u.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3AgeHDd.png\" width=\"80%\">\n</div>\n<h3 id=\"runtime-lod-selection\"><a class=\"anchor\" href=\"#runtime-lod-selection\">#</a> Runtime LoD Selection</h3>\n<p>进行渲染时需要根据相机的位置来选择合适的 LoD。不过对于 DAG 这样的数据结构进行访问时仍然是比较复杂的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ksyj0CF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kdfxjVX.png\" width=\"80%\">\n</div>\n<p>Nanite 还使用了并行化的技术来加速访问。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EhQzZmv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yrk24OX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zUJBS3J.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gYuc6xo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8Vea0HP.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fNc5Fvw.png\" width=\"80%\">\n</div>\n<p>除此之外还可以使用 BVH 来加速 LoD 选择。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dQ5NycI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vAt81U0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VyXHgbj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CKqErz8.png\" width=\"80%\">\n</div>\n<p>BVH 的构建过程还可以使用 job system 来进行加速。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DJU9z9A.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EPeNGyN.png\" width=\"80%\">\n</div>\n<h3 id=\"rasterization\"><a class=\"anchor\" href=\"#rasterization\">#</a> Rasterization</h3>\n<p>Nanite 在渲染时很多三角形的大小已经接近于屏幕上的一个像素，此时需要硬件光栅化来提供支持。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DcUzBNV.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2L4dedd.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KOjJXcx.png\" width=\"80%\">\n</div>\n<p>传统光栅化对于小三角形的支持不够好，在 Nanite 中会结合 compute shader 来实现软光栅。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p0KWN6k.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zgn7m1k.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3jznVLB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OhlqPzG.png\" width=\"80%\">\n</div>\n<p>在深度测试时，Nanite 还利用了一些 trick 进行加速。实际渲染过程与 V-buffer 渲染过程类似。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lA0BmDF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dTZ5FfI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZlRWBNX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0dvYGl4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UHqEgxm.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bjOgl25.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8pLyF6F.png\" width=\"80%\">\n</div>\n<h3 id=\"deferred-material\"><a class=\"anchor\" href=\"#deferred-material\">#</a> Deferred Material</h3>\n<p>Nanite 在绘制材质时会把材质信息转换为深度图，然后对可能出现的深度 (材质) 进行遍历。这样可以一次性绘制所有具有相同材质的像素。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3iTyUyS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p6VYBhZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kbHcpvm.png\" width=\"80%\">\n</div>\n<p>更新的 Nanite 版本还会把屏幕划分为若干个 tile，然后在每个 tile 上统计出现的材质。这样可以加速对全屏材质的遍历和绘制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GO4KN0V.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5cSCV2k.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/biIIKFK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EG9C6lG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/81dKGMu.png\" width=\"80%\">\n</div>\n<h3 id=\"virtual-shadow-map\"><a class=\"anchor\" href=\"#virtual-shadow-map\">#</a> Virtual Shadow Map</h3>\n<p>高精度几何模型还会导致阴影渲染时的困难，而且遗憾的是 Nanite 目前尚不支持实时光追来计算阴影。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LvILsze.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Fq0mN8i.png\" width=\"80%\">\n</div>\n<p>不过计算阴影时也可以结合 LoD，在距离相机不同远近的位置使用不同精度的模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Jp9JaI7.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aDHegzJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7MGXxSP.png\" width=\"80%\">\n</div>\n<p>在这种思想下 Nanite 提出了 virtual shadow map 来表示不同精度的物体。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/h3P1mNc.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BDaCBpa.png\" width=\"80%\">\n</div>\n<p>对于不同类型的光源也可以定制划分 virtual shadow map 的方式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dbDT3Gj.png\" width=\"80%\">\n</div>\n<p>当相机和光源都不变时我们可以把 shadow map 相关的信息写入 page 中方便下一帧读取。而如果相机和光源发生变化则只需更新一部分 page 即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vDtokJ4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Loxw6aU.png\" width=\"80%\">\n</div>\n<p>当然这种 virtual shadow map 在场景光源发生变化时会出现一些问题，因此比较适合主光源不变的场景。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nPoNSLA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/a9pK8mR.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jJIwY56.png\" width=\"80%\">\n</div>\n<h3 id=\"streaming-and-compression\"><a class=\"anchor\" href=\"#streaming-and-compression\">#</a> Streaming and Compression</h3>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9gGOXKY.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ammELtw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/L5pOE3O.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2a5GZ0x.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qVifIqC.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUV0NHkxUDdyby8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 22：GPU-Driven Geometry Pipeline-Nanite (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTdHNHkxeDdWWC8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 22：GPU-Driven Geometry Pipeline-Nanite (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%B8%80%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%B8%80%EF%BC%89/",
            "title": "games104系列笔记（二一）",
            "date_published": "2023-06-28T15:13:05.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的全局光照技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"global-illumination\"><a class=\"anchor\" href=\"#global-illumination\">#</a> Global Illumination</h2>\n<h3 id=\"the-rendering-equation\"><a class=\"anchor\" href=\"#the-rendering-equation\">#</a> The Rendering Equation</h3>\n<p><strong>全局光照 (global illumination, GI)<strong> 是渲染中的重要问题。在介绍 GI 在游戏引擎的实现方法前我们先回顾一下</strong>渲染方程 (the rendering equation)</strong>：</p>\n<div align=center>\n<img data-src=\"//pic1.xuehuaimg.com/proxy/i.imgur.com/QErTxYh.png\" width=\"80%\">\n</div>\n<p>可以说一切渲染问题的本质在于求解渲染方程，而求解渲染方程的难点在于方程自身的递归形式。当场景中的物体被光源照亮后，被照亮的物体又会成为新的光源再次照亮其它物体。以 Cornell box 为例，来自屋顶的灯光会照亮左右两侧红色和绿色的墙壁，然后墙壁反射的光线又会照亮盒子使得盒子的两侧呈现红色或是绿色，这样的现象称为<strong> color bleeding</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2hKEcOR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wokjNvq.png\" width=\"80%\">\n</div>\n<p>在复杂的游戏场景中通过 GI 会极大地提升画面表现力。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/guC0wgq.png\" width=\"80%\">\n</div>\n<h3 id=\"monte-carlo-integration\"><a class=\"anchor\" href=\"#monte-carlo-integration\">#</a> Monte Carlo Integration</h3>\n<p>作为积分方程，求解渲染方程的经典方法是<strong> Monte Carlo 积分 (Monte Carlo integration)</strong>。对于可积函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>，我们可以通过采样的方法来逼近<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 的积分。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mXysFHr.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/huDj09j.png\" width=\"80%\">\n</div>\n<p>** 光线追踪 (ray tracing)** 算法的本质就是通过 Monte Carlo 积分来求解渲染方程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uXDJtP6.png\" width=\"80%\">\n</div>\n<h3 id=\"importance-sampling\"><a class=\"anchor\" href=\"#importance-sampling\">#</a> Importance Sampling</h3>\n<p>Monte Carlo 积分的效率和精度取决于如何设计采样的样本。当样本的数量比较少或是质量比较低时，通过光线追踪渲染出的图像往往会具有非常多的噪声。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/c6PYK0k.png\" width=\"80%\">\n</div>\n<p>因此如何设计采样的分布对于提升渲染质量有着非常重要的意义，其中最简单的采样方法是均匀采样。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zd0jVdV.png\" width=\"80%\">\n</div>\n<p>现代高质量渲染的核心技术在于 ** 重要性采样 (importance sampling)** 的大规模应用。重要性采样理论指出当我们的采样函数接近于被积函数时只需要相对少的样本就可以很好地近似被积函数的积分，而在计算 Monte Carlo 积分时只需要对样本按照 pdf 进行加权求和即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FNRmpH1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bpna884.png\" width=\"80%\">\n</div>\n<p>回到渲染方程中，被积函数包含余弦项<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>cos</mi><mo>⁡</mo><msub><mi>θ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\cos \\theta_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mop\">cos</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，因此一个常见技巧是根据余弦项进行采样；类似地也可以按照 BRDF 来进行采样，这种采样方式对于光泽表面的物体往往有着更高的积分效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mbKK3Re.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BqLeQnj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QTDyg2I.png\" width=\"80%\">\n</div>\n<h2 id=\"reflective-shadow-maps\"><a class=\"anchor\" href=\"#reflective-shadow-maps\">#</a> Reflective Shadow Maps</h2>\n<p>尽管通过光线追踪可以解决 GI 的问题，但它的主要缺陷在于光线追踪基本无法应用在游戏这样有实时性要求的场景中。为了实现实时的 GI 人们设计了各种各样的算法来进行近似，其中最早的工作可以追溯到 2005 年的 **reflective shadow maps (RSM)** 算法。</p>\n<p>从实现的层面上讲，RSM 更接近于<strong>光子映射 (photon mapping)</strong>。光子映射理论认为相机接收到的 radiance 本质是由光源发射的光子经过场景不断的吸收和反射最终的被相机捕获的结果，因此我们可以从光源出发发射大量的光子然后计算光子在场景上的分布，然后通过相机来进行收集即可。</p>\n<p>在 RSM 中我们需要从光源的位置首先渲染一张 shadow map，它表示场景中所有被光源直接照射的部分。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XdBgWzn.png\" width=\"80%\">\n</div>\n<p>shadow map 记录了这些区域在直接光照下反射的 radiance，这样当我们需要考虑 GI 时只需要把直接光照和 shadow map 上记录的来自其它物体的反射光线进行相加即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ekv5MA6.png\" width=\"80%\">\n</div>\n<p>直接计算来自场景中其它物体的反射光线仍然需要非常多的计算量，在 RSM 中使用了<strong> cone tracing</strong> 的技术来进行简化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UmIxSMO.png\" width=\"80%\">\n</div>\n<p>由于间接光照一般来说是相对低频的，在渲染时还可以降低输出的分辨率进一步提升效率。然后在与直接光照相加时通过插值的方式来获得完整分辨率下的间接光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SkJwmwd.png\" width=\"80%\">\n</div>\n<p>通过 RSM 实现的 GI 可以明显提升游戏画面中阴影部分的细节。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/axoYNpE.png\" width=\"80%\">\n</div>\n<p>总结一下，RSM 作为实时 GI 的早期工作非常容易进行实现而且很高的计算效率；而它的缺陷在于 RSM 只能考虑光线的一次反射，而且在计算间接光照时没有进行可见性检测。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Z7y2cSB.png\" width=\"80%\">\n</div>\n<h2 id=\"light-propagation-volumes\"><a class=\"anchor\" href=\"#light-propagation-volumes\">#</a> Light Propagation Volumes</h2>\n<p>**light propagation volumes (LPV)** 是考虑光线在场景中不断传播的一种 GI 算法，最早在 2009 年提出。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mqArPC1.png\" width=\"80%\">\n</div>\n<p>LPV 的核心在于把场景使用三维的网格进行表示，并以此来计算光线在场景中的分布。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dZqKahH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Kil7CKW.png\" width=\"80%\">\n</div>\n<p>LPV 在计算时会记录每个格子上当光线传播到物体表面后散射的 radiance，然后以此为中心向其它格子进行扩散。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SpVvwuf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PKKTZ9G.png\" width=\"80%\">\n</div>\n<p>某种意义上讲 LPV 把光线的传播视为扩散过程，严格来说这样的处理是不完全遵循物理法则的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AbNoemA.png\" width=\"80%\">\n</div>\n<h2 id=\"sparse-voxel-octree-for-real-time-global-illumination\"><a class=\"anchor\" href=\"#sparse-voxel-octree-for-real-time-global-illumination\">#</a> Sparse Voxel Octree for Real-time Global Illumination</h2>\n<p>SVOGI 的思路与 LPV 非常接近，都使用了网格的方式来对场景空间进行划分。在 SVOGI 中使用了 ** 保守光栅化 (conservative rasterization)** 的方法来获取场景的体素表达，从而得到场景中所有表面的体素。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0MvWMYe.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xzfARJO.png\" width=\"80%\">\n</div>\n<p>为了更高效地管理场景中的体素，SVOGI 使用了八叉树这样的数据结构来把体素组织起来。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lfr6buZ.png\" width=\"80%\">\n</div>\n<p>在进行 shading 时则使用了 cone tracing 的方式来对八叉树进行查询。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lZHOASy.png\" width=\"80%\">\n</div>\n<h2 id=\"voxelization-based-global-illumination\"><a class=\"anchor\" href=\"#voxelization-based-global-illumination\">#</a> Voxelization Based Global Illumination</h2>\n<p>VXGI 可以看做是对 SVOGI 的简化。在 VXGI 中使用了 clip map 这样的数据结构来描述场景，离相机越近就具有越高的分辨率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/r5A7Qbt.png\" width=\"80%\">\n</div>\n<p>当相机发生运动时无需更新 clip map，只需要更新相机采样的范围即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3qSR9pn.png\" width=\"80%\">\n</div>\n<p>这样整个场景就得到了一个体素化表达，离相机近的地方体素越稠密，越远的地方体素越稀疏。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LUO4la2.png\" width=\"80%\">\n</div>\n<p>对于每个体素我们还需要计算该体素遮挡了多少的光线，这里会记录体素在三个方向上的可见性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VXGrh9X.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wzeX2fn.png\" width=\"80%\">\n</div>\n<p>当来自光源的光线注入到场景中时需要记录每个体素的表面上接收到的直接光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qpNupD8.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1De4J7C.png\" width=\"80%\">\n</div>\n<p>而对于屏幕上的像素则通过 cone tracing 的方式来计算间接光照，通过叠加整条光路上的 radiance 来获得间接光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mnl8t5h.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dQgCc4H.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3OTwyuW.png\" width=\"80%\">\n</div>\n<p>VXGI 的主要缺陷在于 cone tracing 的结构仍然是对间接光照的一种近似，而且它非常容易出现漏光的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YN6ko26.png\" width=\"80%\">\n</div>\n<h2 id=\"screen-space-global-illumination\"><a class=\"anchor\" href=\"#screen-space-global-illumination\">#</a> Screen Space Global Illumination</h2>\n<p>SSGI 和前面介绍过的方法相比是基于屏幕空间的 GI 技术。在现代 GPU 渲染管线中我们可以快速地渲染出屏幕空间上的各种物理量，通过重用屏幕空间的数据就可以实现 GI。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XWKgasA.png\" width=\"80%\">\n</div>\n<p>当我们渲染得到屏幕空间上的直接光照时，可以利用屏幕空间上像素的法向信息来继续计算间接光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oySPRvo.png\" width=\"80%\">\n</div>\n<p>计算间接光照时可以利用 ray marching 的方式来计算光线和平面空间中物体的交点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wk4IEdG.png\" width=\"80%\">\n</div>\n<p>为了进一步提升 ray marching 的效率，SSGI 还使用了 z-buffer 的 mipmap 来进行加速。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5x2fjcL.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FRPw4jw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aGiPlkJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RH5c9Hu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VtoSAcn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fkFLUF8.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WvvumNd.png\" width=\"80%\">\n</div>\n<p>同时 SSGI 还会对每一个像素来重复使用其相邻像素采样的间接光照，这样可以减少采样的光线数量从而进一步提升渲染效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Pr0GzS3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QknAVnz.png\" width=\"80%\">\n</div>\n<p>和前面介绍过的基于体素的 GI 技术相比，SSGI 对于光泽表面有非常好的渲染效果；但需要注意的是 SSGI 无法处理屏幕空间之外的物体，这容易导致各种错误的渲染结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yTfzdcs.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g5fU0Z8.png\" width=\"80%\">\n</div>\n<h2 id=\"lumen\"><a class=\"anchor\" href=\"#lumen\">#</a> Lumen</h2>\n<p><strong>Luman</strong> 是虚幻 5 引擎提出的最新实时 GI 技术。尽管实时光线追踪也可以实现实时 GI，但它依赖于硬件层面的实现而且需要大量的采样才能实现比较好的渲染效果。而 Luman 不依赖于硬件实现，可以应用到大量对实时性有需求的环境中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DVi3KhH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yvhFBH4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8trxnpf.png\" width=\"80%\">\n</div>\n<h3 id=\"fast-ray-trace-in-any-hardware\"><a class=\"anchor\" href=\"#fast-ray-trace-in-any-hardware\">#</a> Fast Ray Trace in Any Hardware</h3>\n<p>Luman 的渲染过程可以大致划分为 4 个部分，首先是进行高效的路径追踪。考虑到不是所有的硬件都支持光线追踪的加速，Luman 使用了<strong> SDF</strong> 的方式来实现这一过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aHJ6ycQ.png\" width=\"80%\">\n</div>\n<p>由于直接把场景转换成 SDF 往往是比较复杂的，我们可以先对每个物体转换为 SDF。对于平移变换和等比例的放缩，物体坐标系下的 SDF 都可以很容易地转换为场景坐标系下的 SDF。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bfQzQ05.png\" width=\"80%\">\n</div>\n<p>需要注意的是当物体比较薄时要进行一些额外的处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sw4Eenu.png\" width=\"80%\">\n</div>\n<p>SDF 的一大优势在于它可以非常容易地得到光线步进的长度：在任意 p 位置前进 SDF (p) 的距离总是可以保证不会和场景出现相交。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g9RS0mA.png\" width=\"80%\">\n</div>\n<p>同时，SDF 在进行 cone tracing 时也可以很容易地计算出遮挡面积比例的估计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/awD6Fvk.png\" width=\"80%\">\n</div>\n<p>生成 SDF 时可以考虑使用一些稀疏的数据结构进行表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Mkn3KRa.png\" width=\"80%\">\n</div>\n<p>SDF 甚至可以表达物体的不同 LOD。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kOw7VfQ.png\" width=\"80%\">\n</div>\n<p>在低 LOD 下结合 sparse mesh 可以极大地减少模型的存储空间。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lfx4j05.png\" width=\"80%\">\n</div>\n<p>当然，直接将场景中物体的 SDF 组合到一起在进行计算时仍然是过于复杂的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6jK2GgG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vyaXUxT.png\" width=\"80%\">\n</div>\n<p>这里可以结合屏幕空间的概念只考虑相机视野范围内的物体，将它们的 SDF 融合为一个低精度的全局 SDF。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qOM1eNS.png\" width=\"80%\">\n</div>\n<p>在这个低精度的全局 SDF 上进行 ray tracing 可以极大地降低计算压力。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XaoAnjP.png\" width=\"80%\">\n</div>\n<p>除此之外 SDF 也可以结合 mip 的思想，近处的精度高而远处精度低。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wsYS20w.png\" width=\"80%\">\n</div>\n<h3 id=\"radiance-injection-and-caching\"><a class=\"anchor\" href=\"#radiance-injection-and-caching\">#</a> Radiance Injection and Caching</h3>\n<p>接下来我们需要把光照信息注入到场景中。在 Lumen 中使用了<strong> mesh card</strong> 来保存物体在 6 个正方形上被光照亮后的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vh1Y4AY.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UZInL15.png\" width=\"80%\">\n</div>\n<p>对于每个 card 我们还需要记录物体表面的 albedo、法向以及深度等信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VZN64LC.png\" width=\"80%\">\n</div>\n<p>所有物体的表面信息会统一记录到一张标准大小的纹理图像上，称为<strong> surface cache</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/J1dKr8W.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/he2MFQA.png\" width=\"80%\">\n</div>\n<p>根据物体距离相机的远近还可以设置不同的 card 分辨率以降低存储和计算需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jOBTRJW.png\" width=\"80%\">\n</div>\n<p>我们的目标是把物体所有光照的 radiance 记录到 surface cache 上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WVazsi5.png\" width=\"80%\">\n</div>\n<p>在 Lumen 中整个光照可分解为直接光照、体素化光照以及间接光照三部分。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FfKT5h8.png\" width=\"80%\">\n</div>\n<p>直接光照相对比较简单，我们只需要考虑光源直接照射到物体上反射的 radiance 即可。对于阴影中的物体则可以结合 shadow map 来进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sXxDa1S.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tuAQkhB.png\" width=\"80%\">\n</div>\n<p>得到直接光照后 Lumen 会对场景进行体素化来存储物体在 6 个方向上直接光照的亮度。而且体素化后的光照信息会在相邻帧上进行传递，随着时间的积累会得到光线多次弹射的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bl2W3pc.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Wz5FXG7.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MqTMqR1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mifxBnk.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pvKJKhg.png\" width=\"80%\">\n</div>\n<p>最后计算间接光照时只需要从 surface cache 上进行采样，利用上一步体素化光照作为照明即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mZ3d1Sx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/f9prX01.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jP0AMxn.png\" width=\"80%\">\n</div>\n<p>把直接光照和间接光照相加就得到了环境中光照的信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jC5FQXK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z8nILPV.png\" width=\"80%\">\n</div>\n<h3 id=\"build-a-lot-of-probes-with-different-kinds\"><a class=\"anchor\" href=\"#build-a-lot-of-probes-with-different-kinds\">#</a> Build a lot of Probes with Different Kinds</h3>\n<h4 id=\"screen-space-probe\"><a class=\"anchor\" href=\"#screen-space-probe\">#</a> Screen Space Probe</h4>\n<p>有了光照后我们需要在物体表面通过采样来计算着色，此时我们需要在场景中放置 ** 探针 (probe)** 来采样光照。Lumen 中直接在屏幕空间里放置 probe，每个 probe 会同时记录光线前进的距离以及收集到的 radiance。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VgdvQGB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/006g2B0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VRDNkVw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VQ94vxR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NOodpnE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UvYvEHf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zhjSeyZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sb0YOvv.png\" width=\"80%\">\n</div>\n<h4 id=\"importance-sampling-2\"><a class=\"anchor\" href=\"#importance-sampling-2\">#</a> Importance Sampling</h4>\n<p>为了提升渲染质量我们需要使用重要性采样的技术尽可能在比较重要的方向上进行采样。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3JKEnmG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dx3MYx9.png\" width=\"80%\">\n</div>\n<p>回到 Monte Carlo 积分的公式中，我们需要把光线更多地分布在光照比较强或是接近物体法线的方向上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/S1neliN.png\" width=\"80%\">\n</div>\n<p>Lumen 中会对上一帧以及四周相邻的 probe 进行平均来估计光照的分布。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6leqAhj.png\" width=\"80%\">\n</div>\n<p>而对于物体法向附近的方向，Lumen 会估计 probe 附近的法向分布。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ze229M3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Fn4QTe9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BOdAmpj.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/n0XdleD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Dcki2jC.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nuHBA28.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B1mJcUA.png\" width=\"80%\">\n</div>\n<h4 id=\"denoising-and-spatial-probe-filtering\"><a class=\"anchor\" href=\"#denoising-and-spatial-probe-filtering\">#</a> Denoising and Spatial Probe Filtering</h4>\n<p>为了进一步提升渲染效果我们还需要对图像进行滤波降噪。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/S6WruqB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NQzkbjB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iMnqBfZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ylJXhz4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8qPkbQU.png\" width=\"80%\">\n</div>\n<h4 id=\"world-space-probes-and-ray-connecting\"><a class=\"anchor\" href=\"#world-space-probes-and-ray-connecting\">#</a> World Space Probes and Ray Connecting</h4>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0BcwerI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3Tm04xJ.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rJBVlCh.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vCO0LYl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gBzUQZ9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Sjg0xl3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Qyo4nzF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DW1gJZq.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4RC5kGK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6qzEI9w.png\" width=\"80%\">\n</div>\n<h3 id=\"shading-full-pixels-with-screen-space-probes\"><a class=\"anchor\" href=\"#shading-full-pixels-with-screen-space-probes\">#</a> Shading Full Pixels with Screen Space Probes</h3>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/E8xnzbw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6ShDBdx.png\" width=\"80%\">\n</div>\n<h3 id=\"overall-performance-and-result\"><a class=\"anchor\" href=\"#overall-performance-and-result\">#</a> Overall, Performance and Result</h3>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OGrZx0U.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Du1JFo0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9lFxUih.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XorQ4VJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vSlN6Ff.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uqTW2ka.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jfUcHRd.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cLZvdcK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VZr10cL.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Uid83XJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hcc7Mrp.png\" width=\"80%\">\n</div>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1aOH2Bk.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW9lNDExdTdESi8/dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 21：Dynamic Global Illumination and Lumen (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlhNDExZzdUaC8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 21：Dynamic Global Illumination and Lumen (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/",
            "title": "games104系列笔记（二十）",
            "date_published": "2023-06-28T15:01:33.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍面向数据编程以及任务系统在游戏引擎中的应用。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>现代游戏引擎对于性能的需求非常高，为了保证游戏的实时性需要使用大量的高性能编程技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/n4izpFM.png\" width=\"80%\">\n</div>\n<h2 id=\"basics-of-parallel-programming\"><a class=\"anchor\" href=\"#basics-of-parallel-programming\">#</a> Basics of Parallel Programming</h2>\n<p>随着硬件技术的发展，芯片中晶体管的数量已经接近了物理极限。因此在现代计算机中会使用 ** 多核 (multi-core)** 处理器来进一步提升计算性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jJCUbEH.png\" width=\"80%\">\n</div>\n<h3 id=\"process-and-thread\"><a class=\"anchor\" href=\"#process-and-thread\">#</a> Process and Thread</h3>\n<p>** 进程 (process)<strong> 和</strong>线程 (thread)** 是并行编程会涉及到的基本概念。简单来说一个程序就是一个进程，它拥有自己的内存空间；而一个进程可以拥有很多线程，它们会共享进程指向的同一片内存数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZXcQyWy.png\" width=\"80%\">\n</div>\n<h3 id=\"types-of-multitasking\"><a class=\"anchor\" href=\"#types-of-multitasking\">#</a> Types of Multitasking</h3>\n<p>对于多核的计算机我们希望能够充分利用不同的计算核心来提升程序的性能。根据处理器管理任务的不同可以把进程调度分为两种：** 抢占式 (preemptive multitasking)<strong> 和</strong>非抢占式 (non-preemptive multitasking)** 式。preemptive multitasking 是由调度器来控制任务的切换，而 non-preemptive multitasking 则是由任务自身来进行控制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tdkyo1m.png\" width=\"80%\">\n</div>\n<h3 id=\"thread-context-switch\"><a class=\"anchor\" href=\"#thread-context-switch\">#</a> Thread Context Switch</h3>\n<p>线程在进行切换时会产生额外的开销，因此在游戏引擎中我们希望尽可能减少线程的上下文切换。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/THTA4rT.png\" width=\"80%\">\n</div>\n<h3 id=\"parallel-problems-in-parallel-computing\"><a class=\"anchor\" href=\"#parallel-problems-in-parallel-computing\">#</a> Parallel Problems in Parallel Computing</h3>\n<p>在并行程序中我们希望不同的任务之间互不打扰，只需要在程序最后把所有的计算结果进行汇总就好。这样的程序往往有着非常高的运行效率，比如说 Monte Carlo 模拟就是典型的例子。不过现实中的程序往往不会这样理想，很多任务之间存在各种相互依赖，这会降低程序的运行效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/af0Rea9.png\" width=\"80%\">\n</div>\n<h3 id=\"data-race-in-parallel-programming\"><a class=\"anchor\" href=\"#data-race-in-parallel-programming\">#</a> Data Race in Parallel Programming</h3>\n<p><strong>data race</strong> 是编写并行程序中最常见的问题，当不同的线程想要访问并修改同一块内存时就会产生 data race。由于线程的调度是不可预料的，data race 会导致程序的计算结果出现各种各样的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6XW6ewO.png\" width=\"80%\">\n</div>\n<h4 id=\"blocking-algorithm\"><a class=\"anchor\" href=\"#blocking-algorithm\">#</a> Blocking Algorithm</h4>\n<p>处理 data race 最简单的方式是给程序<strong>上锁 (lock)</strong>，这样可以保证同一时间只能有一个线程对指定的内存区域进行访问。锁之间的程序片断称为<strong> critical section</strong>，当某个线程执行 critical section 时其它需要访问同一内存的线程会被强制等待。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j1n5Zax.png\" width=\"80%\">\n</div>\n<p>尽管使用锁可以保证程序的正确执行，但锁的存在会影响程序的并行性。更严重的是它可能会产生 ** 死锁 (dead lock)** 的现象从而阻塞程序的运行。因此在编写并行程序时需要注意尽可能减少锁的使用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/h6rClgJ.png\" width=\"80%\">\n</div>\n<h4 id=\"atomic-operation\"><a class=\"anchor\" href=\"#atomic-operation\">#</a> Atomic Operation</h4>\n<p>处理 data race 的另一种常用方法是使用<strong>原子操作 (atomic operation)</strong>。原子操作是硬件层面实现的最基本操作，它无法同时被多个 CPU 一起执行。利用原子操作可以实现无锁的程序并行，从而极大地提升运行效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DaOv4bG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UaGzzhG.png\" width=\"80%\">\n</div>\n<h4 id=\"complier-reordering-optimizations\"><a class=\"anchor\" href=\"#complier-reordering-optimizations\">#</a> Complier Reordering Optimizations</h4>\n<p>另一方面需要注意的是现代编译器对于高级语言是可以进行自动优化的。通过调整代码的执行顺序可以提升单线程程序的运行效率，但对于多线程的情况这种调整则可能会导致一些问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lJ5go39.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JBLswBA.png\" width=\"80%\">\n</div>\n<p>实际上很多的现代芯片出于种种方面的考虑都无法保证多线程情况下编译后代码的执行顺序。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pqU3uW8.png\" width=\"80%\">\n</div>\n<h2 id=\"parallel-framework-of-game-engine\"><a class=\"anchor\" href=\"#parallel-framework-of-game-engine\">#</a> Parallel Framework of Game Engine</h2>\n<h3 id=\"fixed-multi-thread\"><a class=\"anchor\" href=\"#fixed-multi-thread\">#</a> Fixed Multi-Thread</h3>\n<p>游戏引擎在使用多线程时最经典的架构是<strong> fixed multi-thread</strong>，此时引擎中的每个系统都各自拥有一个线程。在每一帧开始时会通过线程间的通信来交换数据，然后各自执行自己的任务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ouQEYc2.png\" width=\"80%\">\n</div>\n<p>fixed multi-thread 的一个缺陷在于它很难保证不同线程上负载是一致的。实际上不同线程之间负载的差异往往非常巨大，很多时候一些线程已经完成了自己的任务却必须要等待其它线程结束。这就造成了计算资源的浪费。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4QD7Os7.png\" width=\"80%\">\n</div>\n<h3 id=\"thread-fork-join\"><a class=\"anchor\" href=\"#thread-fork-join\">#</a> Thread Fork-Join</h3>\n<p>另一种并行处理的方式是<strong> fork-join</strong>。对于某些负载比较高的系统我们可以实现申请一系列线程，当需要执行计算时通过 fork 操作把不同的计算任务分配到各个线程中并最后汇总到一起。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mZimjhq.png\" width=\"80%\">\n</div>\n<p>fork-join 的缺陷在于有很多的任务是无法事先预测具体的负载的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sqNrEQU.png\" width=\"80%\">\n</div>\n<p>在虚幻引擎中设计了 name thread 和 worker thread 两种类型的线程。其中 name thread 对应引擎中的不同系统，而 worker thread 则是系统中具体计算任务的线程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g92VyeU.png\" width=\"80%\">\n</div>\n<h3 id=\"task-graph\"><a class=\"anchor\" href=\"#task-graph\">#</a> Task Graph</h3>\n<p>除此之外还可以使用<strong> task graph</strong> 来处理多线程，task graph 会根据不同任务之间的依赖性来决定具体的执行顺序以及需要进行并行的任务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/R93aA32.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9W9WcXV.png\" width=\"80%\">\n</div>\n<h2 id=\"job-system\"><a class=\"anchor\" href=\"#job-system\">#</a> Job System</h2>\n<h3 id=\"coroutine\"><a class=\"anchor\" href=\"#coroutine\">#</a> Coroutine</h3>\n<p>** 协程 (coroutine)** 是一种轻量的线程上下文切换机制，它允许函数在执行过程中临时切换到协程上然后再切换回来。和线程相比，协程无需硬件层面上的数据切换，可以由程序自己进行定义，也不需要进入系统内核执行 interruption。因此协程要比线程切换高效的多。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zYk2WG5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4K5bxSp.png\" width=\"80%\">\n</div>\n<h4 id=\"stackful-coroutine\"><a class=\"anchor\" href=\"#stackful-coroutine\">#</a> Stackful Coroutine</h4>\n<p>协程有两种实现方式。首先是使用栈来保存函数切换时的状态，当协程切换回来后根据栈上的数据来恢复之前的状态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/o0mpzYa.png\" width=\"80%\">\n</div>\n<h4 id=\"stackless-coroutine\"><a class=\"anchor\" href=\"#stackless-coroutine\">#</a> Stackless Coroutine</h4>\n<p>另一种实现方式是不保存函数切换时的状态，当协程切换回来后按照当前的状态继续执行程序。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/o2xyE3l.png\" width=\"80%\">\n</div>\n<p>在实践中一般推荐使用基于栈来实现的协程。尽管它在进行切换时的开销要稍微多一些，但可以避免状态改变导致的各种问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0onKFv9.png\" width=\"80%\">\n</div>\n<h3 id=\"fiber-based-job-system\"><a class=\"anchor\" href=\"#fiber-based-job-system\">#</a> Fiber-Based Job System</h3>\n<p>基于协程的思想可以实现<strong> fiber-based job system</strong>。在这种任务系统中 job 会通过 fiber 来进行执行，在线程进行计算时通过 fiber 的切换来减少线程调度的开销。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RWfrZAo.png\" width=\"80%\">\n</div>\n<p>对于多核的情况我们希望尽可能保证一个线程对应一个核 (包括逻辑核)，这样可以进一步减少线程切换带来的额外开销。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/35O1kTr.png\" width=\"80%\">\n</div>\n<p>在执行计算时根据程序的需要生成大量的 job，然后调度器根据线程负载分配到合适的线程以及线程上的 fiber 中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uNQRZQH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/paEmijU.png\" width=\"80%\">\n</div>\n<p>在执行 job 时根据计算顺序可以分为 FIFO 以及 LIFO 两种模式，在实践工程中一般会选择 LIF。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Yqgz4Dj.png\" width=\"80%\">\n</div>\n<p>当 job 出现依赖时会把当前的 job 移动到等待区然后执行线程中的下一个 job。这样的方式可以减少 CPU 的等待，提高程序效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7XJlq5G.png\" width=\"80%\">\n</div>\n<p>如果出现了线程闲置的情况，调度器会把其他线程中的 job 移动到闲置线程中进行计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/X0OhYKv.png\" width=\"80%\">\n</div>\n<p>和上面介绍过的多线程方法相比，任务系统可以更好地利用多核并且避免线程切换从而提升计算性能。不过目前原生 C++ 暂不支持协程，而且在不同的操作系统中任务系统的实现往往是不同的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zUutz2a.png\" width=\"80%\">\n</div>\n<h2 id=\"programming-paradigms\"><a class=\"anchor\" href=\"#programming-paradigms\">#</a> Programming Paradigms</h2>\n<p>除了硬件之外，** 编程范式 (programming paradigms)** 对于程序的性能也会有一定的影响。在游戏引擎中我们会使用各种类型的编程范式来实现各种各样的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VHpBnKC.png\" width=\"80%\">\n</div>\n<h3 id=\"procedural-oriented-programming\"><a class=\"anchor\" href=\"#procedural-oriented-programming\">#</a> Procedural-Oriented Programming</h3>\n<p>早期的游戏一般是使用 ** 面向过程编程 (procedural-oriented programming, POP)** 来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qyqb62v.png\" width=\"80%\">\n</div>\n<h3 id=\"object-oriented-programming\"><a class=\"anchor\" href=\"#object-oriented-programming\">#</a> Object-Oriented Programming</h3>\n<p>随着游戏系统变得不断复杂，** 面向对象编程 (object-oriented programming, OOP)** 的思想在现代游戏引擎中起着越来越重要的作用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ti89OFt.png\" width=\"80%\">\n</div>\n<h3 id=\"problems-of-oop\"><a class=\"anchor\" href=\"#problems-of-oop\">#</a> Problems of OOP</h3>\n<p>然而在大量的实践中人们发现 OOP 也不是完美的，一个最常见的问题是 OOP 存在二义性：角色的攻击行为既可以写在角色身上，也可以写在被攻击者身上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ppamXnP.png\" width=\"80%\">\n</div>\n<p>同时 OOP 中存在大量的继承关系，有时很难去查询对象的方法具体是在那个类中实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zZ52pQT.png\" width=\"80%\">\n</div>\n<p>另外 OOP 中的基类往往需要提供非常多的功能，对于很多派生子类来说这样的基类实在过于臃肿了。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nCymIMH.png\" width=\"80%\">\n</div>\n<p>OOP 最大的问题在于它的性能可能是很低的。尽管 OOP 很符合人的认识，但对象的数据往往分布在不同的内存区域上。这就导致程序运行时会浪费大量的时间来读取数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fkdRrTK.png\" width=\"80%\">\n</div>\n<p>最后，OOP 的可测试性非常差。当我们想要去测试对象的某个方法是否按照我们的期望运作时，往往需要从头创建出整个对象，这与单元测试的思想是相违背的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Dxh8FNW.png\" width=\"80%\">\n</div>\n<h2 id=\"data-oriented-programming\"><a class=\"anchor\" href=\"#data-oriented-programming\">#</a> Data-Oriented Programming</h2>\n<p>** 面向数据编程 (data-oriented programming, DOP)** 是现代游戏引擎中越来越流行的一种编程范式。现代计算机的发展趋势是 CPU 运行速度越来越快，但是相对地内存访问的速度却跟不上 CPU 计算的速度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q2Q6Nfu.png\" width=\"80%\">\n</div>\n<h3 id=\"cache\"><a class=\"anchor\" href=\"#cache\">#</a> Cache</h3>\n<p>为了解决的问题人们设计了 ** 缓存 (cache)** 这样的机制来加快内存的访问。一般来说现代计算机都有多级缓存系统，越底层的缓存容量越小但访问速度越快。通过缓存机制我们可以把内存中的数据先放到缓存中来加快 CPU 的访问速度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ks5babw.png\" width=\"80%\">\n</div>\n<h3 id=\"principle-of-locality\"><a class=\"anchor\" href=\"#principle-of-locality\">#</a> Principle of Locality</h3>\n<p>利用缓存机制进行编程时就需要考虑数据的<strong> locality</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jFgY0dN.png\" width=\"80%\">\n</div>\n<h4 id=\"single-instruction-multiple-data\"><a class=\"anchor\" href=\"#single-instruction-multiple-data\">#</a> Single Instruction Multiple Data</h4>\n<p><strong>SIMD</strong> 是利用缓存机制实现高性能编程的经典案例。现代 CPU 基本都实现了 SIMD 机制，这样可以在一个指令中同时处理 4 个操作。因此我们可以把数据尽可能组织成 SIMD 的格式来对程序进行加速。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zuDYYPF.png\" width=\"80%\">\n</div>\n<h4 id=\"least-recently-used\"><a class=\"anchor\" href=\"#least-recently-used\">#</a> Least Recently Used</h4>\n<p><strong>LRU</strong> 同样是高性能编程中的常用的技巧。当缓存满了后系统会把最不常用的数据置换出去，只留下近期用过的数据从而提升缓存的利用率。在实践中也会采用随机丢弃数据的策略，可以证明这样的策略拥有更好的性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PU2yrzW.png\" width=\"80%\">\n</div>\n<h3 id=\"cache-line\"><a class=\"anchor\" href=\"#cache-line\">#</a> Cache Line</h3>\n<p>当缓存中的数据进行读写时，不是对单个数据进行操作而是直接读写一条 cache line 上的全部数据 (一般是 64 byte)。实际上 CPU 的读写操作都是以 cache line 作为单位来执行的，因此需要操作系统来保证 CPU 读写缓存以及内存数据时的顺序和一致性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Gnz5Fyl.png\" width=\"80%\">\n</div>\n<p>因此我们在设计数据的存储形式时就可以利用 cache line 的机制来加速访问。以矩阵这种数据格式为例，按照行来进行存储的矩阵往往要比按照列来存储的有更高的读写效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/INwVsd9.png\" width=\"80%\">\n</div>\n<h3 id=\"data-oriented-programming-2\"><a class=\"anchor\" href=\"#data-oriented-programming-2\">#</a> Data-Oriented Programming</h3>\n<p>DOP 的核心思想在于把游戏世界 (包括代码) 认为是数据的集合，在编写程序时要尽可能利用缓存同时避免 cache miss。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Dbp3kph.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/odyfyVG.png\" width=\"80%\">\n</div>\n<p>因此在 DOP 中我们会把数据和代码看做一个整体，同时使它们在缓存中的分布尽可能地集中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/P5rpu32.png\" width=\"80%\">\n</div>\n<h2 id=\"performance-sensitive-programming\"><a class=\"anchor\" href=\"#performance-sensitive-programming\">#</a> Performance-Sensitive Programming</h2>\n<h3 id=\"reducing-order-dependency\"><a class=\"anchor\" href=\"#reducing-order-dependency\">#</a> Reducing Order Dependency</h3>\n<p>那么如何基于 DOP 的思想来设计高性能的程序呢？首先我们需要避免程序对于代码执行顺序的依赖。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Tr379sN.png\" width=\"80%\">\n</div>\n<h3 id=\"false-sharing-in-cache-line\"><a class=\"anchor\" href=\"#false-sharing-in-cache-line\">#</a> False Sharing in Cache Line</h3>\n<p>对于多线程的程序要避免两个线程同时访问同一块数据，我们希望不同的线程之间尽可能地相互独立。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tQ6HTQ2.png\" width=\"80%\">\n</div>\n<h3 id=\"branch-prediction\"><a class=\"anchor\" href=\"#branch-prediction\">#</a> Branch Prediction</h3>\n<p>对于包含分支的程序，CPU 会对程序可能选择的分支进行预测并把最有可能直线的指令提前送到缓存中，如果程序选择了不常见的分支则往往需要从内存中重新读取相应的指令从而降低程序性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M0OgVIl.png\" width=\"80%\">\n</div>\n<p>因此在设计程序时要尽可能保证具有相同分支的程序在一起执行，比如说可以通过对数据进行排序的方式来避免错误的分支预测。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6gXqtzq.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AGin0Fw.png\" width=\"80%\">\n</div>\n<p>更通用的方法是按照业务逻辑对数据进行分组，每一组中只使用相同的函数进行处理。这样可以完全避免分支判断从而极大地提升程序性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FIpvGmR.png\" width=\"80%\">\n</div>\n<h2 id=\"performance-sensitive-data-arrangements\"><a class=\"anchor\" href=\"#performance-sensitive-data-arrangements\">#</a> Performance-Sensitive Data Arrangements</h2>\n<p>当然数据的组织方式对于程序性能也有巨大的影响。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dlPYY4S.png\" width=\"80%\">\n</div>\n<p>一个经典的案例是 AOS 和 SOA。根据 OOP 的思想，我们可以把数据封装到不同对象中然后使用一个数组作为这些对象的容器，这种组织方式称为<strong> AOS (array of structure)</strong>；或者直接对数据进行封装把所有数据放到一个巨大的对象中，称为<strong> SOA (structure of array)</strong>。当程序需要对数据进行访问时 AOS 往往会产生大量的 cache miss，因此在高性能编程中更推荐使用 SOA 的组织方式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0WtRXuF.png\" width=\"80%\">\n</div>\n<h2 id=\"entity-component-system\"><a class=\"anchor\" href=\"#entity-component-system\">#</a> Entity Component System</h2>\n<p>本节课最后介绍了现代游戏引擎中的<strong> ECS 架构 (entity component system)</strong>。回忆在前面的课程中我们介绍过基于 OOP 来对组件进行编程，然后通过继承的方式来实现具体的 GO。就像前面介绍过的那样，这种编程范式是相对低效的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hTwkXA4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HZueMMt.png\" width=\"80%\">\n</div>\n<p>而在 ECS 架构中则使用了 entity 的概念将不同的组件组织起来。entity 实际上只是一个 ID，用来指向一组 component。而 ECS 架构中的 component 则只包括各种类型的数据，不包含任何具体的业务逻辑。当需要执行具体的计算和逻辑时则需要调用 system 来修改 component 中的数据。这样游戏中的数据可以集中到一起进行管理，从而极大地提升数据读写的效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DZ30zN6.png\" width=\"80%\">\n</div>\n<h3 id=\"unity-data-oriented-tech-stacks\"><a class=\"anchor\" href=\"#unity-data-oriented-tech-stacks\">#</a> Unity Data-Oriented Tech Stacks</h3>\n<p>unity 中的 **DOTS 系统 (data-oriented tech stacks)** 就是基于 ECS 架构来实现的，同时它还结合了 C# 任务系统用来进行并行化以及设计了 burst 编译器来优化代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NwsFdXo.png\" width=\"80%\">\n</div>\n<p>在 unity 的 ECS 架构中设计了 archetype 来对不同类型的 entity 进行抽象，这样具有相似功能的 entity 可以组织到一起方便管理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ypaM5VW.png\" width=\"80%\">\n</div>\n<p>在内存中系统会为不同的 archetype 分配不同大小的存储空间，称为 chunk。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1CWrVU6.png\" width=\"80%\">\n</div>\n<p>对于 system 而言只需要一次性更新 chunk 中的相关数据即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IphCaFO.png\" width=\"80%\">\n</div>\n<p>而为了支持这样的高性能架构还需要 native 级别的任务系统、容器以及安全检查，也因此 unity 需要定制编译器来把 C# 代码编译成更底层的代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZLp50TE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rsHFQLi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/szm9KVI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/28DBypw.png\" width=\"80%\">\n</div>\n<h3 id=\"unreal-mass-system\"><a class=\"anchor\" href=\"#unreal-mass-system\">#</a> Unreal Mass System</h3>\n<p>虚幻引擎中使用了<strong> Mass</strong> 系统来实现 ECS 架构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BuBKD3x.png\" width=\"80%\">\n</div>\n<p>Mass 系统与 DOTS 非常类似，都使用了 entity 作为 component 的索引 ID。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fGdrKKs.png\" width=\"80%\">\n</div>\n<p>Mass 系统中的 component 称为 fragment，用来强调它只具有数据的属性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/K7sO3oV.png\" width=\"80%\">\n</div>\n<p>而 system 则称为 processor，这表示它只承担业务逻辑的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5l4LoQd.png\" width=\"80%\">\n</div>\n<p>processor 需要实现 query 和 excute 两个接口。前者表示在内存中选出所需的 entity，而后者则是不同 system 执行的逻辑。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pN2QnoU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Qcmnrn5.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/E35mzqs.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUVQNDExVjdqeC8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 20：Data-Oriented Programming and Job System (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMU1kNHkxRzd6cC8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 20：Data-Oriented Programming and Job System (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/",
            "title": "games104系列笔记（十九）",
            "date_published": "2023-06-28T15:01:26.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍网络游戏架构的高级技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"character-movement-replication\"><a class=\"anchor\" href=\"#character-movement-replication\">#</a> Character Movement Replication</h2>\n<p>** 角色位移同步 (character movement replication)** 是现代大型网络游戏必须要实现的功能。由于网络环境的不稳定，玩家操作角色在自己视角和其他玩家视角下的行为往往会有一定的延迟，即角色在其他玩家视角下的动作会滞后于操作玩家的第一视角。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tFMlMp2.png\" width=\"80%\">\n</div>\n<h3 id=\"interpolation-extrapolation\"><a class=\"anchor\" href=\"#interpolation-extrapolation\">#</a> Interpolation &amp; Extrapolation</h3>\n<p>在这种情况下我们可以使用 ** 内插 (interpolation)<strong> 和</strong>外插 (extrapolation)** 两种插值方法来缓解延迟。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yqZyoVf.png\" width=\"80%\">\n</div>\n<h4 id=\"interpolation\"><a class=\"anchor\" href=\"#interpolation\">#</a> Interpolation</h4>\n<p>内插是指利用已知的控制点来获得中间的状态。当网络存在波动时利用内插的方法可以保证角色的动作仍然是足够平滑的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CmimxUn.png\" width=\"80%\">\n</div>\n<p>在具体进行插值时还可以人工设置一个 offset 来保证 buffer 中有足够多的控制点，这样虽然会提高一些延迟但可以获得更加光滑稳定的插值结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4TztLxV.png\" width=\"80%\">\n</div>\n<p>当然内插也存在一些问题。由于内插加剧了网络延迟的问题，同样的游戏世界在操作者和其他玩家的视角下会有非常大的差别。这样的问题在一些延迟要求很高的游戏中可能是不可接受的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fdKLO6w.png\" width=\"80%\">\n</div>\n<h4 id=\"extrapolation\"><a class=\"anchor\" href=\"#extrapolation\">#</a> Extrapolation</h4>\n<p>相比于内插，外插的本质是利用已有的信息来预测未来的状态。当我们对网络延迟有一定的估计时就可以通过外插的方法来推断角色的状态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/616YGbl.png\" width=\"80%\">\n</div>\n<p>实际上外插的思想在很多领域都有非常多的应用，dead reckoning 算法那就是外插在导航领域的实践。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XFPxN6h.png\" width=\"80%\">\n</div>\n<h3 id=\"projective-velocity-blending\"><a class=\"anchor\" href=\"#projective-velocity-blending\">#</a> Projective Velocity Blending</h3>\n<p>回到游戏领域的应用中来，**projective velocity blending (PVB)** 是一种使用外插来更新角色位置的算法。假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 时刻角色的位置、速度和加速度分别为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">p_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">a_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，而收到来自服务器同步的位置、速度和加速度则是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>p</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">p_0&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>v</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">v_0&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>a</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">a_0&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span>。假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>B</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 时间内没有意外状况发生，则<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 时刻角色的位置为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msubsup><mi>p</mi><mi>t</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>=</mo><msubsup><mi>p</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>+</mo><msubsup><mi>v</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mi>t</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mi>a</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><msup><mi>t</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">p_t&#x27; = p_0&#x27; + v_0&#x27; t + \\frac{1}{2} a_0&#x27; t^2\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0489em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0489em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0489em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>我们的目的是通过调整速度使得角色可以在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>B</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 时刻到达位置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>d</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，因此首先对速度进行插值：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub><mo>=</mo><msub><mi>v</mi><mn>0</mn></msub><mo>+</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><msubsup><mi>v</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>−</mo><msub><mi>v</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v_t = v_0 + \\lambda (v_0&#x27; - v_0)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0519em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>λ</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mo>−</mo><msub><mi>t</mi><mn>0</mn></msub></mrow><mrow><msub><mi>t</mi><mi>B</mi></msub><mo>−</mo><msub><mi>t</mi><mn>0</mn></msub></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\lambda = \\frac{t - t_0}{t_B - t_0}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1281em;vertical-align:-0.836em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2921em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.836em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>上式意味着对速度进行线性插值使得<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>B</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 时刻具有速度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。接下来再对位置进行线性插值即可：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><msub><mi>p</mi><mn>0</mn></msub><mo>+</mo><msub><mi>v</mi><mi>t</mi></msub><mi>t</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mi>a</mi><mn>0</mn><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><msup><mi>t</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">p_t = p_0 + v_t t + \\frac{1}{2} a_0&#x27; t^2\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0074em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3214em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">2</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi>p</mi><mi>d</mi></msub><mo>=</mo><msub><mi>p</mi><mi>t</mi></msub><mo>+</mo><mi>λ</mi><mo stretchy=\"false\">(</mo><msubsup><mi>p</mi><mi>t</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p_d = p_t + \\lambda (p_t&#x27; - p_t)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0519em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">λ</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8019em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cfkbSI3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/T2xxB3l.png\" width=\"80%\">\n</div>\n<p>这里需要注意的是 PVB 算法并不符合动力学原理，它仅仅是一种插值方法。</p>\n<h3 id=\"collision-issues\"><a class=\"anchor\" href=\"#collision-issues\">#</a> Collision Issues</h3>\n<p>外插在处理碰撞时会容易产生严重的物体穿插问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cfkbSI3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FTNokpo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dnTfCgL.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LjMsRPj.png\" width=\"80%\">\n</div>\n<p>要处理这样的情况一般需要切换到本地物理引擎来处理碰撞问题，比如说在看门狗 2 中就使用了这样的方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bLAd2fC.png\" width=\"80%\">\n</div>\n<h3 id=\"usage-scenarios\"><a class=\"anchor\" href=\"#usage-scenarios\">#</a> Usage Scenarios</h3>\n<p>简单总结一下，对于玩家操作角色经常出现瞬移或是具有很大加速度的情况比较适合内插，对于操作角色比较符合物理规律的情况比较适合外插，而在一些大型在线游戏中还会同时结合这两种插值方法来提升玩家的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/b0y65Aj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DyzYnkN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lhECvgQ.png\" width=\"80%\">\n</div>\n<h2 id=\"hit-registration\"><a class=\"anchor\" href=\"#hit-registration\">#</a> Hit Registration</h2>\n<p>** 命中判定 (hit registration)** 同样是现代网络游戏必须要提供的基本服务。以 FPS 游戏为例，从玩家开枪到击中敌人这一过程实际上有着非常大的一段延迟，在各种不确定因素的影响下如何判断玩家确实击中目标就需要一些专门的设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qC70S6X.png\" width=\"80%\">\n</div>\n<h3 id=\"challenges\"><a class=\"anchor\" href=\"#challenges\">#</a> Challenges</h3>\n<p>命中判定的难点之一在于确定敌人在什么位置。由于网络延迟和插值算法的存在，玩家视角下的目标是落后于服务器上目标的真实位置的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eIXnga5.png\" width=\"80%\">\n</div>\n<p>命中判定的另一个难点在于如何判定是否击中了目标。在游戏场景中目标往往是运动的，而且往往会位于一些掩体附近。当弹道不是瞬间命中时就需要一些额外的算法来进行判断。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hIE2zD5.png\" width=\"80%\">\n</div>\n<h3 id=\"client-side-hit-detection\"><a class=\"anchor\" href=\"#client-side-hit-detection\">#</a> Client-Side Hit Detection</h3>\n<p>因此命中判定的目标是保证游戏中的玩家就是否命中的问题能够达成一个<strong>共识 (consensus)</strong>。目前主流的处理方法包括在客户端上进行检测，称为<strong> client-side hit detection</strong>，以及在服务器端进行判断的<strong> server-side hit registration</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AgnAR2f.png\" width=\"80%\">\n</div>\n<p>在客户端上进行检测时的基本思想是一切以玩家客户端视角下的结果为准。玩家开枪后的弹道轨迹以及击中判断都先在本地进行，然后发送到服务器上再进行验证。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ovxyJWQ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ixhlK5h.png\" width=\"80%\">\n</div>\n<p>在服务器上会对玩家的行为进行一些验证从而保证确实击中了目标。当然在实际的游戏中这个验证过程是相当复杂的，涉及到大量的验证和反作弊检测。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kc5gU2I.png\" width=\"80%\">\n</div>\n<p>在客户端上进行命中检测的优势在于它非常高效而且可以减轻服务器的负担，但它的核心问题在于它不够安全，一旦客户端被破解或是网络消息被劫持就需要非常复杂的反作弊系统来维持游戏平衡。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tj85ODS.png\" width=\"80%\">\n</div>\n<h3 id=\"server-side-hit-registration\"><a class=\"anchor\" href=\"#server-side-hit-registration\">#</a> Server-Side Hit Registration</h3>\n<p>在服务器端进行检测的一个难点在于服务器上角色的位置和状态是领先于玩家视角的，当玩家开枪时目标很可能已经移动到其它的位置上了。从这样的角度来看，玩家很难命中移动中的目标。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0F8KuiO.png\" width=\"80%\">\n</div>\n<p>因此我们需要对网络延迟进行一定的补偿。当服务器收到射击的消息时不会直接使用当前的游戏状态，而是根据延迟使用之前保存的游戏状态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vD6oP4t.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/i0eINIy.png\" width=\"80%\">\n</div>\n<h3 id=\"cover-problems\"><a class=\"anchor\" href=\"#cover-problems\">#</a> Cover Problems</h3>\n<p>对于掩体的问题，由于网络延迟的存在可能会出现射击者优势或窥视者优势的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KNl7rGj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/K7bWAn1.png\" width=\"80%\">\n</div>\n<p>为了缓解延迟的问题在游戏设计时还可以利用动作 ** 前摇 (startup frames)** 来掩盖掉网络同步。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yVxbd4l.png\" width=\"80%\">\n</div>\n<p>类似地，也可以使用各种特效来为服务器同步争取时间。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/h1nlMaE.png\" width=\"80%\">\n</div>\n<h2 id=\"mmog-network-architecture\"><a class=\"anchor\" href=\"#mmog-network-architecture\">#</a> MMOG Network Architecture</h2>\n<p>对于 ** 大型多人在线游戏 (massively multiplayer online game, MMOG)** 我们还需要一些额外的网络架构设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j14nTXF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KF0oXyN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/780UYmm.png\" width=\"80%\">\n</div>\n<h3 id=\"mmo-architecture\"><a class=\"anchor\" href=\"#mmo-architecture\">#</a> MMO Architecture</h3>\n<p>MMOG 中一般会有各种子系统来组成整体的玩法系统。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0qXuLs4.png\" width=\"80%\">\n</div>\n<p>简单的 MMO 分层架构如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Pmk69yp.png\" width=\"80%\">\n</div>\n<h4 id=\"link-layer\"><a class=\"anchor\" href=\"#link-layer\">#</a> Link Layer</h4>\n<p>** 连接层 (link layer)** 是玩家和游戏建立连接的一层。在 MMO 中为了保护服务器不受攻击，我们需要单独的连接层来分离玩家和服务器数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9gQBCpZ.png\" width=\"80%\">\n</div>\n<h4 id=\"lobby\"><a class=\"anchor\" href=\"#lobby\">#</a> Lobby</h4>\n<p>连接到 link layer 后玩家会进入<strong>大厅 (lobby)</strong>。大厅可以理解为一个特殊的游戏模式，从而方便管理等待进行游戏的玩家。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IeRz6gW.png\" width=\"80%\">\n</div>\n<h4 id=\"character-server\"><a class=\"anchor\" href=\"#character-server\">#</a> Character Server</h4>\n<p>由于 MMO 中玩家的数据往往非常巨大，玩家的数据一般会保存在一个专门的服务器上称为<strong> character server</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PLmkdaN.png\" width=\"80%\">\n</div>\n<h4 id=\"trading-system\"><a class=\"anchor\" href=\"#trading-system\">#</a> Trading System</h4>\n<p>** 交易系统 (trading system)** 是 MMO 的重要组成部分，在设计交易系统时需要保证系统有足够高的安全性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Pxc1tp4.png\" width=\"80%\">\n</div>\n<h4 id=\"social-system\"><a class=\"anchor\" href=\"#social-system\">#</a> Social System</h4>\n<p>玩家之间的聊天和交互功能一般会通过专门的 ** 社交系统 (social system)** 来进行实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uyerceT.png\" width=\"80%\">\n</div>\n<h4 id=\"matchmaking\"><a class=\"anchor\" href=\"#matchmaking\">#</a> Matchmaking</h4>\n<p>很多 MMO 还需要实现玩家的匹配。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cVe4JPI.png\" width=\"80%\">\n</div>\n<h3 id=\"data-storage\"><a class=\"anchor\" href=\"#data-storage\">#</a> Data Storage</h3>\n<p>** 数据存储 (data storage)** 是 MMO 中非常重要的问题。不同于单机游戏，在 MMO 中玩家可能会随时下线但服务器则必须要保证一直运行。因此如何存储和调用数据是一个非常重要也非常困难的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kgT9Qp5.png\" width=\"80%\">\n</div>\n<h4 id=\"relational-data-storage\"><a class=\"anchor\" href=\"#relational-data-storage\">#</a> Relational Data Storage</h4>\n<p>关系数据库是最基本的数据存储方式，像游戏中玩家数据和游戏数据都会使用关系数据库进行存储。现代网络游戏中往往还会结合分布式的技术进行存储。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/46I3L2C.png\" width=\"80%\">\n</div>\n<h4 id=\"non-relational-data-storage\"><a class=\"anchor\" href=\"#non-relational-data-storage\">#</a> Non-Relational Data Storage</h4>\n<p>除了关系数据库外，非关系数据库也是目前非常流行的数据存储方法。像游戏中的日志还有各种 game state 就比较适合使用非关系数据库。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/agWInxl.png\" width=\"80%\">\n</div>\n<h4 id=\"in-memory-data-storage\"><a class=\"anchor\" href=\"#in-memory-data-storage\">#</a> In-Memory Data Storage</h4>\n<p>随着游戏系统变得越来越复杂，在服务器运行过程中会产生大量的中间数据存储在内存中。因此我们需要一些内存数据管理工具。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cv1WZNU.png\" width=\"80%\">\n</div>\n<h3 id=\"distributed-system\"><a class=\"anchor\" href=\"#distributed-system\">#</a> Distributed System</h3>\n<p>随着玩家数量的增长，在单个服务器上支撑所有玩家进行游玩是几乎不可能的。在这种情况下就需要使用 ** 分布式系统 (distributed system)** 来提供游戏服务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/00LDjjN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yDYZFHW.png\" width=\"80%\">\n</div>\n<p>分布式系统有很多自身的难点：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JutnbuX.png\" width=\"80%\">\n</div>\n<h4 id=\"load-balancing\"><a class=\"anchor\" href=\"#load-balancing\">#</a> Load Balancing</h4>\n<p>** 负载均衡 (load balancing)** 是分布式系统中非常重要的概念，我们希望在不同服务器上都有相近的负载从而避免某些服务器负载过大的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ufBhKRa.png\" width=\"80%\">\n</div>\n<p><strong>consistent hashing</strong> 是实现负载均衡的经典技术。它的核心在于为服务器以及玩家设计对应的 hashing 算法，然后把服务器和玩家映射到一个环上，当玩家需要连接服务器时只需要利用 hashing 值寻找最近的服务器即可。当某个服务器从圆环上删除时只需要把玩家连接到下一个服务器上即可，类似地添加新的服务器只需要在圆环上添加新的节点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kHwgUOZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q5XbEC9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6yTXD2i.png\" width=\"80%\">\n</div>\n<p>显然 consistent hashing 算法的效果很大程度上依赖于 hashing 函数，当服务器或是玩家在环上的分布不够均匀时是很难保证负载均衡的。为了缓解这样的问题我们可以在环上设置一些虚拟的服务器，然后再把虚拟服务器链接到真实服务器上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rHL7KHv.png\" width=\"80%\">\n</div>\n<h4 id=\"servers-management\"><a class=\"anchor\" href=\"#servers-management\">#</a> Servers Management</h4>\n<p>分布式系统的另一大难点在于如何管理大量同时运行的服务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gHMwTjv.png\" width=\"80%\">\n</div>\n<p>我们可以使用 Apache 或是 etcd 这样的工具来监视和管理各种服务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DbDopr1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MXnBY7Z.png\" width=\"80%\">\n</div>\n<h2 id=\"bandwidth-optimization\"><a class=\"anchor\" href=\"#bandwidth-optimization\">#</a> Bandwidth Optimization</h2>\n<p>** 带宽优化 (bandwidth optimization)** 是现代网络游戏必须要解决的问题。网络带宽不仅仅是游戏运营成本的重要组成部分，对玩家的游戏体验也有着重要的影响。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WdmseYi.png\" width=\"80%\">\n</div>\n<p>带宽的计算实际上非常简单，根据计算视角的不同我们有不同的衡量指标：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WsZthB9.png\" width=\"80%\">\n</div>\n<h3 id=\"data-compression\"><a class=\"anchor\" href=\"#data-compression\">#</a> Data Compression</h3>\n<p>** 数据压缩 (data compression)** 是经典的带宽优化方法。在网络游戏中我们可以把浮点数转换为低精度的定点数来减少数据量。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Kb4mLM7.png\" width=\"80%\">\n</div>\n<p>我们甚至可以对游戏地图进行分区然后在小区域中使用定点数来缓解低精度数值带来的影响。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A9u9Rhn.png\" width=\"80%\">\n</div>\n<h3 id=\"object-relevance\"><a class=\"anchor\" href=\"#object-relevance\">#</a> Object Relevance</h3>\n<p>另一种缓解带宽需求的方式是只同步和玩家相关的对象，这样可以极大地减少每次和玩家同步的数据量。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JkOF2ir.png\" width=\"80%\">\n</div>\n<p>我们可以把整个游戏世界划分为若干个区域，这样每个玩家都会位于某个区域中。不同区域的数据是相互隔绝的，因此在同步时只需要同步区域中的数据即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tzahT46.png\" width=\"80%\">\n</div>\n<p>在一些开放世界游戏中我们不希望出现区域的划分，此时则可以利用 **area of inerest (AOI)** 的概念。AOI 的意义在于我们只需要关注玩家附近的情况而无需考虑更远区域的信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5Xhh4Hl.png\" width=\"80%\">\n</div>\n<p>AOI 最简单的实现方法是利用一个半径来查询附近信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/02i5E6x.png\" width=\"80%\">\n</div>\n<p>当玩家数量很多时还可以利用网格划分的方法来加速查询。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Eo4nybu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JrR4qRH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9PfuZr1.png\" width=\"80%\">\n</div>\n<p>除此之外我们也可以使用十字链表这样的数据结构来进行加速。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JinHfiG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lvlpUCn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xfrBC3Y.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NH3nVAK.png\" width=\"80%\">\n</div>\n<p>当然也可以使用<a href=\"/2022/04/06/GAMES104-NOTES-04.html#visibility-culling\"> PVS</a> 这样的技术来剔除不相关的对象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4qgBB5x.png\" width=\"80%\">\n</div>\n<h3 id=\"varying-update-frequency\"><a class=\"anchor\" href=\"#varying-update-frequency\">#</a> Varying Update Frequency</h3>\n<p>除了上面介绍的方法我们也可以通过调整更新频率的方式来降低带宽。一种经典的策略是根据物体和玩家之间的距离来设置更新频率，使得距离玩家远的物体更新得慢一些，距离近的更新得快一些。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CDsf2D7.png\" width=\"80%\">\n</div>\n<h2 id=\"anti-cheat\"><a class=\"anchor\" href=\"#anti-cheat\">#</a> Anti-Cheat</h2>\n<p>** 反作弊 (anti-cheat)** 同样是现代网络游戏必须要实现的功能，作弊行为对游戏运营和其他玩家都会造成非常巨大的伤害。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M6CRsm0.png\" width=\"80%\">\n</div>\n<p>网络游戏中的作弊手段是相当多样的，比如说可以修改本地的代码或是内存中的数据，骇入底层三方库的接口，甚至可以通过劫持网络通信来实现作弊行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hwRjHmm.png\" width=\"80%\">\n</div>\n<h3 id=\"obfuscating-memory\"><a class=\"anchor\" href=\"#obfuscating-memory\">#</a> Obfuscating Memory</h3>\n<p>作弊最基本的方法是修改本地的内存。对于很多在客户端进行校验的游戏只需要修改游戏内存中的数据就可以进行作弊。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bgU8N4y.png\" width=\"80%\">\n</div>\n<p>为了应对这种作弊方式，我们可以对客户端套一个壳来防止侵入。类似地，也可以对内存数据进行加密来防止侵入。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/s2WqxxE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8cDyY6t.png\" width=\"80%\">\n</div>\n<h3 id=\"verifying-local-files-by-hashing\"><a class=\"anchor\" href=\"#verifying-local-files-by-hashing\">#</a> Verifying Local Files by Hashing</h3>\n<p>另一种常见的作弊方法是修改本地的资源文件。我们可以通过对比本地和服务器上资源的 hashing 来进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UO05xRD.png\" width=\"80%\">\n</div>\n<h3 id=\"packet-interception-and-manipulation\"><a class=\"anchor\" href=\"#packet-interception-and-manipulation\">#</a> Packet Interception and Manipulation</h3>\n<p>消息的劫持和篡改是网络游戏中经常遇到的作弊方式，因此对于客户端和服务器发出的包就必须进行加密。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iUVLAY8.png\" width=\"80%\">\n</div>\n<p>目前主流的加密算法包括对称加密和非对称加密两种。对称加密是指客户端和服务器共享一副秘钥，它的缺陷在于当客户端被破解后秘钥就是公开的了，此时加密也就失效了。因此在实践中更多地使用的是非对称加密算法，此时客户端只有公钥而在服务器端存有私钥。这样即使客户端被破解了也无法完全获知所有数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9vbcbMy.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MyuD5be.png\" width=\"80%\">\n</div>\n<h3 id=\"system-software-invoke\"><a class=\"anchor\" href=\"#system-software-invoke\">#</a> System Software Invoke</h3>\n<p>除此之外，作弊者还可以通过修改底层游戏引擎代码来进行作弊。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dZLo907.png\" width=\"80%\">\n</div>\n<p>针对这种情况可以使用各种安全软件来检测游戏引擎是否存在注入的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/25JUJhG.png\" width=\"80%\">\n</div>\n<h3 id=\"ai-cheat\"><a class=\"anchor\" href=\"#ai-cheat\">#</a> AI Cheat</h3>\n<p>目前随着 AI 技术的发展还出现了使用 AI 进行作弊的现象，这对下一代反作弊系统的开发又提出了新的挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dWc2ZVf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/L76HX9u.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/t7K3uje.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mQLLWxI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XZQwyGQ.png\" width=\"80%\">\n</div>\n<h2 id=\"build-a-scalable-world\"><a class=\"anchor\" href=\"#build-a-scalable-world\">#</a> Build a Scalable World</h2>\n<p>构建可拓展的游戏世界可以说是每个游戏从业者的梦想。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dQZHPqI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7mMG5xF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ta0T7O5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QtFHPiv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XpPd83e.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/w4TOA6C.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kqUeO4M.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTNCNHkxTDdiWj92ZF9zb3VyY2U9N2EyNTQyYzZjOTA5YjNlZTFmYWI1NTEyNzczNjA4MjY=\">Lecture 19：Online Gaming Architecture Advanced Topics (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJHNDExdDdUUC8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 19：Online Gaming Architecture Advanced Topics (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/",
            "title": "games104系列笔记（十八）",
            "date_published": "2023-06-28T15:01:21.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍网络游戏的架构基础。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>网络游戏的出现是游戏发展历程中的重要里程碑，基于互联网玩家可以同时和全球的其它玩家一起进行游玩。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fRaTd2O.png\" width=\"80%\">\n</div>\n<p>网络游戏和单机游戏相比有很多难点，比如说如何保证每个玩家的游戏状态是一致的、如何进行网络同步、如何处理延迟和丢包、如何检测玩家的作弊行为、如何处理不同的设备和系统、如何设计高性能的服务器系统等等。这些网络游戏专有的问题都为游戏引擎的开发提出了更大的挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9mpPBvg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZvzYf3O.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gJCpl60.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RPGWfhI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SSEhBIn.png\" width=\"80%\">\n</div>\n<p>所以网络游戏是一个非常复杂庞大的系统，在这一部分我们同样分为两节来介绍相关的技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2e033aT.png\" width=\"80%\">\n</div>\n<h2 id=\"network-protocols\"><a class=\"anchor\" href=\"#network-protocols\">#</a> Network Protocols</h2>\n<p>在介绍网络游戏相关的内容前我们先来介绍一下<strong>网络协议 (network protocols)</strong>。实际上互联网的概念最早是由 Vint 和 Robert 提出的，他们设计了 TCP/IP 协议从而实现了不同设备基于电话线和卫星的通信。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pVNWu3A.png\" width=\"80%\">\n</div>\n<h3 id=\"the-problem-of-communication\"><a class=\"anchor\" href=\"#the-problem-of-communication\">#</a> The Problem of Communication</h3>\n<p>网络协议要解决的核心问题是如何实现两台计算机之间的数据通信，当软件应用和硬件连接不断地变得复杂时直接进行通信是非常困难的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B9dcFn4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iSaKg2z.png\" width=\"80%\">\n</div>\n<p>因此人们提出了 ** 中间层 (intermediate layer)** 的概念来隔绝掉应用和硬件，使得开发者可以专注于程序本身而不是具体的通信过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QPRK1uy.png\" width=\"80%\">\n</div>\n<p>在现代计算机网络中人们设计了 **OSI 模型 (OSI model)** 来对通信过程进行封装和抽象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fCIbDEe.png\" width=\"80%\">\n</div>\n<h3 id=\"socket\"><a class=\"anchor\" href=\"#socket\">#</a> Socket</h3>\n<p>对于网络游戏开发来说一般不需要接触到很底层的通信协议，在大多数情况下只需要知道如何使用<strong> socket</strong> 建立连接即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6WSvYyY.png\" width=\"80%\">\n</div>\n<p>socket 是一个非常简单的结构体，我们只需要知道对方的 IP 地址和端口号就可以使用 socket 建立连接来发送和接收数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/c6tG9Jf.png\" width=\"80%\">\n</div>\n<p>建立连接时需要额外注意到底是使用 IPv4 还是 IPv6，使用 TCP 还是 UDP 协议等问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mbJexOn.png\" width=\"80%\">\n</div>\n<h3 id=\"tcp\"><a class=\"anchor\" href=\"#tcp\">#</a> TCP</h3>\n<p>TCP 是最经典也是著名的网络协议，它可以确保发送端发送的数据包都按照顺序被接收端接收。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/v60kukQ.png\" width=\"80%\">\n</div>\n<p>TCP 的核心是<strong> retransmission mechanism</strong>，这个机制要求接收端收到消息后会向发送端发送一个 ACK，而发送端只有接收到这个 ACK 之后才会继续发包。当然 TCP 实际使用的机制要比上述的过程复杂得多。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FgMnkfF.png\" width=\"80%\">\n</div>\n<p>当 TCP 出现网络拥堵时会主动调节单次发包的数量。如果发包都能顺利地接收到则会提高发包数量以提升效率，反之则会减少发包数量以提升稳定性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/l02709r.png\" width=\"80%\">\n</div>\n<h3 id=\"udp\"><a class=\"anchor\" href=\"#udp\">#</a> UDP</h3>\n<p>除了 TCP 之外人们还开发出了 UDP 这样的轻量级网络协议。UDP 的本质是一个端到端的网络协议，它不需要建立长时间的连接，也不要求发送数据的顺序，因此 UDP 要比 TCP 简单得多。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lkhvMOA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ogqTASz.png\" width=\"80%\">\n</div>\n<p>在现代网络游戏中根据游戏类型的不同使用合适的网络协议，比如说对于实时性要求比较高的游戏会优先选择 UDP，而策略类的游戏则会考虑使用 TCP。在大型网络游戏中还可能会使用复合类型的协议来支持游戏中不同系统的通信需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nRMrubO.png\" width=\"80%\">\n</div>\n<h3 id=\"reliable-udp\"><a class=\"anchor\" href=\"#reliable-udp\">#</a> Reliable UDP</h3>\n<p>同时现代网络游戏中往往还会对网络协议进行定制。以 TCP 为例，虽然 TCP 协议比较稳定但是效率过于低了，而且网络游戏中出现一定的丢包是可以接受的；而对于 UDP 来说它虽然非常高效但是却不够稳定。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lU06LWU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rYmTEsj.png\" width=\"80%\">\n</div>\n<p>因此现代网络游戏中往往会基于 UDP 来定制一个网络协议，这样既可以利用 UDP 的高效性又可以保证数据通信的有序性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MJVPK9K.png\" width=\"80%\">\n</div>\n<p>ACK 及其相关技术是保证数据可靠通信的基本方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/397uLf2.png\" width=\"80%\">\n</div>\n<h4 id=\"automatic-repeat-request\"><a class=\"anchor\" href=\"#automatic-repeat-request\">#</a> Automatic Repeat Request</h4>\n<p>**ARQ (automatic repeat request)** 是基于 ACK 的错误控制方法，所有的通信算法都要事项 ARQ 的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qDJYLpA.png\" width=\"80%\">\n</div>\n<h5 id=\"sliding-window-protocol\"><a class=\"anchor\" href=\"#sliding-window-protocol\">#</a> Sliding Window Protocol</h5>\n<p>** 滑窗协议 (sliding window protocol)** 是经典的 ARQ 实现方法，它在发送数据时每次发送窗口大小的包然后检验回复的 ACK 来判断是否出现丢包的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jZFWWil.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tLF4fgq.png\" width=\"80%\">\n</div>\n<p>滑窗协议的一个缺陷在于它需要等待接收端的 ACK 才能继续发送数据，因此在很多情况下它无法完全利用带宽。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FxLGXbt.png\" width=\"80%\">\n</div>\n<h5 id=\"go-back-n-arq\"><a class=\"anchor\" href=\"#go-back-n-arq\">#</a> Go-Back-N ARQ</h5>\n<p>对滑窗协议的一种改进方法是<strong> Go-Back-N ARQ</strong>，当出现丢包时它只会把窗口内的包重新发送。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KZPczGt.png\" width=\"80%\">\n</div>\n<h5 id=\"selective-repeat-arq\"><a class=\"anchor\" href=\"#selective-repeat-arq\">#</a> Selective Repeat ARQ</h5>\n<p>另一种改进方法是<strong> selective repeat ARQ</strong>，它只会重新发送丢失或损坏的包从而进一步提升带宽的利用率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/80AwIwn.png\" width=\"80%\">\n</div>\n<h4 id=\"forward-error-correction\"><a class=\"anchor\" href=\"#forward-error-correction\">#</a> Forward Error Correction</h4>\n<p>在网络游戏中需要额外处理丢包的问题，因此我们在自定义网络协议时一般会结合 **forward error correction (FEC)** 的方法来避免数据的反复发送。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k1DV9q4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CsHLLBt.png\" width=\"80%\">\n</div>\n<p>目前常用的 FEC 算法包括异或校验位以及 Reed-Solomon codes 两大类。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XSe7wNx.png\" width=\"80%\">\n</div>\n<h5 id=\"xor-fec\"><a class=\"anchor\" href=\"#xor-fec\">#</a> XOR FEC</h5>\n<p>异或校验位是使用 ** 异或 (XOR)** 运算来恢复丢失数据的方法。这里需要注意的是当同时有多个包丢失时，使用异或校验位是无法恢复数据的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jVvBZ6n.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WHgXNfq.png\" width=\"80%\">\n</div>\n<h5 id=\"reed-solomon-codes\"><a class=\"anchor\" href=\"#reed-solomon-codes\">#</a> Reed-Solomon Codes</h5>\n<p><strong>Reed-Solomon codes</strong> 是经典的信息传输算法，它利用 Vandemode 矩阵及其逆阵来恢复丢失的数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ambH2LP.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JXRqK67.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rWgOaVo.png\" width=\"80%\">\n</div>\n<p>总结一下，在自定义 UDP 时需要考虑 ARQ 和 FEC 两类问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sGR29tV.png\" width=\"80%\">\n</div>\n<h2 id=\"clock-synchronization\"><a class=\"anchor\" href=\"#clock-synchronization\">#</a> Clock Synchronization</h2>\n<p>有了网络协议后就可以开始对网络游戏进行开发了，不过在具体设计游戏前我们还需要考虑不同玩家之间的时钟同步 **(clock synchronization)** 问题。</p>\n<h3 id=\"round-trip-time\"><a class=\"anchor\" href=\"#round-trip-time\">#</a> Round Trip Time</h3>\n<p>由于网络通信延迟的存在，客户端向服务器端发送一个包后都需要等待一定的时间才能收到回包，这个间隔的时间称为<strong> round-trip time (RTT)</strong>。RTT 的概念类似于 ping，不过它们的区别在于 ping 更加偏向于底层而 RTT 则位于顶部的应用层。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4stDgLL.png\" width=\"80%\">\n</div>\n<h3 id=\"network-time-protocol\"><a class=\"anchor\" href=\"#network-time-protocol\">#</a> Network Time Protocol</h3>\n<p>利用 RTT 就可以实现不同设备之间的时间同步。实际上不仅仅是网络游戏，现实生活中的各种电子设备进行同步都使用了 RTT 的技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M3rtVnf.png\" width=\"80%\">\n</div>\n<p>在实际设备的时间同步过程中一般会利用层次化的结构来进行实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jQnWaqR.png\" width=\"80%\">\n</div>\n<p>NTP 的算法实际上非常简单，我们只需要从客户端发送请求然后从服务器接收一个时刻就好，这样就可以得到 4 个时间戳。如果我们进一步假定网络上行和下行的延迟是一致的，我们可以直接计算出 RTT 的时间长短以及两个设备之间的时间偏差。当然需要注意的是在实际中网络上行和下行的带宽往往是不一致的，因此这个算法也不是十分的严谨。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gPKvNtD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uVmrlot.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RbcMpsm.png\" width=\"80%\">\n</div>\n<p>实际上我们可以证明在不可靠的通信中是无法严格校准时间的。不过在实践中我们可以通过不断的使用 NTP 算法来得到一系列 RTT 值，然后把高于平均值 50% 的部分丢弃，剩下的 RTT 平均值的 1.5 倍就可以作为真实 RTT 的估计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/u91VJfr.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6AOUgh9.png\" width=\"80%\">\n</div>\n<h2 id=\"remote-procedure-call\"><a class=\"anchor\" href=\"#remote-procedure-call\">#</a> Remote Procedure Call</h2>\n<h3 id=\"socket-programming\"><a class=\"anchor\" href=\"#socket-programming\">#</a> Socket Programming</h3>\n<p>尽管利用 socket 我们可以实现客户端和服务器的通信，但对于网络游戏来说完全基于 socket 的通信是非常复杂的。这主要是因为网络游戏中客户端需要向服务器发送大量不同类型的消息，同时客户端也需要解析相应类型的反馈，这就会导致游戏逻辑变得无比复杂。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KZM8Gvm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/u0PpVr6.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3U7rWwh.png\" width=\"80%\">\n</div>\n<p>另一方面客户端和服务器往往有着不同的硬件和操作系统，这些差异会使得游戏逻辑更加复杂且难以调试。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RlvC7u3.png\" width=\"80%\">\n</div>\n<h3 id=\"rpc\"><a class=\"anchor\" href=\"#rpc\">#</a> RPC</h3>\n<p>因此在现代网络游戏中一般会使用 **RPC (remote procedure call)** 的方式来实现客户端和服务器的通信。基于 RPC 的技术在客户端可以像本地调用函数的方式来向服务器发送请求，这样使得开发人员可以专注于游戏逻辑而不是具体底层的实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0S5BHcm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YLHfSUC.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B9KyYkC.png\" width=\"80%\">\n</div>\n<p>在 RPC 中会大量使用 **IDL (interface definiton language)** 来定义不同的消息形式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zyH16Q8.png\" width=\"80%\">\n</div>\n<p>然后在启动时通过<strong> RPC stubs</strong> 来通知客户端有哪些 RPC 是可以进行调用的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9LamOli.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lU7y4gU.png\" width=\"80%\">\n</div>\n<p>当然真实游戏中的 RPC 在实际进行调用时还有很多的消息处理和加密工作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/E8B4iMu.png\" width=\"80%\">\n</div>\n<h2 id=\"network-topology\"><a class=\"anchor\" href=\"#network-topology\">#</a> Network Topology</h2>\n<h3 id=\"peer-to-peer\"><a class=\"anchor\" href=\"#peer-to-peer\">#</a> Peer-to-Peer</h3>\n<p>在设计网络游戏时还需要考虑网络自身的架构。最经典的网络架构是<strong> P2P (peer-to-peer)</strong>，此时每个客户端之间会直接建立通信。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BZZpxpu.png\" width=\"80%\">\n</div>\n<p>当 P2P 需要集中所有玩家的信息时则可以选择其中一个客户端作为主机，这样其它的客户端可以通过连接主机的方式来实现联机。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KwGMySw.png\" width=\"80%\">\n</div>\n<p>很多早期经典的游戏都是使用这样的网络架构来实现联网功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7M95cjf.png\" width=\"80%\">\n</div>\n<h3 id=\"dedicated-server\"><a class=\"anchor\" href=\"#dedicated-server\">#</a> Dedicated Server</h3>\n<p>在现代网络游戏中更多地会使用<strong> dedicated server</strong> 这样的网络架构，此时网络中有一个专门的服务器向其它客户端提供服务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HTIobK1.png\" width=\"80%\">\n</div>\n<p>从实践结果来看，对于小型的网络游戏 P2P 是一个足够好的架构，而对于大型的商业网络游戏则必须使用 dedicated server 这样的形式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2b7aAt7.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/h6XtOgN.png\" width=\"80%\">\n</div>\n<h2 id=\"game-synchronization\"><a class=\"anchor\" href=\"#game-synchronization\">#</a> Game Synchronization</h2>\n<p>在前面的课程中我们介绍过游戏世界是分层的。从玩家的角度来看，玩家的操作通过输入层一路向下到达游戏逻辑层，然后通过渲染器展示给玩家。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mhJ7u3t.png\" width=\"80%\">\n</div>\n<p>而在网络游戏中，除了单机游戏都需要的分层外我们还需要考虑不同玩家之间的同步。在理想情况下我们希望客户端只负责处理玩家的输入，整个游戏逻辑都放在服务器端。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/O18uyKs.png\" width=\"80%\">\n</div>\n<p>由于延迟的存在，不同玩家视角下的对方可能会有不同的行为表现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/N20v8ts.png\" width=\"80%\">\n</div>\n<p>因此我们需要使用游戏同步技术来保证玩家的游戏体验是一致的。目前常用的同步技术包括快照同步、帧同步以及状态同步等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yKnCCci.png\" width=\"80%\">\n</div>\n<h3 id=\"snapshot-synchronization\"><a class=\"anchor\" href=\"#snapshot-synchronization\">#</a> Snapshot Synchronization</h3>\n<p>** 快照同步 (snapshot synchronization)** 是一种相对古老的同步技术。在快照同步中客户端只负责向服务器发送当前玩家的数据，由服务器完成整个游戏世界的运行。然后服务器会为游戏世界生成一张快照，再发送给每个客户端来给玩家反馈。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IQMJUaK.png\" width=\"80%\">\n</div>\n<p>快照同步可以严格保证每个玩家的状态都是准确的，但其缺陷在于它给服务器提出了非常巨大的挑战。因此在实际游戏中一般会降低服务器上游戏运行的帧率来平衡带宽，然后在客户端上通过插值的方式来获得高帧率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AEm7RCO.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/I7DP65v.png\" width=\"80%\">\n</div>\n<p>由于每次生成快照的成本是相对较高的，为了压缩数据我们可以使用状态的变化量来对游戏状态进行表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rMP3i1z.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mves6kv.png\" width=\"80%\">\n</div>\n<p>快照同步非常简单也易于实现，但它基本浪费掉了客户端上的算力同时在服务器上会产生过大的压力。因此在现代网络游戏中基本不会使用快照同步的方式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FfcLpSy.png\" width=\"80%\">\n</div>\n<h3 id=\"lockstep-synchronization\"><a class=\"anchor\" href=\"#lockstep-synchronization\">#</a> Lockstep Synchronization</h3>\n<p>** 帧同步 (lockstep synchronization)** 是现代网络游戏中非常常用的同步技术。不同于快照同步完全通过服务器来运行游戏世界，在帧同步中服务器更多地是完成数据的分发工作。玩家的操作通过客户端发送到服务器上，经过服务器汇总后将当前游戏世界的状态返还给客户端，然后在每个客户端上运行游戏世界。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1euHnTF.png\" width=\"80%\">\n</div>\n<h4 id=\"lockstep-initialization\"><a class=\"anchor\" href=\"#lockstep-initialization\">#</a> Lockstep Initialization</h4>\n<p>使用帧同步时首先需要进行初始化，将客户端上所有的游戏数据与服务器进行同步。这一过程一般是在游戏 loading 阶段来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CMgmUwJ.png\" width=\"80%\">\n</div>\n<h4 id=\"deterministic-lockstep\"><a class=\"anchor\" href=\"#deterministic-lockstep\">#</a> Deterministic Lockstep</h4>\n<p>在游戏过程中客户端会在每一帧将玩家数据发送到服务器上，服务器接收到所有玩家的数据后再统一转发到玩家客户端上，然后由玩家客户端执行游戏逻辑。当然这种同步方式也存在一定的缺陷，当某个玩家的数据滞后了所有玩家都必须要进行等待。这种情况在一些早期的联网游戏中都很常见。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HV7yXAp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PysXnFy.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bbprCsj.png\" width=\"80%\">\n</div>\n<h4 id=\"bucket-synchronization\"><a class=\"anchor\" href=\"#bucket-synchronization\">#</a> Bucket Synchronization</h4>\n<p>为了克服这样的问题，人们提出了<strong> bucket synchronization</strong> 这样的策略。此时服务器只会等待 bucket 长度的时间，如果超时没有收到客户端发来的数据就越过去，看下一个 bucket 时间段能否接收到。通过这样的方式其它玩家就无需一直等待了。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DgUu6sJ.png\" width=\"80%\">\n</div>\n<p>bucket synchronization 本质是对玩家数据的一致性以及游戏体验进行的一种权衡。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Q8VbczA.png\" width=\"80%\">\n</div>\n<h4 id=\"deterministic-difficulties\"><a class=\"anchor\" href=\"#deterministic-difficulties\">#</a> Deterministic Difficulties</h4>\n<p>帧同步的一大难点在于它要保证不同客户端上游戏世界在相同输入的情况下有着完全一致的输出。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WJhpGd6.png\" width=\"80%\">\n</div>\n<p>为了保证输出的确定性我们首先要保证浮点数在不同客户端上的一致性，这可以使用 IEEE 754 标准来实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dknWYuT.png\" width=\"80%\">\n</div>\n<p>其次在不同的设备上我们需要保证相关的数学运算函数有一致的行为，对于这种问题则可以使用查表的方式来避免实际的计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZWREFCA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AAiS8tm.png\" width=\"80%\">\n</div>\n<p>除此之外还可以使用定点数来替换浮点数，从而避免浮点数导致的各种问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1dWMRlL.png\" width=\"80%\">\n</div>\n<p>除了浮点数之外还要考虑随机数的问题，我们要求随机数在不同的客户端上也必须是完全一致的。因此在游戏客户端和服务器进行同步时需要将随机数种子以及随机数生成算法进行同步。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/73HE7yp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RLlboTV.png\" width=\"80%\">\n</div>\n<p>总结一下，保证客户端上游戏世界模拟一致的常用方法如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hzfLfoY.png\" width=\"80%\">\n</div>\n<h4 id=\"tracing-and-debugging\"><a class=\"anchor\" href=\"#tracing-and-debugging\">#</a> Tracing and Debugging</h4>\n<p>现代网络游戏的逻辑往往非常复杂，在玩家进行游玩时可能无法避免地出现一些 bug，因此对于服务器来说检测客户端发送的数据是否存在 bug 就非常重要。一般来说我们会要求客户端每隔一段时间就上传本地的 log，由服务器来检查上传数据是否存在 bug。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/btwvmgg.png\" width=\"80%\">\n</div>\n<h4 id=\"lag-and-delay\"><a class=\"anchor\" href=\"#lag-and-delay\">#</a> Lag and Delay</h4>\n<p>为了处理网络延迟的问题我们还可以在客户端上缓存若干帧，当然缓存的大小会在一定程度上影响玩家的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wKHfYVk.png\" width=\"80%\">\n</div>\n<p>另一方面我们还可以把游戏逻辑帧和渲染帧进行分离，然后通过插值的方式来获得更加平滑的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ujc90wZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HraSLPC.png\" width=\"80%\">\n</div>\n<h4 id=\"reconnection-problem\"><a class=\"anchor\" href=\"#reconnection-problem\">#</a> Reconnection Problem</h4>\n<p>由于网络的不稳定，玩家可能会不可避免地遇到断线的情况，此时我们还需要设计断线重连的机制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dWDYMYx.png\" width=\"80%\">\n</div>\n<p>实际上再进行帧同步时每个若干帧会设置一个关键帧。在关键帧进行同步时还会更新游戏世界的快照，这样可保证即使游戏崩溃了也可以从快照中恢复。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/77JxtFl.png\" width=\"80%\">\n</div>\n<p>为了实现这样的功能可以使用<strong> quick catch up</strong> 技术，此时我们暂停游戏的渲染把所有的计算资源用来执行游戏逻辑。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ChKjkZa.png\" width=\"80%\">\n</div>\n<p>而在服务器端也可以使用类似的技术，从而帮助掉线的玩家快速恢复到游戏的当前状态。实际上网络游戏的观战和回放功能也是使用这样的技术来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/thT8qmi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Af3toAV.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VOjiM0n.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/amdVNYV.png\" width=\"80%\">\n</div>\n<h4 id=\"lockstep-cheating-issues\"><a class=\"anchor\" href=\"#lockstep-cheating-issues\">#</a> Lockstep Cheating Issues</h4>\n<p>网络游戏中作弊行为的检查是非常重要的。对于帧同步的游戏，玩家可以通过发送虚假的状态来实现作弊行为，这就要求我们实现一些反作弊机制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zQUAdaa.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nYorUTc.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pq6eOLm.png\" width=\"80%\">\n</div>\n<h4 id=\"lockstep-summary\"><a class=\"anchor\" href=\"#lockstep-summary\">#</a> Lockstep Summary</h4>\n<p>总结一下，帧同步会占用更少的带宽也比较适合各种需要实时反馈的游戏。而帧同步的难点主要集中在如何保证在不同客户端上游戏运行的一致性，如何设计断线重连机制等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8kYdIwT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1MtwE0j.png\" width=\"80%\">\n</div>\n<h3 id=\"state-synchronization\"><a class=\"anchor\" href=\"#state-synchronization\">#</a> State Synchronization</h3>\n<p>** 状态同步 (state synchronization)** 是目前大型网游非常流行的同步技术，它的基本思想是把玩家的状态和事件进行同步。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NULvJO4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Pm5bGaV.png\" width=\"80%\">\n</div>\n<p>进行状态同步时由客户端提交玩家的状态数据，而服务器则会在收集到所有玩家的数据后运行游戏逻辑，然后把下一时刻的状态分发给所有的客户端。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pdLhfXx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Y85yMr4.png\" width=\"80%\">\n</div>\n<h4 id=\"authorized-and-replicated-clients\"><a class=\"anchor\" href=\"#authorized-and-replicated-clients\">#</a> Authorized and Replicated Clients</h4>\n<p>状态同步中服务器称为<strong> authorized server</strong>，它是整个游戏世界的绝对权威；而玩家的本地客户端称为<strong> authorized client</strong>，它是玩家操作游戏角色的接口；在其他玩家视角下的同一角色则称为<strong> replicated client</strong>，表示它们仅仅是 authorized client 的一个副本。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dBSxewy.png\" width=\"80%\">\n</div>\n<h4 id=\"state-synchronization-example\"><a class=\"anchor\" href=\"#state-synchronization-example\">#</a> State Synchronization Example</h4>\n<p>当 authorized client 执行了某种行为时首先会向服务发送相关的数据，然后由服务器驱动游戏逻辑并把相应的状态发布给所有的玩家。当其他客户端接收到更新后的状态时，再驱动 replicated client 执行 authorized client 的行为。类似地，authorized client 行为产生的后果也是由服务器进行计算再发布给所有的客户端。这样的好处在于我们无需要求每个客户端上的模拟是严格一致的，整个游戏世界本质上仍然是由统一的服务器进行驱动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bcg3Ef3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5YFmho5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7m4OQQg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PqvdC6S.png\" width=\"80%\">\n</div>\n<h4 id=\"dumb-client-problem\"><a class=\"anchor\" href=\"#dumb-client-problem\">#</a> Dumb Client Problem</h4>\n<p>由于游戏角色的所有行为都需要经过服务器的确认才能执行，状态同步会产生<strong> dumb client</strong> 的问题，即玩家视角下角色的行为可能是滞后的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/la1hpwr.png\" width=\"80%\">\n</div>\n<p>要缓解这样的问题可以在客户端上对玩家的行为进行预测。比如说当角色需要进行移动时首先在本地移动半步，然后等服务器传来确定的消息后再进行对齐，这样就可以改善玩家的游戏体验。在守望先锋中就使用了这样的方式来保证玩家顺畅的游玩。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CZeCNpS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d7rEr71.png\" width=\"80%\">\n</div>\n<p>由于网络波动的存在，来自服务器的确认消息往往会滞后于本地的预测。因此我们可以使用一个 buffer 来缓存游戏角色的状态，这样当收到服务器的消息时首先跟 buffer 中的状态进行检验。当 buffer 中的状态和服务器的数据不一致时就需要根据服务器的数据来矫正玩家状态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g9UmJfj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tiEgguJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/an1O2qU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WJ0LdQC.png\" width=\"80%\">\n</div>\n<p>当然这样的机制对于网络条件不好的玩家是不太公平的，他们的角色状态会不断地被服务器修正。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Upf6B4E.png\" width=\"80%\">\n</div>\n<h4 id=\"packet-loss\"><a class=\"anchor\" href=\"#packet-loss\">#</a> Packet Loss</h4>\n<p>对于丢包的问题在服务器端也会维护一个小的 buffer 来储存玩家的状态。如果 buffer 被清空则说明可能出现了掉线的情况，此时服务器会复制玩家上一个输入来维持游戏的运行。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HT2xI2P.png\" width=\"80%\">\n</div>\n<p>帧同步和状态同步两种主流同步技术的对比如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7cnr6C0.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUxhNDExbzdrRy8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 18：Online Gaming Architecture Fundamentals (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUhONHkxNTdacS8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 18：Online Gaming Architecture Fundamentals (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/",
            "title": "games104系列笔记（十七）",
            "date_published": "2023-06-28T15:01:16.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏 AI 的高级技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"hierarchical-tasks-network\"><a class=\"anchor\" href=\"#hierarchical-tasks-network\">#</a> Hierarchical Tasks Network</h2>\n<p>** 层次任务网络 (hierarchical tasks network, HTN)** 是经典的游戏 AI 技术，和上一节介绍过的行为树相比 HTN 可以更好地表达 AI 自身的意志和驱动力。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4I7FBkU.png\" width=\"80%\">\n</div>\n<p>HTN 的思想是把总体目标分解成若干个步骤，其中每个步骤可以包含不同的选项。AI 在执行时需要按照顺序完成每个步骤，并且根据自身的状态选择合适的行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WTmq3fH.png\" width=\"80%\">\n</div>\n<h3 id=\"htn-framework\"><a class=\"anchor\" href=\"#htn-framework\">#</a> HTN Framework</h3>\n<p>HTN 框架中包含两部分，<strong>world state</strong> 和<strong> sensor</strong> 两部分。其中 world state 是 AI 对于游戏世界的认知，而 sensor 则是 AI 从游戏世界获取信息的渠道。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PzwkQex.png\" width=\"80%\">\n</div>\n<p>除此之外 HTN 还包括<strong> domain</strong>，<strong>planner</strong> 以及<strong> plan runner</strong> 来表示 AI 的规划以及执行规划的过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NIgzWmt.png\" width=\"80%\">\n</div>\n<h3 id=\"htn-task-types\"><a class=\"anchor\" href=\"#htn-task-types\">#</a> HTN Task Types</h3>\n<p>在 HTN 中我们将任务分为两类，<strong>primitive task</strong> 和<strong> compound task</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WHd8iWK.png\" width=\"80%\">\n</div>\n<p>primitive task 一般表示一个具体的动作或行为。在 HTN 中每个 primitive task 需要包含 precondition、action 以及 effects 三个要素。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8e2Rubm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7LbXg9S.png\" width=\"80%\">\n</div>\n<p>而 compound task 则包含不同的方法，我们把这些方法按照一定的优先级组织起来并且在执行时按照优先级高到低的顺序进行选择。每个方法还可以包含其它的 primitive task 或者 compound task，当方法内所有的 task 都执行完毕则表示任务完成。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uyiZZfx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0AM4PCH.png\" width=\"80%\">\n</div>\n<p>在此基础上就可以构造出整个 HTN 的 domain，从而实现 AI 的行为逻辑。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Jak3o9O.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gpnKV0x.png\" width=\"80%\">\n</div>\n<h3 id=\"planning\"><a class=\"anchor\" href=\"#planning\">#</a> Planning</h3>\n<p>接下来就可以进行规划了，我们从 root task 出发不断进行展开逐步完成每个任务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6wDGpPe.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jGFZOQn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8e1rE9T.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZeuFXIu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CULPkyw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yjPOnj9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Kiq24df.png\" width=\"80%\">\n</div>\n<h3 id=\"replan\"><a class=\"anchor\" href=\"#replan\">#</a> Replan</h3>\n<p>执行 plan 时需要注意有时任务会失败，这就需要我们重新进行规划，这一过程称为<strong> replan</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/l1qMknL.png\" width=\"80%\">\n</div>\n<p>当 plan 执行完毕或是发生失败，亦或是 world state 发生改变后就需要进行 replan。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rFOzkJ1.png\" width=\"80%\">\n</div>\n<p>总结一下 HTN 和 BT 非常相似，但它更加符合人的直觉也更易于设计师进行掌握。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wzusHJq.png\" width=\"80%\">\n</div>\n<h2 id=\"goal-oriented-action-planning\"><a class=\"anchor\" href=\"#goal-oriented-action-planning\">#</a> Goal-Oriented Action Planning</h2>\n<p>**goal-oriented action planning (GOAP)** 是一种基于规划的 AI 技术，和前面介绍过的方法相比 GOAP 一般会更适合动态的环境。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nJGp297.png\" width=\"80%\">\n</div>\n<h3 id=\"structure\"><a class=\"anchor\" href=\"#structure\">#</a> Structure</h3>\n<p>GOAP 的整体结构与 HTN 非常相似，不过在 GOAP 中 domain 被替换为<strong> goal set</strong> 和<strong> action set</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SEu8fOf.png\" width=\"80%\">\n</div>\n<p>goal set 表示 AI 所有可以达成的目标。在 GOAP 中需要显式地定义可以实现的目标，这要求我们把目标使用相应的状态来进行表达。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qrFICyp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XnTavoj.png\" width=\"80%\">\n</div>\n<p>而 action set 则接近于 primitive task 的概念，它表示 AI 可以执行的行为。需要注意的是 action set 还包含 ** 代价 (cost)** 的概念，它表示不同动作的 &quot;优劣&quot; 程度。在进行规划时我们希望 AI 尽可能做出代价小的决策。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/o1RfZ08.png\" width=\"80%\">\n</div>\n<h3 id=\"planning-2\"><a class=\"anchor\" href=\"#planning-2\">#</a> Planning</h3>\n<p>GOAP 在进行规划时会从目标来倒推需要执行的动作，这一过程称为<strong>反向规划 (backward planning)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CuHnqbo.png\" width=\"80%\">\n</div>\n<p>在进行规划时首先需要根据优先级来选取一个目标，然后查询实现目标需要满足的状态。为了满足这些状态需求，我们需要从 action set 中选择一系列动作。需要注意的是很多动作也有自身的状态需求，因此我们在选择动作时也需要把这些需求添加到列表中。最后不断地添加动作和需求直到所有的状态需求都得到了满足，这样就完成了反向规划。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HN9Qc2G.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PyowWXA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gcBOPre.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/U5N6zrU.png\" width=\"80%\">\n</div>\n<p>GOAP 的难点在于如何从 action set 进行选择，我们要求状态需求都能够得到满足而且所添加动作的代价要尽可能小。显然这样的问题是一个 ** 动态规划 (dynamic programming)** 问题，我们可以利用图这样的数据结构来进行求解。在构造图时把状态的组合作为图上的节点，不同节点之间的有向边表示可以执行的动作，边的权重则是动作的代价。这样整个规划问题就等价于在有向图上的最短路径问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pwihLZo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gsJO3uj.png\" width=\"80%\">\n</div>\n<p>总结一下 GOAP 可以让 AI 的行为更加动态，而且可以有效地解耦 AI 的目标与行为；而 GOAP 的主要缺陷在于它会比较消耗计算资源，一般情况下 GOAP 需要的计算量会远高于 BT 和 HTN。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ikCwkRc.png\" width=\"80%\">\n</div>\n<h2 id=\"monte-carlo-tree-search\"><a class=\"anchor\" href=\"#monte-carlo-tree-search\">#</a> Monte Carlo Tree Search</h2>\n<p>** 蒙特卡洛树搜索 (Monte Carlo tree search, MCTS)** 也是经典的 AI 算法，实际上 AlphaGo 就是基于 MCTS 来实现的。简单来说，MCTS 的思路是在进行决策时首先模拟大量可行的动作，然后从这些动作中选择最好的那个来执行。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4ieIubf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ujK4M6o.png\" width=\"80%\">\n</div>\n<p>MCTS 的核心是<strong> Monte Carlo 方法 (Monte Carlo method)</strong>，它指出定积分可以通过随机采样的方法来进行估计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LudIyAu.png\" width=\"80%\">\n</div>\n<p>以围棋为例，MCTS 会根据当前棋盘上的状态来估计落子的位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3An5WPn.png\" width=\"80%\">\n</div>\n<p>从数学的角度来看，我们把棋盘上棋子的位置称为<strong>状态 (state)</strong>，同时把落子的过程称为<strong>行为 (action)</strong>。这样整个游戏可以建模为从初始节点出发的状态转移过程，而且所有可能的状态转移可以表示为一棵树。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tZaXkiQ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vuF8yKH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7GUChUW.png\" width=\"80%\">\n</div>\n<p>显然构造出完整的树结构可能是非常困难的，不过实际上我们并不需要完整的树。在使用 MCTS 时，完成每一个行为后只需要重新以当前状态构造一棵新树即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vjnGXgI.png\" width=\"80%\">\n</div>\n<h3 id=\"simulation\"><a class=\"anchor\" href=\"#simulation\">#</a> Simulation</h3>\n<p>** 模拟 (simulation)** 是 MCTS 中的重要一环，这里的 &quot;模拟&quot; 是指 AI 利用当前的策略快速地完成整个游戏过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WEhWhLW.png\" width=\"80%\">\n</div>\n<h3 id=\"backpropagate\"><a class=\"anchor\" href=\"#backpropagate\">#</a> Backpropagate</h3>\n<p>我们从同一节点出发进行不断的模拟就可以估计该节点的价值 (胜率)。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z9uwLvH.png\" width=\"80%\">\n</div>\n<p>然后把模拟的结果从下向上进行传播就可以更新整个决策序列上所有节点的价值。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/v5BJp2x.png\" width=\"80%\">\n</div>\n<h3 id=\"iteration-steps\"><a class=\"anchor\" href=\"#iteration-steps\">#</a> Iteration Steps</h3>\n<p>这样我们就可以定义 MCTS 的迭代步骤如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DHXs8wg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PZ4bgIj.png\" width=\"80%\">\n</div>\n<h4 id=\"selection\"><a class=\"anchor\" href=\"#selection\">#</a> Selection</h4>\n<p>在对节点进行选择时，MCTS 会优先选择可拓展的节点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2YYCxQ6.png\" width=\"80%\">\n</div>\n<p>在进行拓展时往往还要权衡一些 exploitation 和 exploration，因此我们可以把 UCB 可以作为一种拓展的准则。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/h9uaKy5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BVxMdUV.png\" width=\"80%\">\n</div>\n<p>这样在进行选择时首先需要从根节点出发然后不断选择当前 UCB 最大的那个节点向下进行访问，当访问到一个没有拓展过的节点时选择该节点进行展开。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OMpPE0Q.png\" width=\"80%\">\n</div>\n<h4 id=\"expansion\"><a class=\"anchor\" href=\"#expansion\">#</a> Expansion</h4>\n<p>对节点进行展开时我们需要根据可执行的动作选择一组进行模拟，然后把模拟的结果自下而上进行传播。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JP9pHzs.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/svfwwgQ.png\" width=\"80%\">\n</div>\n<h4 id=\"the-end-condition\"><a class=\"anchor\" href=\"#the-end-condition\">#</a> The End Condition</h4>\n<p>当对树的探索达到一定程度后就可以终止拓展过程，此时我们就得到了树结构上每个节点的价值。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Q04XZMp.png\" width=\"80%\">\n</div>\n<p>然后只需要回到根节点选择一个最优的子节点进行执行即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0krzkYb.png\" width=\"80%\">\n</div>\n<p>总结一下，MCTS 是一种非常强大的决策算法而且很适合搜索空间巨大的决策问题；而它的主要缺陷在于它具有过大的计算复杂度，而且它的效果很大程度上依赖于状态和行为空间的设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ncm3OPv.png\" width=\"80%\">\n</div>\n<h2 id=\"machine-learning-basic\"><a class=\"anchor\" href=\"#machine-learning-basic\">#</a> Machine Learning Basic</h2>\n<h3 id=\"ml-types\"><a class=\"anchor\" href=\"#ml-types\">#</a> ML Types</h3>\n<p>近几年在 ** 机器学习 (machine learning, ML)** 技术的不断发展下有越来越多的游戏 AI 开始使用机器学习来进行实现。根据学习的方式，机器学习大致可以分为监督学习、无监督学习、半监督学习以及强化学习等几类。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KirOIOL.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Q4kuYnv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YoTgaVU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6hK3EYE.png\" width=\"80%\">\n</div>\n<p>** 强化学习 (reinforcement learning, RL)** 是游戏 AI 技术的基础。在强化学习中我们希望 AI 能够通过和环境的不断互动来学习到一个合理的策略。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GFfBQ24.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Au7Diie.png\" width=\"80%\">\n</div>\n<h3 id=\"markov-decision-process\"><a class=\"anchor\" href=\"#markov-decision-process\">#</a> Markov Decision Process</h3>\n<p>强化学习的理论基础是<strong> Markov 决策过程 (Markov decision process, MDP)</strong>。在 MDP 中智能体对环境的感知称为<strong>状态 (state)</strong>，环境对于智能体的反馈称为<strong>奖励 (reward)</strong>。MDP 的目标是让智能体通过和环境不断的互动来学习到如何在不同的环境下进行决策，这样的一个决策函数称为<strong>策略 (policy)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rwzXfAH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B8yB5bO.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2rSrHCU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/74fN1x4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0Wx8eD9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9SrZJ3H.png\" width=\"80%\">\n</div>\n<h2 id=\"build-advanced-game-ai\"><a class=\"anchor\" href=\"#build-advanced-game-ai\">#</a> Build Advanced Game AI</h2>\n<p>尽管目前基于机器学习的游戏 AI 技术大多还处于试验阶段，但已经有一些很优秀的项目值得借鉴和学习，包括 DeepMind 的 AlphaStar 以及 OpenAI 的 Five 等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Zi9wKOO.png\" width=\"80%\">\n</div>\n<p>这些基于 ** 深度强化学习 (deep reinforcement learning, DRL)** 的游戏 AI 都是使用一个深度神经网络来进行决策，整个框架包括接收游戏环境的观测，利用神经网络获得行为，以及从游戏环境中得到反馈。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GQfYwXT.png\" width=\"80%\">\n</div>\n<h3 id=\"state\"><a class=\"anchor\" href=\"#state\">#</a> State</h3>\n<p>以 AlphaStar 为例，智能体可以直接从游戏环境获得的信息包括地图、统计数据、场景中的单位以及资源数据等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/THHWUGS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ShPvtmz.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FvMjfmM.png\" width=\"80%\">\n</div>\n<h3 id=\"actions\"><a class=\"anchor\" href=\"#actions\">#</a> Actions</h3>\n<p>在 AlphaStar 中智能体的行为还取决于当前选中的单位。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nIDeT85.png\" width=\"80%\">\n</div>\n<h3 id=\"rewards\"><a class=\"anchor\" href=\"#rewards\">#</a> Rewards</h3>\n<p>奖励函数的设计对于模型的训练以及最终的性能都有着重要的影响。在 AlphaStar 中使用了非常简单的奖励设计，智能体仅在获胜时获得 + 1 的奖励；而在 OpenAI Five 中则采用了更加复杂的奖励函数并以此来鼓励 AI 的进攻性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k3foZZp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/s0ykcHe.png\" width=\"80%\">\n</div>\n<h3 id=\"network\"><a class=\"anchor\" href=\"#network\">#</a> Network</h3>\n<p>在 AlphaStar 中使用了不同种类的神经网络来处理不同类型的输入数据，比如说对于定长的输入使用了 MLP，对于图像数据使用了 CNN，对于非定长的序列使用了 Transformer，而对于整个决策过程还使用了 LSTM 进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fNjxQRD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/23BXyl5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dZAGsOi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6Gaa8pE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qdyb42p.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/e6wTx96.png\" width=\"80%\">\n</div>\n<h3 id=\"training-strategy\"><a class=\"anchor\" href=\"#training-strategy\">#</a> Training Strategy</h3>\n<p>除此之外，AlphaStar 还对模型的训练过程进行了大规模的革新。在 AlphaStar 的训练过程中首先使用了监督学习的方式来从人类玩家的录像中进行学习。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/00HJFrp.png\" width=\"80%\">\n</div>\n<p>接着，AlphaStar 使用了强化学习的方法来进行自我训练。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eSUJEhD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d91TqXp.png\" width=\"80%\">\n</div>\n<p>试验结果分析表明基于监督学习训练的游戏 AI 其行为会比较接近于人类玩家，但基本无法超过人类玩家的水平；而基于强化学习训练的 AI 则可能会有超过玩家的游戏水平，不过需要注意的是使用强化学习可能需要非常多的训练资源。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/35w2RVS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/G38F34e.png\" width=\"80%\">\n</div>\n<p>因此对于游戏 AI 到底是使用监督学习还是使用强化学习进行训练需要结合实际的游戏环境进行考虑。对于奖励比较密集的环境可以直接使用强化学习进行训练，而对于奖励比较稀疏的环境则推荐使用监督学习。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rUP1LAI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qaEZ2k5.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWlHNHkxaTc4UT9zcG1faWRfZnJvbT0zMzMuMzM3LnNlYXJjaC1jYXJkLmFsbC5jbGljayZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 17：Advanced Artificial Intelligence (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWphNDExVTd6Sy8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 17：Advanced Artificial Intelligence (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/",
            "title": "games104系列笔记（十六）",
            "date_published": "2023-06-28T15:01:11.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏 AI 的基本内容。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"navigation\"><a class=\"anchor\" href=\"#navigation\">#</a> Navigation</h2>\n<p>游戏 AI 是玩法系统重要的组成部分，其中最基本的功能是允许玩家选择目的地进行<strong>导航 (navigation)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NowXwKg.png\" width=\"80%\">\n</div>\n<p>导航算法需要考虑游戏地图的不同表达形式，然后寻找到从起点到目的地的最短路径，有时还需要结合一些其它算法来获得更加光滑的路线。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gYKOfzy.png\" width=\"80%\">\n</div>\n<h3 id=\"map-representation\"><a class=\"anchor\" href=\"#map-representation\">#</a> Map Representation</h3>\n<p>因此我们首先需要考虑游戏中如何来表达地图，我们可以认为地图是玩家和 NPC 可以行动的区域。游戏中常见的地图形式包括路点<strong>网络图 (waypoint network)</strong>、<strong>网格 (grid)</strong>、** 寻路网格 (navigation mesh)<strong> 以及</strong>八叉树 (sparse voxel octree)** 等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OYDu8iH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kPOhH7c.png\" width=\"80%\">\n</div>\n<h4 id=\"waypoint-network\"><a class=\"anchor\" href=\"#waypoint-network\">#</a> Waypoint Network</h4>\n<p>waypoint network 是早期游戏中最常用的地图表示方式。我们可以把地图上的路标使用节点来表示，然后可通行的节点使用边来连接起来就形成了一个网络结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qXDILJ1.png\" width=\"80%\">\n</div>\n<p>当玩家需要进行导航时只需要选择距离起点和目的地最近的两个路标，然后在网络图上进行导航即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aRJu9E2.png\" width=\"80%\">\n</div>\n<p>waypoint network 的优势在于它非常易于实现，而且我们有成熟的路径搜索算法可以直接应用在网络图上；但它的缺陷在于路网图需要不断地和开发中的地图进行更新，而且使用路网进行导航时角色会倾向于沿路径中心前进而无法利用两边的通道。因此在现代游戏中路网的应用并不是很多。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CWHulfR.png\" width=\"80%\">\n</div>\n<h4 id=\"grid\"><a class=\"anchor\" href=\"#grid\">#</a> Grid</h4>\n<p>网格同样是表达游戏地图的经典方法，常用的网格地图包括方格地图、三角形地图或是六边形地图等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rZfpwW8.png\" width=\"80%\">\n</div>\n<p>使用网格来表示地图时只需要把不可通行的区域遮挡住就可以了，因此网格可以动态地反映地图环境的变化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4W2KL5B.png\" width=\"80%\">\n</div>\n<p>显然网格地图同样非常容易实现，而且支持动态更新，也便于调试；而它的缺陷在于网格地图的精度受制于地图分辨率，而且比较占用存储空间，最严重的问题是网格很难表示重叠区域之间的连接关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d45U0hV.png\" width=\"80%\">\n</div>\n<h4 id=\"navigation-mesh\"><a class=\"anchor\" href=\"#navigation-mesh\">#</a> Navigation Mesh</h4>\n<p>为了克服网格地图的这些问题，人们开发出了寻路网格这样的地图表达形式。在寻路网格中可通行的区域会使用多边形来进行覆盖，这样可以方便地表达不同区域直接相互连接的拓扑关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/72FC5tn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vgf8AlW.png\" width=\"80%\">\n</div>\n<p>在寻路网格中我们还会要求每个多边形都必须是凸多边形，这样才能保证角色在行进中不会穿过网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2j6zXlf.png\" width=\"80%\">\n</div>\n<p>寻路网格是现代游戏中广泛应用的地图表达形式，而它的缺陷主要在于生成寻路网格的算法相对比较复杂，而且它无法表达三维空间的拓扑连接关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zipSbRi.png\" width=\"80%\">\n</div>\n<h4 id=\"voxel-voxel-octree\"><a class=\"anchor\" href=\"#voxel-voxel-octree\">#</a> Voxel Voxel Octree</h4>\n<p>如果要制作三维空间中的地图则可以考虑八叉树这样的数据结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3zLpnOL.png\" width=\"80%\">\n</div>\n<h3 id=\"path-finding\"><a class=\"anchor\" href=\"#path-finding\">#</a> Path Finding</h3>\n<p>得到游戏地图后就可以使用寻路算法来计算路径了，当然无论我们使用什么样的地图表达方式我们首先都需要把游戏地图转换为拓扑地图，然后再使用相应的算法进行寻路。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cnymCfs.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6H0jZIY.png\" width=\"80%\">\n</div>\n<h4 id=\"depth-first-search\"><a class=\"anchor\" href=\"#depth-first-search\">#</a> Depth-First Search</h4>\n<p>寻路算法的本质是在图上进行搜索，因此我们可以使用 ** 深度优先搜索 (depth-first search, DFS)** 来进行求解。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WLIiyP2.png\" width=\"80%\">\n</div>\n<h4 id=\"width-first-search\"><a class=\"anchor\" href=\"#width-first-search\">#</a> Width-First Search</h4>\n<p>另一种常用的图搜索算法是<strong>广度优先搜索 (width-first search, BSF)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qIjB3T4.png\" width=\"80%\">\n</div>\n<h4 id=\"dijkstra-algorithm\"><a class=\"anchor\" href=\"#dijkstra-algorithm\">#</a> Dijkstra Algorithm</h4>\n<p>直接使用 DFS 或是 BFS 往往是过于低效的，实践中更常用的寻路算法是<strong> Dijkstra 算法 (Dijkstra algorithm)</strong>：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OetqRny.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3pgWF0B.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4kL80jw.png\" width=\"80%\">\n</div>\n<h4 id=\"a-star\"><a class=\"anchor\" href=\"#a-star\">#</a> A Star</h4>\n<p>Dijkstra 算法可以计算从起始节点出发到图上任意节点的最短路径，但它的缺陷在于图上很多节点对于我们想要计算的路径是没有意义的。因此人们还提出了<strong> A star</strong> 算法来进行改进，在 A star 算法中通过引入一个启发式函数来控制节点访问的倾向性，使得路径的搜索会更倾向于访问目标点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/m9iKxea.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZQZT7Il.png\" width=\"80%\">\n</div>\n<p>在网格地图中常用的启发函数包括 Manhattan 距离等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g99PD7V.png\" width=\"80%\">\n</div>\n<p>而在寻路网格中则可以使用欧氏距离作为启发函数。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q2AkyRE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3OPi9S4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CYcj7il.png\" width=\"80%\">\n</div>\n<p>显然启发式算法的设计对于最终计算得到的路径会产生显著的影响。当启发函数的值过低时可能会需要更多次循环才能寻找到路径，而当启发函数值过高时则可能无法找到最短路径。因此在实际应用中需要进行一定的权衡。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uNt3Qqi.png\" width=\"80%\">\n</div>\n<h3 id=\"path-smoothing\"><a class=\"anchor\" href=\"#path-smoothing\">#</a> Path Smoothing</h3>\n<p>直接使用寻路算法得到的路径往往包含各种各样的折线不够光滑，因此我们还需要使用一些路径平滑的算法来获得更加光滑的路径。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/65QCV5I.png\" width=\"80%\">\n</div>\n<p>游戏导航中比较常用 funnel 算法来对折线路径进行平滑，它不仅可以应用在二维平面上也可以应用在寻路网格上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Xt09Pyl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HuTJwNr.png\" width=\"80%\">\n</div>\n<h3 id=\"navmesh-generation\"><a class=\"anchor\" href=\"#navmesh-generation\">#</a> NavMesh Generation</h3>\n<p>如何从游戏地图上生成寻路网格是一个相对困难的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IttR04U.png\" width=\"80%\">\n</div>\n<p>一般来说想要生成寻路网格首先需要将地图转换为体素，然后在体素地图上计算距离场得到区域的划分，最后就可以在划分好的区域中生成一个凸多边形网格作为寻路网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5uHRHol.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PL4YnLA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zelYNTv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p8Chp6H.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g1MFQ9q.png\" width=\"80%\">\n</div>\n<p>除此之外我们还可以在多边形上设置不同的 flag 来触发不同的动画、声效以及粒子效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IWcQ6Z1.png\" width=\"80%\">\n</div>\n<p>对于动态的环境我们可以把巨大的场景地图划分为若干个 tile。当某个 tile 中的环境发生改变时只需要重新计算该处的路径就可以得到新的路径。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hsIXDXl.png\" width=\"80%\">\n</div>\n<p>还需要注意的是使用自动化算法生成的寻路网格是不包括传送点这样的信息的，有时为了提升玩家和场景的互动我们还需要手动设置这些传送点。当然这会导致寻路算法更加复杂。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SAtEQBW.png\" width=\"80%\">\n</div>\n<h2 id=\"steering\"><a class=\"anchor\" href=\"#steering\">#</a> Steering</h2>\n<p>得到最优路径后就可以根据路径来控制角色前进了。但在实际游戏中角色可能包含自身的运动学约束使得我们无法严格按照计算出的路径进行运动，这一点对于各种载具尤为明显。因此我们还需要结合<strong> steering</strong> 算法来调整实际的行进路径。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lp99uMo.png\" width=\"80%\">\n</div>\n<p>steering 算法可以按照行为分为以下几种：<strong>追赶和逃脱 (seek/flee)</strong>、<strong>速度匹配 (velocity match)<strong> 以及</strong>对齐 (align)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7adi8uZ.png\" width=\"80%\">\n</div>\n<h3 id=\"seekflee\"><a class=\"anchor\" href=\"#seekflee\">#</a> Seek/Flee</h3>\n<p>seek/flee 的要求是根据自身和目标当前的位置来调整自身的加速度从而实现追赶或是逃脱的行为，像游戏中的跟踪、躲避或是巡逻等行为都可以使用 seek/flee 来实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UiWKyTT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EOxRT6q.png\" width=\"80%\">\n</div>\n<h3 id=\"velocity-match\"><a class=\"anchor\" href=\"#velocity-match\">#</a> Velocity Match</h3>\n<p>velocity match 的目的是利用当前自身和目标的相对速度以及匹配时间来进行控制，使得自身可以按指定的速度到达目标位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HUdJyk0.png\" width=\"80%\">\n</div>\n<h3 id=\"align\"><a class=\"anchor\" href=\"#align\">#</a> Align</h3>\n<p>align 则是从角度和角加速度的层面进行控制，使得自身的朝向可以接近目标。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ToUpq8o.png\" width=\"80%\">\n</div>\n<h2 id=\"crowd-simulation\"><a class=\"anchor\" href=\"#crowd-simulation\">#</a> Crowd Simulation</h2>\n<p>** 群体模拟 (crowd simulation)** 是游戏 AI 必须要处理的问题。在游戏场景中往往会具有大量的 NPC，如何控制和模拟群体性的行为是现代游戏的一大挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eoP4lld.png\" width=\"80%\">\n</div>\n<p>游戏场景中群体模拟的先驱是 Reynolds，他同时也是 steering 系统的提出者。目前游戏中群体行为模拟的方法主要可以分为三种：<strong>微观模型 (microscopic models)</strong>、<strong>宏观模型 (macroscopic models)<strong> 以及</strong>混合模型 (mesoscopic models)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5MnaF9X.png\" width=\"80%\">\n</div>\n<h3 id=\"microscopic-models\"><a class=\"anchor\" href=\"#microscopic-models\">#</a> Microscopic Models</h3>\n<p>微观模型的思想是对群体中每一个个体进行控制从而模拟群体的行为，通常情况下我们可以设计一些规则来控制个体的行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SHkaE4Z.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k6LqZY9.png\" width=\"80%\">\n</div>\n<h3 id=\"macroscopic-models\"><a class=\"anchor\" href=\"#macroscopic-models\">#</a> Macroscopic Models</h3>\n<p>宏观模型的思想则是在场景中设计一个势场或流场来控制群体中每个个体的行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hRayLFW.png\" width=\"80%\">\n</div>\n<h3 id=\"mesoscopic-models\"><a class=\"anchor\" href=\"#mesoscopic-models\">#</a> Mesoscopic Models</h3>\n<p>混合模型则综合了微观和宏观两种模型的思路，它首先把整个群体划分为若干个小组，然后在每个小组中对每个个体使用微观模型的规则来进行控制。这样的方法在各种 RTS 游戏中有着广泛的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sILQ4Ki.png\" width=\"80%\">\n</div>\n<h3 id=\"collision-avoidance\"><a class=\"anchor\" href=\"#collision-avoidance\">#</a> Collision Avoidance</h3>\n<p>群体模拟中的一大难点在于如何保证个体之间不会出现碰撞的问题。比较常用的方法是对每个个体施加一定的力来控制它的运动，这样就可以操纵群体的运动行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rDCqeuH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/snYXpxU.png\" width=\"80%\">\n</div>\n<p>另一种处理的方法是基于 ** 速度障碍 (velocity obstacle, VO)** 来进行控制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NVg4MRR.png\" width=\"80%\">\n</div>\n<p>VO 的思想是当两个物体将要发生碰撞时相当于在速度域上形成了一定的障碍，因此需要调整自身的速度来避免相撞。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CpN0O5r.png\" width=\"80%\">\n</div>\n<p>当参与避让的个体数比较多时还需要进行一些整体的优化，此时可以使用 ORCA 等算法进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Qs8cIj1.png\" width=\"80%\">\n</div>\n<h2 id=\"sensing\"><a class=\"anchor\" href=\"#sensing\">#</a> Sensing</h2>\n<p><strong>感知 (sensing)<strong> 是游戏 AI 的基础，根据获得信息的不同我们可以把感知的内容分为</strong>内部信息 (internal information)<strong> 和</strong>外部信息 (external information)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6SDtqNB.png\" width=\"80%\">\n</div>\n<p>内部信息包括 AI 自身的位置、HP 以及各种状态。这些信息一般可以被 AI 直接访问到，而且它们是 AI 进行决策的基础。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DWpGTJP.png\" width=\"80%\">\n</div>\n<p>而外部信息则主要包括 AI 所处的场景中的信息，它会随着游戏进程和场景变化而发生改变。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3H0weGF.png\" width=\"80%\">\n</div>\n<p>外部信息的一种常用表达方式是<strong> influence map</strong>，场景的变化会直接反映在 influence map 上。当 AI 需要进行决策时会同时考虑自身的状态并且查询当前的 influence map 来选择自身的行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QMW85m8.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kENc5Mv.png\" width=\"80%\">\n</div>\n<p>游戏 AI 进行感知时还需要注意我们不能假设 AI 可以直接获得所有游戏的信息，而是希望 AI 能够像玩家一样只利用局部感知的信息来进行决策。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j7682HD.png\" width=\"80%\">\n</div>\n<h2 id=\"classic-decision-making-algorithms\"><a class=\"anchor\" href=\"#classic-decision-making-algorithms\">#</a> Classic Decision Making Algorithms</h2>\n<p>在上面这些知识的基础上就可以开始构建游戏 AI 系统了。游戏 AI 算法的核心是 ** 决策 (decision making)<strong> 系统，经典的决策系统包括</strong>有限状态机 (finite state machine, FSM)<strong> 和</strong>行为树 (behavior tree, BT)** 两种。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/e3jPk0w.png\" width=\"80%\">\n</div>\n<h3 id=\"finite-state-machine\"><a class=\"anchor\" href=\"#finite-state-machine\">#</a> Finite State Machine</h3>\n<p>在有限状态机模型中我们认为 AI 的行为可以建模为在不同状态之间的游走，不同状态之间的切换称为<strong>转移 (transition)</strong>。以吃豆人游戏为例，游戏 AI 可以使用一个包含 3 个状态的状态机来表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/N2Ra01C.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Z31sYmR.png\" width=\"80%\">\n</div>\n<p>有限状态机的缺陷在于现代游戏中 AI 的状态空间可能是非常巨大的，因此状态之间的转移会无比复杂。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p6GJfIY.png\" width=\"80%\">\n</div>\n<p>为了克服有限状态机过于复杂的问题，人们还提出了 **hierarchical finite state machine (HFSM)** 这样的模型。在 HFSM 中我们把整个复杂的状态机分为若干层，不同层之间通过有向的接口进行连接，这样可以增加模型的可读性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B7s5Eop.png\" width=\"80%\">\n</div>\n<h3 id=\"behavior-tree\"><a class=\"anchor\" href=\"#behavior-tree\">#</a> Behavior Tree</h3>\n<p>在现代游戏中更为常用的决策算法是行为树，它的决策行为更接近人脑的决策过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fB7RF1x.png\" width=\"80%\">\n</div>\n<p>行为树中的 ** 执行节点 (excution node)** 表示 AI 执行的过程，它包括条件判断以及具体执行的动作两种节点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AAMJSsw.png\" width=\"80%\">\n</div>\n<p>行为树中的另一种节点是<strong>控制节点 (control node)</strong>，它用来表示决策过程的控制流。control node 包括 sequence、selector、parallel 以及 decorator 等几种。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mUME3m1.png\" width=\"80%\">\n</div>\n<p><strong>sequence</strong> 是表示对当前节点的子节点依次进行访问和执行，一般可以用来表示 AI 在当前状态下的行为计划。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZICLz0o.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BxrTXGy.png\" width=\"80%\">\n</div>\n<p><strong>selector</strong> 同样会遍历当前节点的子节点，但不同于 sequence 的地方是如果某个子节点返回 True 则会终止遍历。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/82BGT5I.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5NW15o2.png\" width=\"80%\">\n</div>\n<p><strong>parallel</strong> 会同时执行当前节点下的所有子节点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Er2XteB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2f48cJz.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gul61tg.png\" width=\"80%\">\n</div>\n<p>行为树在进行执行时需要注意每一次执行时都需要返回根节点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OD7uAsQ.png\" width=\"80%\">\n</div>\n<p>在现代游戏中还提出了<strong> decorator</strong> 节点来丰富可以执行的行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Dzh4NyR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QANYKPp.png\" width=\"80%\">\n</div>\n<p>我们还可以使用<strong> precondition</strong> 和<strong> blackborad</strong> 来提升决策过程的可读性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VEVFGoA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3nV406Y.png\" width=\"80%\">\n</div>\n<p>行为树的决策过程非常符合人的决策行为而且也易于调试，因此广泛应用在各种游戏 AI 中。当然行为树也有一些缺点，比如说每次调用时都必须从根节点出发重新执行，这样的效率是比较低的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hvAQ2Ra.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g8kpKWM.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PLt4gjd.png\" width=\"80%\">\n</div>\n<p>目前随着 AI 技术的发展，游戏 AI 也开始使用一些 ** 规划 (planning)** 算法来进行决策。这些更先进的算法我们会在后面的课程进行介绍。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wzZRDuz.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTlONHkxVDdlVT9zcG1faWRfZnJvbT0zMzMuMzM3LnNlYXJjaC1jYXJkLmFsbC5jbGljayZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 16：Basic Artificial Intelligence (Part I)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXIzNHkxSjdTZy8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 16：Basic Artificial Intelligence (Part II)</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/",
            "title": "games104系列笔记（十五）",
            "date_published": "2023-06-28T15:01:04.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中的玩法系统。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"overview\"><a class=\"anchor\" href=\"#overview\">#</a> Overview</h2>\n<p>玩法系统是游戏引擎最重要的部分，它是区分游戏引擎和渲染器以及物理引擎的核心。实际上玩法系统往往会贯穿整个游戏引擎，与引擎的其它系统进行交互，这样才能满足游戏设计师的需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M4uTyxk.png\" width=\"80%\">\n</div>\n<p>另一方面现代游戏的玩法是极其丰富的，即使是同一类型的游戏也具有多种多样的表现形式。这些丰富的游戏内容都需要通过玩法系统来进行实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/n8dyUHT.png\" width=\"80%\">\n</div>\n<p>而在游戏行业中玩法系统还面临着快速迭代的问题，同一个游戏的核心玩法在开发运营初期和后期可能会有着巨大的差别。因此玩法系统在设计时也需要考虑需求变更和快速迭代。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zooQ5OC.png\" width=\"80%\">\n</div>\n<h2 id=\"event-mechanism\"><a class=\"anchor\" href=\"#event-mechanism\">#</a> Event Mechanism</h2>\n<p>玩法系统的核心是<strong>事件机制 (event mechanism)</strong>，在游戏世界中不同类型的 GO 会通过事件 / 消息的方式进行通信从而驱动游戏世界的运行。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MWD6VBi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tJkUrTI.png\" width=\"80%\">\n</div>\n<h3 id=\"publish-subscribe-pattern\"><a class=\"anchor\" href=\"#publish-subscribe-pattern\">#</a> Publish-Subscribe Pattern</h3>\n<p>在游戏引擎中一般会使用<strong> publish-subscribe</strong> 这样的模式来实现具体的通信过程。在 publish-subscribe 模式中每个 GO 有着自己的 publish 功能来向其它 GO 发送事件，同时自身的 subscribe 功能来实现接收事件以及相应的反馈。当然在 publish-subscribe 模式中还需要一个<strong> event dispatcher</strong> 来执行高效的事件派送。因此在 publish-subscribe 模式中的三要素为<strong>事件定义 (event definition)</strong>、<strong>注册回调 (callback registration)<strong> 以及</strong>事件派送 (event dispatching)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2nVAJad.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DfwNkkL.png\" width=\"80%\">\n</div>\n<h3 id=\"event-definition\"><a class=\"anchor\" href=\"#event-definition\">#</a> Event Definition</h3>\n<p>事件定义是实现事件机制的第一步，最简单的定义方式是为事件定义一个类型以及相应的参数。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uCJTv82.png\" width=\"80%\">\n</div>\n<p>因此我们可以使用继承的方式来实现不同类型事件的定义。但这种方式的缺陷在于玩法系统往往是由设计师来实现的，而对于游戏引擎来说一般无法由程序员事先确定。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/o77FA7j.png\" width=\"80%\">\n</div>\n<p>在现代游戏引擎中会使用反射和代码渲染的方式来允许设计师自定义事件类型和相关的数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oBNZmKu.png\" width=\"80%\">\n</div>\n<h3 id=\"callback-registration\"><a class=\"anchor\" href=\"#callback-registration\">#</a> Callback Registration</h3>\n<p>当 GO 接收到事件后就会激活调用相应的回调函数来改变自身的状态，而为了正确地使用回调函数则首先需要对不同的回调函数进行注册。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/adtFj5v.png\" width=\"80%\">\n</div>\n<p>回调函数的一大特点在于它的注册和执行往往是分开的。这一特点可能会导致回调函数调用时相关的一些 GO 可能已经结束了生命周期，因此回调函数的安全性是整个事件系统的一大难题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iYe01qG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5N8opi1.png\" width=\"80%\">\n</div>\n<p>为了处理这样的问题我们可以使用 ** 强引用 (strong reference)** 这样的机制来锁定相关 GO 的生命周期。强引用会保证所有和回调函数相关的资源在回调函数调用前不会被回收，从而确保系统的安全。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Oo0C0MI.png\" width=\"80%\">\n</div>\n<p>当然强引用的方式在一些场景下可能是不合适的，很多时候我们希望某些资源可以正确的卸载掉。因此我们还可以使用 ** 弱引用 (weak reference)** 的机制在调用回调函数时判断资源是否已经被卸载掉。当然弱引用机制的滥用可能会影响整个系统的性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UnuKH6g.png\" width=\"80%\">\n</div>\n<h3 id=\"event-dispatching\"><a class=\"anchor\" href=\"#event-dispatching\">#</a> Event Dispatching</h3>\n<p>事件会通过分发系统来实现消息的传递。由于游戏中每一时刻往往存在着成千上万个 GO 和相应的回调函数，我们需要一个非常高效的分发系统才能保证游戏的实时性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bOB6gmu.png\" width=\"80%\">\n</div>\n<p>最简单的分发机制是把消息瞬时发出去。这种方式的缺陷在于它会阻塞前一个函数的执行，从而形成一个巨大的调用栈使得系统难以调试；此外很多回调函数在执行时会申请一些额外的资源，这就容易导致游戏的帧率很难稳定。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eiuBCwp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6OzCzgs.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bhRBpjP.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ohtMhb8.png\" width=\"80%\">\n</div>\n<p>现代游戏引擎中更常用的分发方式是使用 ** 事件队列 (event queue)** 来收集当前帧上所有的事件，然后在下一帧再进行分发和处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vkJfaKd.png\" width=\"80%\">\n</div>\n<p>由于 event queue 中有不同类型的事件，因此我们还需要结合序列化和反序列化的操作来进行存储。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lpqlllo.png\" width=\"80%\">\n</div>\n<p>event queue 一般会使用 ring buffer 这样的数据结构来实现，这样可以重用一块统一的内存空间来提升效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/I3nS0JC.png\" width=\"80%\">\n</div>\n<p>现代游戏引擎中往往会同时有多个不同的 event queue 来处理不同类型的事件，每个 queue 用来保存一些相对独立的事件。这种方式可以便于我们进行调试，也可以提升系统的性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HL9kTFx.png\" width=\"80%\">\n</div>\n<p>当然 event queue 也有一些自身的问题。首先 event queue 无法保证 event 执行的顺序，同时对于一些实时性的事件 event queue 可能会导致执行的延误。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sF6elEf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qAxWa7o.png\" width=\"80%\">\n</div>\n<h2 id=\"game-logic\"><a class=\"anchor\" href=\"#game-logic\">#</a> Game Logic</h2>\n<p>在事件机制的基础上就可以开始设计游戏的逻辑了。在早期的游戏开发中会直接使用 C++ 来编写游戏的逻辑来获得更高的运行效率，而随着游戏系统变得越来越复杂这种直接基于高级语言的开发方式就不能满足开发者的需求了。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Xvdfo63.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eWxcFLO.png\" width=\"80%\">\n</div>\n<p>除此之外游戏引擎面对的用户往往是设计师而不是程序员，对于设计师来说直接使用编程语言来设计游戏可能是过于复杂的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5zZJRVB.png\" width=\"80%\">\n</div>\n<p>因此在现代游戏引擎中往往会使用脚本语言来实现游戏的开发工作，它的优势在于它可以直接在虚拟机上运行。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dNcnEOo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rphXyr7.png\" width=\"80%\">\n</div>\n<p>因此我们可以把游戏中的很多逻辑使用脚本语言来实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EltRBBd.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IG7llbW.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DMymdJ3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7w4FmmQ.png\" width=\"80%\">\n</div>\n<p>脚本语言的另一大特点是可以进行热更新。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0PBbTOd.png\" width=\"80%\">\n</div>\n<p>当然脚本语言也有许多缺点，比如说它的效率一般会比较低，因此选择合适的脚本语言是十分重要的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JJETKQu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/R7sqFZi.png\" width=\"80%\">\n</div>\n<p>目前游戏行业中常用的脚本语言包括 Lua、Python、C# 等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/N6n9yIM.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ix8rNge.png\" width=\"80%\">\n</div>\n<h2 id=\"visual-scripting\"><a class=\"anchor\" href=\"#visual-scripting\">#</a> Visual Scripting</h2>\n<p>** 可视化脚本 (visual scripting)** 是现代游戏引擎几乎必备的功能。和传统的脚本语言相比可视化脚本无需开发者直接进行编程，因此它对于设计师和艺术家而言更容易进行掌握。像虚幻和 unity 这样的商业级游戏引擎都实现了自身的可视化脚本功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OuYzwbe.png\" width=\"80%\">\n</div>\n<p>当然可视化脚本本身也是一种编程语言，它需要实现相应的变量、语句、表达式、控制流程、函数甚至面向对象编程等功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/T3OIC8U.png\" width=\"80%\">\n</div>\n<p>以虚幻引擎的 blueprint 功能为例，每个变量需要封装数据类型以及作用域两种属性。而在可视化脚本中，不同类型的数据会使用不同的颜色来方便用户进行区分。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7diINMQ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ETiD8yJ.png\" width=\"80%\">\n</div>\n<p>在变量的基础上可以构造表达式，在可视化脚本中会使用节点来进行表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CbzSQ1V.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/N8udGlH.png\" width=\"80%\">\n</div>\n<p>而控制语句则会使用三角形的符号来表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/E4egf8p.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/J0rYHtg.png\" width=\"80%\">\n</div>\n<p>类似于高级语言中函数的概念，我们可以在可视化脚本中把节点按照一定的顺序连接起来形成一张图。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kAP0AFV.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/K9PxeUJ.png\" width=\"80%\">\n</div>\n<p>我们还可以把数据和函数打包在一起，这样就形成了类的概念。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Z7YnaXo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YAgARIW.png\" width=\"80%\">\n</div>\n<p>除此之外在可视化脚本中往往还需要提供一些方便用户操作的功能，如查找节点、调试等功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JHlBYnr.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cjv0pgm.png\" width=\"80%\">\n</div>\n<p>可视化脚本也有一些自身的问题。首先可视化脚本很难进行协作，在大型开发团队中很难把每个开发者定义的脚本直接组装到一起，往往需要通过大量人工的重新排序才能得到正确的结果；同时当脚本中的节点过多时整个脚本在视觉上可能会非常繁琐，让人难以阅读。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dCGF7Kh.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MsfxkoG.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qk3CIVW.png\" width=\"80%\">\n</div>\n<h2 id=\"character-control-and-camera\"><a class=\"anchor\" href=\"#character-control-and-camera\">#</a> Character, Control and Camera</h2>\n<p><strong>角色 (character)</strong>、** 控制 (control)<strong> 以及</strong>镜头 (camera)** 是构成玩家体验最重要的元素。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yVy94pM.png\" width=\"80%\">\n</div>\n<h3 id=\"character\"><a class=\"anchor\" href=\"#character\">#</a> Character</h3>\n<p>角色是指游戏中如何设置玩家控制角色以及 NPC 的运动和各种状态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bdHzj0F.png\" width=\"80%\">\n</div>\n<p>在现代游戏中角色的运动往往涉及大量不同的动画和状态改变，我们需要非常多的细节才能设计出符合人认知的角色运动。同时在游戏世界中角色还需要和环境中的各种元素进行互动，往往需要结合游戏引擎其它系统进行设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/F7wmsnO.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q0NUQcB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/I0tEGuu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hKjcuiP.png\" width=\"80%\">\n</div>\n<p>因此角色系统一般需要一个非常复杂的状态机模型来描述角色状态的切换和转移。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ImM2sox.png\" width=\"80%\">\n</div>\n<h3 id=\"control\"><a class=\"anchor\" href=\"#control\">#</a> Control</h3>\n<p>控制系统的核心问题是要兼容玩家不同的输入设备。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/TSeiwJr.png\" width=\"80%\">\n</div>\n<p>来自控制器的信号通过控制系统会转换成游戏可以识别的输入，然后通过事件机制来控制角色。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ddGNsyG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HovjByf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SueDW5C.png\" width=\"80%\">\n</div>\n<p>同时我们还可以利用控制器的反馈功能来进一步提升玩家的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KkwTVFA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A5537al.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cGaKiMT.png\" width=\"80%\">\n</div>\n<h3 id=\"camera\"><a class=\"anchor\" href=\"#camera\">#</a> Camera</h3>\n<p>镜头会直接描述玩家视角中看到的场景和事物。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LzMxHoo.png\" width=\"80%\">\n</div>\n<p>从实现角度来说，我们只要设置好相机的位置和视角就可以直接利用渲染系统来实现镜头的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QQpmD9n.png\" width=\"80%\">\n</div>\n<p>在游戏场景中最常见的情况是相机要绑定在玩家控制的角色身上，随着角色的运动一起运动。同时我们还需要保证相机在运动的过程中不要出现穿墙等各种问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rulwPTj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/U1zQYeE.png\" width=\"80%\">\n</div>\n<p>镜头系统的一大难点在于如何根据角色的状态来调整相机的相关参数，使游戏画面更接近于人眼的真实反映。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uXwXL2Z.png\" width=\"80%\">\n</div>\n<p>同时镜头系统也需要考虑各种相机特效的实现，包括镜头抖动、动态模糊等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/TQ1ADQk.png\" width=\"80%\">\n</div>\n<p>在复杂场景中往往还会有多个相机同时存在，因此我们也需要管理这些相机和相关参数。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MzLoNa4.png\" width=\"80%\">\n</div>\n<p>整个镜头系统对于提升和改善玩家的游戏体验起着至关重要的作用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rAW1YJC.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rQda0dm.png\" width=\"80%\">\n</div>\n<p>因此游戏引擎中的镜头系统需要允许用户使用脚本或是可视化脚本来编辑相机的各种属性和参数。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5eLbhpi.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXUzNHkxSDdqZD92ZF9zb3VyY2U9N2EyNTQyYzZjOTA5YjNlZTFmYWI1NTEyNzczNjA4MjY=\">Lecture 15：Gameplay Complexity and Building Blocks</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/",
            "title": "games104系列笔记（十四）",
            "date_published": "2023-06-28T15:00:51.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍工具链的应用和一些高级技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"glance-of-game-production\"><a class=\"anchor\" href=\"#glance-of-game-production\">#</a> Glance of Game Production</h2>\n<p>在现代游戏的开发过程中，设计师和艺术家往往需要使用大量的第三方工具来辅助进行游戏角色和场景的建模。同时对于不同类型的游戏，游戏玩法和关卡设计也往往存在着巨大的差别。因此对于工具链来说，它需要实现和不同开发工具的通信也要考虑不同用户的使用需求。除此之外 WYSIWYG 原则又要求开发者在引擎中的体验必须和实际游戏时完全一致的，这对工具链的设计提出了更大的挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pgMUmKK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/D6xwWPt.png\" width=\"80%\">\n</div>\n<h2 id=\"world-editor\"><a class=\"anchor\" href=\"#world-editor\">#</a> World Editor</h2>\n<p>** 世界编辑器 (world editor)** 是整合了游戏引擎中几乎所有功能的平台。以虚幻引擎为例，虚幻中的世界编辑器界面包括各种不同的面板以服务不同的开发者：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1Qk77H1.png\" width=\"80%\">\n</div>\n<h3 id=\"editor-viewport\"><a class=\"anchor\" href=\"#editor-viewport\">#</a> Editor Viewport</h3>\n<p><strong>viewport</strong> 可以说是整个编辑器最重要的窗口，它是连接开发者与所构建的游戏世界的接口。实际上在 viewport 中所展示的正是游戏世界在运行时的状态，从而方便开发者对游戏内容进行各种调整。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5iSoLRW.png\" width=\"80%\">\n</div>\n<h3 id=\"editable-object\"><a class=\"anchor\" href=\"#editable-object\">#</a> Editable Object</h3>\n<p>在编辑器中所有的对象都是<strong>可编辑对象 (editable object)</strong>，开发者可以根据需要调整这些对象的位置、姿态、材质等属性。因此游戏中所有的元素都必须抽象为这样的可编辑对象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9TnnzNb.png\" width=\"80%\">\n</div>\n<p>在同一个游戏场景中可能有成千上万个对象，因此我们需要一些高效的管理工具。在编辑器中往往会使用树状结构或是分层的方式来管理场景中的对象，有时还会根据对象自身的特点设计相应的管理工具。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Wapieq2.png\" width=\"80%\">\n</div>\n<p>当开发者选中某个对象时需要使用<a href=\"/2022/07/06/GAMES104-NOTES-13.html#schema\"> schema</a> 来获取该对象自身的信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KI2FxmG.png\" width=\"80%\">\n</div>\n<h3 id=\"content-browser\"><a class=\"anchor\" href=\"#content-browser\">#</a> Content Browser</h3>\n<p>在编辑器中还需要实现<strong> content browser</strong> 用来管理开发过程中设计的各种美术、场景资产。在游戏开发过程中很多的资产是可以重复利用的，通过 content browser 可以方便地查看、检索以及分享现有的资产，从而提升游戏开发的效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xSuZ3lF.png\" width=\"80%\">\n</div>\n<h3 id=\"editing\"><a class=\"anchor\" href=\"#editing\">#</a> Editing</h3>\n<p>因此世界编辑器的核心功能是方便开发者去编辑游戏场景中的各种对象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/l3TLTVe.png\" width=\"80%\">\n</div>\n<p>而在编辑器的实现中，首先也是最重要的功能是如何实现通过鼠标来选取物体。最简单的实现方法是使用渲染系统中的 ray casting 功能，利用鼠标的位置来发射光线并通过与物体 bounding box 求交来来选择物体。这种实现的缺陷在于当物体比较复杂时 bounding box 是不能完全反应物体的几何形状的，此时使用 ray casting 的效率可能会比较低。另一种实现方法是在渲染流程中添加一个额外的选取帧，为图像上每一个像素赋予一个物体编号，这样使用鼠标进行选取时只需根据物体编号进行查询即可。当然这种实现方式对计算机的硬件提出了更高的要求，同时需要注意在游戏发布时去掉这部分编辑环境下的代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0QfFkOA.png\" width=\"80%\">\n</div>\n<p>选取得到物体后一般还会对物体进行一些几何变换，包括平移、旋转和缩放等，这些操作的具体实现往往还需要根据使用者的习惯来进行设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/t0H5csf.png\" width=\"80%\">\n</div>\n<p>对地形进行设计时需要结合高度场、地形纹理以及各种装饰件等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Tfn5MJ7.png\" width=\"80%\">\n</div>\n<p>对于边界器来说地形设计最常用的工具是<strong>高度笔刷 (height brush)</strong>，如何对设计出的高度场进行平滑需要很多相关的经验。当然很多商业级引擎中还提供了自定义的工具来帮助设计师对效果进行定制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CUlM65E.png\" width=\"80%\">\n</div>\n<p>另一种常用的笔刷是<strong> instance brush</strong>，它通常用来在设计好的地形上添加各种装饰件。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XR66JYw.png\" width=\"80%\">\n</div>\n<p>除此之外编辑器还需要提供各种环境元素的实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xnNtXAq.png\" width=\"80%\">\n</div>\n<h3 id=\"rule-system\"><a class=\"anchor\" href=\"#rule-system\">#</a> Rule System</h3>\n<p>游戏中的各种对象需要按照一定的规则来组织起来，因此 ** 规则系统 (rule system)** 也是编辑器的重要组件。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DUakQeV.png\" width=\"80%\">\n</div>\n<p>早期的游戏引擎往往不包括这样的系统，为了保证游戏世界的合理性需要设计师人工调整游戏中的各种对象。而在现代游戏引擎中则需要提供自动化的规则系统，通过程序化的方式来保证游戏中的各种对象遵循相互之间的规则。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0KDZu1V.png\" width=\"80%\">\n</div>\n<h2 id=\"editor-plugin-architecture\"><a class=\"anchor\" href=\"#editor-plugin-architecture\">#</a> Editor Plugin Architecture</h2>\n<p>显然整个世界编辑器是一个非常复杂的软件程序，我们很难直接在开发过程中实现所有需要的功能。因此在现代游戏引擎中一般会设计相应的插件系统来帮助用户根据自身的需求来丰富编辑器的功能。实际上不仅是游戏引擎，很多现代软件都使用了类似的策略来允许用户对系统进行定制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Heddgrs.png\" width=\"80%\">\n</div>\n<p>而对于游戏引擎而言，插件系统需要考虑的一个问题是如何对插件种类进行划分。我们可以按照游戏对象的种类 (网格、粒子、动画等) 对插件进行分类，也可以根据对象的内容 (NPC、建筑、人群等) 进行分类。因此现代游戏引擎的编辑器往往需要支持这种矩阵式的分类方法，允许用户根据喜好来选择和定制插件。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AG4kekg.png\" width=\"80%\">\n</div>\n<p>在对插件系统进行整合时还需要考虑不同插件之间的版本问题。不同的版本之间可以按照 ** 覆盖 (covered)<strong> 或是</strong>分布式 (distributed)** 的方式进行协作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/50VKL1d.png\" width=\"80%\">\n</div>\n<p>除了上面提到的两种模式外，对于几何数据往往还会使用 ** 流水线 (pipeline)<strong> 的模式将几何体的操作进行分解；而对于更加复杂的对象有时还会使用</strong>洋葱圈 (onion ring)** 的模式同时和其他的插件进行协作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZBzBAMe.png\" width=\"80%\">\n</div>\n<p>随着编辑器以及各种插件之间版本的迭代，插件系统一般还需要考虑版本控制的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ess3RP9.png\" width=\"80%\">\n</div>\n<h2 id=\"design-narrative-tools\"><a class=\"anchor\" href=\"#design-narrative-tools\">#</a> Design Narrative Tools</h2>\n<p>除了游戏资产的设计外，** 叙事 (story telling)** 在整个游戏开发流程中同样是非常重要的一环。叙事可以看做一个线性的过程，相关的游戏资产需要在一个时间轴上按照顺序进行调度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/F0TfW5l.png\" width=\"80%\">\n</div>\n<p>在虚幻引擎中使用了 sequencer 来跟踪游戏对象及其属性在时间轴上的变化。当我们把不同的对象利用 sequencer 在时间轴上组织起来就实现了简单的叙事。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YE9ZvnD.png\" width=\"80%\">\n</div>\n<p>要使用 sequencer 首先需要选中对象然后把 sequencer 绑定到对象上，然后选择相关的属性并利用关键帧设置这些属性的变化，最后利用插值就完成了叙事。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Qy4BWH0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M8aF6Ko.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LL6iwde.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8ujzyal.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HWZK46Q.png\" width=\"80%\">\n</div>\n<h2 id=\"reflection-and-gameplay\"><a class=\"anchor\" href=\"#reflection-and-gameplay\">#</a> Reflection and Gameplay</h2>\n<p>** 反射 (reflection)** 是 sequencer 乃至整个游戏引擎编程中都非常重要的技术，通过反射我们可以让游戏引擎在运行阶段获取操作对象具有的各种属性。实际上对于游戏开发流程而言，游戏引擎的开发者很难实现预判用户的需求。因此反射对于现代游戏引擎而言几乎是一个必备的工具。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BWjqLtP.png\" width=\"80%\">\n</div>\n<p>早期的游戏引擎是不基于反射技术来实现的，这导致开发者在进行编程时必须手动为游戏对象添加所有需要的属性和数据，使得工具链的开发很难与游戏开发进行匹配。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q2tRbPK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/89mkQdY.png\" width=\"80%\">\n</div>\n<p>反射是现代高级语言中引入的一个非常实用的概念。通过反射，系统可以获知每个新实现的类提供的接口。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LMhACJh.png\" width=\"80%\">\n</div>\n<p>反射可以理解为沟通代码和工具之间的一座桥梁。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eYByCba.png\" width=\"80%\">\n</div>\n<p>在 C++ 中默认是不支持反射的，不过可以基于编译器来实现反射的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kR3g1VR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4eBkq8q.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cqVwhah.png\" width=\"80%\">\n</div>\n<p>在本课程提供的小引擎中使用了 clang 编译器来实现反射。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CXfbdmz.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1MZ69FW.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M7dcRZ4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M7dcRZ4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MOD3gZE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9ITQZEc.png\" width=\"80%\">\n</div>\n<p>除此之外，在小引擎中还使用了 ** 代码渲染 (code rendering)** 的技术来自动生成相关的代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/49M3Teb.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zxkDMRf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kyj3wYU.png\" width=\"80%\">\n</div>\n<h2 id=\"collaborative-editing\"><a class=\"anchor\" href=\"#collaborative-editing\">#</a> Collaborative Editing</h2>\n<p>** 协同编辑 (collaborative editing)** 是现代游戏在开发过程中所需要面对的挑战。在复杂的游戏场景中往往需要大量的开发工作者进行协作，如何保证协作开发中各种资源的合理调度并避免相互之间的冲突是一个相等复杂的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OMmmiE3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Vi6YOdM.png\" width=\"80%\">\n</div>\n<p>避免冲突最简单直接的方法是对整个任务按照内容进行分解，然后安排不同的开发者独立地进行开发。但这种管理方式的问题在于有时很难进行合理的划分，而且在很多情况下不同的任务之间存在相互依赖。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/07qG99h.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hvcwjNA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kIrT0IO.png\" width=\"80%\">\n</div>\n<p>另一种常见的处理方法是直接对任务进行分解，但这种处理方法的效果同样不够理想，容易产生场景的割裂。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/a845LsV.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QTlI3Ew.png\" width=\"80%\">\n</div>\n<p>在虚幻引擎中提出了 OFPA 的策略来生成大量的文件来进行管理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ftuIylf.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uVMs2Xs.png\" width=\"80%\">\n</div>\n<p>实际上协同编辑的终极目标是允许不同的开发者同时在同一个系统上进行编辑。尽管这个问题仍然非常复杂，但它已经成为了现代大型软件系统的研究热点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/krm1GDp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZiRnE4W.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7XR15OG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IMPvGtL.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z9AbOiz.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dsMATRi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jzs93s2.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FYnaK7Y.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nl2epxk.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVFONHkxdTc4UC8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 14：Tool Chains</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/",
            "title": "games104系列笔记（十三）",
            "date_published": "2023-06-28T15:00:46.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中的工具链。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"tool-chain\"><a class=\"anchor\" href=\"#tool-chain\">#</a> Tool Chain</h2>\n<p>** 工具链 (tool chain)** 是沟通游戏引擎用户以及更底层 run time (渲染系统、物理引擎、网络通信等) 之间的桥梁。对于商业级游戏引擎来说，工具链的工程量往往要比 run time 大得多。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0NRgQ9s.png\" width=\"80%\">\n</div>\n<p>另一方面，工具链也是连接游戏引擎以及第三方 DCC 工具的核心。在现代游戏工业中需要使用到大量的第三方工具如 MAYA、3DS MAX 等，在进行游戏开发时需要通过工具链将这些第三方 DCC 的资源加载到游戏引擎中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OWjN2oF.png\" width=\"80%\">\n</div>\n<p>从更高级的视角来看，工具链的本质是调和不同背景和思维方式用户的一套平台。对于开发者，工具链需要方便开发者管理游戏中大量资源和对象；对于设计师，工具链需要帮助他们快速实现不同的游戏逻辑；而对于艺术家，工具链则需要帮助他们表达不同的创意。工具链需要服务这些拥有不同知识背景的用户以便更好地完成游戏开发的过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CN0im4K.png\" width=\"80%\">\n</div>\n<h2 id=\"complicated-tool\"><a class=\"anchor\" href=\"#complicated-tool\">#</a> Complicated Tool</h2>\n<h3 id=\"gui\"><a class=\"anchor\" href=\"#gui\">#</a> GUI</h3>\n<p>GUI 是工具链与用户直接进行交互的接口，在现代软件工程中 GUI 是人机交互的必要模块。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d5Vo39i.png\" width=\"80%\">\n</div>\n<p>目前 GUI 主要有两大类实现方式，其一是<strong> immediate mode</strong>。在 immediate mode 中用户的操作会直接调用 GUI 模块进行绘制，让用户立刻看到操作后的效果。这种模式的特点是它非常直观而且易于实现，但它的效率和可拓展性往往不尽如人意。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mULZMjS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ss1pyou.png\" width=\"80%\">\n</div>\n<p>在现代游戏引擎中更常用的 GUI 实现方式是<strong> retained mode</strong>。在 retained mode 中用户的操作不会直接进行绘制，而是会把用户提交的指令先存储到一个 buffer 中，然后在引擎的绘制系统中再进行绘制。这样做的好处是可以极大地提高系统的运行效率和可拓展性，当然代价是这种方式的实现要更加复杂。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WMShmUa.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fj7b0OF.png\" width=\"80%\">\n</div>\n<h3 id=\"design-pattern\"><a class=\"anchor\" href=\"#design-pattern\">#</a> Design Pattern</h3>\n<p>在设计 GUI 系统时需要 ** 设计模式 (design pattern)** 相关的知识，这里简要介绍一些在 GUI 设计中常用的设计模式。</p>\n<h4 id=\"mvc\"><a class=\"anchor\" href=\"#mvc\">#</a> MVC</h4>\n<p>MVC 是经典的人机交互设计模式。MVC 的思想是把<strong>用户 (user)</strong>、** 视图 (view)<strong> 和</strong>模型 (model)<strong> 进行分离，当用户想要修改视图时只能通过</strong>控制器 (controller)** 进行操作并由控制器转发给模型，从而避免用户直接操作数据产生各种冲突。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UYl6x0x.png\" width=\"80%\">\n</div>\n<h4 id=\"mvp\"><a class=\"anchor\" href=\"#mvp\">#</a> MVP</h4>\n<p>MVP 可以看做是对 MVC 的演变。MVP 模式对视图和模型进行了更彻底的分离，视图只负责对数据进行展示而模型只负责对数据进行处理，它们之间的通信则通过 ** 展示者 (presenter)** 来实现。当用户想要修改数据时，用户的请求会通过视图提交给展示者，然后再由它转发给模型进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZGIJtvh.png\" width=\"80%\">\n</div>\n<h4 id=\"mvvm\"><a class=\"anchor\" href=\"#mvvm\">#</a> MVVM</h4>\n<p>MVVM 是目前游戏引擎中大量使用的 UI 设计模式，在 MVVM 中视图和模型的中间层称为<strong> ViewModel</strong>。在 MVVM 模式中，视图只包含简单的 UI 状态数据，这些数据通过 ViewModel 解析成合适的数据结构再提交给模型进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DZhWLgl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5CrPt9f.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A3haF2l.png\" width=\"80%\">\n</div>\n<h3 id=\"load-and-save\"><a class=\"anchor\" href=\"#load-and-save\">#</a> Load and Save</h3>\n<p>加载和保存各种不同类型的数据是工具链的核心功能。在保存数据时需要使用 ** 序列化 (serialization)<strong> 的技术来将各种不同的数据结构或是 GO 转换成二进制格式，而当需要加载数据时则需要通过</strong>反序列化 (deserialization)** 从二进制格式恢复原始的数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1htdhGc.png\" width=\"80%\">\n</div>\n<p>最简单的序列化方法是把数据打包成 text 文件。text 文件虽然简单，但实际上目前很多系统仍然是使用 text 文件进行信息的传输。目前常用的 text 文件格式包括 json、yaml、xml 等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hymNWCB.png\" width=\"80%\">\n</div>\n<p>text 文件可以方便开发人员理解存储数据的内容，但计算机对于文本的读取和处理往往是比较低效的。当需要序列化的数据不断增长时就需要使用更加高效的存储格式，通常情况下我们会使用二进制格式来对数据进行存储。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/44an1yH.png\" width=\"80%\">\n</div>\n<p>和 text 文件相比，二进制文件往往只占用非常小的存储空间，而且对数据进行读取也要高效得多。因此在现代游戏引擎中一般都会使用二进制文件来进行数据的保存和加载。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uIWX55d.png\" width=\"80%\">\n</div>\n<h3 id=\"asset-reference\"><a class=\"anchor\" href=\"#asset-reference\">#</a> Asset Reference</h3>\n<p>在很多情况下游戏的资产是重复的，此时为每一个实例单独进行保存就会浪费系统的资源。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6o4TUa4.png\" width=\"80%\">\n</div>\n<p>因此，在现代游戏引擎中会使用 ** 资产引用 (asset reference)** 的方式来管理各种重复的资产。实际上资产的引用和去重是游戏引擎工具链最重要的底层逻辑之一。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dWNWesQ.png\" width=\"80%\">\n</div>\n<p>在游戏开发过程中工具链往往还需要提供对 GO 进行修改，从而实现不同的艺术效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nQuoZpq.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/88u3JwT.png\" width=\"80%\">\n</div>\n<p>在调整和修改数据时直接进行复制很可能会破坏 GO 之间的关联而且容易造成数据的冗余，因此在现代游戏引擎中对于数据引入了 ** 继承 (inheritance)** 的概念。数据之间的继承可以很方便地派生出更多更复杂的游戏对象，从而方便设计师和艺术家实现不同的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AAkNNR4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Yp383W1.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-load-asset\"><a class=\"anchor\" href=\"#how-to-load-asset\">#</a> How to Load Asset</h2>\n<h3 id=\"parsing\"><a class=\"anchor\" href=\"#parsing\">#</a> Parsing</h3>\n<p>在上一节我们主要是考虑如何对数据进行保存，而游戏引擎中工具链的一大难点在于如何加载不同的资产，即反序列化的过程。反序列化的过程可以理解为对文件进行<strong>解析 (parsing)</strong>，文件中的不同字段往往有着不同的关键字以及域。我们需要对整个文件进行扫描来获得整个文件的结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hPZ4DWO.png\" width=\"80%\">\n</div>\n<p>对文件完成解析后可以得到一棵由 &lt;key-value&gt; 对组成的树来表达不同类型的数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WjLLDGo.png\" width=\"80%\">\n</div>\n<p>实际上这样的过程与对文本文件的解析过程是非常类似的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kZu63C2.png\" width=\"80%\">\n</div>\n<h3 id=\"endianness\"><a class=\"anchor\" href=\"#endianness\">#</a> Endianness</h3>\n<p>对二进制文件进行反序列化和解析时需要额外注意<strong> endianness</strong> 的问题。在不同的硬件和操作系统上同样的二进制文件可能会被解析为不同的数据，这对于跨平台的应用需要额外注意。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uWBVtfN.png\" width=\"80%\">\n</div>\n<h3 id=\"version-compatibility\"><a class=\"anchor\" href=\"#version-compatibility\">#</a> Version Compatibility</h3>\n<p>在工具链的反序列化过程中还需要考虑资产的兼容性问题。游戏的开发周期往往是比较长的，在这一过程中可能会不可避免地出现引擎以及各种工具的升级。而我们希望新版本可以对旧版本中设计好的资源进行兼容，从而避免重复的劳动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tRLCjXu.png\" width=\"80%\">\n</div>\n<p>在版本更迭中最常见的情况是数据的域发生了修改，新版本的数据定义可能会添加或删去老版本定义的域。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/l4695Kj.png\" width=\"80%\">\n</div>\n<p>为了处理这种问题可以手动为数据添加版本号，在加载数据时根据版本号来控制加载过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7YLfES1.png\" width=\"80%\">\n</div>\n<p>更好的处理方法是使用 guid 来进行管理。如 Google 就提出了使用 protocol 来为每一个域赋予一个 uid，在进行反序列化时只需要对域的 uid 进行比较即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gxLIBKK.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-make-robust-tools\"><a class=\"anchor\" href=\"#how-to-make-robust-tools\">#</a> How to Make Robust Tools</h2>\n<p>在游戏引擎中工具链对于鲁棒性有非常高的要求，一旦游戏引擎的工具链出现问题会对整个游戏开发流程产生巨大的影响。鲁棒性最基本的要求是允许程序从崩溃中进行恢复，从而还原初始的开发状态。为了实现这样的功能我们需要将用户所有的行为抽象为原子化的<strong>命令 (command)</strong>，通过命令的序列来表示整个开发的过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6SedPCb.png\" width=\"80%\">\n</div>\n<p>对 command 类进行抽象时需要为每一个 command 实例赋予单调的 UID 从而保证顺序的正确性，同时每一个 command 定义都需要实现 <code>Invoke()</code>  和 <code>Revoke()</code>  方法表示执行命令以及恢复到执行命令前的状态。除此之外还需要实现 <code>Serialize()</code>  和 <code>Deserialize()</code>  方法来控制生成的数据序列化以及反序列化过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FENLvoB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xkpOW7x.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g5Asrev.png\" width=\"80%\">\n</div>\n<p>整个 command 系统可以划分为三种不同类型的指令，包括添加数据、删除数据以及更新数据。实际上几乎所有的 command 都可以视为这三种基本指令的组合。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2dbDrAt.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-make-a-tool-chain\"><a class=\"anchor\" href=\"#how-to-make-a-tool-chain\">#</a> How to Make a Tool Chain</h2>\n<p>现代游戏引擎的工具链往往包含成百上千个不同的工具程序，这些程序会面向不同背景的开发人员并实现相应的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/26uLq3N.png\" width=\"80%\">\n</div>\n<p>而对于工具链来说，一个基本要求是要保证不同工具之间的沟通以及整个系统的可拓展性。我们不希望每个工具程序都使用单独的一套数据定义方式，这会导致整个工具链系统过于庞大而且难以进行维护。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B2MRb3I.png\" width=\"80%\">\n</div>\n<p>因此我们需要去寻找不同工具中的一些共性，并把这些共同的数据封装为基本的单元。利用对这些基本单元的组合来描述更加复杂的数据结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wuHwT5L.png\" width=\"80%\">\n</div>\n<h3 id=\"schema\"><a class=\"anchor\" href=\"#schema\">#</a> Schema</h3>\n<p><strong>schema</strong> 是一种对数据进行描述的结构，它描述了具体的数据结构是由哪些基本单元构成的。在工具链系统中所有流动的数据都要通过 schema 来进行描述，从而保证不同的程序都可以对数据进行解读。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ywGKReN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ItSMQfM.png\" width=\"80%\">\n</div>\n<p>在 schema 的实现中一般也需要实现继承和引用功能来方便定义新的数据类型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/boGhyQO.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fyCio81.png\" width=\"80%\">\n</div>\n<p>不难发现 schema 与高级语言有着很多相似之处，实际上 schema 确实可以直接使用高级语言来进行定义。目前游戏引擎中的 schema 系统主要有两种实现方式，其一是单独实现 schema 的定义，而另一种则是使用高级语言进行定义。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bIniZQh.png\" width=\"80%\">\n</div>\n<p>这两种实现方式各有各的优缺点，它们的特点可以总结如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZRSr5wJ.png\" width=\"80%\">\n</div>\n<h3 id=\"three-views-for-engine-data\"><a class=\"anchor\" href=\"#three-views-for-engine-data\">#</a> Three Views for Engine Data</h3>\n<p>基于 schema 系统我们可以发现同样的数据在游戏引擎的不同系统和工具中可能会有不同的表现形式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RToxc9E.png\" width=\"80%\">\n</div>\n<p>在 runtime 中一般会以运行和计算效率为第一要务。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/F3nPiEJ.png\" width=\"80%\">\n</div>\n<p>而在进行存储时则要游戏考虑数据的读写速度和空间需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RwcMtLi.png\" width=\"80%\">\n</div>\n<p>而在面向开发者的工具程序中需要根据不同使用者的背景和需求来设计不同的数据表现形式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YqZDjkg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/P6VuXCs.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8h4bf9J.png\" width=\"80%\">\n</div>\n<h2 id=\"what-you-see-is-what-you-get\"><a class=\"anchor\" href=\"#what-you-see-is-what-you-get\">#</a> What You See is What You Get</h2>\n<p>** 所见即所得 (what you see is what you get, WYSIWYG)** 是我们设计构建整个工具链系统的核心精神，它的目标是保证设计师和艺术家在工具链中的设计结果能完美地重现在实际的游戏场景中。在早期的游戏引擎中一般会设计一个独立工具层用来辅助开发者进行设计，但这种设计方式往往会违背 WYSIWYG 原则因此在现代游戏引擎中基本已经被弃用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7KGoWr1.png\" width=\"80%\">\n</div>\n<p>目前商用级游戏引擎一般会把工具层设计在整个游戏引擎的最上层，换句话说工具层会调用底层的模块来辅助游戏开发者的工作。这种设计方式的好处是可以严格遵循 WYSIWYG 原则，提高开发效率。当然其缺陷在于此时的工具层依赖于整个引擎的实现，当引擎崩溃时工具链也会直接崩溃。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zsJdnzo.png\" width=\"80%\">\n</div>\n<h3 id=\"play-in-editor\"><a class=\"anchor\" href=\"#play-in-editor\">#</a> Play in Editor</h3>\n<p>基于 in game 的设计模式就可以实现在工具层中进行游戏，当然这也要求我们在工具层上再设置一个编辑器来编辑游戏的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k0fAnwK.png\" width=\"80%\">\n</div>\n<p>在编辑器中进行游玩时同样有两种实现方式，包括直接在编辑器中进行游戏或是基于编辑器当前的状态生成一个新的游戏窗口进行游戏。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q8FFyyj.png\" width=\"80%\">\n</div>\n<p>直接在编辑器中进行游戏可以无缝地对当前游戏场景进行编辑，但需要注意在进行编辑时不要污染游戏场景中的数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9T5XAiF.png\" width=\"80%\">\n</div>\n<p>另一种实现方式是新建一个沙盒来重现当前的游戏环境，整个游戏过程都在沙盒中进行。这种设计方式可以保证编辑器中的数据与实际游戏中的数据保持相互独立，避免出现数据污染的情况。在大型游戏引擎的开发中一般会使用这种模式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bBt73oT.png\" width=\"80%\">\n</div>\n<h2 id=\"plugin\"><a class=\"anchor\" href=\"#plugin\">#</a> Plugin</h2>\n<p>在工具链中我们往往还需要允许用户根据自身的需要自行设计并开发新的工具，也即<strong>插件 (plugin)</strong>。实际上这些插件定义了整个游戏引擎的可拓展性，在现代游戏开发过程中需要使用到各种各样的插件以实现不同的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rx3m7YQ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j0rqiuq.png\" width=\"80%\">\n</div>\n<p>目前市面上的商业级游戏引擎都对插件有很好的支持，方便用户自行开发和分享各种插件。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/s3uTdtW.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fFWKIUB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5KpxVqb.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Vm2YJQe.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NLw62RS.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTFUNDExRzdxQi8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 13：Tool Chains</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/",
            "title": "games104系列笔记（十二）",
            "date_published": "2023-06-28T15:00:35.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中的粒子和声效系统。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"particle-system\"><a class=\"anchor\" href=\"#particle-system\">#</a> Particle System</h2>\n<p>** 粒子系统 (particle system)** 是现代游戏中非常重要的组成部分，游戏中大量的特效都是基于粒子系统来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1nYY0vx.png\" width=\"80%\">\n</div>\n<h3 id=\"fundamentals\"><a class=\"anchor\" href=\"#fundamentals\">#</a> Fundamentals</h3>\n<p>实际上粒子系统来自于电影行业对于视觉特效的追求，它最早可以追溯到 1982 年的电影《星际迷航 2：可汗之怒》。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B22YoaE.png\" width=\"80%\">\n</div>\n<p>所谓的粒子是指具有一些物理信息的物体，常见的物理量包括位置、速度、大小、颜色等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/l1P5LWt.png\" width=\"80%\">\n</div>\n<p>同时粒子还需要考虑自身的<strong>生命周期 (life cycle)</strong>，当粒子的生命周期结束后需要被系统回收。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YX6cKLu.png\" width=\"80%\">\n</div>\n<h4 id=\"particle-emitter\"><a class=\"anchor\" href=\"#particle-emitter\">#</a> Particle Emitter</h4>\n<p>每一种不同的粒子都是由相应的 ** 粒子发射器 (particle emitter)** 生成的。每一种粒子发射器需要指定自身的生成规则同时为粒子赋予相应的仿真逻辑。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k2Fxw6q.png\" width=\"80%\">\n</div>\n<p>在一个粒子系统中往往会同时具有多个不同的例子发射器进行工作，它们之间相互配合就实现了丰富的粒子效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yf6Zs78.png\" width=\"80%\">\n</div>\n<h4 id=\"particle-spawn\"><a class=\"anchor\" href=\"#particle-spawn\">#</a> Particle Spawn</h4>\n<p>粒子系统在生成粒子时可以根据需求使用不同的生成策略。比较简单的生成方式是从单点生成粒子，而在现代粒子生成器中则可以从某个区域甚至从物体的网格来生成粒子。同时粒子生成器也可以根据需求只产生一次性的粒子，或是源源不断地生成新的粒子。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/211dGFE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RoX5ZrB.png\" width=\"80%\">\n</div>\n<h4 id=\"simulation\"><a class=\"anchor\" href=\"#simulation\">#</a> Simulation</h4>\n<p>完成粒子的生成后就可以利用质点运动学的相关方法对粒子进行仿真。由于粒子系统一般不需要严格地遵守物理规律，在实践中往往只会使用最简单的前向积分来实现对粒子状态进行更新。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MCd3qzl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QxLwHUq.png\" width=\"80%\">\n</div>\n<h4 id=\"particle-type\"><a class=\"anchor\" href=\"#particle-type\">#</a> Particle Type</h4>\n<p>早期的粒子系统会假定粒子都位于某个平面上进行运动，这种方法称为 billboard particle。当观察者的视角发生变化时，billboard 会随着观察者的视角一起变化从而保证它一直位于观察者的正前方。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/823PbYe.png\" width=\"80%\">\n</div>\n<p>随着游戏技术的进步，后来还出现了 mesh particle 这种带有几何信息的粒子。这种形式的粒子可以用来模拟岩石、碎屑等带有明显几何信息的颗粒。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NBFTU4J.png\" width=\"80%\">\n</div>\n<p>在很多游戏中还使用了 ribbon particle 这种带状的粒子用来模拟各种拖动的效果，比如说游戏中各种武器的特效一般都是使用这种技术来制作的。在使用 ribbon particle 时一般还会结合 Catmull 曲线来形成光滑连贯的特效。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LBPodD5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/csbLONb.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uKexVfU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FE5St2A.png\" width=\"80%\">\n</div>\n<h3 id=\"particle-system-rendering\"><a class=\"anchor\" href=\"#particle-system-rendering\">#</a> Particle System Rendering</h3>\n<h4 id=\"particle-sort\"><a class=\"anchor\" href=\"#particle-sort\">#</a> Particle Sort</h4>\n<p>粒子在进行渲染时的一大难点在于如何进行排序。按照 alpha 混合的理论，我们需要从最远端开始由远及近地对场景中的物体进行绘制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XGjKchv.png\" width=\"80%\">\n</div>\n<p>由于场景中往往同时存在巨量的粒子，对这些粒子进行排序往往会耗费大量的计算资源。目前对于粒子进行排序主要有两种做法：其一是全局排序即无考虑发射器的信息单纯对所有的粒子进行排序，这种做法可以获得正确的结果但需要非常多的计算资源；另一种做法是按照发射器进行排序，这种方法可以极大地减少计算资源但可能会出现错误的排序结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iGRGY5D.png\" width=\"80%\">\n</div>\n<h4 id=\"resolution\"><a class=\"anchor\" href=\"#resolution\">#</a> Resolution</h4>\n<p>当粒子充满场景时非透明的粒子会导致我们必须在同一像素上进行反复的绘制，这往往会导致帧数极大的下降。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/y2D8BOw.png\" width=\"80%\">\n</div>\n<p>因此在对粒子进行渲染时还会结合降采样的技术来减少需要进行绘制的像素数。把降采样后的图像和非透明的粒子按照透明度混合后在通过上采样来恢复原始分辨率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uR9sKNP.png\" width=\"80%\">\n</div>\n<h3 id=\"gpu-particle\"><a class=\"anchor\" href=\"#gpu-particle\">#</a> GPU Particle</h3>\n<p>显然粒子系统这种天然并行的系统非常适合使用 GPU 进行计算，在现代游戏中也确实是使用 GPU 来实现对粒子系统的仿真。稍后我们会看到使用 GPU 来对粒子系统进行计算不仅可以节约 CPU 的计算资源，更可以加速整个渲染的流程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QbAkj9p.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RlmoVbN.png\" width=\"80%\">\n</div>\n<h4 id=\"particle-lists\"><a class=\"anchor\" href=\"#particle-lists\">#</a> Particle Lists</h4>\n<p>我们可以通过维护若干个列表来实现对粒子系统的仿真。首先我们把系统中所有可能的粒子及其携带的信息放入 particle pool 中，并且在 deal list 中初始化所有的粒子编号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kRKwyMM.png\" width=\"80%\">\n</div>\n<p>当 emitter 生成新的粒子时只需要将 dead list 中的粒子推入当前帧的 alive list 即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GXE4vrw.png\" width=\"80%\">\n</div>\n<p>对粒子进行仿真时只需要考虑 alive list 中的粒子。如果某个粒子的生命周期结束了，则需要把该粒子编号重新放入 dead list 中，然后在写入下一帧的 alive list 时跳过该编号。当需要切换到下一帧时只需交换两个 alive list 即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wnxD34D.png\" width=\"80%\">\n</div>\n<p>由于所有的数据都在 GPU 上，我们还可以方便地对粒子进行 frustum culling 以及排序。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hnuZytT.png\" width=\"80%\">\n</div>\n<h4 id=\"parallel-mergesort\"><a class=\"anchor\" href=\"#parallel-mergesort\">#</a> Parallel Mergesort</h4>\n<p>在 GPU 上进行排序时需要使用并行的排序算法，其中比较经典的算法是<strong> parallel mergesort</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fbtqORb.png\" width=\"80%\">\n</div>\n<p>在合并两个有序数组时还可以使用从目标队列出发寻找源队列的方式进一步提升性能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Wi90uL8.png\" width=\"80%\">\n</div>\n<h4 id=\"depth-buffer-collision\"><a class=\"anchor\" href=\"#depth-buffer-collision\">#</a> Depth Buffer Collision</h4>\n<p>除此之外还可以在 GPU 中进行粒子和场景的碰撞检测。出于计算效率方面的考虑，在对粒子进行碰撞检测时一般只会使用屏幕空间和深度图来简化计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VTDR8mO.png\" width=\"80%\">\n</div>\n<h3 id=\"advanced-particles\"><a class=\"anchor\" href=\"#advanced-particles\">#</a> Advanced Particles</h3>\n<h4 id=\"crowd-simulation\"><a class=\"anchor\" href=\"#crowd-simulation\">#</a> Crowd Simulation</h4>\n<p>现代游戏的粒子系统已经远不局限于实现不同的视觉特效，实际上我们可以基于粒子系统来实现更加丰富的功能。比如说游戏中大量 NPC 的运动行为就可以利用粒子系统进行实现。此时每个粒子不仅仅具有常见的物理属性，还会携带顶点等几何信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9hECtLf.png\" width=\"80%\">\n</div>\n<p>基于粒子的几何信息还可以让 NPC 动起来，甚至可以利用状态机的理论制作简单的动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pvYnmyw.png\" width=\"80%\">\n</div>\n<p>基于 SDF 的相关技术还可以控制群体的运动行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lGuEqAR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Sk8EH0Z.png\" width=\"80%\">\n</div>\n<p>在虚幻 5 引擎中就实现了非常强大的粒子系统，从而方便开发者设计各种复杂的玩法和场景。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/01g4eH8.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IzX3uLr.png\" width=\"80%\">\n</div>\n<h4 id=\"utilizing-particle-system-in-games\"><a class=\"anchor\" href=\"#utilizing-particle-system-in-games\">#</a> Utilizing Particle System in Games</h4>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NXBoRfH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vh1aQww.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KtOp3xD.png\" width=\"80%\">\n</div>\n<h2 id=\"sound-system\"><a class=\"anchor\" href=\"#sound-system\">#</a> Sound System</h2>\n<p>音效是影响游戏氛围和玩家体验的重要一环，很多游戏都需要使用大量的音效来调动玩家的情绪。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9bNxo6a.png\" width=\"80%\">\n</div>\n<p>声音的大小称为<strong>音量 (volume)</strong>，它表示声波的振幅。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9HUyQPn.png\" width=\"80%\">\n</div>\n<p>从物理的角度上讲，声音的本质是空气的振动。当空气发生振动时会产生相应的压强，这个压强的大小就对应人感知到的音量。音量的单位是分贝 (dB)，它是基于人对于声音的感知来定义的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7psbvc7.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Yheun7X.png\" width=\"80%\">\n</div>\n<p>** 音高 (pitch)** 是描述人耳对声音调子感受的物理量，它取决于声音振动的频率。音高越高，声音就越尖锐。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EanjB77.png\" width=\"80%\">\n</div>\n<p>** 音色 (timbre)** 是描述声波形状的量。不同的乐器在演奏时会产生不同形式的基波，因此即使声波的频率相同也会产生不同的音色。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/myroGQ2.png\" width=\"80%\">\n</div>\n<p>由于声音的本质是空气振动，我们可以在接收端叠加一个与当前振动相反的振动从而产生静音的效果。这就是现代降噪耳机的基本原理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tbQL6zV.png\" width=\"80%\">\n</div>\n<p>人耳对不同频率声音的感受范围可参考下图：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oHJRdkZ.png\" width=\"80%\">\n</div>\n<h3 id=\"digital-sound\"><a class=\"anchor\" href=\"#digital-sound\">#</a> Digital Sound</h3>\n<p>自然界中的声音是连续的信号，因此要使用计算机存储或者表达声音就需要对连续的信号进行离散。最常用的声音采样设备是<strong> PCM (pulse-code modulation)</strong>，它可以把连续的信号量化为离散的数字信号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lTiRyK6.png\" width=\"80%\">\n</div>\n<p>根据 Nyquist 采样定理，我们只需要 2 倍于人耳接收频率的采样频率就可以完美的重建原始信号。不过在实际采样时往往会使用更高一些的采样频率来获得更好的音质。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k6YqIxR.png\" width=\"80%\">\n</div>\n<p>采样后的信号需要通过量化的过程编码为数字。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oTgd7Fe.png\" width=\"80%\">\n</div>\n<p>基于上面介绍的过程就可以把声音使用计算机可以识别和保存的数据。目前常用的声音格式如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fFDaAw8.png\" width=\"80%\">\n</div>\n<h3 id=\"3d-audio-rendering\"><a class=\"anchor\" href=\"#3d-audio-rendering\">#</a> 3D Audio Rendering</h3>\n<p>在游戏设计中我们需要在三维的环境里设置音效从而让玩家有身临其境的感受，因此我们需要设置一个虚拟的麦克风来采集场景中的声音。通常情况下这个虚拟麦克风需要包含位置、速度以及朝向等物理信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xIwlPfr.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/G3Dz2eZ.png\" width=\"80%\">\n</div>\n<p>对于人耳而言，我们可以利用双耳之间接收声音细微的变化来判断声源的大致位置。因此在游戏音效系统中可以利用人耳的这种效应来制造空间感。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/koA1TIX.png\" width=\"80%\">\n</div>\n<h4 id=\"panning\"><a class=\"anchor\" href=\"#panning\">#</a> Panning</h4>\n<p>当音响有多个通道时我们可以调整不同音响的参数来产生空间感，这种方法称为<strong> panning</strong>。最简单的 panning 是进行线性插值，假设有某个声源从前方经过，我们可以对左右两通道的声音进行线性插值来模拟这种效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d0oBcsX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/not5fZg.png\" width=\"80%\">\n</div>\n<p>实际上人耳对于声音的感知是一个非线性函数，因此我们可以使用平方函数来改进线性插值的效果。此时会出现当声源经过正前方时接收到的声音会小一点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wOjO7g6.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M88fAo1.png\" width=\"80%\">\n</div>\n<p>更进一步还可以使用三角函数来描述声音的变化，这样可以得到更逼真的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jLrz81m.png\" width=\"80%\">\n</div>\n<p>当然实际游戏中的 panning 算法会比上面介绍的要复杂得多，也可以表达更加复杂的空间位置变化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MTG38C2.png\" width=\"80%\">\n</div>\n<h4 id=\"attenuation\"><a class=\"anchor\" href=\"#attenuation\">#</a> Attenuation</h4>\n<p>当声源远离麦克风时会出现 ** 衰减 (attenuation)** 的现象，随着距离的增加虚拟麦克风能接受到的声音会不断减少。实际上不仅是接收到的音量会发生变化，距离也会对接收到声音的频率产生一定的影响。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bkYGlNk.png\" width=\"80%\">\n</div>\n<p>最简单的衰减模型是球形衰减，此时声音的变化只与声源和麦克风之间的距离有关。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z0Y5jGU.png\" width=\"80%\">\n</div>\n<p>更复杂的模型是胶囊形的衰减模型，它主要与麦克风到中心轴的距离相关。当接收端沿轴方向运动时声音的衰减基本保持不变。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4Xg3Q7q.png\" width=\"80%\">\n</div>\n<p>对于室内场景可以考虑盒子形的衰减模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MxJ8ZXj.png\" width=\"80%\">\n</div>\n<p>对于高音喇叭这种声源则可以使用锥形的衰减模型描述声源的朝向。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cwJcfuY.png\" width=\"80%\">\n</div>\n<h4 id=\"obstruction-and-occlusion\"><a class=\"anchor\" href=\"#obstruction-and-occlusion\">#</a> Obstruction and Occlusion</h4>\n<p>由于声音的本质是波，在封闭环境中还需要考虑声波与环境的互动。当声音被场景中的障碍物阻挡时可以通过衍射的方式继续传播，而如果声音的传播被完全阻挡它也可以通过阻挡物自身的振动继续向外传播。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q55bgZV.png\" width=\"80%\">\n</div>\n<p>因此在复杂的场景中往往需要使用一些采样的方法来模拟声音传播的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BZCJn3S.png\" width=\"80%\">\n</div>\n<h4 id=\"reverb\"><a class=\"anchor\" href=\"#reverb\">#</a> Reverb</h4>\n<p>除此之外声音在室内场景中还会出现 ** 混响 (reverb)** 的现象，这是由于声波在场景中不断反射所导致的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AUq95ka.png\" width=\"80%\">\n</div>\n<p>混响的效果很大程度上取决于材质的吸声特性，不同材质往往在不同的频率上有着巨大的性能差异。另一方面混响也取决于场景的几何特征。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/habH87x.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/72JL3Iy.png\" width=\"80%\">\n</div>\n<p>通过调整不同的混响组合比例可以实现丰富的声学效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VCBHqaG.png\" width=\"80%\">\n</div>\n<h4 id=\"sound-in-motion\"><a class=\"anchor\" href=\"#sound-in-motion\">#</a> Sound in Motion</h4>\n<p>当声源发生运动时由于 Doppler 效应会导致接收端接收到的频率发生变化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p8J2WFm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pbqTEs5.png\" width=\"80%\">\n</div>\n<h4 id=\"sound-field\"><a class=\"anchor\" href=\"#sound-field\">#</a> Sound Field</h4>\n<p>很多时候还可以对整个声场进行采集。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PjCoFP5.png\" width=\"80%\">\n</div>\n<p>目前市面上常用的专业级声学引擎包括 fmod 或 wwise 等，这些引擎可以更好地辅助专业的声学设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UbUmsiD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KMR5ny1.png\" width=\"80%\">\n</div>\n<p>目前想要表现大规模场景的声学特性仍是非常复杂的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7GRrfmB.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWJVNHkxUjd4NS8/c3BtX2lkX2Zyb209MzMzLjc4OCZhbXA7dmRfc291cmNlPTdhMjU0MmM2YzkwOWIzZWUxZmFiNTUxMjc3MzYwODI2\">Lecture 12：Effects</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/",
            "title": "games104系列笔记（十一）",
            "date_published": "2023-06-28T15:00:28.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的应用以及一些高级算法。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"character-controller\"><a class=\"anchor\" href=\"#character-controller\">#</a> Character Controller</h2>\n<p>** 角色控制器 (character controller)** 是玩家操作角色和游戏世界进行交互的接口。和很多人直观的认识不同，角色控制器在很多情况下实际上是一个非物理的。最常见的例子是玩家控制角色停止移动时角色会立即停住，而不是严格按照刚体仿真那样通过摩擦力来逐渐停止运动。某种意义上讲，角色控制器虽然是反物理的但却更符合人对物理世界的认知。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/x6NYW7E.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wgAbEwW.png\" width=\"80%\">\n</div>\n<h3 id=\"build-a-controller-in-physics-system\"><a class=\"anchor\" href=\"#build-a-controller-in-physics-system\">#</a> Build a Controller in Physics System</h3>\n<p>在构建角色控制器时一般会使用简化后的形状来包裹角色，这样便于处理各种场景之间的互动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KflUJE2.png\" width=\"80%\">\n</div>\n<h3 id=\"collide-with-environment\"><a class=\"anchor\" href=\"#collide-with-environment\">#</a> Collide with Environment</h3>\n<p>在角色和场景进行互动时最常见的情况是玩家控制的角色撞到了墙壁上。如果严格按照物理引擎进行模拟，此时角色会一直停在碰撞的位置；而现代游戏中更常见的处理方式是修改角色的运动方向，使得角色可以沿墙壁方向进行滑动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WkqxvJj.png\" width=\"80%\">\n</div>\n<h3 id=\"auto-stepping\"><a class=\"anchor\" href=\"#auto-stepping\">#</a> Auto Stepping</h3>\n<p>上下楼梯同样也是角色在场景中的一种常见行为。如果严格按照物理仿真进行处理，胶囊的上下楼梯会非常地困难。因此在游戏引擎中需要单独考虑这种情况，当角色上下楼梯时自动修正角色的位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LpIReRH.png\" width=\"80%\">\n</div>\n<p>对于斜坡这种情况，如果按照刚体运动学进行处理会导致角色下坡时直接从斜坡上滑下来，或是在上坡时由于具有过大的速度角色直接冲上它不应该到达的位置。为了避免这些问题需要单独考虑角色停在斜坡或是限制角色的位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HD0H4EI.png\" width=\"80%\">\n</div>\n<h3 id=\"controller-volume-update\"><a class=\"anchor\" href=\"#controller-volume-update\">#</a> Controller Volume Update</h3>\n<p>角色控制器还需要考虑角色体积发生变化的情况。当玩家控制角色进行下蹲等动作时需要自动更新角色控制体的体积，否则容易出现角色卡在门口无法进入的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/i9mL6Br.png\" width=\"80%\">\n</div>\n<h3 id=\"controller-push-objects\"><a class=\"anchor\" href=\"#controller-push-objects\">#</a> Controller Push Objects</h3>\n<p>当玩家控制角色和场景中的物体互动时需要对动态对象的运动状态加以更新。比较常见的处理方式是发生碰撞时对动态对象施加一个相应的冲量来控制它们的运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HjTnDFv.png\" width=\"80%\">\n</div>\n<h3 id=\"standing-on-moving-platform\"><a class=\"anchor\" href=\"#standing-on-moving-platform\">#</a> Standing on Moving Platform</h3>\n<p>除此之外，角色控制器还需要考虑动态场景的情况。当角色位于运动的平台时需要根据平台的运动来调整角色的运动状态，否则会出现平台发生运动时角色的运动没有同步或是滞后的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hORYId3.png\" width=\"80%\">\n</div>\n<h2 id=\"ragdoll\"><a class=\"anchor\" href=\"#ragdoll\">#</a> Ragdoll</h2>\n<p>** 布娃娃 (ragdoll)** 系统是游戏角色动画的一个重要组成部分，它最常见的例子是角色的处决动画：当玩家控制的角色处决了某个游戏对象时，根据处决场景的不同被处决对象会发生相应场景互动的动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ed9j3XJ.png\" width=\"80%\">\n</div>\n<h3 id=\"map-skeleton-to-rigid-bodies\"><a class=\"anchor\" href=\"#map-skeleton-to-rigid-bodies\">#</a> Map Skeleton to Rigid Bodies</h3>\n<p>实际上 ragdoll 与前面介绍过的<a href=\"/2022/05/11/GAMES104-NOTES-08.html#skinned-animation-implementation\">骨骼动画</a>密切相关。在模拟 ragdoll 的运动时，我们同样会在角色身上设置相应的节点并把不同节点之间的骨骼按照刚体进行模拟。不过出于实时计算上的考虑，ragdoll 一般只会使用非常少量的节点和骨骼来进行模拟。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/G7rFn2k.png\" width=\"80%\">\n</div>\n<h3 id=\"human-joint-constraints\"><a class=\"anchor\" href=\"#human-joint-constraints\">#</a> Human Joint Constraints</h3>\n<p>同样地，在 ragdoll 中需要考虑角色身上不同节点的运动是带有一定约束的。如果忽略了人体骨骼关节的约束则会导致非常扭曲的模拟效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ub9Higm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/54bcEHK.png\" width=\"80%\">\n</div>\n<p>一般来说 ragdoll 关节的约束会由 TA 进行设置，如果设置的不好会出现一些反直觉的动画效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LJ9jkf7.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VA9MPtd.png\" width=\"80%\">\n</div>\n<h3 id=\"animating-skeleton-by-ragdoll\"><a class=\"anchor\" href=\"#animating-skeleton-by-ragdoll\">#</a> Animating Skeleton by Ragdoll</h3>\n<p>需要注意的是尽管我们可以使用 ragdoll 来模拟角色的动画，在实际游戏中仍然是需要通过骨骼关节系统来驱动整个角色的运动。由于 ragdoll 中的骨骼关节数量一般会少于实际角色的骨骼关节，我们需要使用<a href=\"/2022/05/17/GAMES104-NOTES-09.html#animation-retargeting\">动画重定向</a>技术来将 ragdoll 计算出的运动映射到实际的角色骨骼上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4cavCTn.png\" width=\"80%\">\n</div>\n<h3 id=\"blending-between-animation-and-ragdoll\"><a class=\"anchor\" href=\"#blending-between-animation-and-ragdoll\">#</a> Blending between Animation and Ragdoll</h3>\n<p>在使用时还需要注意角色动画切换到 ragdoll 的过程。还是以角色处决动画为例，在一开始被处决对象是使用预先录制的角色动画，然后在某一时刻会切换成 ragdoll 使用物理系统来实时计算角色的行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M1gOC3P.png\" width=\"80%\">\n</div>\n<p>更进一步，在现代 3A 游戏中还会将角色动画和 ragdoll 实时计算出的动画进行混合来提升玩家的代入感和游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lW6B7z6.png\" width=\"80%\">\n</div>\n<h2 id=\"cloth\"><a class=\"anchor\" href=\"#cloth\">#</a> Cloth</h2>\n<p>布料系统是游戏物理仿真中的重要一环。早期的布料模拟是使用预先录制的动画来实现的，我们可以在角色身上设置一些额外的骨骼来控制衣物的运动，这样就可以实现角色执行不同动作时衣物随之飘动的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/a75lfeS.png\" width=\"80%\">\n</div>\n<p>另一种处理衣物的方法是使用刚体运动的方法来模拟衣物和角色以及场景的互动。这样的处理方法虽然需要更多的计算资源，但可以实现相对真实衣物运动的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DVGIo03.png\" width=\"80%\">\n</div>\n<h3 id=\"mesh-based-cloth-simulation\"><a class=\"anchor\" href=\"#mesh-based-cloth-simulation\">#</a> Mesh-Based Cloth Simulation</h3>\n<p>而在现代游戏引擎中衣物运动更多地是使用网格来进行模拟。这里首先要说明的是布料仿真中使用的网格是不同于渲染中所使用的网格，出于计算效率上的考虑布料仿真中使用的网格要比渲染中的网格要稀疏很多。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yvcxpLE.png\" width=\"80%\">\n</div>\n<p>同时在布料仿真中往往还会为网格上的每个顶点赋予一定位移的约束，从而获得更符合人直觉的仿真结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lpxqy0A.png\" width=\"80%\">\n</div>\n<h3 id=\"mass-spring-system\"><a class=\"anchor\" href=\"#mass-spring-system\">#</a> Mass-Spring System</h3>\n<p>使用网格进行布料仿真的基本处理方法是使用质点弹簧系统进行模拟。我们为网格的顶点赋予一定的质量，然后将相邻顶点使用弹簧连接起来就形成了布料仿真的物理系统。这里需要注意的是除了弹簧弹力之外一般还需要为质点施加一定的阻尼来保证质点的运动最终能够停住。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ILMJXu6.png\" width=\"80%\">\n</div>\n<p>在放置弹簧时除了横竖方向外一般还需要在对角方向上也设置一些弹簧，这样可以保证布料具有抵抗对角方向的刚度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OUjIc7G.png\" width=\"80%\">\n</div>\n<p>最后把外力施加在质点弹簧系统上就可以进行布料的运动仿真了。这里需要注意的是在进行仿真时不要忘记质点除了弹簧施加的弹力和阻尼外自身还会收到重力以及空气阻力的作用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fpiqBe9.png\" width=\"80%\">\n</div>\n<h3 id=\"verlet-integration\"><a class=\"anchor\" href=\"#verlet-integration\">#</a> Verlet Integration</h3>\n<p>对质点弹簧系统进行仿真时不可避免地会使用到一些数值积分的方法，这里我们着重介绍一些 Verlet 积分算法。Verlet 积分本质仍然是半隐式欧拉积分，不过在实际积分时可以将速度项约掉只保留位移和加速度项就能进行计算。因此 Verlet 积分不需要保存每一时刻的速度，我们只需要位移和力 (加速度) 就可以进行计算，从而提高布料仿真的效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ciq7KUH.png\" width=\"80%\">\n</div>\n<h3 id=\"self-collision\"><a class=\"anchor\" href=\"#self-collision\">#</a> Self Collision</h3>\n<p>布料仿真的一大难点在于如何处理 ** 自相交 (self collision)** 问题。由于我们使用了没有体积的网格来表示布料，在进行仿真时很容易出现网格直接相互的穿插。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CEGDBDD.png\" width=\"80%\">\n</div>\n<p>目前布料自相交的问题还没有一个十分完善的解决方法。在工业界会使用一些 trick 来缓解自相交的问题，比如说对布料进行加厚、减少仿真时的时间步长、限制顶点的速度以及使用 SDF 进行控制等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cT2esCi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EdJTqyM.png\" width=\"80%\">\n</div>\n<h2 id=\"destruction\"><a class=\"anchor\" href=\"#destruction\">#</a> Destruction</h2>\n<p>玩家对场景的破坏是通过破坏系统来进行实现。一个好的破坏系统可以极大地提升玩家的游戏体验，有些游戏甚至是以破坏系统为核心玩法进行设计的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OStgfyI.png\" width=\"80%\">\n</div>\n<h3 id=\"chunk-hierarchy\"><a class=\"anchor\" href=\"#chunk-hierarchy\">#</a> Chunk Hierarchy</h3>\n<p>我们可以使用一棵树来描述同一物体不同碎片之间的层次关系：树的根节点表示完整的物体，而它下面的每一层表示物体经受一定程度的冲击后所产生的碎片。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AVRjG2n.png\" width=\"80%\">\n</div>\n<h3 id=\"connectivity-graph\"><a class=\"anchor\" href=\"#connectivity-graph\">#</a> Connectivity Graph</h3>\n<p>当确定了物体承受的冲击后就可以使用一张图来表示不同碎片之间的连接关系：图的节点表示碎片，而图的边则表示相互连接的碎片能够承受的荷载，当冲击大于边上的值时就会发生物体的破碎。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FYMepq6.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3I1rdsC.png\" width=\"80%\">\n</div>\n<h3 id=\"damage-calculation\"><a class=\"anchor\" href=\"#damage-calculation\">#</a> Damage Calculation</h3>\n<p>需要说明的是虽然我们使用了冲击和荷载这样的字眼，实际上在游戏引擎中却不会去计算这些物理量。它们只是一些人工设置的数值，并不具备真实的物理意义。在游戏开发中一般会使用一些经验公式来对冲击以及物体的承载力进行计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k7rVcL1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/V3ZRUl6.png\" width=\"80%\">\n</div>\n<h3 id=\"fracturing-with-voronoi-diagram\"><a class=\"anchor\" href=\"#fracturing-with-voronoi-diagram\">#</a> Fracturing with Voronoi Diagram</h3>\n<p>那么如何去生成这样的一张图呢？在物理引擎中一般会使用 **Voronoi 图 (Voronoi diagram)** 这样的技术来对原始的物体区域进行划分，划分后的每一个区域即为所需的碎片。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HHBtH7I.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SjAw3JR.png\" width=\"80%\">\n</div>\n<p>对于三维的情况则要更加复杂一些，除了需要使用 Voronoi 图对空间进行划分还需要使用 Delaunay 三角化来重新生成碎片的三维网格。同时当物体破碎后还需要为碎片的网格赋予内部材质的纹理，这一般需要使用一些程序化的纹理生成算法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tyvoydu.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j1LY4e7.png\" width=\"80%\">\n</div>\n<p>在设置 Voronoi 图的种子时还可以根据需要设置不同模式的种子，这样可以实现相应的破碎效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lUXYEXP.png\" width=\"80%\">\n</div>\n<h3 id=\"destruction-in-physics-system\"><a class=\"anchor\" href=\"#destruction-in-physics-system\">#</a> Destruction in Physics System</h3>\n<p>从物理系统的计算流程上来看，破碎系统一般是仿真碰撞检测后实际解算之前。这主要是因为很多破碎的事件是由碰撞所导致的，同时在物体破碎后往往还会产生新的物体 (碎片) 需要计算相应的运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2J3kAXm.png\" width=\"80%\">\n</div>\n<h3 id=\"issues-with-destruction\"><a class=\"anchor\" href=\"#issues-with-destruction\">#</a> Issues with Destruction</h3>\n<p>除了物理系统的计算外在处理场景破坏时还需要添加相应的声音和粒子效果，这样可以得到更加真实的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1mlO4Po.png\" width=\"80%\">\n</div>\n<p>此外破坏系统的计算是相当昂贵的：当一个物体出现破碎后往往会带来成百上千个碎片需要进行物理仿真，这会极大地增加物理系统的计算负载，因此在使用时需要慎重考虑。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xnQvm41.png\" width=\"80%\">\n</div>\n<h3 id=\"popular-destruction-implementations\"><a class=\"anchor\" href=\"#popular-destruction-implementations\">#</a> Popular Destruction Implementations</h3>\n<p>目前很多商业引擎都有现成的破坏系统。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Bj6sG3u.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3dd57nS.png\" width=\"80%\">\n</div>\n<h2 id=\"vehicle\"><a class=\"anchor\" href=\"#vehicle\">#</a> Vehicle</h2>\n<p>载具系统是现代游戏中重要的组成部分。要对载具进行模拟需要推导相应的动力学模型，以汽车为例整个汽车可以看做通过悬挂系统与地面接触的刚体。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9yzTbK6.png\" width=\"80%\">\n</div>\n<p>整个汽车的驱动力来自于引擎产生的扭矩，而扭矩的大小则需要查询引擎的相关曲线来计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AayfwK5.png\" width=\"80%\">\n</div>\n<p>在竖直方向上由于地面的起伏车身会产生悬挂系统所导致的振动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/buQaM5i.png\" width=\"80%\">\n</div>\n<p>在平面上汽车的轮胎会产生平行于前进方向的径向力，同时还会产生的切向力控制车辆的转动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/S1Y6OuP.png\" width=\"80%\">\n</div>\n<p>根据车身重量的分布我们还需要计算汽车的重心。实际上重心的位置不仅会控制汽车的振动，还会汽车的转向性能有重要的影响。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZuIGy6K.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6yPqGHa.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oBKlN0I.png\" width=\"80%\">\n</div>\n<p>同时需要注意的是当车辆进行加速或是刹车时重心的位置也会发生一些变化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5VgExEa.png\" width=\"80%\">\n</div>\n<p>为了更好地实现转向，现代汽车在设计时会让两个转向轮的转动有微小的差异。在进行模拟时也需要考虑这个微小的角度变化。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XymzlfH.png\" width=\"80%\">\n</div>\n<p>最后需要说明的是在计算地面和车轮求交时需要把轮子看做是球，这样才能模拟出车辆在凹凸不平的地面上行驶的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g8UttI7.png\" width=\"80%\">\n</div>\n<h2 id=\"advanced-pbdxpbd\"><a class=\"anchor\" href=\"#advanced-pbdxpbd\">#</a> Advanced: PBD/XPBD</h2>\n<h3 id=\"pbd\"><a class=\"anchor\" href=\"#pbd\">#</a> PBD</h3>\n<p>本节课最后讨论了 PBD 和 XPBD 两种更高级的物理仿真技术。和前面介绍过的仿真技术相比，PBD 和 XPBD 是建立在 ** 拉格朗日力学 (Lagrangian mechanics)** 基础上的仿真方法。在拉格朗日力学的框架中不再考虑力等物理概念，而是把物理定律视为系统的某种约束来描述运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Hc2CUk6.png\" width=\"80%\">\n</div>\n<p>以匀速圆周运动为例，在拉格朗日力学中我们不会去计算各种改变质点运动状态的力，而是考虑质点运动的位置约束以及速度约束。其中位置约束的导数也称为 Jacobian 矩阵。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OqjyiTA.png\" width=\"80%\">\n</div>\n<p>类似地，弹簧质点系统也可以表示为由约束定义的系统。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PegWuMj.png\" width=\"80%\">\n</div>\n<p>PBD 在求解时，PBD 会把整个物理系统描述为关于位置的约束。然后通过不断迭代来计算满足约束的解。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yRnMoWF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fOfMIs0.png\" width=\"80%\">\n</div>\n<p>整个 PBD 的求解流程如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tUyxErZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mzZrg54.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gIuhjwl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/U7i2vKx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DFCsQRt.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cAvkRvj.png\" width=\"80%\">\n</div>\n<p>PBD 是目前游戏行业非常热门的物理仿真技术，和传统仿真技术相比 PBD 往往会得到更稳定的解。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BUOqb9y.png\" width=\"80%\">\n</div>\n<h3 id=\"xpbd\"><a class=\"anchor\" href=\"#xpbd\">#</a> XPBD</h3>\n<p>XPBD 可以看做是对 PBD 的一种推广，它在 PBD 的基础上引入了 ** 刚度 (stiffness)** 的概念来描述不同约束的强弱。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/q0UNhMU.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlhNDExajdkcy8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 11：Physics System – Applications</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/",
            "title": "games104系列笔记（十）",
            "date_published": "2023-06-26T04:59:11.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的基本概念。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>物理系统是游戏引擎的重要组成部分。在游戏中玩家和整个游戏世界的互动都是依赖于物理系统的实现，同时在现代游戏中大量的粒子效果也都是通过物理系统来进行驱动的。显然物理系统非常复杂，甚至于有很多公司专门去研究物理引擎的高效实现。而在本课程中我们同样把物理系统拆分成两节，这一节课主要介绍物理引擎的基本概念而在下一节课中则会更多地讨论游戏业界更前沿的物理仿真技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kBtO48C.png\" width=\"80%\">\n</div>\n<h2 id=\"physics-actors-and-shapes\"><a class=\"anchor\" href=\"#physics-actors-and-shapes\">#</a> Physics Actors and Shapes</h2>\n<h3 id=\"actor\"><a class=\"anchor\" href=\"#actor\">#</a> Actor</h3>\n<p>在物理引擎中根据对象自身的特点我们可以把它划分为静态对象、动态对象等。其中静态对象是指在仿真过程中不会发生改变的对象，比如说游戏中的地面、墙壁等等；与之对应的是动态对象，它们的运动状态会在游戏过程中动态地进行变化，而且它们的运动过程需要符合相应的动力学模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Xm6vnN2.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/n4ymCuO.png\" width=\"80%\">\n</div>\n<p>除此之外游戏角色和场景的互动还需要相应的 trigger，它可以用来改变对象的各种状态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RYJljH5.png\" width=\"80%\">\n</div>\n<p>最后一个常见的物理对象是 kinematics，它是指不完全基于物理法则的物理对象，但往往与玩法高度相关。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sF9z84D.png\" width=\"80%\">\n</div>\n<p>不同类型的物理对象其特点可以总结如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VZF7ebZ.png\" width=\"80%\">\n</div>\n<h3 id=\"actor-shapes\"><a class=\"anchor\" href=\"#actor-shapes\">#</a> Actor Shapes</h3>\n<p>物理对象最重要的属性是它的<strong>形状 (shape)</strong>。比较规则和简单的形状可以通过解析的方法来进行描述：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OYUnVaF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/I8417Jw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KzXZQLv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1olcNZG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6Gv80w8.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Cah4m9l.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VrigtIo.png\" width=\"80%\">\n</div>\n<p>在进行物理仿真时我们首先会把物理对象进行一定的包裹，使用相对简单的几何形状来近似复杂的模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cbWhC6f.png\" width=\"80%\">\n</div>\n<h3 id=\"shape-properties\"><a class=\"anchor\" href=\"#shape-properties\">#</a> Shape Properties</h3>\n<p>在形状的基础上我们还需要对一些物理量进行定义，包括对象的质量或密度、质心以及物理材质等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ro34OGj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LrIqo9U.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xllUzcI.png\" width=\"80%\">\n</div>\n<h2 id=\"forces-and-movements\"><a class=\"anchor\" href=\"#forces-and-movements\">#</a> Forces and Movements</h2>\n<h3 id=\"forces\"><a class=\"anchor\" href=\"#forces\">#</a> Forces</h3>\n<p>** 力 (force)** 是改变物体运动状态的原因。在物理引擎中我们同样需要力来驱动整个游戏世界的仿真过程，其中常见的类型包括重力、摩擦力等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7xkerkT.png\" width=\"80%\">\n</div>\n<p>另一种常用的仿真方式是使用<strong>冲量 (impulse)</strong>，它比较适合用来模拟物体运动状态发生剧烈变化的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j7rpf29.png\" width=\"80%\">\n</div>\n<h3 id=\"movements\"><a class=\"anchor\" href=\"#movements\">#</a> Movements</h3>\n<p>有了力或者冲量后就可以利用牛顿运动定律来驱动物体的运动了。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZR6pKyo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ADGa3zS.png\" width=\"80%\">\n</div>\n<p>在物理引擎中一般无法使用解析的方式来计算物体的运动，因此我们需要一些数值计算方法来进行求解。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Tk1YJZ8.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/F6Tt6d1.png\" width=\"80%\">\n</div>\n<p>在进行数值积分时，我们可以把时间间隔设置成一个比较小的值然后对被积函数进行累加来近似实际的积分。具体来说，在计算物体的运动轨迹时我们首先计算物体在当前位置上受到的力并且积分得到加速度，然后再利用加速度来更新速度以及物体的位置。这种计算物体运动轨迹的方法称为<strong> Euler 方法 (Euler's method)</strong>，也称为<strong>显式积分 (explicit integration)</strong>。Euler 方法实现起来非常简单，但需要注意的是它的本质是使用物体的当前状态来估计下一时刻的运动状态，此时系统的能量是不守恒的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/by4T9LW.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KsAsvAg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BqGJCpA.png\" width=\"80%\">\n</div>\n<p>为了提高数值积分的稳定性，人们还开发出了 ** 隐式积分 (implicit integration)** 的技术。隐式积分的实现也很简单，只需要在求解加速度和速度时使用下一时刻而不是当前时刻的值即可，同时可以证明此时系统的能量会不断衰减。当然这又引入了另一个问题，即如何计算系统在下一时刻的物理量，这在很多情况下是比较困难的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YHGHQVD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iL8tssw.png\" width=\"80%\">\n</div>\n<p>在游戏引擎中更常用的积分方法是<strong>半隐式 Euler 方法 (semi-implicit Euler's method)</strong>，即在计算加速度时使用当前时刻的力推导下一时刻的速度，而在计算位置时使用刚才计算出的速度再更新位置。半隐式方法有非常高的数值稳定性，广泛应用于各种类型的物理仿真中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8WeSzpc.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5DqUf1w.png\" width=\"80%\">\n</div>\n<h2 id=\"rigid-body-dynamics\"><a class=\"anchor\" href=\"#rigid-body-dynamics\">#</a> Rigid Body Dynamics</h2>\n<p>有了牛顿定律和数值积分算法就可以开始进行物理仿真了，其中最简单的情况是<strong>质点动力学 (particle dynamics)</strong>。在质点动力学中所有的物体都被抽象为没有具体形状的质点，此时我们只需要按照牛顿定律更新质点的运动状态即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ROnupqR.png\" width=\"80%\">\n</div>\n<p>在游戏引擎中更为常见的仿真场景是<strong>刚体动力学 (rigid body dynamics)</strong>。和质点动力学不同，刚体动力学仿真需要考虑物体自身的形状，也因此需要在质点运动的基础上引入刚体旋转的相关概念。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7Sy9Rz2.png\" width=\"80%\">\n</div>\n<h3 id=\"orientation\"><a class=\"anchor\" href=\"#orientation\">#</a> Orientation</h3>\n<p>刚体的 ** 朝向 (orientation)** 可以使用一个旋转矩阵或者四元数来表示，它表示刚体当前姿态相对于初始姿态的旋转。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8G908wr.png\" width=\"80%\">\n</div>\n<h3 id=\"angular-velocity\"><a class=\"anchor\" href=\"#angular-velocity\">#</a> Angular Velocity</h3>\n<p>** 角速度 (angular velocity)** 表示刚体绕某个旋转轴旋转的速度，需要注意的是在描述角速度时必须要指明旋转轴。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2rxwk0r.png\" width=\"80%\">\n</div>\n<h3 id=\"angular-acceleration\"><a class=\"anchor\" href=\"#angular-acceleration\">#</a> Angular Acceleration</h3>\n<p>** 角加速度 (angular acceleration)** 类似于加速度，不过它描述的是角速度的变化。这里需要说明的是角速度的变化不仅包括绕当前轴转速的变化，它还包括旋转轴发生变化的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bS0yLoP.png\" width=\"80%\">\n</div>\n<h3 id=\"rotational-inertia\"><a class=\"anchor\" href=\"#rotational-inertia\">#</a> Rotational Inertia</h3>\n<p>** 转动惯量 (rotational inertia)** 类似于质量，它描述了刚体抵抗旋转的能力。转动惯量与质量的一大区别在于转动惯量不是一个常数而是一个张量 (矩阵)，当刚体的朝向发生改变时需要利用旋转矩阵来计算当前姿态下的转动惯量；同时转动惯量也与刚体上的质量分布密切相关。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4Bqa8Ec.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3RwVNDp.png\" width=\"80%\">\n</div>\n<h3 id=\"angular-momentum\"><a class=\"anchor\" href=\"#angular-momentum\">#</a> Angular Momentum</h3>\n<p>** 角动量 (angular momentum)** 则描述了刚体旋转的状态，它是转动惯量与角速度的乘积。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XrraRKH.png\" width=\"80%\">\n</div>\n<h3 id=\"torque\"><a class=\"anchor\" href=\"#torque\">#</a> Torque</h3>\n<p>当外力不通过刚体的质心时会产生<strong>力矩 (torque)</strong>，从而导致刚体发生旋转。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XiK4Efj.png\" width=\"80%\">\n</div>\n<p>在质点动力学的基础上把旋转部分也考虑进来对物体的运动状态进行更新就得到了刚体动力学的仿真方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3eCei78.png\" width=\"80%\">\n</div>\n<h3 id=\"applicationbilliard-dynamics\"><a class=\"anchor\" href=\"#applicationbilliard-dynamics\">#</a> Application：Billiard Dynamics</h3>\n<p>以台球游戏模拟为例，我们假设台球自身与桌面没有摩擦，这样台球的运动可以简化为二维平面运动。在进行仿真时需要把球杆给予台球的力 (冲量) 移动到球心来计算台球沿球杆方向的速度；同时这种移动还会对台球施加一个力矩使台球产生旋转，因此也需要更新台球的角速度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fxJYjLJ.png\" width=\"80%\">\n</div>\n<h2 id=\"collision-detection\"><a class=\"anchor\" href=\"#collision-detection\">#</a> Collision Detection</h2>\n<p>在进行刚体仿真时我们需要考虑不同刚体之间的相互作用，也即所谓的碰撞问题。要求解碰撞问题的第一步是对刚体碰撞进行检测，目前在物理引擎中注意是使用两阶段的检测方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mqBFg6T.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/D54gen6.png\" width=\"80%\">\n</div>\n<h3 id=\"broad-phase\"><a class=\"anchor\" href=\"#broad-phase\">#</a> Broad Phase</h3>\n<p>显然场景中大部分的物体是不会同时发生接触的，因此所谓的 broad phase 就是只利用物体的 bounding box 来快速筛选出可能发生碰撞的物体。目前物理引擎中常用的碰撞检测包括<strong>空间划分 (space partitioning)<strong> 以及</strong> sort and sweep</strong> 两类方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CbCNGlM.png\" width=\"80%\">\n</div>\n<h4 id=\"bvh-tree\"><a class=\"anchor\" href=\"#bvh-tree\">#</a> BVH Tree</h4>\n<p>我们在介绍渲染技术时就介绍过空间划分的相关概念，它的思想是把场景中的物体使用一个树状的数据结构进行管理从而加速判断物体是否相交的过程。BVH 是空间划分的经典算法，它使用一棵二叉树来管理场景中所有物体的 bounding box。BVH 的特点是它可以通过动态更新节点来描述场景中物体的变化，因此可以快速地检测场景中的 bounding box 可能存在的碰撞。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BTn69Gr.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GU83kZ1.png\" width=\"80%\">\n</div>\n<h4 id=\"sort-and-sweep\"><a class=\"anchor\" href=\"#sort-and-sweep\">#</a> Sort and Sweep</h4>\n<p>sort and sweep 是使用排序来检测碰撞的算法。它的思想非常直观：对于使用 AABB 进行表示的 bounding box，两个 bounding box 出现碰撞时必然会导致它们的边界产生了重叠，而判断是否出现重叠则可以通过对 bounding box 的边界进行排序来进行计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OPbcj3y.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fhDlpvI.png\" width=\"80%\">\n</div>\n<h3 id=\"narrow-phase\"><a class=\"anchor\" href=\"#narrow-phase\">#</a> Narrow Phase</h3>\n<p>筛选出可能发生碰撞的物体后就需要对它们进行实际的碰撞检测，这个阶段称为 narrow phase。除了进一步判断刚体是否相交外，在 narrow phase 中一般还需要去计算交点、相交深度以及方向等信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tvh33wy.png\" width=\"80%\">\n</div>\n<p>目前在 narrow phase 中一般会使用相交测试、Minkowski 距离以及分离轴等方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KxjbSBY.png\" width=\"80%\">\n</div>\n<h4 id=\"basic-shape-intersection-test\"><a class=\"anchor\" href=\"#basic-shape-intersection-test\">#</a> Basic Shape Intersection Test</h4>\n<p>对于一些简单的几何形状可以使用解析的方法来判断它们是否相交并且计算交点的信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jdQ6Q0i.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/P2BCxgg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YxlKkkm.png\" width=\"80%\">\n</div>\n<h4 id=\"minkowski-difference-based-methods\"><a class=\"anchor\" href=\"#minkowski-difference-based-methods\">#</a> Minkowski Difference-based Methods</h4>\n<p>对于凸多边形的情况则可以使用 **Minkowski 差异 (Minkowski distance)<strong> 来判断它们是否相交。在介绍 Minkowski 距离之前首先要引入</strong> Minkowski 和 (Minkowski sum)** 的概念：对于两个点集<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，它们的 Minkowski 和定义为两个集合中任意一对矢量相加后得到的新的点集。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/35TVcQX.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/y3nee7s.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d4a88wl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OojulLx.png\" width=\"80%\">\n</div>\n<p>对于凸多边形，它们的 Minkowski 和也必为一个凸多边形，而且这个新多边形的顶点也是原始多边形顶点的和。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2rfDCYz.png\" width=\"80%\">\n</div>\n<p>在此基础上我们定义点集<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 的 Minkowski 差异为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">-B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 的 Minkowski 和，即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊖</mo><mi>B</mi><mo>=</mo><mi>A</mi><mo>⊕</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\ominus B = A \\oplus (-B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7SjNI4Y.png\" width=\"80%\">\n</div>\n<p>可以证明当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 相交时，原点必位于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\ominus B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 中。这样判断两个凸多边形是否相交的问题就转化为判断原点是否位于凸多边形<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊖</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\ominus B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 中的问题，这种问题一般可以使用 GJK 算法来求解。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6Ei7LyQ.png\" width=\"80%\">\n</div>\n<p>GJK 算法的主要流程如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SjZ3MV1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kyRrnrg.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9bV8uAH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UZUcRfZ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/i8bw17o.png\" width=\"80%\">\n</div>\n<p>当 GJK 算法判断出两个凸多边形相交后还可以进一步计算交点以及深度等信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gmOENC1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2mf7Jtd.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XZA74cV.png\" width=\"80%\">\n</div>\n<h4 id=\"separating-axis-theorem\"><a class=\"anchor\" href=\"#separating-axis-theorem\">#</a> Separating Axis Theorem</h4>\n<p>** 分离轴定理 (separating axis theorem, SAT)** 同样是一种计算凸多边形相交的算法，它的思想是平面上任意两个互不相交的图形我们必然可以找到一条直线将它们分隔在两端。对于凸多边形还可以进一步证明必然存在以多边形顶点定义的直线来实现这样的分隔，因此判断凸多边形相交就等价于寻找这样的分隔直线。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M7bO9gx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/G5cTsoH.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/38sHteu.png\" width=\"80%\">\n</div>\n<p>使用 SAT 判断凸多边形是否相交时需要分别对两个图形的边进行遍历，然后判断另一个图形上的每个顶点是否落在边的同一侧。只要发现存在一条边可以分隔两个图形即说明它们互不相交，否则继续遍历直到用尽所有的边，此时两个图形必然是相交的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UhbV4EU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MxNpdwC.png\" width=\"80%\">\n</div>\n<p>当图形的位置发生变化时还可以从上一次检测得到的分离轴开始重新进行检测，这样可以进一步提高算法的效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BtCn8ib.png\" width=\"80%\">\n</div>\n<p>对于三维图形的情况则不仅需要考虑面和面的分隔关系，还要考虑边和边的分隔关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uBGMWHF.png\" width=\"80%\">\n</div>\n<h2 id=\"collision-resolution\"><a class=\"anchor\" href=\"#collision-resolution\">#</a> Collision Resolution</h2>\n<p>完成碰撞检测后就需要对发生碰撞的刚体进行处理，使它们相互分开。目前刚体的碰撞主要有三种处理思路，分别是 penalty force、velocity constraints 以及 position constraints，本节课我们主要介绍前两种处理方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/izyNrfE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/af5kMU1.png\" width=\"80%\">\n</div>\n<h3 id=\"applying-penalty-force\"><a class=\"anchor\" href=\"#applying-penalty-force\">#</a> Applying Penalty Force</h3>\n<p><strong>penalty force</strong> 是最直观的碰撞处理方法，它的思想是当两个物体相交后沿反方向分别施加一个排斥力把它们推开。这种方法要求设置比较大的排斥力以及很小的积分时间间隔，否则容易出现非常不符合直觉的碰撞效果，因此现代物理引擎中几乎不会使用 penalty force 来处理刚体碰撞问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/P9yMWHK.png\" width=\"80%\">\n</div>\n<h3 id=\"solving-velocity-constraints\"><a class=\"anchor\" href=\"#solving-velocity-constraints\">#</a> Solving Velocity Constraints</h3>\n<p>目前物理引擎中主流的刚体碰撞处理算法是基于 Lagrangian 力学的求解方法，它会把刚体之间的碰撞和接触转换为系统的约束，然后求解约束优化问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tosTRin.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ucyeaYT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/o3XzgqS.png\" width=\"80%\">\n</div>\n<h2 id=\"scene-query\"><a class=\"anchor\" href=\"#scene-query\">#</a> Scene Query</h2>\n<p>除了上面介绍过的内容外，在游戏中我们往往还需要对场景中的物体进行一些查询，这些查询操作也需要物理引擎的支持。</p>\n<h3 id=\"raycast\"><a class=\"anchor\" href=\"#raycast\">#</a> Raycast</h3>\n<p><strong>raycast</strong> 是非常基本的查询操作，我们希望能够获取某条射线在场景中击中的物体。实际上在光线追踪中就大量使用了 raycast 的相关操作，而在物理引擎中 raycast 也有大量的应用，比如说子弹击中目标就是使用 raycast 来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iMFQdMo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pjDUDRG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vv4M7iu.png\" width=\"80%\">\n</div>\n<h3 id=\"sweep\"><a class=\"anchor\" href=\"#sweep\">#</a> Sweep</h3>\n<p><strong>sweep</strong> 与 raycast 类似，不过在 sweep 中需要使用有一定几何形态的物体取击中场景中的其它物体。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YuM4lA0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VqGbEOV.png\" width=\"80%\">\n</div>\n<h3 id=\"overlap\"><a class=\"anchor\" href=\"#overlap\">#</a> Overlap</h3>\n<p>另一种常用的操作是<strong> overlap</strong>，此时我们需要判断场景中的物体是否位于某个几何形状中。overlap 与碰撞检测非常类似，不过 overlap 一般只会使用简单的几何体来进行检测。像游戏中爆炸效果的检测就是使用 overlap 来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B2mIhJY.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/udCfXRz.png\" width=\"80%\">\n</div>\n<h3 id=\"collision-group\"><a class=\"anchor\" href=\"#collision-group\">#</a> Collision Group</h3>\n<p>在物理引擎中还需要额外注意对场景中的物体进行分组，这样可以提高各种物理仿真算法的效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3uu4yB2.png\" width=\"80%\">\n</div>\n<h2 id=\"efficiency-accuracy-and-determinism\"><a class=\"anchor\" href=\"#efficiency-accuracy-and-determinism\">#</a> Efficiency, Accuracy, and Determinism</h2>\n<p>本节课最后讨论了物理仿真中的一些其它技巧。</p>\n<h3 id=\"simulation-optimization\"><a class=\"anchor\" href=\"#simulation-optimization\">#</a> Simulation Optimization</h3>\n<p>我们知道物理仿真是极其消耗计算资源的，如果在所有时刻都对场景中的物体进行模拟会造成计算资源的浪费。因此一种常用的手段是把场景中的物体划分为若干个 island，当 island 内没有外力作用时就对它们进行休眠，这样就可以节约计算资源。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CQkD7Sl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JQrKbtm.png\" width=\"80%\">\n</div>\n<h3 id=\"continuous-collision-detection\"><a class=\"anchor\" href=\"#continuous-collision-detection\">#</a> Continuous Collision Detection</h3>\n<p>当物体运动的速度过快时可能会出现一个物体之间穿过另一个物体的现象，此时可以使用 CCD 的相关方法来进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7kE1JVx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nljc4CS.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8yp0TpG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1ntB36F.png\" width=\"80%\">\n</div>\n<h3 id=\"deterministic-simulation\"><a class=\"anchor\" href=\"#deterministic-simulation\">#</a> Deterministic Simulation</h3>\n<p>在进行物理仿真时还需要考虑仿真结果的确定性。尽管在编程时我们使用的都是同一套物理定律，在程序运行阶段由于帧率、计算顺序以及浮点数精度等问题容易出现同一个场景在不同终端上产生不同的模拟结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eh7I1IX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XD9JJJZ.png\" width=\"80%\">\n</div>\n<p>总而言之，物理仿真仍然是比较困难的。在现代游戏引擎中还有很多开放问题待我们进行解决。</p>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTZVNHkxMTdWVS8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 10：Physics System – Basic Concepts</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/",
            "title": "games104系列笔记（九）",
            "date_published": "2023-06-26T04:59:05.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍动画系统中的一些前沿技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>在上一节课中我们介绍了游戏引擎中动画系统的基本内容。基于上一讲的内容已经可以实现一些简单的动画了，而现代 3A 游戏会在这些内容的基础上添加更多的细节来实现更加真实的动画效果。</p>\n<h2 id=\"animation-blending\"><a class=\"anchor\" href=\"#animation-blending\">#</a> Animation Blending</h2>\n<p>基于<a href=\"/2022/05/11/GAMES104-NOTES-08.html#animation-dcc-process\"> DCC 流程</a>我们可以获得不同的动画资源，然而这些资源往往是相互独立的，在实际游戏中我们还需要将不同类型的动画混合起来以实现更加自然的运动效果。以角色的跑动为例，人体的跑动包含低速的步行以及高速的跑动两个部分的动画。将两个动画混合起来就可以实现自然的变速效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YWYeBeY.png\" width=\"80%\">\n</div>\n<p>要实现动画的混合非常简单，我们只需要对骨骼的姿态进行插值即可。但和上节课介绍的<a href=\"2022/05/11/GAMES104-NOTES-08.html#interpolation\">关键帧插值</a>不同，在进行动画混合时不仅需要考虑同一组动画关键帧之间的插值，还要考虑不同组动画不同关键帧的插值。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EHVN0nu.png\" width=\"80%\">\n</div>\n<p>计算插值权重也比不是很难，我们可以按照当前角色运动的速度来选择两个相邻动作的关键帧。两个动作的权重即为对速度进行线性插值的权重。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nylXVVz.png\" width=\"80%\">\n</div>\n<p>在进行动画混合时还要考虑时间线上对齐的问题。要使插值后的动作更加自然，我们需要动画师在动画建模时将每个动画都按照无限循环播放的形式进行设计。同时，两组进行混合的动画最好要保证角色具有相同的肢体运动频率。这样可以保证混合后的动画更加自然，不会出现角色滑行的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RzuZvJ5.png\" width=\"80%\">\n</div>\n<h2 id=\"blend-space\"><a class=\"anchor\" href=\"#blend-space\">#</a> Blend Space</h2>\n<h3 id=\"2d-blend-space\"><a class=\"anchor\" href=\"#2d-blend-space\">#</a> 2D Blend Space</h3>\n<p>上面介绍的动画混合技术主要针对的是角色一维运动，我们可以基于同样的思想把角色在平面上的运动动画进行混合，进而获得角色不同方向上的连续动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BPFBwXn.png\" width=\"80%\">\n</div>\n<p>对骨骼动画进行插值的方法也很简单，只要根据角色运动的状态在两个方向上分别进行线性插值即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sCOa7HX.png\" width=\"80%\">\n</div>\n<p>有时动画师会为角色的平面运动建立多个不同的预设 clip，在这种情况下直接进行插值是比较困难的。为了解决这种问题我们可以利用 Delaunay 三角化的方式对平面进行划分，在需要对动作进行插值时首先选择动作所在的三角形，然后再利用重心坐标进行插值即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sdSZd48.png\" width=\"80%\">\n</div>\n<h3 id=\"skeleton-masked-blending\"><a class=\"anchor\" href=\"#skeleton-masked-blending\">#</a> Skeleton Masked Blending</h3>\n<p>除了平面运动外，有些角色的动作可能只依赖于一部分骨骼。以鼓掌动作为例，角色在鼓掌时只涉及上半身的骨骼运动而与下半身无关，因此我们可以把上半身鼓掌的动作融合到其它下半身动作中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/77QoSO1.png\" width=\"80%\">\n</div>\n<p>要进行这样的处理也十分简单，我们也有设置一个 mask 来标记混合动画时需要考虑角色的哪些骨骼。这样就可以单独录制不同的动作然后根据需要组合出新的动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MK5DQ43.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LY3POsr.png\" width=\"80%\">\n</div>\n<h3 id=\"additive-blending\"><a class=\"anchor\" href=\"#additive-blending\">#</a> Additive Blending</h3>\n<p>角色动作另一种常见的情况是动作本身只与关节相对姿态有关，而与绝对姿态无关。以点头动画为例，角色在点头时可以有不同的朝向，但在录制动画时只需要一套统一的动画。要处理这种情况则需要在保存动画时指明这个 clip 是只依赖于相对位姿的动画，在实际进行动画混合时再根据角色当前的姿态叠加上相对位姿。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6PKc2ZA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YQk7Qot.png\" width=\"80%\">\n</div>\n<p>使用这种 additive blending 技术时需要额外注意角色的姿态，尤其要避免角色关节的姿态超过最大值的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5wmlfqV.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KENrnfM.png\" width=\"80%\">\n</div>\n<h2 id=\"action-state-machine-asm\"><a class=\"anchor\" href=\"#action-state-machine-asm\">#</a> Action State Machine (ASM)</h2>\n<p>在很多时候角色的动作不能直接通过对动画进行插值来获得。以跳跃为例，实际上角色的跳跃动作可以划分为起跳、浮空以及落地三个不同状态。不同的状态之间存在着一定的依赖关系，这会使得我们可能无法通过直接插值的方式来计算角色当前的动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6J8RXYA.png\" width=\"80%\">\n</div>\n<p>实际上我们可以把角色的动作和状态视为图上的节点，这样角色的运动就等价于在不同节点之间进行游走。这种模型称为<strong>动作状态机 (action state machine, ASM)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2JnJiPS.png\" width=\"80%\">\n</div>\n<p>当玩家发出指令后，角色根据指令和预设的状态转移条件来判断是否需要转移到其它的状态。当确定需要发生转移时就可以根据动画师的设计来切换角色的动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/THpAOuS.png\" width=\"80%\">\n</div>\n<p>在切换角色动画时根据切换的方法可以分为 smooth transition 和 frozen transition 两种。进行 smooth transition 时，我们需要使用前面介绍过的动画混合插值方法逐步从一个动画过渡到另一个动画；而需要进行 frozen transition 时，我们则会停住角色当前的动画然后根据设置直接切换到下一个动画。这两种动画切换形式在游戏工业中都有广泛的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/V4LvPxf.png\" width=\"80%\">\n</div>\n<p>同时，在进行 smooth transition 时可以根据动画师的需要设计不同的过渡曲线来表达不同的动画切换效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KYqiday.png\" width=\"80%\">\n</div>\n<p>目前，动作状态机技术已经广泛应用于各种游戏引擎中。虚幻引擎中就实现了 ASM 来运行游戏开发者自定义角色的动画状态和切换条件。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qVSa5dL.png\" width=\"80%\">\n</div>\n<p>同时在游戏业界还结合了多层次的设计将角色身体的不同部位单独设计成状态机，这样可以实现更加丰富的角色肢体动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MduTu8H.png\" width=\"80%\">\n</div>\n<h2 id=\"animation-blend-tree\"><a class=\"anchor\" href=\"#animation-blend-tree\">#</a> Animation Blend Tree</h2>\n<p>在 ASM 的基础上现代游戏引擎还引入了 ** 动画树 (animation blend tree)** 的概念。动画树可以理解为一棵表达树，它可以对不同的动画资源按照指定的计算规则进行混合，从而产生新的动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XpUXh01.png\" width=\"80%\">\n</div>\n<p>以线性插值为例，我们可以把 LERP 运算看做是一个节点，它将两个输入的动画资源按照比例混合到一起。基于动画树的结构可以在 LERP 的基础上定义更加复杂的动画混合插值计算。类似地，前面介绍过的 additive blending 也可以看做是一种特殊的运算节点，通过该节点可以在原始动作上叠加一个新的动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cOt6eME.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XuLxxWK.png\" width=\"80%\">\n</div>\n<p>使用动画树来描述动画混合的优势在于它可以基于简单的树状结构描述复杂的动画混合过程，比如说 layered ASM 就可以看做是不同动画资源在相应层级上进行混合的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GkYtkmp.png\" width=\"80%\">\n</div>\n<p>同时，动画树还可以看做是一种递归的计算结构。我们可以在游戏引擎中将各种不同的动画生成方法都定义为动画树的节点，在一个计算节点中可以包含很多更复杂的计算过程，甚至是小型的动画树。这样的结构形式会为设计师提供更高的设计自由度，从而实现复杂的动画效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QhaLbkD.png\" width=\"80%\">\n</div>\n<p>虚幻引擎中同样实现了动画树的功能。游戏开发者和设计师可以利用大量的计算节点来自定义角色的不同行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AV9yOGS.png\" width=\"80%\">\n</div>\n<p>动画树的一个核心在于使用 ** 控制变量 (control parameters)** 来改变输出动画的结果。一般来说控制变量来源于游戏的玩法系统，当控制变量发生改变时动画树会根据自身定义的规则动态地调整动画混合的比例以及使用的动画资源。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XATVFVt.png\" width=\"80%\">\n</div>\n<p>还是以虚幻引擎为例，虚幻引擎中使用 variable 作为动画树的控制变量调整不同动画之间的混合比例。此外，虚幻引擎中还使用了 event 作为资源切换的信号，当动画树接收到某个 event 后会调整自身的动画资源实现角色动画状态的改变。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aFhIuQD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dzWKf1W.png\" width=\"80%\">\n</div>\n<h2 id=\"inverse-kinematics-ik\"><a class=\"anchor\" href=\"#inverse-kinematics-ik\">#</a> Inverse Kinematics (IK)</h2>\n<p>我们目前介绍过的动画系统都是之间利用骨骼和关节的运动学公式来驱动角色的动作，这种方式称为<strong>前向运动学 (forward kinematics, FK)</strong>。在很多情况下我们还需要考虑游戏场景对于角色肢体的约束，并且利用这些约束来求出角色合适的骨骼关节姿态，这种动画技术则称为<strong>反向运动学 (inverse kinematics, IK)</strong>。IK 在游戏中有着非常丰富的应用场景，比如说角色在崎岖不平的地面上行走时我们根据地面的起伏来调整前进的动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HyXs8tI.png\" width=\"80%\">\n</div>\n<h3 id=\"two-bones-ik\"><a class=\"anchor\" href=\"#two-bones-ik\">#</a> Two Bones IK</h3>\n<p>IK 最简单的情况是只考虑角色两块骨骼的运动，然后利用约束来求解关节的姿态。这种问题的解法其实非常简单，我们可以利用骨骼的大小以及场景约束来构造三角形，然后利用几何关系来求解出所需的姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vT1yN5j.png\" width=\"80%\">\n</div>\n<p>当然在三维空间中我们基于上述方法实际上会得到无穷多组解，因此在实际计算中还要引入一些额外的约束来保证解的位移性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A3gcWi5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ihuUR7m.png\" width=\"80%\">\n</div>\n<h3 id=\"multi-joint-ik\"><a class=\"anchor\" href=\"#multi-joint-ik\">#</a> Multi-Joint IK</h3>\n<p>在 IK 问题中更常见的情况是链式的关节，此时我们需要求解出末端到达指定位置时每个关节对应的姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/INQNLpo.png\" width=\"80%\">\n</div>\n<p>除此之外，在实际求解前还需要考虑解的存在性。很多时候可能并不存在能够满足需求的关节姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jhSok3o.png\" width=\"80%\">\n</div>\n<p>另一方面，角色的不同关节往往还具有不同类型的约束。在进行求解时需要考虑这些约束，否则会出现角色动作过于扭曲的状况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LxP6RoN.png\" width=\"80%\">\n</div>\n<p>总体来看，在三维空间中求解带约束的 IK 问题是非常复杂的，目前还没有通用的算法来进行实时求解。在现代游戏引擎中一般是通过一些启发式的算法来进行近似求解。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/F5gQIa9.png\" width=\"80%\">\n</div>\n<h3 id=\"ccd\"><a class=\"anchor\" href=\"#ccd\">#</a> CCD</h3>\n<p>**CCD (cyclic coordinate decent)** 是目前游戏引擎中求解 IK 问题最主流的算法。它的求解过程非常简单：在每次迭代中按照关节顺序对当前关节进行旋转，使得末端关节指向目标位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pAJWLdQ.png\" width=\"80%\">\n</div>\n<p>在标准 CCD 算法的基础上还可以对迭代过程进行优化，比如设置 tolerance region 控制每次旋转的角度，或是对接近根部关节的旋转施加额外的约束从而保证根部不会出现过大的旋转。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HAFdSwo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6uxZzWG.png\" width=\"80%\">\n</div>\n<h4 id=\"fabrik\"><a class=\"anchor\" href=\"#fabrik\">#</a> FABRIK</h4>\n<p>**FABRIK (forward and backward reaching inverse kinematics)** 也是一种经典的 IK 求解算法。它的思想是在每一轮迭代中进行一次前向计算以及一次反向计算：前向计算时从末端关节向根部关节移动骨骼，而在反向计算时则从根部出发向末端移动关节。通过不断迭代同样可以计算出合适的姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OpehUir.png\" width=\"80%\">\n</div>\n<p>FABRIK 可以很容易地考虑关节约束的问题。当关节的转动角度存在约束时只需要把关节转到约束内垂直与目标的方向即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GgtwQED.png\" width=\"80%\">\n</div>\n<h4 id=\"jacobian-matrix\"><a class=\"anchor\" href=\"#jacobian-matrix\">#</a> Jacobian Matrix</h4>\n<p>**Jacobian 矩阵 (Jacobian matrix)** 是一种基于优化来求解 IK 问题的算法，它在机器人学中有着非常广泛的应用。关于 Jacobian 矩阵的细节我们会在后面的物理系统中进行详细的介绍。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AbYl4WJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3Uem3bX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HXCVvUe.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JjGqZ6c.png\" width=\"80%\">\n</div>\n<h4 id=\"other-ik-solutions\"><a class=\"anchor\" href=\"#other-ik-solutions\">#</a> Other IK Solutions</h4>\n<p>除了上面介绍的几种经典算法外，目前游戏业界对于 IK 问题也提出了一些其它方法进行处理。总体来看 IK 仍然是非常复杂的问题，在近几年得到了人们越来越多的关注。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sTg3clU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j3iujPV.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QFsrdhW.png\" width=\"80%\">\n</div>\n<p>同时需要注意的是 IK 也需要整合到动画管线中作为后处理来调整骨骼和关节的姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fQ9T1SH.png\" width=\"80%\">\n</div>\n<h2 id=\"facial-animation\"><a class=\"anchor\" href=\"#facial-animation\">#</a> Facial Animation</h2>\n<p>表情动画是动画系统中的重要组成部分，从人体的生理学基础来讲表情是由面部肌肉的运动来进行控制的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dpOMPX1.png\" width=\"80%\">\n</div>\n<p>而表情动画的难点在于人的表情变化往往只有非常少的肌肉运动，换句话说不同面部表情之间的差异可能是非常细微的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ufSmj0e.png\" width=\"80%\">\n</div>\n<h3 id=\"facs\"><a class=\"anchor\" href=\"#facs\">#</a> FACS</h3>\n<p>得益于电影工业对面部表情的探索，人们发现只需要面部五官进行组合就可以表现出不同的表情。这种表达表情的方式称为<strong> FACS (facial action coding system)</strong>，它一共包含 46 组基本单元。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0cJ8JXk.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lgkqh44.png\" width=\"80%\">\n</div>\n<p>同时由于面部的对称性，实际上在制作表情动画时只需要一半左右的单元就可以表达不同的表情。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IZfPFXD.png\" width=\"80%\">\n</div>\n<h3 id=\"key-pose-blending\"><a class=\"anchor\" href=\"#key-pose-blending\">#</a> Key Pose Blending</h3>\n<p>基于 FACS 就可以着手制作不同的表情动画了。在表情动画中我们一般是直接使用面部的网格而不是骨骼关节系统来描述表情，不过动画插值的思想和骨骼动画是一致的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dfFW4in.png\" width=\"80%\">\n</div>\n<p>进行表情混合时需要注意直接对面部进行混合往往会得到错误的结果，这是由于人脸在表达不同表情时一般只会用到一小部分面部肌肉，直接对表情进行混合容易造成整个面部发生运动。要解决这个问题也十分简单，只需要存储一个基本表情然后利用前面介绍过的<a href=\"/2022/05/17/GAMES104-NOTES-09.html#additive-blending\"> additive blending</a> 技术对表情进行叠加即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vqVPIsc.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1tCRsVP.png\" width=\"80%\">\n</div>\n<p>当然目前也有一些使用骨骼来表达面部表情的实践。使用骨骼动画的优势在于它比较适合表达面部比较大的变形，比如说眼球的转动或是嘴巴张开以及游戏中常见的捏脸系统等等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IoJXjQk.png\" width=\"80%\">\n</div>\n<h3 id=\"uv-texture-facial-animation\"><a class=\"anchor\" href=\"#uv-texture-facial-animation\">#</a> UV Texture Facial Animation</h3>\n<p>除了使用网格或是骨骼外很多游戏也会使用二维纹理图像来实现表情动画，这种方法在很多卡通渲染的游戏中有着大量的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SbbIS3T.png\" width=\"80%\">\n</div>\n<p>目前在学术界还出现了通过直接对人的面部肌肉进行建模然后实现表情动画的方法。尽管这种方法还没有大规模应用在游戏业界，而且它的计算需求也远高于传统方法，但它却可以实现更加逼真的角色表情。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yq1kycj.png\" width=\"80%\">\n</div>\n<h2 id=\"animation-retargeting\"><a class=\"anchor\" href=\"#animation-retargeting\">#</a> Animation Retargeting</h2>\n<p>本节课最后介绍了<strong>动画重定向 (animation retargeting)<strong> 技术在游戏行业中的应用。在动画制作中动画师往往只会对同一个动作进行一次建模，而在游戏中设计师则希望可把这个动作应用到各种不同的角色中。这种把一组动作从一个角色迁移到另一个角色的技术称为动画重定向，其中已经绑定好动作的模型称为</strong>源角色 (source character)<strong> 而需要施加动画的角色称为</strong>目标角色 (target character)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p2bPE3m.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gBzcfdw.png\" width=\"80%\">\n</div>\n<p>动画重定向最直接的做法是把对应骨骼和关节的动作直接复制过去。当然考虑到源角色和目标角色骨骼之间位置的差异，一般需要对关节姿态进行一定的补偿。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dRVtPN2.png\" width=\"80%\">\n</div>\n<p>考虑到不同角色之间姿态的差异，在进行重定向时可以只施加关节的相对运动。这种做法会得到更加自然以及符合人直觉的动画效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/flaYKvo.png\" width=\"80%\">\n</div>\n<p>综合上面的内容就得到了动画重定向最基本的算法：处理关节旋转时我们考虑关节的相对旋转，处理骨骼的平移时则需要根据目标角色骨骼的实际长度进行补偿，而对于缩放的情况则直接按照比例进行缩放。这样就可以把源角色的动作迁移到目标角色身上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oIyfkyH.png\" width=\"80%\">\n</div>\n<p>在实际工程中人们发现基于上面介绍的算法进行重定向时，由于源角色和目标角色本身骨骼的差异强行迁移动作容易造成目标角色悬空的现象。因此还需要对角色的高度再进行一定的补偿。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k7s6dAP.png\" width=\"80%\">\n</div>\n<p>如果源角色和目标角色的体型相差很多的话还会出现各种诡异的动画。要处理这种情况还需要利用一些 IK 的方法来进一步修正。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DriA7j9.png\" width=\"80%\">\n</div>\n<p>目前介绍的重定向方法都假定了源角色和目标角色的骨骼有相同的拓扑结构，但在很多情况下两个角色的骨骼是没有办法做到一一对应的，此时就需要一些更复杂的算法来传递动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/59jWcg5.png\" width=\"80%\">\n</div>\n<p>比较直接的处理方法是利用骨骼和关节的对应关系来对关节运动进行插值，这样就可以把原始骨骼的动作重定向到新的骨骼上。实际上在 Omniverse 上就使用了类似的方法来处理动画重定向的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kVhscwQ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sycZFW1.png\" width=\"80%\">\n</div>\n<p>当然动画重定向仍然是一个相对比较复杂的问题，很多时候即使把源角色的动作迁移到目标角色上仍然会出现很多穿模或者相交的问题。在这种情况下一般还需要动画师对迁移后的动画进行一些微调。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lLHyjkA.png\" width=\"80%\">\n</div>\n<p>动画重定向的技术除了可以应用在骨骼上，实际上还可以应用在表情动画上。当然在迁移的时候由于不同模型尺度的差异，有时会出现穿模等诡异的问题。此时可以对网格施加一些额外的约束来强行获得正确的动画效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4E4X0Sy.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JPtnwbe.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXBZNDExRjdwQQ==\">Lecture 09：Advanced Animation Technology</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/",
            "title": "games104系列笔记（八）",
            "date_published": "2023-06-26T04:59:00.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的动画系统。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>动画系统是游戏引擎的重要组成部分。从远古时代开始，我们的祖先就试图用各种手段让静止的画面动起来。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Buo3S4y.png\" width=\"80%\">\n</div>\n<p>直到近代，人们发现利用人眼的 &quot;视觉残留&quot; 效应可以将静止的画面产生运动的效果。这一发现构成了所有显示设备和电影动画的理论基础。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lZIS1ca.png\" width=\"80%\">\n</div>\n<h3 id=\"animation-techniques-in-film\"><a class=\"anchor\" href=\"#animation-techniques-in-film\">#</a> Animation Techniques in Film</h3>\n<p>目前游戏行业所使用的动画技术理论和经验基本都源自于电影行业对动画技术的探索。从早期的 2D 动画到如今大规模应用的三维动画，整个电影动画工业取得了令人瞩目的进步。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/257ecRO.png\" width=\"80%\">\n</div>\n<p>早期的动画主要是由艺术家逐帧手绘来实现，而在今天基于计算机的动画模拟技术已经成为了电影工业的主流。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zeIoC9R.png\" width=\"80%\">\n</div>\n<h3 id=\"animation-techniques-in-game\"><a class=\"anchor\" href=\"#animation-techniques-in-game\">#</a> Animation Techniques in Game</h3>\n<p>回到游戏领域，早期的游戏动画都是制作者根据真实图片进行绘制来实现的，这与早期的二维动画异曲同工。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mT3vvZt.png\" width=\"80%\">\n</div>\n<p>后来随着 GPU 和 3D 游戏引擎的出现，人们开始使用计算机来直接生成游戏场景中的动画。而在今天的 3A 游戏大作中，结合真人动捕以及物理仿真的计算机动画已经可以以假乱真的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CQ4nPTc.png\" width=\"80%\">\n</div>\n<h3 id=\"challenges-in-game-animation\"><a class=\"anchor\" href=\"#challenges-in-game-animation\">#</a> Challenges in Game Animation</h3>\n<p>和电影行业中的计算机动画相比，游戏中的动画难点之一在于游戏是一个和玩家不断互动的过程。游戏开发者很难预设玩家的行为，而且必须考虑玩家的行为与场景进行互动的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GdwwROs.png\" width=\"80%\">\n</div>\n<p>同时，游戏对于实时性有着更高的需求。在很多情况下我们甚至需要考虑游戏场景中有着上万个单位同时进行运动的情况，这样大规模的计算给游戏动画系统的性能造成了巨大的挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fCEt0vQ.png\" width=\"80%\">\n</div>\n<p>除此之外，玩家对于现代游戏角色的动画也提出了更高的要求。我们希望游戏角色有着更加生动的表情，同时在运动过程中的行为尽可能自然。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qZca7Fo.png\" width=\"80%\">\n</div>\n<p>本课程中我们将游戏引擎的动画系统分成两部分。本节课会介绍一些基础的动画知识，而在下一节中则会讨论一些业界更加前沿的技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vBrlvCV.png\" width=\"80%\">\n</div>\n<h2 id=\"2d-animation-techniques-in-games\"><a class=\"anchor\" href=\"#2d-animation-techniques-in-games\">#</a> 2D Animation Techniques in Games</h2>\n<h3 id=\"sprite-animation\"><a class=\"anchor\" href=\"#sprite-animation\">#</a> Sprite animation</h3>\n<p>首先我们来看游戏中二维动画的实现。二维动画是最早的游戏动画形式，直到今天仍然有很多游戏使用二维动画来进行表现。最简单的二维动画称为<strong> sprite animation</strong>，它是将游戏角色的行为逐帧绘制并在游戏中进行循环播放。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/n1KK0aS.png\" width=\"80%\">\n</div>\n<p>为了实现更加生动的表现效果，还可以在不同的视角下对同一动作进行绘制并且在实际游戏中根据需要选择合适的动作帧进行播放。这样就可以利用 2D 动画实现伪 3D 的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hOAOwSx.png\" width=\"80%\">\n</div>\n<p>在现代游戏中 sprite animation 仍然占有一席之地，很多游戏的特效就是通过预先渲染出的特效帧来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Grz7N0v.png\" width=\"80%\">\n</div>\n<h3 id=\"live2d\"><a class=\"anchor\" href=\"#live2d\">#</a> Live2D</h3>\n<p>目前虚拟主播中大范围应用的<strong> Live2D</strong> 技术同样来自于 2D 动画，通过对一系列图像进行变形就可以实现非常生动的表现效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/S85PogN.png\" width=\"80%\">\n</div>\n<p>Live2D 技术的核心是把角色的各个部位分解成不同的元素，通过对每个元素进行变形来实现虚拟人物的不同动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qRKSOx9.png\" width=\"80%\">\n</div>\n<p>在放置不同元素时还可以通过对图层顺序的变化进一步提升表现力。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fEsdrOi.png\" width=\"80%\">\n</div>\n<p>对于每一个图元则需要事先设置好它的网格来控制形变，这样角色的不同动作就可以通过对网格控制点的运动来进行描述。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xPYGwD4.png\" width=\"80%\">\n</div>\n<p>最后根据关键帧把角色不同元素不同控制点的运动组织起来就完成了一个虚拟角色的动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZC8pYoD.png\" width=\"80%\">\n</div>\n<h2 id=\"3d-animation-techniques-in-games\"><a class=\"anchor\" href=\"#3d-animation-techniques-in-games\">#</a> 3D Animation Techniques in Games</h2>\n<h3 id=\"degrees-of-freedom\"><a class=\"anchor\" href=\"#degrees-of-freedom\">#</a> Degrees of Freedom</h3>\n<p>3D 动画所需的技术要比 2D 动画复杂一些，在介绍具体的动画技术前我们需要先复习一下相关的数学知识。三维空间中物体的运动有 ** 自由度 (degrees of freedom, DoF)** 的概念，对于刚体而言描述它的运动需要 3 个平动和 3 个旋转一共 6 个自由度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mglgyzB.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IODmWKK.png\" width=\"80%\">\n</div>\n<h3 id=\"rigid-hierarchical-animation\"><a class=\"anchor\" href=\"#rigid-hierarchical-animation\">#</a> Rigid Hierarchical Animation</h3>\n<p>最简单的 3D 动画技术是把角色的不同部位都视为刚体，然后按照一定的层次把它们组织起来。早期的 3D 游戏就是使用这样的方法来实现三维角色的不同行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EwJTkNf.png\" width=\"80%\">\n</div>\n<h3 id=\"per-vertex-animation\"><a class=\"anchor\" href=\"#per-vertex-animation\">#</a> Per-vertex Animation</h3>\n<p>另一种实现三维动画的方法是利用网格的顶点来控制运动，这种技术称为<strong>顶点动画 (per-vertex animation)</strong>。此时网格上的每个顶点有具有 3 个平移自由度，通过对网格顶点坐标的变换就可以实现模型的运动。这种动画方法在人物角色上的应用比较少，但在物理仿真中则相对比较常见。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EgHxfOd.png\" width=\"80%\">\n</div>\n<h3 id=\"morph-target-animation\"><a class=\"anchor\" href=\"#morph-target-animation\">#</a> Morph Target Animation</h3>\n<p>类似于顶点动画，<strong>morph target animation</strong> 同样是利用顶点来控制模型的运动。和顶点动画不同的是，morph target animation 不会直接操作网格顶点的坐标而是通过顶点的位置和权重来控制整个网格的行为。morph target animation 在表现角色面部表情上有很广泛的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6pkkdzz.png\" width=\"80%\">\n</div>\n<h3 id=\"skinned-animation\"><a class=\"anchor\" href=\"#skinned-animation\">#</a> Skinned Animation</h3>\n<p>本节课的核心是介绍 ** 蒙皮动画 (skinned animation)** 的相关技术。蒙皮动画是目前游戏行业最主流的三维动画技术，它通过控制角色内部骨骼的运动来实现整个角色的运动。和刚体动画相比，蒙皮动画可以实现更加真实和自然的运动效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/njDSxGm.png\" width=\"80%\">\n</div>\n<p>蒙皮动画同样可以应用在二维动画上。基于 2D 蒙皮动画的运动会比刚体动画有更加自然的表现效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OEjHE1m.png\" width=\"80%\">\n</div>\n<h3 id=\"physics-based-animation\"><a class=\"anchor\" href=\"#physics-based-animation\">#</a> Physics-based Animation</h3>\n<p>在蒙皮动画之外另一大类动画形式是<strong>物理动画 (physics-based animation)</strong>。物理动画是完全基于物理法则的动画模拟方法，和蒙皮动画相比需要更加深入的数学物理知识进行描述。本课程中不会过多地介绍物理动画的相关内容。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KrsywfT.png\" width=\"80%\">\n</div>\n<h3 id=\"animation-content-creation\"><a class=\"anchor\" href=\"#animation-content-creation\">#</a> Animation Content Creation</h3>\n<p>如何获得动画呢？早期的解决方法是由动画师在软件中通过关键帧来对角色的动作进行建模，而目前越来越多的游戏和电影则是通过真人动捕来获得更加自然的运动动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zroTBXC.png\" width=\"80%\">\n</div>\n<h2 id=\"skinned-animation-implementation\"><a class=\"anchor\" href=\"#skinned-animation-implementation\">#</a> Skinned Animation Implementation</h2>\n<p>接下来我们介绍蒙皮动画的实现细节。从整体上来看，蒙皮动画的实现包括以下 5 个步骤：</p>\n<ol>\n<li>建立网格模型；</li>\n<li>建立网格模型附着的骨骼；</li>\n<li>为网格上每个顶点赋予骨骼对应的权重；</li>\n<li>利用骨骼完成角色的运动；</li>\n<li>结合顶点的骨骼权重实现网格的运动。</li>\n</ol>\n<p>上述步骤看上去不是很难，但在实际编程中需要多加小心防止出现网格爆炸的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PbIyyWv.png\" width=\"80%\">\n</div>\n<h3 id=\"different-spaces\"><a class=\"anchor\" href=\"#different-spaces\">#</a> Different Spaces</h3>\n<p>要描述骨骼的运动我们还需要引入相应的坐标系统。首先整个游戏世界定义了一个<strong>世界坐标系 (world space)</strong>，所有的物体都位于这个坐标系中；对于每个单独的模型，模型自身还定义了一个<strong>模型坐标系 (model space)</strong>；最后每个骨骼还定义了一个 ** 局部坐标系 (local space)** 来描述网格顶点和骨骼的相对位置关系。任意两个坐标系之间的变换关系可以通过 3 个平移和 3 个旋转一共 6 个自由度来表示，这样每个顶点的坐标都可以从局部坐标系变换到模型坐标系再变换到世界坐标系上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0ssOQop.png\" width=\"80%\">\n</div>\n<h3 id=\"skeleton\"><a class=\"anchor\" href=\"#skeleton\">#</a> Skeleton</h3>\n<p>在此基础上就可以结合角色自身的特点构建出具有一定拓扑关系的<strong>骨骼模型 (skeleton)</strong>，这一般可以通过一棵树来表示。对于类人型的骨骼，整棵树的根节点一般位于胯部。而对于四足动物等其它类型的骨骼其根部则会位于其它位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OEtRhQL.png\" width=\"80%\">\n</div>\n<h3 id=\"joint\"><a class=\"anchor\" href=\"#joint\">#</a> Joint</h3>\n<p>我们定义骨骼与骨骼之间相连接的部位为一个<strong>关节 (joint)</strong>。实际上我们不会直接按照骨骼进行编程，而是利用关节及他们直接的连接关系来表达整个骨骼的运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/op1a6fz.png\" width=\"80%\">\n</div>\n<p>在游戏建模中除了常见的四肢外可能还会根据角色的服装和特点来构建更加复杂的骨骼模型。比如说玩家手中的武器就是通过在角色手上绑定一个新的骨骼来实现的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uKxY3lz.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yxiIkmz.png\" width=\"80%\">\n</div>\n<p>除此之外，在进行建模时我们往往还会定义一个 root 关节。不同于前面介绍过的胯部骨骼，root 关节一般会定义在角色的两脚之间，这样方便把角色固定的地面上。类似地，对于坐骑的骨骼也往往会单独把 root 关节定义在接近地面的位置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZQQJVZT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RaIuePg.png\" width=\"80%\">\n</div>\n<p>很多游戏动画需要将不同的骨骼绑定到一起。最直观的例子就是角色骑马的动画，此时角色和马都有自身独立的动画而我们需要将它们组合到一起完成角色骑马的动作。要实现这种功能需要设计一个单独的 mount 关节，然后通过这个关节将两个模型拼接到一起。需要注意的是在拼接时不仅要考虑关节坐标的一致性，更要保证两个模型的 mount 关节上有一致的朝向，这样才能实现模型正确的结合。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/c4EQs4E.png\" width=\"80%\">\n</div>\n<h3 id=\"bind-pose\"><a class=\"anchor\" href=\"#bind-pose\">#</a> Bind Pose</h3>\n<p>早期的骨骼建模会使用 T-pose 作为角色动作的基准。但在实践过程中发现 T-pose 会导致角色的肩部出现挤压的状况，因此现代 3A 游戏中更多地会使用 A-pose 这种姿势进行建模</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/W2iiKgz.png\" width=\"80%\">\n</div>\n<h3 id=\"skeleton-pose\"><a class=\"anchor\" href=\"#skeleton-pose\">#</a> Skeleton Pose</h3>\n<p>完成骨骼建模后，角色的运动就可以通过骨骼的 ** 姿态 (pose)** 来进行描述。这里需要注意的是表达角色的不同动作时每个关节实际上具有 9 个自由度，除了刚体变换的 6 个自由度外还需要考虑 3 个放缩变换引入的自由度。这 3 个放缩自由度对于表现一些大变形的动作起着很重要的作用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pD3qTj4.png\" width=\"80%\">\n</div>\n<h2 id=\"math-of-3d-rotation\"><a class=\"anchor\" href=\"#math-of-3d-rotation\">#</a> Math of 3D Rotation</h2>\n<h3 id=\"2d-orientation-math\"><a class=\"anchor\" href=\"#2d-orientation-math\">#</a> 2D Orientation Math</h3>\n<p>在这一节中我们会详细介绍三维空间中如何表示物体旋转这一问题，不过首先我们来回顾一下二维空间的旋转。对于二维空间中的点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x, y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>，当它绕原点进行旋转时只需要一个旋转角度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span></span></span></span> 就可以进行描述，旋转的过程可以通过一个旋转矩阵<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>θ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R(\\theta)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"mclose\">)</span></span></span></span> 来进行表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GKzfmDl.png\" width=\"80%\">\n</div>\n<h3 id=\"3d-orientation-math\"><a class=\"anchor\" href=\"#3d-orientation-math\">#</a> 3D Orientation Math</h3>\n<h4 id=\"euler-angle\"><a class=\"anchor\" href=\"#euler-angle\">#</a> Euler Angle</h4>\n<p>三维空间中的旋转要更复杂一些。我们可以把任意三维空间的旋转分解为绕三个轴的旋转，每个旋转都对应一个三维旋转矩阵，这样就可以通过绕三个轴的旋转角度来进行表达。这种描述三维旋转的方法称为<strong>欧拉角 (Euler angle)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5390dbF.png\" width=\"80%\">\n</div>\n<p>欧拉角在很多领域都有大量的应用，比如说飞行器的导航和姿态描述一般都是基于欧拉角的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FxLbJHp.png\" width=\"80%\">\n</div>\n<p>但是需要说明的是欧拉角有很多局限性，比如说欧拉角是依赖于旋转顺序的。在使用欧拉角时必须指明绕三个旋转轴进行旋转的顺序，同样的欧拉角按照不同的顺序进行旋转会得到不同的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UKyhDeV.png\" width=\"80%\">\n</div>\n<p>欧拉角的另一个缺陷在于<strong>万向锁 (gimbal lock)</strong>：在有些情况下按照欧拉角进行旋转会出现退化的现象，导致物体的旋转会被锁死在某个方向上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CdOg5wv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VcKrsyw.png\" width=\"80%\">\n</div>\n<p>总结一下，欧拉角的主要缺陷如下：</p>\n<ul>\n<li>万向锁及相应的自由度退化问题；</li>\n<li>很难对欧拉角进行插值；</li>\n<li>很难通过欧拉角对旋转进行叠加；</li>\n<li>很难描述绕<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">x, y, z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> 轴之外其它轴的旋转。</li>\n</ul>\n<p>由于这些缺陷的存在，游戏引擎中几乎不会直接使用欧拉角来表达物体的旋转。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XQuDqSf.png\" width=\"80%\">\n</div>\n<h4 id=\"quaternion\"><a class=\"anchor\" href=\"#quaternion\">#</a> Quaternion</h4>\n<p>在游戏引擎中更常用的旋转表达方式是<strong>四元数 (quaternion)</strong>，它由 Hamilton 爵士于 19 世纪提出。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dBghycw.png\" width=\"80%\">\n</div>\n<p>我们知道二维空间中的旋转可以使用复数来进行表示。换句话说，二维平面上的旋转等价于复数乘法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9XAz6u1.png\" width=\"80%\">\n</div>\n<p>类似地，我们可以认为四元数是复数在三维空间的推广。一个四元数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> 具有 1 个实部和 3 个虚部<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">i, j, k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，四元数的运算法则如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VITLmJH.png\" width=\"80%\">\n</div>\n<p>可以证明，任意的三维旋转可以通过一个单位四元数来表示。当我们需要对点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">v</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4444em;\"></span><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">v</span></span></span></span> 进行旋转时，只需要先把<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">v</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{v}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4444em;\"></span><span class=\"mord mathbf\" style=\"margin-right:0.01597em;\">v</span></span></span></span> 转换成一个纯四元数，然后再按照四元数乘法进行变换，最后取出虚部作为旋转后的坐标即可：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SvvziQT.png\" width=\"80%\">\n</div>\n<p>进一步可以证明用欧拉角表达的旋转都对应着一个四元数的表示。同样地，四元数与旋转矩阵直接也存在着相应的转换关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LNviId1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/91QxDoc.png\" width=\"80%\">\n</div>\n<p>使用四元数来表达三维旋转的优势在于我们可以使用简单的代数运算来获得旋转的逆运算、旋转的组合以及两个单位向量之间的相差的旋转量。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/S1qNKNP.png\" width=\"80%\">\n</div>\n<p>对于绕任意轴旋转的情况，我们同样可以利用旋转轴和旋转角度的信息来构造出四元数进行表达。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UnJwf6m.png\" width=\"80%\">\n</div>\n<h2 id=\"joint-pose\"><a class=\"anchor\" href=\"#joint-pose\">#</a> Joint Pose</h2>\n<h3 id=\"affine-matrix\"><a class=\"anchor\" href=\"#affine-matrix\">#</a> Affine Matrix</h3>\n<p>有了三维旋转的表达方法后我们就可以利用关节的姿态来控制角色模型的运动。具体来说，我们每个关节的姿态可以分为平移、旋转和缩放三个部分，把它们组合到一起就可以通过一个 ** 仿射矩阵 (affine matrix)** 来描述关节的姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BG2rAjG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Txgse4n.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lgecv7n.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iliaaij.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QZRZd5t.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/leV4BaP.png\" width=\"80%\">\n</div>\n<p>对于骨骼上的每一个关节，我们实际上只需要存储它相对于父节点的相对姿态。这样在计算绝对姿态时可以利用仿射矩阵的传递性从根节点出发进行累乘即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RpTendQ.png\" width=\"80%\">\n</div>\n<p>这种利用相对坐标系来描述位姿关系的好处在于它可以正确地对角色动作进行插值，而如果直接从绝对坐标系进行插值则会得到错误的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/POXTmEz.png\" width=\"80%\">\n</div>\n<h3 id=\"skinning-matrix\"><a class=\"anchor\" href=\"#skinning-matrix\">#</a> Skinning Matrix</h3>\n<p>在前面我们介绍过模型的每个顶点是附着在骨骼上的，因此在关节姿态发生变化后顶点会跟着关节一起运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UbeqKF4.png\" width=\"80%\">\n</div>\n<p>记顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 在关节<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> 定义的局部坐标系下的坐标为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>V</mi><mi>b</mi><mi>l</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">V_b^l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1322em;vertical-align:-0.2831em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-2.4169em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2831em;\"><span></span></span></span></span></span></span></span></span></span>，初始时刻进行绑定时<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 在模型坐标系下的坐标为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>V</mi><mi>b</mi><mi>m</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">V_b^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9664em;vertical-align:-0.2831em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4169em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2831em;\"><span></span></span></span></span></span></span></span></span></span>。在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 时刻，当关节位姿发生变化后顶点的局部坐标保持不变。此时顶点在模型坐标系下的坐标和局部坐标直接满足变换关系：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>V</mi><mi>l</mi></msup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mi>V</mi><mi>b</mi><mi>l</mi></msubsup><mo>=</mo><mo stretchy=\"false\">(</mo><msubsup><mi>M</mi><mrow><mi>b</mi><mo stretchy=\"false\">(</mo><mi>J</mi><mo stretchy=\"false\">)</mo></mrow><mi>m</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msubsup><mi>V</mi><mi>b</mi><mi>m</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">V^l(t) = V_b^l = (M_{b(J)}^m)^{-1} V_b^m\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1491em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1461em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-2.453em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3111em;vertical-align:-0.447em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.428em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.447em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.453em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>M</mi><mrow><mi>b</mi><mo stretchy=\"false\">(</mo><mi>J</mi><mo stretchy=\"false\">)</mo></mrow><mi>m</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">M_{b(J)}^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1803em;vertical-align:-0.497em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.378em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.497em;\"><span></span></span></span></span></span></span></span></span></span> 即为初始时刻进行绑定时关节<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> 对应的姿态。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UVOaeKR.png\" width=\"80%\">\n</div>\n<p>利用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> 时刻关节的位姿<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>M</mi><mi>J</mi><mi>m</mi></msubsup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M_J^m(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0253em;vertical-align:-0.2753em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4247em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2753em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>，可以得到顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 模型坐标系下的坐标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mi>m</mi></msup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">V^m(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> 与初始时刻模型坐标系下绑定的坐标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>V</mi><mi>b</mi><mi>m</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">V_b^m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9664em;vertical-align:-0.2831em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4169em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2831em;\"><span></span></span></span></span></span></span></span></span></span> 之间的变换关系：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>V</mi><mi>m</mi></msup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mi>M</mi><mi>J</mi><mi>m</mi></msubsup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><msubsup><mi>V</mi><mi>J</mi><mi>l</mi></msubsup><mo>=</mo><msubsup><mi>M</mi><mi>J</mi><mi>m</mi></msubsup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mo stretchy=\"false\">(</mo><msubsup><mi>M</mi><mrow><mi>b</mi><mo stretchy=\"false\">(</mo><mi>J</mi><mo stretchy=\"false\">)</mo></mrow><mi>m</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><msubsup><mi>V</mi><mi>b</mi><mi>m</mi></msubsup><mo>=</mo><msub><mi>K</mi><mi>J</mi></msub><msubsup><mi>V</mi><mi>b</mi><mi>m</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">V^m(t) = M_J^m(t) V_J^l = M_J^m(t) \\cdot (M_{b(J)}^m)^{-1} V^m_b = K_J V_b^m\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1491em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.453em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-2.453em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.453em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3111em;vertical-align:-0.447em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.428em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.447em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.453em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9614em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-2.453em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>K</mi><mi>J</mi></msub><mo>=</mo><msubsup><mi>M</mi><mi>J</mi><mi>m</mi></msubsup><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mo stretchy=\"false\">(</mo><msubsup><mi>M</mi><mrow><mi>b</mi><mo stretchy=\"false\">(</mo><mi>J</mi><mo stretchy=\"false\">)</mo></mrow><mi>m</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">K_J = M_J^m(t) \\cdot (M_{b(J)}^m)^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0253em;vertical-align:-0.2753em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.4247em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2753em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3111em;vertical-align:-0.497em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.378em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.497em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 称为关节<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> 的<strong>蒙皮矩阵 (skinning matrix)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jsEnq8f.png\" width=\"80%\">\n</div>\n<p>注意到蒙皮矩阵的第二项包含矩阵求逆运算，在游戏引擎中为了提高计算效率一般会直接存储整个逆阵。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SqXrA6N.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1lpMUjL.png\" width=\"80%\">\n</div>\n<p>对于同一个顶点绑定到多个骨骼的情况则需要通过插值进行处理。此时顶点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 会同时存储它所绑定到的关节以及对应的权重，其在世界坐标系下的坐标为它在每个关节上定义的局部坐标转换到世界坐标后的加权和。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ntBsxy7.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g9CmPbV.png\" width=\"80%\">\n</div>\n<h3 id=\"interpolation\"><a class=\"anchor\" href=\"#interpolation\">#</a> Interpolation</h3>\n<p>在动画制作过程中一般只会记录下一系列关键帧上骨骼的姿态，而要得到实际的动画还需要通过插值来获得中间帧上模型的运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M1db1l9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jjcpka3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Sdf7NU4.png\" width=\"80%\">\n</div>\n<p>线性插值是最基本的插值方法，我们可以通过对关节姿态的插值来计算中间帧上的模型运动。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SmP2Hmu.png\" width=\"80%\">\n</div>\n<p>对于三维旋转的插值要相对复杂一些，不过我们可以借助四元数的运算来进行处理。要获得插值后的旋转只需要对四元数直接进行线性插值，然后再进行归一化即可，这样的方法称为 NLERP。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WlKsM7V.png\" width=\"80%\">\n</div>\n<p>需要说明的是 NLERP 并不是真的对旋转进行线性插值。当动画的帧数较高时 NLERP 会有明显的违和感，这是由于它没有考虑旋转并不是线性空间。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QN8JLOn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gqX20SA.png\" width=\"80%\">\n</div>\n<p>想要真的对旋转进行线性插值可以使用 SLERP 这样的算法，不过 SLERP 的计算代价要比 NLERP 要大一些。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pYZRMOa.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/T8HywuY.png\" width=\"80%\">\n</div>\n<h3 id=\"animationruntime-pipeline\"><a class=\"anchor\" href=\"#animationruntime-pipeline\">#</a> AnimationRuntime Pipeline</h3>\n<p>我们把上面介绍过的算法整理一下就得到了一个简单的蒙皮动画管线如下。现代 3A 游戏在此基础上还会更多地把计算配置到 GPU 上来充分计算资源。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bUd0mki.png\" width=\"80%\">\n</div>\n<h2 id=\"animation-compression\"><a class=\"anchor\" href=\"#animation-compression\">#</a> Animation Compression</h2>\n<p>** 动画压缩 (animation compression)** 是计算机动画中非常实用的技术。实际上直接存储每个模型上每个关节的姿态需要占用非常多的资源，因此利用一些压缩技术来减少动画存储空间有着非常重要的意义。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3t7Q3lX.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4KwBtKs.png\" width=\"80%\">\n</div>\n<h3 id=\"dof-reduction\"><a class=\"anchor\" href=\"#dof-reduction\">#</a> DoF Reduction</h3>\n<p>在广泛的实践中人们发现不同关节不同自由度的信号之间有着巨大的差异。以大腿关节为例，在大多数情况下它的缩放自由度都是 1 而且大部分的平动自由度都是 0，它的运动基本都是来自于旋转；而对于手指这样的关节，它的旋转很少但是平动会相对多一些。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ZrLqUbE.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/peQRBaL.png\" width=\"80%\">\n</div>\n<p>因此最简单的动画压缩方法是直接缩减运动的自由度，把关节的缩放和平动自由度直接去掉只保存旋转。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yCFjhH4.png\" width=\"80%\">\n</div>\n<h3 id=\"keyframe\"><a class=\"anchor\" href=\"#keyframe\">#</a> Keyframe</h3>\n<p>对于旋转自由度我们可以使用 ** 关键帧 (keyframe)** 来对信号进行离散，然后通过插值来重建原始信号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dKc9cfF.png\" width=\"80%\">\n</div>\n<p>在离散时还可以利用不等间距采样的方式来进一步压缩信号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VeZ58bv.png\" width=\"80%\">\n</div>\n<p>直接使用线性插值来描述非等间距采样的旋转信号仍然不够自然，这里推荐使用 Catmull-Rom 曲线来对关键帧进行插值。Catmull-Rom 曲线只需要一个锐度参数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> 以及 4 个控制点就可以获得 C1 连续的光滑曲线。基于 Catmull-Rom 曲线可以实现非常高精度的信号离散和重建效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MyMcVie.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sVlPLoz.png\" width=\"80%\">\n</div>\n<h3 id=\"quantization\"><a class=\"anchor\" href=\"#quantization\">#</a> Quantization</h3>\n<p>进一步压缩数据时还可以考虑使用低精度的存储方式来记录位移信号。比如说可以通过规范化的方法将 32 位浮点数转换为 16 位无符号整数来表示，这样虽然损失了一些精度但却可以极大地减少存储空间。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/I4myLEt.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/U78vCfT.png\" width=\"80%\">\n</div>\n<p>对四元数进行压缩时可以利用单位四元数每一位上数值的范围来进行化简。具体来说我们可以首先使用 2 个 bit 来表示四元数的哪一位被丢掉了，剩下的 3 位可以分别使用 15 个 bit 来进行表达。这样一个四元数可以使用 48 个 bit 来进行存储，远小于使用 4 个 float 所需的 128 个 bit。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/l1oAS6E.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qKKYL21.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Aws7WJE.png\" width=\"80%\">\n</div>\n<h3 id=\"error-propagation\"><a class=\"anchor\" href=\"#error-propagation\">#</a> Error Propagation</h3>\n<p>数据压缩必然会导致精度损失的问题。对于一些末端的关节，由于误差传播的效应可能会产生非常大的累计误差。这种现象的直观反映就是模型可能会产生视觉上可见的偏移。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1xVzglG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/TUCwZ8G.png\" width=\"80%\">\n</div>\n<p>要缓解这种累计误差首先需要定量化的描述误差。我们可以直接对比数据压缩前后模型每个顶点上的坐标差异，但这种做法的计算代价过于巨大，目前工业界的主流处理方法是在关节上设置虚拟顶点然后利用虚拟顶点压缩前后的差异来描述误差。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nF4XjmT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tJeN51Y.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rrj5hpp.png\" width=\"80%\">\n</div>\n<p>而要缓解累计误差我们可以为不同的关节设置不同的存储精度，或是通过主动补偿的方式来进行修正。总体而言，对于累计误差目前没有非常完善的处理方法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AWHqvZ1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/TM7KBzf.png\" width=\"80%\">\n</div>\n<h2 id=\"animation-dcc-process\"><a class=\"anchor\" href=\"#animation-dcc-process\">#</a> Animation DCC Process</h2>\n<p>本节课最后介绍了动画制作的流程。一般来说蒙皮动画的制作包括建立网格模型、绑定骨骼、蒙皮、制作骨骼动画以及导出等步骤。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pvb6Fi2.png\" width=\"80%\">\n</div>\n<p>动画制作的第一步是建立网格模型。一般来说建模师设计的三维模型会具有远高于动画需求的精度，因此在动画制作阶段往往只会使用低精度的模型进行处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CJX7EPp.png\" width=\"80%\">\n</div>\n<p>需要注意的一点是为了保证最终动画成品的效果，建模师在建模时一般会在关节处对网格进行加密。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dNYN4cc.png\" width=\"80%\">\n</div>\n<p>接下来需要为模型制作骨骼，目前主流的三维建模软件都集成了骨骼的功能。在角色基本骨骼的基础上一般还会根据游戏玩法进一步添加一些额外的关节，包括武器、坐骑等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LS7MJ4w.png\" width=\"80%\">\n</div>\n<p>然后我们需要把顶点绑定到骨骼上，这一般需要在软件自动计算的基础上结合建模师的经验进行手动校正。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yTF8jfK.png\" width=\"80%\">\n</div>\n<p>在动画建模阶段则需要由动画师根据关键帧设置模型的动作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9tJr5FN.png\" width=\"80%\">\n</div>\n<p>最后游戏引擎需要提供相应的模型导出功能。目前工业标准是使用 FBX 格式来保存动画所需的全部几何运动数据。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YK3oTvn.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWpyNHkxdDdXUi8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 08：Basics of Animation Technology I</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWZGNDExajdoQS8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 08：Basics of Animation Technology II</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9rcmFzamV0LmdpdGh1Yi5pby9xdWF0ZXJuaW9uL3F1YXRlcm5pb24ucGRm\">四元数与三维旋转</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXFhNDExQjc5Mj90PTY1NTcuNg==\">曹则贤开讲 &quot;从一元二次方程到规范场论&quot; 中国科学院 2022 跨年科学演讲第三场全程回顾</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/",
            "title": "games104系列笔记（七）",
            "date_published": "2023-06-26T04:58:54.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的渲染管线以及其它常用的技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"ambient-occlusion\"><a class=\"anchor\" href=\"#ambient-occlusion\">#</a> Ambient Occlusion</h2>\n<p>** 环境光遮蔽 (ambient occlusion, AO)** 是现代游戏必备的渲染技术，通过 AO 可以获得更加丰富的光影变化以及更加立体的视觉感受。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fgWRpwv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lqb8MXU.png\" width=\"80%\">\n</div>\n<p>从渲染方程的角度来看，AO 的本质是计算网格上每个点在光照下的可见性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Bc9Fp0b.png\" width=\"80%\">\n</div>\n<p>早期的 AO 是通过对网格进行预计算来实现，我们可以把顶点的可见性事先烘焙到网格信息中以便实际渲染时调用。这种方法目前在游戏工业中仍然有很多的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sAinfzq.png\" width=\"80%\">\n</div>\n<h3 id=\"ssao\"><a class=\"anchor\" href=\"#ssao\">#</a> SSAO</h3>\n<p>显然这种 AO 方法只考虑的单个模型自身的几何信息，当把模型放置在场景中时是无法得到正确的 AO 效果的。为了克服这样的问题，人们提出了<strong> SSAO</strong> 这种基于屏幕空间的 AO 算法。SSAO 的处理方法是首先从相机出发渲染出一张深度图，然后对于深度图上的每一个像素我们在屏幕空间上找到该点对应的模型位置并在它的周围采样出<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个点。利用这<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 个采样点以及深度图我们就可以估计该点处的遮挡关系，从而实现 AO 的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KzUvxuI.png\" width=\"80%\">\n</div>\n<p>当然 SSAO 是一种近似方法，它本身是存在一些问题的。在 SSAO 的基础上人们又发展出了 SSAO + 算法，SSAO + 没有在整个球体内进行采样而是根据顶点法向考虑法向对应的上半球上进行采样。这种改进克服了 SSAO 容易产生的整个游戏画面过暗的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WMTInR9.png\" width=\"80%\">\n</div>\n<p>使用 SSAO + 实现的 AO 效果可见下图。SSAO 相关方法的缺陷在于它只考虑了屏幕空间上的几何，这种简化在某些情况下会导致错误的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/igPLdvy.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BdM2lst.png\" width=\"80%\">\n</div>\n<h3 id=\"hbao\"><a class=\"anchor\" href=\"#hbao\">#</a> HBAO</h3>\n<p><strong>HBAO</strong> 同样是基于屏幕空间的 AO 算法，它的思想是使用天顶角<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span></span></span></span> 的可见性来代替 SSAO 中的采样方法。我们可以通过对顶点法向上半球的方向通过 ray marching 的方式进行积分来估计它的可见性。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ikaG0lR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/O1ju9M4.png\" width=\"80%\">\n</div>\n<h3 id=\"gtao\"><a class=\"anchor\" href=\"#gtao\">#</a> GTAO</h3>\n<p>上面介绍的几种算法都隐含地假设了顶点接收到来自不同方向上的光照是一致的，但实际上这种假设都没有考虑到渲染方程中的余弦项<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\cos \\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mop\">cos</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span></span></span></span>。<strong>GTAO</strong> 补充了缺失的余弦项，此外对光线进行多次弹射的效果进行了拟合。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BhAuMSY.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1Pr7dlH.png\" width=\"80%\">\n</div>\n<h3 id=\"ray-tracing-ambient-occlusion\"><a class=\"anchor\" href=\"#ray-tracing-ambient-occlusion\">#</a> Ray-Tracing Ambient Occlusion</h3>\n<p>当然，利用现代 GPU 的强大计算能力我们也可通过 real time ray tracing 的方式来计算 AO。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j6xbYJi.png\" width=\"80%\">\n</div>\n<h2 id=\"fog\"><a class=\"anchor\" href=\"#fog\">#</a> Fog</h2>\n<h3 id=\"depth-fog\"><a class=\"anchor\" href=\"#depth-fog\">#</a> Depth Fog</h3>\n<p>雾效是游戏设计者非常喜欢的视觉效果。最简单的雾效是使用深度信息来考虑雾的视觉效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hvzkrfl.png\" width=\"80%\">\n</div>\n<h3 id=\"height-fog\"><a class=\"anchor\" href=\"#height-fog\">#</a> Height Fog</h3>\n<p>当然基于深度的雾效只有有限的表达效果。现实中的雾往往和它所处的高度有关，海拔高度越低的地方雾的效果越明显。对于这种视觉效果可以使用高度信息来进行近似：当高度大于一定的阈值时雾的效果会呈指数递减。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B2rvZE6.png\" width=\"80%\">\n</div>\n<h3 id=\"voxel-based-volumetric-fog\"><a class=\"anchor\" href=\"#voxel-based-volumetric-fog\">#</a> Voxel-based Volumetric Fog</h3>\n<p>在现代 3A 游戏中雾效可以使用体素化的方法来进行表现。在进行渲染时需要利用 ray marching 的方式考虑光线在参与介质中的各种行为，这样就可以获得逼真的雾效。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Akl4nVm.png\" width=\"80%\">\n</div>\n<h2 id=\"anti-aliasing\"><a class=\"anchor\" href=\"#anti-aliasing\">#</a> Anti-aliasing</h2>\n<p>** 走样 (aliasing)** 是渲染中非常容易出现的问题。当相机的采样频率小于场景变化的频率时就会导致图像上出现各种各样的锯齿和走样。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UVE3UiC.png\" width=\"80%\">\n</div>\n<p>** 反走样 (anti-aliasing)** 的目标是去除掉图像上的走样，它的基本思路是在每个像素点上进行多次采样并取平均，这样就可以过滤掉高频信号。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/PnlGGVE.png\" width=\"80%\">\n</div>\n<h3 id=\"ssaa-and-msaa\"><a class=\"anchor\" href=\"#ssaa-and-msaa\">#</a> SSAA and MSAA</h3>\n<p>早期的反走样方法是直接使用更高的分辨率进行渲染，然后在输出图像前再通过降采样的方法来获得正常分辨率的图像，这样的方法称为<strong>超采样 (super sampling)</strong>。显然超采样的方法会导致非常大的计算复杂度，在现代游戏引擎中基本已经弃用。类似地，<strong>MSAA</strong> 则是在渲染时利用采样点进行着色然后通过取平均的方式来处理走样的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OT1fc7q.png\" width=\"80%\">\n</div>\n<h3 id=\"fxaa\"><a class=\"anchor\" href=\"#fxaa\">#</a> FXAA</h3>\n<p>SSAA 和 MSAA 的主要问题在于超采样的过程导致了巨大的计算复杂度，而<strong> FXAA</strong> 则是直接在原始分辨率的图像上进行反走样。FXAA 的思想是在图像的边缘区域使用插值的方式来实现反走样，因此 FXAA 首先需要使用边缘检测算子来检测出图像亮度发生剧烈变化的区域。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Cgz4FWD.png\" width=\"80%\">\n</div>\n<p>然后通过卷积运算，FXAA 判断这些区域是在水平方向还是垂直方向发生了较大的变化并以此作为反走样补偿的方向。得到补偿方向后还需要根据相邻像素之间的亮度差值来选择亮度差异大的作为具体的方向。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/xwwwnMX.png\" width=\"80%\">\n</div>\n<p>接下来 FXAA 会沿补偿方向的垂直方向寻找像素对，如果相邻像素在补偿方向上的差异与当前像素接近则与当前像素为同一组。通过向两边进行查找的方法来获得插值计算的端点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AjLIxdG.png\" width=\"80%\">\n</div>\n<p>得到端点后可以根据当前点到两端的距离来确定插值的系数。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YJ0Vlkb.png\" width=\"80%\">\n</div>\n<p>最后对同一组中的像素进行颜色插值即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5bPg1vh.png\" width=\"80%\">\n</div>\n<p>FXAA 的反走样效果如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tOUV843.png\" width=\"80%\">\n</div>\n<h3 id=\"taa\"><a class=\"anchor\" href=\"#taa\">#</a> TAA</h3>\n<p>除了上面介绍过的方法外另一种进行反走样的思路是利用时序信息进行反走样，这类方法称为<strong> TAA</strong>。TAA 的思想是考虑每个像素在上一帧所处的位置，然后将上一帧对应位置的颜色和当前帧上的颜色进行加权平均来进行滤波。目前很多游戏引擎都使用了 TAA 相关的方法来实现反走样。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aQJ5lsd.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eid6iya.png\" width=\"80%\">\n</div>\n<h2 id=\"post-process\"><a class=\"anchor\" href=\"#post-process\">#</a> Post-process</h2>\n<p>在现代 3A 游戏中对画面进行渲染后一般还需要添加各种后处理来提升画面的表现力。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yLeFsev.png\" width=\"80%\">\n</div>\n<h3 id=\"bloom\"><a class=\"anchor\" href=\"#bloom\">#</a> Bloom</h3>\n<p><strong>bloom</strong> 是一种非常常见的灯光效果，在光源的四周我们往往可以看到一圈放大的光晕。从物理的角度上讲，bloom 的成因在于真实相机的镜头并不符合完美的针孔相机，因此在成像时会出现这样的光学现象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A4Yl55t.png\" width=\"80%\">\n</div>\n<p>想要实现 bloom 的效果也非常简单，我们可以通过对渲染后的图像进行滤波来获得类似的效果。首先，我们需要找出图像中高亮度的区域。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1SvpS4B.png\" width=\"80%\">\n</div>\n<p>然后我们对这些高亮的区域使用高斯模糊来获得 bloom 的效果。实际处理时往往还会对高斯核进行分解并且结合图像金字塔来进行加速。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/T7NPPMh.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WIuE4Pf.png\" width=\"80%\">\n</div>\n<p>最后，我们把高亮的区域叠加到原始图像上就可以得到 bloom 的效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AOW34Tx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/a9CAzjU.png\" width=\"80%\">\n</div>\n<h3 id=\"tone-mapping\"><a class=\"anchor\" href=\"#tone-mapping\">#</a> Tone Mapping</h3>\n<p>** 色调映射 (tone mapping)** 是输出最终渲染图像前的一个重要环节。目前 3A 游戏的光照往往都是 HDR 的，这容易导致渲染出的图像上会出现过明或过暗的区域。通过色调映射我们可以把 HDR 图像的亮度进行压缩来获得更好的显示效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tBjPWhw.png\" width=\"80%\">\n</div>\n<p>色调映射的实现同样非常简单，我们只需要利用一条曲线对亮度进行缩放即可。filmic 曲线就是色调映射中常用的一种曲线，它可以让游戏画面获得电影般的质感。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CWtf1sB.png\" width=\"80%\">\n</div>\n<p>目前 3A 游戏中更多地使用了 ACES 曲线来进行色调映射。ACES 来自于电影工业大量专业视觉工作者的总结，使用 ACES 曲线不仅会让画面更有表现力，而且它对于不同的显示设备都有很好的支持。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QBZV4Aw.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/n8irJiG.png\" width=\"80%\">\n</div>\n<p>使用不同的常用曲线进行色调映射的效果如下。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HmfKnYT.png\" width=\"80%\">\n</div>\n<h3 id=\"color-grading\"><a class=\"anchor\" href=\"#color-grading\">#</a> Color Grading</h3>\n<p>** 颜色分级 (color grading)** 是游戏设计者非常常用的一种调色方法，它的本质是建立一个颜色到颜色的映射从而获得不同的画面表现效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/eFkPAgH.png\" width=\"80%\">\n</div>\n<p>我们可以使用 3D texture 或者 texture array 等技术将这个映射存储在纹理中，然后通过查表的方式对画面进行调色。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ow9wb9J.png\" width=\"80%\">\n</div>\n<p>因此对于游戏引擎来说则需要开发相关的模块来方便设计师建立这样的颜色映射。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/knSf8Rm.png\" width=\"80%\">\n</div>\n<p>通过 color grading 可以烘托玩家不同的情绪，从而提升玩家的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SVrlEii.png\" width=\"80%\">\n</div>\n<h2 id=\"rendering-pipeline\"><a class=\"anchor\" href=\"#rendering-pipeline\">#</a> Rendering Pipeline</h2>\n<h3 id=\"forward-rendering\"><a class=\"anchor\" href=\"#forward-rendering\">#</a> Forward Rendering</h3>\n<p>到目前为止我们已经学到了很多工业界常用的渲染算法，在实际进行渲染时还需要通过 ** 渲染管线 (rendering pipeline)** 来将这些算法组织起来。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IJUYZk6.png\" width=\"80%\">\n</div>\n<p>最直接的渲染管线是按照网格和光源进行遍历，依次把计算得到的颜色累加到指定的像素上。这样的渲染管线称为<strong>前向渲染 (forward rendering)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fAi9Wuf.png\" width=\"80%\">\n</div>\n<p>对于半透明的物体，前向渲染还需要考虑物体之间的渲染顺序。比如说我们需要先绘制不透明的物体然后才能绘制半透明的物体，而在绘制不同的半透明物体时还需要按照深度由远及近进行绘制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uWCyMg9.png\" width=\"80%\">\n</div>\n<h3 id=\"deferred-rendering\"><a class=\"anchor\" href=\"#deferred-rendering\">#</a> Deferred Rendering</h3>\n<p>前向渲染的一个缺陷在于当场景中的光源数比较多时效率会非常低下。为了克服前向渲染这样的问题，人们还开发出了 ** 延迟渲染 (deferred rendering)** 的技术。在延迟渲染的管线中，每个像素的渲染分为两个步骤：首先把每个像素对应的各种几何信息存储到 G-buffer 中，然后再对像素进行渲染。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/leSjXEL.png\" width=\"80%\">\n</div>\n<p>延迟渲染的优势在于它可以极大地提升渲染效率，而且 G-buffer 中存储的几何信息也可以方便后处理的各种计算；但它的缺点也很明显，延迟渲染需要首先将几何信息写入 G-buffer 中因此对显存有着更高的需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4n74WFn.png\" width=\"80%\">\n</div>\n<h3 id=\"tile-based-rendering\"><a class=\"anchor\" href=\"#tile-based-rendering\">#</a> Tile-based Rendering</h3>\n<p>为了缓解延迟渲染的显存压力，我们可以使用 ** 分片渲染 (tile-based rendering)** 的方式将整个画面拆成若干个分片，然后在每个分片上单独使用延迟渲染。这样的方式可以有效减少显存的需求，在很多移动设备上都有应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kWxDuSM.png\" width=\"80%\">\n</div>\n<p>更进一步，我们可以把每个分片需要考虑的光源信息写入 G-buffer 中。这样在对每个分片进行渲染时只考虑可能出现在该分片上的光照，从而进一步提升渲染效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Rq6I3wR.png\" width=\"80%\">\n</div>\n<p>除此之外，我们还可以利用空间深度信息来进一步优化每一个分片上需要考虑的光源。这样可以更高效地处理多光源的场景。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dYWfdOp.png\" width=\"80%\">\n</div>\n<p>很多游戏还是要了<strong> forward+ rendering</strong> 这种形式的渲染管线，它是将 forward rendering 按照分片进行渲染的绘制方式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VeFykg7.png\" width=\"80%\">\n</div>\n<h3 id=\"cluster-based-rendering\"><a class=\"anchor\" href=\"#cluster-based-rendering\">#</a> Cluster-based Rendering</h3>\n<p>对空间进行划分时还可以同时按照深度进行切分，这样可以处理场景中有上千个光源的极端情况。它可以看做是分片渲染在深度上的推广。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wHjEAVY.png\" width=\"80%\">\n</div>\n<h3 id=\"visibility-buffer\"><a class=\"anchor\" href=\"#visibility-buffer\">#</a> Visibility Buffer</h3>\n<p>目前游戏工业还发展出了基于 V-buffer 的渲染管线。V-buffer 与 G-buffer 类似，但在 V-buffer 中储存的是像素的深度和面片信息，而在实际渲染时根据每个像素对应的几何信息来进行绘制。这样的渲染管线更加适合如今越来越复杂的几何场景。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vNYm14i.png\" width=\"80%\">\n</div>\n<h2 id=\"frame-graph\"><a class=\"anchor\" href=\"#frame-graph\">#</a> Frame Graph</h2>\n<p>在商业游戏引擎的渲染系统中，除了需要包含各种先进的渲染算法外还需要考虑如何对各种算法有序地进行管理。以虚幻引擎为例，整个渲染管线中包含了大量的可选算法，在实际渲染时需要进行相应的调度使它们按顺序进行执行。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Q15Lew4.png\" width=\"80%\">\n</div>\n<p>同时，像 Vulkan 和 DirectX 12 等现代图形 API 往往开放了大量的 GPU 底层接口进行编程。这使得程序员可以高效地实现对硬件计算资源的管理，但相应的如果开发时不够谨慎则容易造成整个系统的崩溃。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M1XtUgj.png\" width=\"80%\">\n</div>\n<p>为了便于整个开发和渲染流程，游戏工业目前尝试使用<strong> frame graph</strong> 这样的技术对整个渲染过程进行管理。它的思想是把整个渲染过程所需的算法和各种资源表示为一张<strong>有向无环图 (DAG)</strong>，这样就可以通过对图的管理来实现不同资源的调度。当然 frame graph 这样的技术仍在探索阶段，但我们可以期待它在今后整个游戏工业界的表现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Q4EPi1A.png\" width=\"80%\">\n</div>\n<h2 id=\"render-to-monitor\"><a class=\"anchor\" href=\"#render-to-monitor\">#</a> Render to Monitor</h2>\n<p>当我们在 GPU 完成渲染后就需要把渲染的结果输出到显示屏幕上。这里需要注意的是当显示器的刷新频率和 GPU 的输出频率不一致时会产生画面割裂的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2FrtPLJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4T3LkP7.png\" width=\"80%\">\n</div>\n<p>为了克服这样的问题人们开发出了<strong> V-Sync</strong> 技术，它会强制显示器等待 GPU 的输出结果这样就可以避免画面的不一致。当然 V-Sync 也带来了一些新的问题：在场景发生变化时画面的帧率会忽快忽慢影响玩家的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WEe4lfS.png\" width=\"80%\">\n</div>\n<p>因此目前一些硬件厂商提出了<strong> variable refresh rate</strong> 的概念，让显示器画面的刷新率可以由 GPU 根据需要来动态设置。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lQSgtX6.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWtZNDExUDdRTS8=\">Lecture 07：Render Pipeline, Post-process and Everything</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/",
            "title": "games104系列笔记（六）",
            "date_published": "2023-06-26T04:58:47.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎中的地形和大气渲染技术。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>现实世界中有着丰富的自然场景，如果只使用简单的绘制程序则很难给予玩家真实的游戏体验。因此在本节课中我们会介绍 3A 游戏中使用的自然场景渲染技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jDU9UTs.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kyjqMAi.png\" width=\"80%\">\n</div>\n<h2 id=\"landscape\"><a class=\"anchor\" href=\"#landscape\">#</a> Landscape</h2>\n<p>目前的 3A 游戏中以及可以生成逼真的地形环境渲染效果。以微软的模拟飞行为例，最新一代的模拟飞行已经基本实现了真实地球的地貌绘制，此外基于地形绘制技术我们也可以生成其它星球的地形和地貌。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WvpUiNj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4RBc4Bg.png\" width=\"80%\">\n</div>\n<h3 id=\"terrain-geometry\"><a class=\"anchor\" href=\"#terrain-geometry\">#</a> Terrain Geometry</h3>\n<h4 id=\"heightfield\"><a class=\"anchor\" href=\"#heightfield\">#</a> Heightfield</h4>\n<p>表示地形最简单的方法是使用<strong>高度场 (heightfield)</strong>。我们可以把地形看做是平面上具有不同高度的函数，然后通过在平面进行均匀采样来近似它。这种方法在遥感等领域仍然有着很多的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BUMI1bU.png\" width=\"80%\">\n</div>\n<p>高度场的缺陷在于当我们需要表示大规模的地形或者需要更精细的地形时所需的采样点数会成倍的增长。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8ipmMFn.png\" width=\"80%\">\n</div>\n<p>在游戏引擎中由于玩家观察的 ** 视野 (field of view, FOV)** 是有限的，实际上我们不需要对所有的网格进行加密采样，只需关注视野中的地形即可。在这种思想下人们提出了两条加密采样原则：首先是根据距离和视野来调整网格的疏密，对于不再视野范围内或是距离观察点比较遥远位置的地形无需使用加密的网格；另一条是在对地形进行采样时要考虑对网格进行加密或者化简后地形高度的误差不要超过一定的范围，我们希望近处地形的误差尽可能小而远处的误差可以大一些。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yrCAWyn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cvS6LlC.png\" width=\"80%\">\n</div>\n<p>对三角网格进行加密可以通过三角网剖分算法来实现。对于均匀分布的网格，其中每个三角形都是等腰直角三角形。因此在进行剖分时可以直接选择三角形的斜边中点将它剖分成两个一样的小等腰直角三角形。显然这样的剖分方法等价于为二叉树添加叶节点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g4B0POh.png\" width=\"80%\">\n</div>\n<p>在进行剖分时还需要注意<strong> T-junction</strong> 的问题：当我们对某个三角形进行剖分后必须同时将与它具有相同邻边的三角形同时进行剖分，否则会有顶点落在其它三角形的边上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7OcPIHA.png\" width=\"80%\">\n</div>\n<p>利用现代 GPU 的计算性能和上面介绍的三角剖分算法就可以实现大规模场景地形的实时渲染。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FQjh3Cn.png\" width=\"80%\">\n</div>\n<p>当然在游戏行业中更常用的高度场表达方式是使用四叉树来表达地形。这种方法更符合人的直觉，同时也可以直接使用纹理的存储方式来存储这种四叉树的结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/W7maqBa.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ow3FGeY.png\" width=\"80%\">\n</div>\n<p>quad-tree 同样需要考虑 T-junction 的问题。不过在 quad-tree 中可以通过将三角形顶点之间吸附到其它顶点上的方法来简化处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6C9QOZn.png\" width=\"80%\">\n</div>\n<h4 id=\"triangulated-irregular-network\"><a class=\"anchor\" href=\"#triangulated-irregular-network\">#</a> Triangulated Irregular Network</h4>\n<p>在很多场景中均匀采样的地形会造成一些存储空间的浪费。实际上对于高度变化不大的区域只需要少量的三角形就可以进行表达，而对于高程变化剧烈的区域使用数量更多的三角形来还原地形的细节。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FJZUHMc.png\" width=\"80%\">\n</div>\n<p>不过目前这样的方法在游戏工业界的应用还比较少，主流的地形处理方法仍然是使用均匀采样的网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YMiJrPI.png\" width=\"80%\">\n</div>\n<h4 id=\"hardware-tessellation\"><a class=\"anchor\" href=\"#hardware-tessellation\">#</a> Hardware Tessellation</h4>\n<p>利用现代 GPU 的强大计算能力我们可以把地形的细化完全放到 GPU 上进行实时计算。在 DirectX 11 中提供了 hull shader、tessellator 以及 domain shader 等工具来网格的实时细分。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9VS9DOk.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FXYNtPt.png\" width=\"80%\">\n</div>\n<p>在更新的 DirectX 12 中则将这些概念合并到 mesh shader 中，通过 mesh shader 来实现全部的网格细分功能，从而极大地方便来游戏开发和图形程序。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/E9qJF6L.png\" width=\"80%\">\n</div>\n<p>此外还可以利用 GPU 的计算性能实现动态的地形绘制，从而进一步提升玩家的游戏体验。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6bk1Rza.png\" width=\"80%\">\n</div>\n<h4 id=\"non-heightfield-terrain\"><a class=\"anchor\" href=\"#non-heightfield-terrain\">#</a> Non-Heightfield Terrain</h4>\n<p>有些游戏场景如洞穴可能无法使用高度场来进行表示。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/a2fkexF.png\" width=\"80%\">\n</div>\n<p>对于这种场景可以考虑使用体素来表达场景的几何，然后利用 marching cube 算法来生成表面。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/kLhqRWJ.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4YlsCTZ.png\" width=\"80%\">\n</div>\n<p>当然这种方法目前仍处于试验阶段，几乎没有游戏使用相关的技术来表示地形。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BJ5seF5.png\" width=\"80%\">\n</div>\n<h3 id=\"terrain-texture\"><a class=\"anchor\" href=\"#terrain-texture\">#</a> Terrain Texture</h3>\n<h4 id=\"texture-splatting\"><a class=\"anchor\" href=\"#texture-splatting\">#</a> Texture Splatting</h4>\n<p>有了地形的几何表示后就可以为它添加纹理细节进行渲染。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LfeXZDs.png\" width=\"80%\">\n</div>\n<p>基于纹理合成算法，我们可以控制不同纹理之间的混合比例从而获得接近真实地形的纹理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/g8WSPjC.png\" width=\"80%\">\n</div>\n<p>此外我们还可以利用地形的高程来动态调节混合比例，从而实现高低起伏上不同的纹理效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/x0FA2Nc.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EWBobK4.png\" width=\"80%\">\n</div>\n<p>当需要对多种不同材质进行混合时还可以使用 texture array 来管理不同材质的混合关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/22ESqns.png\" width=\"80%\">\n</div>\n<p>除此之外在地形渲染中还大量使用了视差贴图的技术来产生立体感。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oQ4hgwP.png\" width=\"80%\">\n</div>\n<h4 id=\"virtual-texture\"><a class=\"anchor\" href=\"#virtual-texture\">#</a> Virtual Texture</h4>\n<p>直接对地形纹理进行混合时容易造成计算上的性能问题，这是由于对纹理进行插值的计算是相对复杂的。如果没有设计好渲染管线则会导致渲染效率的下降。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gusNEDr.png\" width=\"80%\">\n</div>\n<p>在现代游戏引擎中大量使用了 ** 虚拟纹理 (virtual texture)** 的技术来提高渲染性能。使用虚拟纹理时首先需要把纹理分解成若干个尺寸相同的 tile，然后把不同 LOD 的纹理则需要事先进行烘焙存储在硬盘上。在实际渲染时根据绘制目标的精度来决定所需的 LOD 以及对应的 tile，然后将需要进行渲染的纹理 tile 加载到内存中作为实际的纹理贴图。这样的方式可以极大地缓解纹理读写的内存需求从而提高渲染效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z91kpNL.png\" width=\"80%\">\n</div>\n<p>显然虚拟纹理的性能瓶颈在于从硬盘加载纹理的 IO 过程。想要进一步提高效率甚至可以直接让 GPU 从硬盘进行加载。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XzcJg6B.png\" width=\"80%\">\n</div>\n<h4 id=\"camera-relative-rendering\"><a class=\"anchor\" href=\"#camera-relative-rendering\">#</a> Camera-Relative Rendering</h4>\n<p>当渲染物体与相机的距离达到一定程度时就需要考虑浮点数的计算精度问题，如果不进行处理会导致严重的抖动和穿模现象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FWsKPlL.png\" width=\"80%\">\n</div>\n<p>想要缓解这种问题可以将相机设置为世界坐标的中心，这样的处理方法称为<strong> camera-relative rendering</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fIS7NIy.png\" width=\"80%\">\n</div>\n<h4 id=\"decorator\"><a class=\"anchor\" href=\"#decorator\">#</a> Decorator</h4>\n<p>除了各种地貌纹理外，游戏设计中还需要在地面上设置各种植被、草丛、道路等各种<strong>装饰件 (decorator)</strong>。这些装饰件看起来很简单，但实际上要想做出比较好的效果仍然需要非常复杂的算法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gngpnIF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/89YtUQm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bkN12xN.png\" width=\"80%\">\n</div>\n<h2 id=\"sky-and-atmosphere\"><a class=\"anchor\" href=\"#sky-and-atmosphere\">#</a> Sky and Atmosphere</h2>\n<h3 id=\"atmosphere\"><a class=\"anchor\" href=\"#atmosphere\">#</a> Atmosphere</h3>\n<h4 id=\"analytic-atmosphere-appearance-modeling\"><a class=\"anchor\" href=\"#analytic-atmosphere-appearance-modeling\">#</a> Analytic Atmosphere Appearance Modeling</h4>\n<p>对于天空和大气的渲染，最简单的方法是使用拟合公式来直接计算着色。当然这种方法的缺陷也很多，比如说它只能表示从地表进行观察的效果，而且可以调整的参数也有很多的限制。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/r8dHMFA.png\" width=\"80%\">\n</div>\n<h4 id=\"volume-rendering-equation\"><a class=\"anchor\" href=\"#volume-rendering-equation\">#</a> Volume Rendering Equation</h4>\n<p>如果想要渲染出真实的大气效果则需要考虑光照与大气相互作用的物理过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/K2BTctv.png\" width=\"80%\">\n</div>\n<p>当光线与大气中的各种气体分子以及灰尘等气溶胶发生相互作用时有三种可能的现象：<strong>吸收 (absorption)</strong>、<strong>发射 (emission)<strong> 以及</strong>散射 (scattering)</strong>，其中散射又可以分为<strong>内散射 (in-scattering)<strong> 和</strong>外散射 (out-scattering)</strong>。基于 ** 辐射传输方程 (radiative transfer equation, RTE)** 我们可以得到出射光线的 radiance 在指定方向上的微分。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CjArM5L.png\" width=\"80%\">\n</div>\n<p>通过对 RTE 沿光路进行积分，我们可以得到光线穿越介质后的 radiance。这个方程也称为<strong>体渲染方程 (volume rendering equation, VRE)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QI285co.png\" width=\"80%\">\n</div>\n<h4 id=\"scattering\"><a class=\"anchor\" href=\"#scattering\">#</a> Scattering</h4>\n<p>求解 VRE 最复杂的地方在于如何计算散射项。在大气渲染时我们一般只考虑 **Rayleigh 散射 (Rayleigh scattering)<strong> 和</strong> Mie 散射 (Miew scattering)** 两种形式的散射。当大气中介质的尺寸远小于光线的波长时会发生 Rayleigh 散射，此时散射自身是无方向的而且散射的行为只与光线的波长有关。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oIMkuv5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sueQgAm.png\" width=\"80%\">\n</div>\n<p>当光线发生 Rayleigh 散射时太阳光中不同波长的色光会发生不同程度的散射。具体而言短波长的蓝光会出现大量的散射行为，而长波长的红光则只会发生少量的散射。这样的现象就导致了白天我们观察天空时眼睛会接收到来自四面八方散射的蓝光，因此天空呈蓝色；而在日出或是傍晚时太阳方向上只剩下未散射的红光，此时太阳呈红色。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9xA7Kiv.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oN9r1W1.png\" width=\"80%\">\n</div>\n<p>当大气中介质的尺寸接近或大于光线的波长时会发生 Mie 散射，它的特点是散射程度与波长无关只与观测方向有关。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fUNMroI.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EeTuGuc.png\" width=\"80%\">\n</div>\n<p>我们日常生活中常见的雾气和光晕都是 Mie 散射的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JG2XHhq.png\" width=\"80%\">\n</div>\n<h4 id=\"absorption\"><a class=\"anchor\" href=\"#absorption\">#</a> Absorption</h4>\n<p>除了散射外，在大气渲染时还需要注意不同的气体分子对于不同波长的光线有着不同的吸收行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JIqezj1.png\" width=\"80%\">\n</div>\n<h4 id=\"multi-scattering\"><a class=\"anchor\" href=\"#multi-scattering\">#</a> Multi Scattering</h4>\n<p>在计算散射时还要注意大气的多重散射行为：在积分时不仅要考虑光路上介质的散射行为，整个空间中介质粒子都会对接收到的光线产生贡献。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8hZsGsR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z7s7eAX.png\" width=\"80%\">\n</div>\n<h4 id=\"ray-marching\"><a class=\"anchor\" href=\"#ray-marching\">#</a> Ray Marching</h4>\n<p>对大气进行渲染时可以利用<strong> ray marching 算法</strong>进行计算，它的思想非常简单：我们只需要把整条光线分解成 N 段然后在每一小段上单独进行积分，最后把 N 段的积分相加即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lektrcB.png\" width=\"80%\">\n</div>\n<p>而在游戏引擎中更是可以通过预计算的方式提前存储在硬盘中，这样实际渲染时只需要进行查表即可。以透射率为例，我们可以把大气的透射率分布参数化为海拔高度与天顶角的函数，然后通过预计算存储在一张纹理图像上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BuMdddS.png\" width=\"80%\">\n</div>\n<p>对于单次散射的情况，我们同样通过预计算的方法将散射参数化为海拔高度、观测角度以及太阳角度的函数。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2qMlHs7.png\" width=\"80%\">\n</div>\n<p>最后我们把透射率的纹理图像以及单次散射的纹理不断进行积分就得到了多次散射情况下大气渲染的预计算纹理。目前很多 3A 游戏的天空渲染都是基于这样的方式进行处理的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Fid3vR4.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Njnirz3.png\" width=\"80%\">\n</div>\n<p>上面介绍的方法虽然可以获得非常好的效果，但它仍然具有一些缺陷：比如说离线的预计算仍然是非常费时的，而且在实时渲染时高维纹理的插值对于一些移动设备不够友好，更重要的是它很难处理大气成分发生变化时的渲染问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ovSGYgl.png\" width=\"80%\">\n</div>\n<p>为了缓解这些问题，人们还开发出了各种近似方法。比如说我们可以假设大气是各向同性的均匀介质，然后使用一个衰减系数来模拟单次散射后接收到的光线。这样可以使用几何级数来表示光线经过无限次散射后到达相机的能量比例。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/wXTDp9Z.png\" width=\"80%\">\n</div>\n<p>对于高维纹理的问题可以假设观察位置和太阳位置是不变的，这样光照就只是观测方向的纹理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ysymbkl.png\" width=\"80%\">\n</div>\n<p>最后通过 ray marching 沿路径进行积分就可以得到大气散射的近似效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/i9XsRcS.png\" width=\"80%\">\n</div>\n<p>实践证明这样的近似方法在一些移动设备上也可以实现不错的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NLjM6R1.png\" width=\"80%\">\n</div>\n<h3 id=\"cloud\"><a class=\"anchor\" href=\"#cloud\">#</a> Cloud</h3>\n<p>在大气的基础上添加云可以实现更加真实的环境渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bp1aVjo.png\" width=\"80%\">\n</div>\n<p>早期对云进行渲染的方法是使用网格来建立云的模型。这种方法可以渲染出高质量的云，但由于它非常不灵活现在基本已经弃用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Jm07fD7.png\" width=\"80%\">\n</div>\n<p>过去也出现过使用透明通道来近似云效果的方法，不过这种方法很难生成逼真的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ncDQFPG.png\" width=\"80%\">\n</div>\n<p>目前 3A 游戏一般会使用体积云的方式来对云进行渲染，尽管它有着比较高的计算复杂度但却可以实现逼真的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EOjDENn.png\" width=\"80%\">\n</div>\n<p>使用体积云进行渲染时我们需要一张 weather texture 来表示云在平面以及厚度的分布。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/S9jZpo2.png\" width=\"80%\">\n</div>\n<p>生成体积云模型时首先使用 weather texture 产生柱状的云层，然后利用 Perlin 噪声和 Worley 噪声进行腐蚀就可以产生逼真的云模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tE6fT3w.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qbSJCGh.png\" width=\"80%\">\n</div>\n<p>进行渲染时使用 ray marching 的方式来计算散射就可以实现逼真的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qeWaD1T.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWF1NDExeTdGcS8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 06：The Challenges and Fun of Rendering the Beautiful Mother Nature I</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWkzNDExVDdRTC8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 06：The Challenges and Fun of Rendering the Beautiful Mother Nature II</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/",
            "title": "games104系列笔记（五）",
            "date_published": "2023-06-25T15:55:34.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎的实时渲染算法。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>在上一节课中我们介绍了渲染的概念，而本节课我们则会开始介绍游戏引擎中具体的渲染算法。渲染是研究光与材质相互作用的学科，因此本节课从光线、材质以及 shader 三个方面介绍现代游戏引擎中各种经典实时算法的原理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ev8jRMf.png\" width=\"80%\">\n</div>\n<h2 id=\"the-rendering-equation\"><a class=\"anchor\" href=\"#the-rendering-equation\">#</a> The Rendering Equation</h2>\n<p>渲染的本质是求解<strong>渲染方程 (the rendering equation)</strong>，它由 James Kajiya 于 1986 年提出。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/komPRjJ.png\" width=\"80%\">\n</div>\n<p>不严格地讲，渲染方程指出空间点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 在方向<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\omega_o</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">o</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 上出射的能量等于它自身在该方向发射的能量加上来自半球面上所有方向入射并经过反射后反射到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\omega_o</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">o</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 上的能量之和。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OybsJIM.png\" width=\"80%\">\n</div>\n<h3 id=\"complexity-of-real-rendering\"><a class=\"anchor\" href=\"#complexity-of-real-rendering\">#</a> Complexity of Real Rendering</h3>\n<p>显然想要直接求解渲染方程是相当困难的。在现实的场景中光线会在物体表面经过多次反射，同时不同的材质也有着天差地别的反射行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4DmIPlp.png\" width=\"80%\">\n</div>\n<p>渲染的难点之一在于阴影，或者说是光的可见性。如何做出合适的阴影效果远比想象中要难得多，在实践中往往需要通过大量的技巧才能实现符合人认知的阴影效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/73c8jwW.png\" width=\"80%\">\n</div>\n<p>其次，场景中往往有着各种类型的光源需要考虑。常见的光源形式包括平行光、点光源、聚光灯、面光源等等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YVnO16j.png\" width=\"80%\">\n</div>\n<p>材质是渲染中最为复杂的因素之一。如何设计符合现实世界的材质模型并且满足实时计算的要求是实时渲染的一大难点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/79RC5lh.png\" width=\"80%\">\n</div>\n<p>最后，在渲染时需要考虑光线在场景中不断反射的行为。全局光照一直是渲染的终极目标。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ll9aKjG.png\" width=\"80%\">\n</div>\n<p>总结一下，渲染的难点可以分为一下三部分：如何计算入射光线、如何考虑材质以及如何实现全局光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JwPhYP0.png\" width=\"80%\">\n</div>\n<h2 id=\"starting-from-simple\"><a class=\"anchor\" href=\"#starting-from-simple\">#</a> Starting from Simple</h2>\n<h3 id=\"simple-light-solution\"><a class=\"anchor\" href=\"#simple-light-solution\">#</a> Simple Light Solution</h3>\n<p>我们从最简单的情况开始考虑。首先考虑对光照进行分解，将反射光分解为漫反射和环境光两部分。这样已经可以实现一些简单的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AqcuxeH.png\" width=\"80%\">\n</div>\n<p>为了更好地模拟环境光照，我们可以使用环境贴图技术把环境光存储在一个立方体表面上。这样当需要计算入射光线时只要根据方向去进行查询即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Fk3VWxZ.png\" width=\"80%\">\n</div>\n<p>实际上这样的处理方法在数学上也是解释得通的，它相当于把入射光线分解为低频的漫反射和高频的环境光。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IMmHWhk.png\" width=\"80%\">\n</div>\n<h3 id=\"blinn-phong-materials\"><a class=\"anchor\" href=\"#blinn-phong-materials\">#</a> Blinn-Phong Materials</h3>\n<p>有了光照后我们开始考虑材质。最经典的材质模型是<strong> Blinn-Phong 材质 (Blinn-Phong materials)</strong>，它把材质的反射行为分解为与方向无关的环境光、与入射和观察角度有关的漫反射以及高光。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/EUtEQp3.png\" width=\"80%\">\n</div>\n<p>当然 Blinn-Phong 模型也有很多问题，比如说它不遵循能量守恒，同时它也不能描述现实世界中丰富的材质外观。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OyYusoL.png\" width=\"80%\">\n</div>\n<h3 id=\"shadow\"><a class=\"anchor\" href=\"#shadow\">#</a> Shadow</h3>\n<p>对于阴影问题，早期的处理方法主要是 shadow volume，而现代游戏引擎的主流方法则是 shadow map。shadow map 的处理流程是在光源位置设置一个新的相机并渲染出一张深度图，然后在实际相机进行渲染时对每个点检测它到光源处的深度。如果该深度大于深度图对应位置处的深度则说明该点对于光源是不可见的，即位于阴影中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fQBx9aM.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/p6LbVZQ.png\" width=\"80%\">\n</div>\n<p>shadow map 的主要缺陷在于它只能产生 &quot;硬阴影&quot; 而无法产生现实中渐变的 &quot;软阴影&quot;。而且从光源和相机进行采样时往往会使用不同的采样率，这容易导致各种走样和自遮挡的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/T1MPNGr.png\" width=\"80%\">\n</div>\n<p>把上面介绍过的这些技巧组合到一起并且配合美术的精巧设计就可以实现一些不错的渲染效果了。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sMeZU09.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ai6AoHh.png\" width=\"80%\">\n</div>\n<h2 id=\"pre-computed-global-illumination\"><a class=\"anchor\" href=\"#pre-computed-global-illumination\">#</a> Pre-computed Global Illumination</h2>\n<p>全局光照可以显著地提升画面的渲染效果，而它的难点在于如何表示来自其它物体反射的间接光照以及如何计算光照与材质 BRDF 的积分 (卷积)。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Tm59XDY.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rfFDCXU.png\" width=\"80%\">\n</div>\n<h3 id=\"spherical-harmonics\"><a class=\"anchor\" href=\"#spherical-harmonics\">#</a> Spherical Harmonics</h3>\n<p>** 球面谐波函数 (spherical harmonics, SH)** 是实时渲染中表示环境光照的经典方法，不过在介绍 SH 前我们先来回顾一下 Fourier 变换的相关理论。Fourier 变换指出无限循环的时域信号可以分解为不同频率函数的叠加，同时时域信号的卷积等价于经过 Fourier 变换后频域信号的乘积。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vqS5trx.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XtSK2eu.png\" width=\"80%\">\n</div>\n<p>而 SH 可以看成是对球面上信号进行分解，可以证明任意的球面信号可以分解为无限多基函数信号的加权和，而且这些基函数是相互正交的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/V1ZtwXT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3bRdAKT.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2I9Q9Uh.png\" width=\"80%\">\n</div>\n<p>基于 SH 我们可以对场景中任意点接收到的环境光照进行分解，一般来说只需要使用 1-2 阶的低频信号就可以实现合理的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/s2msrQ1.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iVWsK4s.png\" width=\"80%\">\n</div>\n<p>假设我们使用 2 阶的 SH 对环境光照进行分解，在 RGB3 个通道上只需要 12 个参数即可表示任意点接收到的环境光。进行存储时可以对不同的系数使用不同的精度进行存储，这样任意点的环境光照可以使用 RGBA 的 32bits 来表示，换句话说每一点的光场相当于 RGBA 纹理图像上的一个像素。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FlLoGsC.png\" width=\"80%\">\n</div>\n<h3 id=\"lightmap\"><a class=\"anchor\" href=\"#lightmap\">#</a> Lightmap</h3>\n<p>lightmap 正是基于这种思想而提出来的光照技术。我们可以将场景中每个点的光照离线烘焙到一张纹理图上，然后在渲染时读取纹理值来获得 SH 表达的环境光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6Pr5cmE.png\" width=\"80%\">\n</div>\n<p>当然在进行烘焙时不需要使用包含各种细节的网格，我们只需要使用一个精度相对较低的网格并进行参数化即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dwWz1NV.png\" width=\"80%\">\n</div>\n<p>当美术完成场景建模后就可以开始烘焙了。显然计算 lightmap 是非常耗时的，但通过 lightmap 可以实现非常逼真的场景效果，而且在实际渲染时 lightmap 可以实现场景的实时渲染。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DQuIHcF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/O88XabM.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VJyuQ8Z.png\" width=\"80%\">\n</div>\n<p>当然 lightmap 也有一些缺陷，比如说离线烘焙时需要很长的时间、lightmap 无法考虑动态的光源、同时存储 lightmap 也需要非常大的存储空间。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Tt20wAL.png\" width=\"80%\">\n</div>\n<h3 id=\"light-probe\"><a class=\"anchor\" href=\"#light-probe\">#</a> Light Probe</h3>\n<p>除了 lightmap 外还可以在空间上设置一些 ** 探针 (probe)** 来记录环境光照，而在计算物体的着色时只需要对附近 probe 进行插值即可估计该点的光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/cGTvAow.png\" width=\"80%\">\n</div>\n<p>当然如何设置这些 probe 是比较麻烦的。早期的实践中一般是由美术人工进行设置，而目前则可以使用一些自动化的工具来自动生成 probe。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/07xRmcd.png\" width=\"80%\">\n</div>\n<p>如果要考虑材质的反射行为则需要设置专门的反射 probe。一般来说这样的反射 probe 不需要设置很多，但每个 probe 则需要有更高的精度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zRC4WWw.png\" width=\"80%\">\n</div>\n<p>light probe 同样可以进行实时渲染。不同于 lightmap，基于 light probe 可以实现动态的场景和物体渲染，而且现代计算机的计算性能也允许对 probe 进行动态更新。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/RRHp0G8.png\" width=\"80%\">\n</div>\n<h2 id=\"physical-based-material\"><a class=\"anchor\" href=\"#physical-based-material\">#</a> Physical-Based Material</h2>\n<h3 id=\"microfacet-theory\"><a class=\"anchor\" href=\"#microfacet-theory\">#</a> Microfacet Theory</h3>\n<p>有了光照后我们来考虑材质。基于物理的材质模型大量使用了 ** 微表面理论 (microfacet theory)** 来模拟现实世界中材质，简单来说微表面理论认为材质的表面是由大量方向各异的光滑镜面组成，这些镜面的分布控制了不同材质的反射行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5ArPG2D.png\" width=\"80%\">\n</div>\n<p>光线在物体表面上的反射可以分解为 ** 体反射 (body reflection)<strong> 和</strong>表面反射 (surface reflection)** 两种。在体反射中光子会进入到物体的内部进行反射然后从物体表面的另一个点射出；而在表面反射中光子则会直接被反射出去。实际上物体表面的漫反射行为对应着体反射，我们可以使用 Lambert 模型进行表示；而表面反射的行为则可以基于微表面理论使用 Cook-Torrance 模型来进行表达。将二者组合到一起就构成来材质的 BRDF。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3jvW5Qo.png\" width=\"80%\">\n</div>\n<p>Cook-Torrance 模型可以拆分为三项。首先是<strong>法向分布函数 (normal distribution function)</strong>，它表示材质不同方向上镜面法向的分布情况。法向分布函数包含一个参数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> 来表示表面的粗糙度，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> 越大表示表面越粗糙反射行为越接近漫反射，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> 越小表示表面越光滑反射行为越接近理想镜面反射。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/K0Xa1FW.png\" width=\"80%\">\n</div>\n<p>Cook-Torrance 模型中的另一项是<strong>几何项 (geometry attenuation term)</strong>，它表示不同方向镜面的自遮挡行为。在 Cook-Torrance 模型中使用 Smith 模型将几何项分解为出射方向和入射方向两个方向上的可见性乘积，每个方向上的可见性使用 GGX 模型进行计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ibTw6du.png\" width=\"80%\">\n</div>\n<p>Cook-Torrance 模型中的最后一项是<strong> Fresnel 项 (Fresnel equation)</strong>，它表示不同材质光滑表面的理想反射行为。在实时渲染中一般使用 Schilick 近似来计算这一项。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vRtZGt2.png\" width=\"80%\">\n</div>\n<p>为了获得真实材质的光学参数我们还需要进行实际的测量。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jZGZnLmNzYWlsLm1pdC5lZHUvd29qY2llY2gvYnJkZmRhdGFiYXNl\">MERL BRDF 数据库</span>给出了常见材质的 BRDF 测量结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Zaadlyj.png\" width=\"80%\">\n</div>\n<h3 id=\"disney-principled-brdf\"><a class=\"anchor\" href=\"#disney-principled-brdf\">#</a> Disney Principled BRDF</h3>\n<p>为了方便不同背景的从业者进行使用，Disney 提出了著名的<strong> Disney Principled BRDF</strong> 来设计不同的材质模型。它的思想是设计材质模型时要尽可能方便艺术家进行理解，而不要过多地使用物理上面的概念。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4gszGdV.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JaFgFqi.png\" width=\"80%\">\n</div>\n<h3 id=\"pbr-specular-glossiness\"><a class=\"anchor\" href=\"#pbr-specular-glossiness\">#</a> PBR Specular Glossiness</h3>\n<p>目前在游戏引擎中最常用的材质模型是<strong> specular glossiness 模型 (SG)</strong>。在 SG 模型中物体的反射行为分解为三张图的叠加：diffuse 用来控制漫反射、specular 图用来控制 Fresnel 项、而 glossiness 图则控制金属材质的粗糙度。把三张图带入 BRDF 计算公式就可以渲染出非常漂亮的模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Q4TP8Fj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lKbddBs.png\" width=\"80%\">\n</div>\n<p>在长期的实践中为了防止美术在设计时出错，人们还对 SG 模型进行了封装并得到了<strong> metallic roughness 模型 (MR)</strong>。MR 模型同样包含三张图：一张 base color 图表示漫反射、一张 roughness 图表示粗糙度、还有一张 metallic 图表示材质的金属度。当 metallic 值很高时材质会更接近于金属材质产生大量的光泽反射，否则会接近于非金属材质以漫反射为主。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gQvZ6dR.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zV0sv4Y.png\" width=\"80%\">\n</div>\n<p>MR 模型不太适合表示介于金属和非金属之间的材质，但大多数情况下仍然是工程中的首选。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/nauNkGM.png\" width=\"80%\">\n</div>\n<h2 id=\"image-based-lighting\"><a class=\"anchor\" href=\"#image-based-lighting\">#</a> Image-Based Lighting</h2>\n<p>IBR 本身是使用真实图像作为光照的方法，但结合 PBR 材质可以实现非常逼真的实时渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aA22DVJ.png\" width=\"80%\">\n</div>\n<p>根据前面介绍过的 PBR 材质，物体表面的 BRDF 可以分解为漫反射以及镜面反射两项。我们对这两项分别进行处理在累加起来就可以实现 IBR。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/h7qqdz6.png\" width=\"80%\">\n</div>\n<h3 id=\"diffuse-irradiance-map\"><a class=\"anchor\" href=\"#diffuse-irradiance-map\">#</a> Diffuse Irradiance Map</h3>\n<p>对于漫反射项比较简单，我们首先通过预计算的方法对环境光照按照余弦进行积分，接着把积分后的值存储在一个表格中。实际渲染时进行查表并和漫反射系数进行相乘即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/62U96gx.png\" width=\"80%\">\n</div>\n<h3 id=\"specular-approximation\"><a class=\"anchor\" href=\"#specular-approximation\">#</a> Specular Approximation</h3>\n<p>对镜面反射的处理要相对复杂一些。我们首先需要将镜面反射的积分利用 split-sum 拆分成 ** 光照项 (lighting term)<strong> 和</strong> BRDF 项 (BRDF term)** 两部分，而这两项都可以通过预计算的方法事先存储在一个表格中。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pThd9lN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9i9aygl.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/C0XrlMq.png\" width=\"80%\">\n</div>\n<p>最后把漫反射项和镜面反射项加起来就得到了完整的环境光照。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/B48BFcH.png\" width=\"80%\">\n</div>\n<p>在现代 3A 游戏中基于 IBR 可以实现非常逼真的图像效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/39Jfc1I.png\" width=\"80%\">\n</div>\n<h2 id=\"classic-shadow-solution\"><a class=\"anchor\" href=\"#classic-shadow-solution\">#</a> Classic Shadow Solution</h2>\n<p>cascade shadow 是实时渲染中阴影的经典处理方法。它的思想是根据距离来调整 shadow map 的精度，近处的精度高远处的精度低。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YZ6TwKe.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Z3MEZ9a.png\" width=\"80%\">\n</div>\n<p>当然想要得到合理的阴影效果需要大量的技巧，而且 cascade shadow 需要大量的存储空间在计算上也需要大量的时间。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4XX3M90.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/s8hWNS6.png\" width=\"80%\">\n</div>\n<p>现代实时渲染中会更多地使用 PCF 和 PCSS 等算法，它们的特点是可以实现更加自然的软阴影效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sXCms0w.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ixorp5C.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/f8ppi0z.png\" width=\"80%\">\n</div>\n<p>另一种生成软阴影的方法是 VSSM，它基于 Chebyshev 不等式来估计像素上的阴影比例。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OUaHMVN.png\" width=\"80%\">\n</div>\n<p>把上面介绍过的技术全部结合到一起就可以实现上个世代 3A 游戏的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ctmPiUW.png\" width=\"80%\">\n</div>\n<h2 id=\"moving-wave-of-high-quality\"><a class=\"anchor\" href=\"#moving-wave-of-high-quality\">#</a> Moving Wave of High Quality</h2>\n<p>随着各种 shader 模型的提出以及硬件计算性能的进步，上面介绍的实时渲染算法已经不能完全满足人们对画质的需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BqrhuBS.png\" width=\"80%\">\n</div>\n<p>** 实时光线追踪 (real-time ray tracing)** 就是一个很好的案例。随着显卡性能的提升我们可以把光线追踪算法应用在实时渲染中从而获得更加真实的光照和反射效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/LqjwqR3.png\" width=\"80%\">\n</div>\n<p>另一方面 ** 实时全局光照 (real-time global illumination)** 也取得了很大的进步。这几年各种实时全局光照算法层出不穷，基于全局光照可以给游戏画面带来质的飞跃。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JuQgzDk.png\" width=\"80%\">\n</div>\n<p>在材质渲染方面，随着 geometry shader 的出现人们可以获得几乎无限的几何细节。同时大量基于 BSSDF 的 shader 使得人们更准确地描述物理材质与光线的相互作用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tRTylPr.png\" width=\"80%\">\n</div>\n<p>在虚幻 5 引擎中还使用了 virtual shadow map 来生成更加逼真的阴影。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/y7pQ1tc.png\" width=\"80%\">\n</div>\n<h2 id=\"shader-management\"><a class=\"anchor\" href=\"#shader-management\">#</a> Shader Management</h2>\n<p>本节课最后讨论了游戏引擎中的 shader 管理问题。在现代 3A 游戏中每一帧的画面上可能都有上千个 shader 在运行。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QjHNHJF.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Y1VALrs.png\" width=\"80%\">\n</div>\n<p>这些大量的 shader 一方面来自于美术对场景和角色的设计，另一方面不同材质在不同光照条件下的反应也使得程序员需要将不同情况下的 shader 组合到一起，并通过宏的方式让程序自行选择需要执行的代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/JQxT2s3.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/45qisHA.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NOQWplG.png\" width=\"80%\">\n</div>\n<p>除此之外不同的平台上往往使用了不同的图形库，在编写 shader 的时候需要考虑跨平台的问题。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/G0QnlMf.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUozNDExbjdXVA==\">Lecture 05：Rendering on Game Engine</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlLNHkxVDd5WT9wPTM=\">GAMES202 Lecture 03：Real-time Shadows 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlLNHkxVDd5WT9wPTQ=\">GAMES202 Lecture 04：Real-time Shadows 2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlLNHkxVDd5WT9wPTU=\">GAMES202 Lecture 05：Real-Time Environment Mapping 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlLNHkxVDd5WT9wPTY=\">GAMES202 Lecture 06：Real-Time Environment Mapping 2</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlLNHkxVDd5WT9wPTEw\">GAMES202 Lecture 10：Real-Time Physically-Based Materials 1</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlLNHkxVDd5WT9wPTEx\">GAMES202 Lecture 11：Real-Time Physically-Based Materials 2</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/",
            "title": "games104系列笔记（四）",
            "date_published": "2023-06-25T15:54:27.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎的渲染系统。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>在接下来的几节课中我们会开始介绍游戏引擎中的渲染系统。从早期的像素风格渲染到如今 3A 大作逼真的渲染效果，可以说渲染技术伴随了整个游戏行业的发展。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/faYkxUg.png\" width=\"80%\">\n</div>\n<p>游戏渲染的理论基础和图形学中的渲染是一样的。不过渲染研究更关注于算法理论的正确性而对于实时性没有太多的要求，而在游戏渲染中实时性则至关重要。对实时渲染的关注构成了游戏渲染和渲染理论之间的主要差别。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yQqhMiE.png\" width=\"80%\">\n</div>\n<h3 id=\"challenges-on-game-rendering\"><a class=\"anchor\" href=\"#challenges-on-game-rendering\">#</a> Challenges on Game Rendering</h3>\n<p>游戏中渲染的难点有以下几个方面：首先游戏场景往往包含各种不同类型的渲染对象，同时需要在场景中实现光照、大气、天空、水面等不同的渲染效果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/N7dkyTe.png\" width=\"80%\">\n</div>\n<p>其次，在图形学中我们不太关注渲染在硬件中的实现过程。而在游戏引擎中，为了充分利用计算资源则需要考虑渲染过程的硬件实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iWW9Gii.png\" width=\"80%\">\n</div>\n<p>再者，人们对于游戏画质和帧率的要求逐渐提高。现代 3A 大作往往需要适配 4K 的画幅并且保证不同场景下有着足够高的帧率 (60-120FPS)。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6X7QBVS.png\" width=\"80%\">\n</div>\n<p>最后，游戏引擎除了渲染系统外还要为其它物理、逻辑系统提供支持，因此我们不能让渲染系统占掉全部的 CPU 计算资源。一般来说渲染系统只能占掉 10-20% 的计算资源，把省下来的资源让给其它玩法系统。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fgdKxzM.png\" width=\"80%\">\n</div>\n<h3 id=\"rendering-on-game-engine\"><a class=\"anchor\" href=\"#rendering-on-game-engine\">#</a> Rendering on Game Engine</h3>\n<p>总体来看，游戏引擎中的渲染系统是一个庞大的软件工程系统。在整个游戏行业几十年的不断实践中总结出了大量有效的渲染技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QkwFtgX.png\" width=\"80%\">\n</div>\n<p>本课程中我们会逐步介绍游戏引擎的渲染系统。当然游戏引擎涉及到的渲染技术非常丰富，这里只能介绍一些基础的概念。本节课会介绍渲染的基础概念，在后面的课程中会分别介绍游戏行业中标准的材质光照系统、场景渲染和后处理方法以及游戏引擎中的渲染管线设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hfbyh65.png\" width=\"80%\">\n</div>\n<p>本课程不会涉及卡通渲染、2D 渲染引擎、次表面以及毛发渲染等内容。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z2D7r6V.png\" width=\"80%\">\n</div>\n<h2 id=\"building-blocks-of-rendering\"><a class=\"anchor\" href=\"#building-blocks-of-rendering\">#</a> Building Blocks of Rendering</h2>\n<h3 id=\"rendering-pipeline-and-data\"><a class=\"anchor\" href=\"#rendering-pipeline-and-data\">#</a> Rendering Pipeline and Data</h3>\n<p>目前游戏引擎渲染的主流方法仍是基于 ** 光栅化 (rasterization)** 的渲染管线。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ROIImSk.png\" width=\"80%\">\n</div>\n<p>首先我们需要把场景中的物体投影到 NDC 上，然后分别计算平面上每一个像素对应的渲染对象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5l8t58c.png\" width=\"80%\">\n</div>\n<p>接下来对于每一个像素需要调用相应的 shader 计算像素的颜色。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/A9ImQ1w.png\" width=\"80%\">\n</div>\n<p>在调用 shader 时往往还需要通过纹理采样的方法进行反走样等处理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SDld6HF.png\" width=\"80%\">\n</div>\n<h3 id=\"understand-the-hardware\"><a class=\"anchor\" href=\"#understand-the-hardware\">#</a> Understand the Hardware</h3>\n<p>渲染计算的特点是有大量的像素需要进行计算，而像素之间的计算则往往是相互独立的。因此人们设计出了 GPU 来执行图形渲染计算，这样还解放了 CPU 的计算资源。可以说现代 GPU 的发展也推动了整个游戏行业渲染技术的进步。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/T5jJnhi.png\" width=\"80%\">\n</div>\n<p>要了解现代 GPU 的架构我们首先来复习一下 SIMD 和 SIMT 的概念。SIMD 是指在运行程序时可以把一条指令同时执行在不同的数据上，目前现代 CPU 对于 SIMD 有着很好的支持，这种技术在高性能计算等领域中有着广泛的应用；而 SIMT 则是把同一条指令分配到大量的计算核心上同时执行，现代 GPU 的计算过程更类似于 SIMT。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7BmoOw8.png\" width=\"80%\">\n</div>\n<p>在现代 GPU 架构中有着大量重复的内核，每一组内核称为一个 GPC。在每个 GPC 内部存放着大量的 SM，而每个 SM 中还有着大量的 CUDA 核心用来执行数学运算，当 SM 接收到指令进行计算时会把运算分配给 CUDA 核心进行并行计算。同时 GPU 上还有 share memory 用来实现 GPU 上不同核心以及 GPU 和 CPU 之间的通信。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/C0mucM7.png\" width=\"80%\">\n</div>\n<p>GPU 和 CPU 之间通信的代价是非常大的，因此在渲染系统中会尽量把数据通信设计为单向的。这样 GPU 只需要读取 CPU 发送的数据而无需反向传输渲染的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/U9ydhNa.png\" width=\"80%\">\n</div>\n<p>为了进一步提高数据读取的效率还需要合理地运用 GPU 缓存。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YrqUYND.png\" width=\"80%\">\n</div>\n<p>在长期的工程实践中人们总结了 GPU 渲染的性能瓶颈如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hpnAddr.png\" width=\"80%\">\n</div>\n<p>当然 GPU 的架构也是一个不断发展的领域，目前现代 GPU 架构已经可以支持更加灵活的渲染管线。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BDXm3Zc.png\" width=\"80%\">\n</div>\n<p>同时在不同的主机和设备上也往往有着不同于常见 GPU 的架构设计。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/8xuaGYp.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Qzhu6Ge.png\" width=\"80%\">\n</div>\n<h2 id=\"renderable\"><a class=\"anchor\" href=\"#renderable\">#</a> Renderable</h2>\n<p>在进行渲染时我们只需要考虑那些需要进行渲染的 GO，它们称为<strong>可渲染对象 (renderable)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2t0kopS.png\" width=\"80%\">\n</div>\n<p>一般来说我们可以把整个可渲染对象拆分成若干个 block，每个 block 有着自身的网格、材质等渲染信息。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/bK4E93P.png\" width=\"80%\">\n</div>\n<p>对于网格数据，我们需要存储网格上所有的顶点坐标以及每个面包含节点的编号。同时我们往往还需要为每个顶点单独存储一个法向来处理曲面发生突变的情况。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XmtfOfK.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/V8Cf41O.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Lq93Ytl.png\" width=\"80%\">\n</div>\n<p>对于材质数据，我们需要定义常见材质的渲染模型。在现代游戏引擎中往往还会集成大量的 PBR 材质以渲染出更加逼真的图像。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7wW7Vxj.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qAunkso.png\" width=\"80%\">\n</div>\n<p>除此之外，我们还需要考虑材质的纹理。纹理对于材质的定义以及最终渲染呈现的效果起着至关重要的作用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AHtDmHW.png\" width=\"80%\">\n</div>\n<p>当然我们还需要考虑 shader，在进行渲染时需要把编译好的 shader 连同数据一起提交的 GPU 上进行计算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hz6zQ2L.png\" width=\"80%\">\n</div>\n<h2 id=\"render-objects-in-engine\"><a class=\"anchor\" href=\"#render-objects-in-engine\">#</a> Render Objects in Engine</h2>\n<p>接下来我们就可以对 GO 进行渲染了。根据光栅化的渲染管线，我们首先利用 MVP 变换把模型转换到屏幕空间上，然后把渲染数据提交给 GPU 就可以实现渲染的过程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QNBfdUO.png\" width=\"80%\">\n</div>\n<p>然而这样的渲染过程往往不会得到令人满意的渲染结果。实际工程中我们往往需要把一个完整的网格拆分成不同的 submesh，每个 submesh 有着自己的材质和纹理而整个网格共享一套顶点和面片信息。这样利用 submesh 的概念就可以绘制出更加逼真的图像。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/j1d6TgU.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aS1idG4.png\" width=\"80%\">\n</div>\n<p>当我们需要绘制大量 GO 时，如果每个 GO 都使用单独的网格信息则会造成存储和计算资源上的浪费，实际上很多 GO 和 submesh 都共享了相同的材质、纹理甚至是 shader。因此为了更高效地利用计算资源人们还提出了 ** 资源池 (resource pool)** 的概念。在资源池中我们把所有的网格、材质、shader 等资源分别集中到一起，在进行实际渲染时对每个对象分别去寻找对应的数据和资源即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Xg9OJ5q.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jy53UeY.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WwGTwzi.png\" width=\"80%\">\n</div>\n<p>为了更高效地利用 GPU，我们还可以把场景中的 submesh 按照材质进行排序。这样可以保证渲染时具有相同材质的 submesh 会放在一起进行绘制，从而降低 GPU 切换资源的开销。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/s1gCCjg.png\" width=\"80%\">\n</div>\n<p>在很多游戏场景中还存在着大量相似甚至是完全相同的 GO。对于这种情况可以通过<strong> GPU batch rendering</strong> 的方法把这些 GO 组织在一起，然后把同一 batch 中的对象一次性绘制出来，进一步提升场景渲染的效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ywj3QS0.png\" width=\"80%\">\n</div>\n<h2 id=\"visibility-culling\"><a class=\"anchor\" href=\"#visibility-culling\">#</a> Visibility Culling</h2>\n<p>在游戏场景中一种常见的情况是整个场景内有大量的可渲染对象，但在玩家视野内则只有有限数量的单位。在这种情况下如果直接把场景中所有的可渲染对象送入渲染管线无疑会造成计算资源的浪费。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/CrO3DzY.png\" width=\"80%\">\n</div>\n<p>因此 ** 可见性剔除 (visibility culling)** 是渲染系统中非常实用的技术，它的思想是在送入渲染管线前首先判断场景中的每个可渲染对象是否在相机视野中，然后只对视野范围内的对象进行渲染。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dnixfQb.png\" width=\"80%\">\n</div>\n<p>visibility culling 的核心是把可渲染对象使用 bounding box 进行表示，然后通过 bounding box 来迅速判断物体是否在视锥范围内。我们通过 bounding box 将场景中的物体组织起来，这样在渲染时只需要通过对它们进行遍历就可以快速地实现 visibility culling。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ED9xDGd.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Xznd9OZ.png\" width=\"80%\">\n</div>\n<p>在现代游戏引擎中，BVH 是应用最为广泛的 bounding box。BVH 的一大特点是它可以在场景中物体发生运动时通过对节点的操作来动态地修改树的结构，这样无需每次都重新建树从而大大提高了计算效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/DqAB1sd.png\" width=\"80%\">\n</div>\n<p>在游戏设计中，**PVS (potential visibility set)** 是一种非常实用的技术。它的思想是把整个场景划分为若干个相对独立的区域，不同区域之间通过 portal 进行连接。当玩家在场景中进行游戏时只会在某个区域中，而这个区域内的可见性是可以事先确定的，这样就可以利用 PVS 来进一步剔除无需渲染的对象。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mT7PsUa.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3TE6ckZ.png\" width=\"80%\">\n</div>\n<p>当然随着设备计算能力的进步，PVS 的应用在现代游戏中已经没有那么多了。但是 PVS 的思想仍然是值得我们去学习的，实际上除了渲染之外 PVS 的思想在场景管理和资源调度中都有着丰富的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UceWgtk.png\" width=\"80%\">\n</div>\n<p>利用现代 GPU 的强大计算性能我们可以通过查询的方式直接获取每个对象的可见性并以此剔除掉不可见的物体，这样的技术称为<strong> GPU based culling</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tJlBBLk.png\" width=\"80%\">\n</div>\n<h2 id=\"texture-compression\"><a class=\"anchor\" href=\"#texture-compression\">#</a> Texture Compression</h2>\n<p>我们在前面的章节介绍过纹理对于渲染出逼真的物体起着重要的作用。通常情况下纹理会通过一张二维贴图进行表示，并且在计算机中使用 JPG 或是 PNG 这样的压缩格式进行存储。而在游戏引擎中则无法使用这些常用的图像压缩格式，这主要是因为 JPG 这样的压缩算法不支持快速的随机图像坐标访问，而且它们往往具有过大的计算复杂度无法进行实时的压缩与解压。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QMBQXXA.png\" width=\"80%\">\n</div>\n<p>在渲染系统中最常用的纹理压缩算法是<strong> block compression</strong>，它的思想是统计每个 4×4 区域内纹理图像最大和最小值然后通过插值的方法进行查询。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/mIbCX0O.png\" width=\"80%\">\n</div>\n<h2 id=\"authoring-tools-of-modeling\"><a class=\"anchor\" href=\"#authoring-tools-of-modeling\">#</a> Authoring Tools of Modeling</h2>\n<p>游戏中的模型是怎么获得的呢？最经典的建模方法是使用 3ds Max、Maya、blender 等建模软件来绘制 3D 模型。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/iQJSONE.png\" width=\"80%\">\n</div>\n<p>近几年基于雕刻的建模软件也获得了非常多的应用。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/0zMhMgI.png\" width=\"80%\">\n</div>\n<p>随着人工智能和三维重建技术的发展，我们甚至可以从实物通过扫描的方法来重建出非常精细的网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rkXV7JX.png\" width=\"80%\">\n</div>\n<p>除此之外，还有一些自动化建模工具来自动生成地形等场景的网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sl1yQyw.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ugc304a.png\" width=\"80%\">\n</div>\n<h2 id=\"cluster-based-mesh-pipeline\"><a class=\"anchor\" href=\"#cluster-based-mesh-pipeline\">#</a> Cluster-Based Mesh Pipeline</h2>\n<p>本节课最后讨论了 cluster-based mesh shader 这一前沿技术的基本思想。随着现代 GPU 计算能力的提高以及人们对于画质需求的不断增长，在 3A 大作中的模型往往都具有百万级甚至千万级的网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zYQC3Rn.png\" width=\"80%\">\n</div>\n<p>为了渲染出具有如此高精度的网格就需要使用 mesh shader 相关的技术。mesh shader 的核心思想是把网格上的一小块区域视为一个 meshlet，每个 meshlet 都具有固定数量的三角形。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/HFA3yPr.png\" width=\"80%\">\n</div>\n<p>在进行渲染时可以通过实时生成的方法即时生成 meshlet 中的网格。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VKUpBNi.png\" width=\"80%\">\n</div>\n<p>mesh shader 可以生成几乎无限的细节，而且可以根据相机和物体的相对位置关系动态地调整网格的精度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gFSGTim.png\" width=\"80%\">\n</div>\n<p>虚幻 5 中的 Nanite 技术可以认为是更加成熟的 mesh shader。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WJ6Fy3A.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/4bArNVc.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTRyNHkxcDd0dC8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 04：Rendering on Game Engine</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/",
            "title": "games104系列笔记（三）",
            "date_published": "2023-06-25T15:53:02.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎的对象设计和管理方法。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>在上一节课中我们介绍了现代游戏引擎的分层架构，而在本节课中我们会开始构造整个游戏世界。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/lRaNNpv.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-describe-the-world\"><a class=\"anchor\" href=\"#how-to-describe-the-world\">#</a> How to Describe the World?</h2>\n<h3 id=\"game-object\"><a class=\"anchor\" href=\"#game-object\">#</a> Game Object</h3>\n<p>首先我们要考虑游戏世界是由哪些组件构成的。以<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZWEuY29tL3poLWNuL2dhbWVzL2JhdHRsZWZpZWxkL2JhdHRsZWZpZWxkLTIwNDI=\">《战地 2042》</span>为例，游戏中包含了大量的可互动对象包括坦克、无人机、火炮、士兵等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BNHCRGF.png\" width=\"80%\">\n</div>\n<p>除此之外，游戏中还包含了很多静态的对象比如说各种建筑物。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/d89YOTH.png\" width=\"80%\">\n</div>\n<p>这些动态和静态的游戏对象都依附于游戏场景，一般来说场景包括天空、植被以及地形等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fh4DSAS.png\" width=\"80%\">\n</div>\n<p>在玩家看不到的地方还有一些其它类型的游戏对象，它们为整个玩法提供支持。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XUfaz44.png\" width=\"80%\">\n</div>\n<p>总结一下，游戏世界是由各种各样的 ** 游戏对象 (game object, GO)** 组成的。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Tyci9j2.png\" width=\"80%\">\n</div>\n<h3 id=\"components\"><a class=\"anchor\" href=\"#components\">#</a> Components</h3>\n<p>那么如何描述一个游戏对象呢？最直观的方法是使用面向对象编程的思路把 GO 划分为属性和行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vGGR4KW.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/espMMyA.png\" width=\"80%\">\n</div>\n<p>同时，不同 GO 之间的依赖关系还可以通过继承的方式来加以描述。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/yzdRzMh.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jNSMPUC.png\" width=\"80%\">\n</div>\n<p>但在实践中人们发现 GO 之间的关系往往是非常复杂的，仅通过继承的方式无法完整地描述不同对象之间的关系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tNjjJiJ.png\" width=\"80%\">\n</div>\n<p>因此在现代游戏引擎中一般是通过 ** 组件化 (components)** 的方式来描述一个对象，这样每个 GO 都可以拆分成若干个相互独立的组件。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qzZVZOo.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Fo7y66V.png\" width=\"80%\">\n</div>\n<p>以无人机为例，我们可以把任意形式的无人机拆分成 Transform、Motor、Model、AI 等组件，然后单独实现每个组件的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/rFDiO0x.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fbjKRF1.png\" width=\"80%\">\n</div>\n<p>这样当我们想要取定义新的无人机类型时只需要替换相应的组件即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AVpF4qU.png\" width=\"80%\">\n</div>\n<p>目前市面上常见的商业游戏引擎，包括 Unity 和虚幻等都使用了组件化的设计思想。我们在设计自己的游戏引擎时也应遵循这样的设计理念。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KL14QMo.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3u40hLU.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-make-the-world-alive\"><a class=\"anchor\" href=\"#how-to-make-the-world-alive\">#</a> How to Make the World Alive?</h2>\n<h3 id=\"tick\"><a class=\"anchor\" href=\"#tick\">#</a> Tick</h3>\n<p>接下来我们考虑如何让整个游戏世界动起来。回忆我们在上节课介绍过的<a href=\"/2022/03/24/GAMES104-NOTES-02.html#function-layer\"> tick</a> 机制，我们可以在每个时钟周期中分别对每个 GO 调用 tick () 函数，这种方式称为<strong> object-based tick</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/93Gy1CI.png\" width=\"80%\">\n</div>\n<p>另一种调用 tick () 函数的方式是以组件作为基本单位，每个时钟周期内我们依次 tick 不同 GO 的同一类组件。这种方式称为<strong> component-based tick</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/zkDyO1N.png\" width=\"80%\">\n</div>\n<p>component-based tick 相对要反直觉一点，但却有着更高的性能。component-based tick 相当于把系统的 tick () 函数分解成流水线，这样可以提高系统的并行性并重复利用缓存。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/m93zTB7.png\" width=\"80%\">\n</div>\n<h3 id=\"events\"><a class=\"anchor\" href=\"#events\">#</a> Events</h3>\n<p>在调用 tick () 函数时不同的 GO 需要进行通信以确定自身的行为。早期的游戏引擎通过硬编码的方式来编写所有可能的通信行为。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VKMFeWg.png\" width=\"80%\">\n</div>\n<p>当然在现代游戏引擎中已经抛弃了这种过于低效的通信方式，而是使用 ** 事件 (event)** 机制实现 GO 之间的交互。当某个 GO 需要和其他对象进行通信时，它会直接向相应的对象发送一个 event，而接收到这个 event 的对象则会在下个时钟周期进行处理。这样我们无需考虑系统中每种 GO 可能的通信方式，通过 event 机制实现了 GO 之间的解耦。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/z00GxKP.png\" width=\"80%\">\n</div>\n<p>在商业游戏引擎中就使用了 event 机制来实现 GO 之间的通信。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/MEyAioN.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-manage-game-objects\"><a class=\"anchor\" href=\"#how-to-manage-game-objects\">#</a> How to Manage Game Objects?</h2>\n<p>当场景中的 GO 数量不断增加时我们就需要考虑如何高效地管理它们。一般来说对于场景中的每个 GO 我们会为它赋予一个识别号 UID 以及位置坐标，这样当 GO 之间就可以根据空间位置进行交互。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UZD6rt9.png\" width=\"80%\">\n</div>\n<p>最简单的管理方式是不管理，当 GO 需要进行交互时通过直接遍历的方式来查找对象。显然这种方式是过于低效的，随着 GO 数量的增加遍历的代价会按平方函数进行增长。稍微好一点的管理方式是把场景划分成一个均匀的网格，这样需要进行查询时只考虑相邻格子中的 GO 即可。但如果 GO 在网格上不是均匀分布，这种管理方式的效率仍然很低。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/w7INHa2.png\" width=\"80%\">\n</div>\n<p>更合理的管理方法是使用带层级的网格，这种方式的本质是使用一个四叉树进行管理。这样进行查询时只需要对树进行遍历即可。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M8tnkL9.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GIROOgc.png\" width=\"80%\">\n</div>\n<p>除了四叉树之外，现代游戏引擎进行场景管理时还会使用 BVH、BSP、octree、scene graph 等不同类型的数据结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ly3IGGV.png\" width=\"80%\">\n</div>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/u9gEb9n.png\" width=\"80%\">\n</div>\n<p>本节课最后讨论了一下商业游戏引擎中 event 机制的实现。由于不同 GO 之间的依赖关系，直接使用 event 进行消息传递可能是不合理的。同时为了高效的利用多核 CPU，在商业游戏引擎中会使用 &quot;邮局&quot; 的方式来代替 GO 之间的直接通信。&quot;邮局&quot; 的意义在于可以保证系统的严格时序，从而确保整个系统是<strong>确定的 (deterministic)</strong>，不会由于多核并行产生不同的运行结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/m5H0AYh.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVlZNHkxcDc0UC8/c3BtX2lkX2Zyb209MzMzLjc4OA==\">Lecture 03：How to Build a Game World</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "games104系列笔记（二）",
            "date_published": "2023-06-25T15:51:10.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎的分层架构。</p>\n<span id=\"more\"></span>\n</blockquote>\n<p>现代游戏引擎是一个非常复杂的系统并包含了海量的代码，但幸运的是游戏引擎一般会通过分层的方式将这些代码组织起来。因此了解游戏引擎的分层架构有助于对整个系统形成全面的认识。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3BIJ7R6.png\" width=\"80%\">\n</div>\n<h2 id=\"a-glance-of-game-engine-layers\"><a class=\"anchor\" href=\"#a-glance-of-game-engine-layers\">#</a> A Glance of Game Engine Layers</h2>\n<p>打开一个游戏引擎会直接看到各种类型的编辑器。这个直接和开发者进行交互的层称为<strong>工具层 (tool layer)</strong>。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FmzvEMl.png\" width=\"80%\">\n</div>\n<p>在工具层下面包含<strong>功能层 (function layer)</strong>，用来实现游戏的渲染、动画、交互等不同类型的功能。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/sq2OHLx.png\" width=\"80%\">\n</div>\n<p>在此基础上还需要 ** 资源层 (resource layer)** 来管理各种各样的场景美术资源。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7y5oRzD.png\" width=\"80%\">\n</div>\n<p>再下一层是<strong>核心层 (core layer)</strong>，它包括支持游戏渲染、动画、物理系统、内存管理等不同系统的核心代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/5KmiJV0.png\" width=\"80%\">\n</div>\n<p>最底层是<strong>平台层 (platform layer)</strong>，一般包括各种图形 API、输入设备支持以及不同游戏平台的底层代码。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/TcKvOH9.png\" width=\"80%\">\n</div>\n<p>除此之外各种不同类型的中间件也会贯穿整个游戏引擎的不同层。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vFZyFFj.png\" width=\"80%\">\n</div>\n<h2 id=\"explore-game-engine-layers\"><a class=\"anchor\" href=\"#explore-game-engine-layers\">#</a> Explore Game Engine Layers</h2>\n<p>加下来我们介绍游戏引擎不同层的逻辑和功能。</p>\n<h3 id=\"resource-layer\"><a class=\"anchor\" href=\"#resource-layer\">#</a> Resource Layer</h3>\n<p>首先来看资源层。游戏中的每一个对象都包含不同类型的<strong>资产 (asset)</strong>，比如说几何模型、纹理、声音、动画等，同时每种资产都可能包括不同的数据格式。通过资源层我们将游戏对象的资产组织起来并通过全 ** 局唯一标识符 (Globally Unique Identifier, GUID)** 进行识别和管理。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/r230ERY.png\" width=\"80%\">\n</div>\n<p>资源层和通常意义下的资源管理器的一大区别在于资源层需要对各种资产进行动态实时的管理，不同资产之间的通信和交互往往需要通过<strong> handle</strong> 系统来进行实现。handle 系统的细节我们留到后面的章节再详细介绍。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/3YKDim3.png\" width=\"80%\">\n</div>\n<p>因此资源层的核心在于管理不同资产的<strong>生命周期 (life cycle)</strong>。大型游戏需要实时地加载并回收系统资源，如何设计出高效的 ** 垃圾回收 (garbage collection, GC)** 和动态加载机制对于提升系统的运行效率有着重要的价值。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aDghMVO.png\" width=\"80%\">\n</div>\n<h3 id=\"function-layer\"><a class=\"anchor\" href=\"#function-layer\">#</a> Function Layer</h3>\n<p>功能层用来实现游戏的核心玩法。某种意义上讲功能层的作用类似于一个 ** 时钟 (tick)** 用来控制整个游戏世界的运行，在每个时钟周期内功能层需要完成整个游戏系统的全部运算。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/GblyI0D.png\" width=\"80%\">\n</div>\n<p>一般来说 tick 在运行时会依次调用两个函数： <code>tickLogic()</code>  以及 <code>tickRender()</code>  来分别更新系统的状态和并把图像绘制到屏幕上。这里需要注意逻辑的计算是严格早于渲染的，编程时也要注意不要把它们混到一起。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jq5OC47.png\" width=\"80%\">\n</div>\n<p>在每一个时钟周期内一般会把视野范围外的对象裁减掉只对视野中的物体进行渲染。如果仔细观察还可以发现场景中的物体都是按照一帧一帧的方式发生运动，这样通过人眼的视觉残留效应就形成了我们看到的动画。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9TDzYml.png\" width=\"80%\">\n</div>\n<p>当然功能层的作用不仅限于逻辑以及渲染，实际上功能层会占据整个游戏引擎很大比例的内容并且和游戏自身的玩法密切相关。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/1R48Jua.png\" width=\"80%\">\n</div>\n<p>为了提升游戏引擎的计算效率现代游戏引擎往往会通过多核的方式来充分利用 CPU 计算的资源。未来的游戏引擎架构一定会向多核并行的方向上发展，因此在设计引擎时最好从多核的角度进行思考。当然如何管理计算任务之间的依赖仍然是一个难点。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/aThli7D.png\" width=\"80%\">\n</div>\n<h3 id=\"core-layer\"><a class=\"anchor\" href=\"#core-layer\">#</a> Core Layer</h3>\n<p>功能层的各种数学计算需要核心层的代码进行支持。一般来说核心层不会涉及到过于复杂的数学知识，基础的线性代数就能满足绝大多数游戏引擎的需求。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Ps3fgby.png\" width=\"80%\">\n</div>\n<p>核心层的数学库和通用数学库的一大区别在于游戏引擎对于计算的实时性要求更高，有时我们甚至可以牺牲一些计算精度来换取计算效率的提升。同时核心层数学库还大量使用了 CPU 的<strong> SIMD</strong> 指令，这样可以极大地加速矩阵和向量的计算速度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/v8PTzjS.png\" width=\"80%\">\n</div>\n<p>数学库之外核心层还需要包含各种常用数据结构的实现。需要说明的是即使是 C++ 标准库 stl，有些数据结构的实现仍然不是效率最高的，因此在核心层中需要根据需求重新实现一些常用的数据结构。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KHM4GCD.png\" width=\"80%\">\n</div>\n<p>核心层最重要的功能是实现<strong>内存管理 (memory management)</strong>，从这个角度看游戏引擎的功能非常类似于操作系统。在游戏运行时往往会直接申请一大片内存空间然后通过引擎而不是操作系统进行管理，这样可以提升系统的运行效率。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/6q6dUEy.png\" width=\"80%\">\n</div>\n<p>总结一下，核心层是整个游戏引擎的基础，它要求非常高的代码质量而且在大多数情况下不要随意修改它。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Vf8EbWj.png\" width=\"80%\">\n</div>\n<h3 id=\"platform-layer\"><a class=\"anchor\" href=\"#platform-layer\">#</a> Platform Layer</h3>\n<p>为了克服不同平台对于代码的限制，我们需要平台层来提供对不同操作系统和硬件平台的支持。这样我们就只需要一套代码就可以在不同的平台上运行程序。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/QdlUzSg.png\" width=\"80%\">\n</div>\n<p>不同的平台往往使用了不同的图形接口，为了统一代码游戏引擎的平台层提供了 **RHI (render hardware interface)** 作为通用的图形编程 API。RHI 包含了统一套程序在不同图形 API 上的实现，这样上层的图形应用中就可以使用统一的一套 API 进行编程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FfmIvPR.png\" width=\"80%\">\n</div>\n<p>不同的平台甚至可能有着完全不同的硬件架构，为了高效地利用平台的计算资源需要平台层将计算逻辑合理地分配到不同平台的计算硬件上。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/WrpGaKa.png\" width=\"80%\">\n</div>\n<h3 id=\"tool-layer\"><a class=\"anchor\" href=\"#tool-layer\">#</a> Tool Layer</h3>\n<p>工具层是为游戏开发者提供支持的一层。工具层允许游戏开发者直观地预览不同美术资源在游戏环境中的表现，对于游戏开发者和设计师有着重要的意义。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/y2s6QqL.png\" width=\"80%\">\n</div>\n<p>除了游戏引擎自己的开发工具外一般还需要导入其它软件和开发工具的资产，这就需要 asset conditioning pipeline 来提供不同资源导入游戏引擎的统一管线。可以说编辑器和 asset conditioning pipeline 共同构成了游戏引擎的工具层。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/oapSkJP.png\" width=\"80%\">\n</div>\n<h3 id=\"why-layered-architecture\"><a class=\"anchor\" href=\"#why-layered-architecture\">#</a> Why Layered Architecture?</h3>\n<p>对游戏引擎进行分层的意义在于对不同类型的代码进行解耦，这样可以更好地管理这个系统的复杂度。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fwsS0QC.png\" width=\"80%\">\n</div>\n<h2 id=\"mini-engine-pilot\"><a class=\"anchor\" href=\"#mini-engine-pilot\">#</a> Mini Engine: Pilot</h2>\n<p>本课程使用课程组自行开发的 Pilot 引擎来介绍现代游戏引擎的基本架构和实现。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/hX3M22H.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pMBLEhn.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/SDgEGGm.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7XKZrB1.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW9VNHkxUjdLbT9wPTI=\">Lecture 02：Layered Architecture of Game Engine</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/",
            "title": "games104系列笔记（一）",
            "date_published": "2023-06-25T15:48:39.000Z",
            "content_html": "<blockquote>\n<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nYW1lczEwNC5ib29taW5ndGVjaC5jb20vZW4v\">GAMES 104: Modern Game Engine-Theory and Practice</span>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍现代游戏引擎的基本概念。</p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"game-miracle-of-modern-computer-technology\"><a class=\"anchor\" href=\"#game-miracle-of-modern-computer-technology\">#</a> Game: Miracle of Modern Computer Technology</h2>\n<p>现代游戏引擎是一个非常庞大的系统，它集合了整个计算机科学从底层硬件到应用端几乎全部的内容。某种意义上说，开发一个现代游戏引擎的难度不亚于开发一个现代操作系统。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/w1dPJkJ.png\" width=\"80%\">\n</div>\n<h2 id=\"why-we-need-to-learn\"><a class=\"anchor\" href=\"#why-we-need-to-learn\">#</a> Why We Need to Learn?</h2>\n<p>在正式介绍游戏引擎的相关概念前我们先来考虑为什么要学习游戏引擎这个问题。实际上现代游戏引擎的应用范围已经不局限于单纯的电子游戏，游戏引擎和相关的技术是整个虚拟世界的基石。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/M6MrYVT.png\" width=\"80%\">\n</div>\n<h3 id=\"metahuman\"><a class=\"anchor\" href=\"#metahuman\">#</a> Metahuman</h3>\n<p>游戏中的 &quot;捏脸&quot; 以及目前火热的 ** 虚拟人 (metahuman)** 背后是游戏引擎和图形技术十几年来不断进步的结果。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/XLPkm8K.png\" width=\"80%\">\n</div>\n<h3 id=\"cinematic-animation\"><a class=\"anchor\" href=\"#cinematic-animation\">#</a> Cinematic &amp; Animation</h3>\n<p>影视工业中虚拟场景的渲染也不再是离线渲染技术一枝独秀的领域。通过游戏引擎已经可以实现实时的场景渲染，方便影视工作者及时调整拍摄流程。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/qxoWj9o.png\" width=\"80%\">\n</div>\n<h3 id=\"simulation\"><a class=\"anchor\" href=\"#simulation\">#</a> Simulation</h3>\n<p>在军事领域，各国已经在使用游戏引擎辅助战术训练。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/jyKmrYn.png\" width=\"80%\">\n</div>\n<h3 id=\"digital-twin\"><a class=\"anchor\" href=\"#digital-twin\">#</a> Digital Twin</h3>\n<p>** 数字孪生 (digital twin)** 更是需要游戏引擎作为基石。可以说游戏引擎是沟通现实世界与虚拟世界之间的桥梁。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/w0tjdEP.png\" width=\"80%\">\n</div>\n<h2 id=\"history-of-game-engine\"><a class=\"anchor\" href=\"#history-of-game-engine\">#</a> History of Game Engine</h2>\n<p>从历史发展的角度上来看游戏引擎是一个非常年轻的概念。早期的游戏并没有专门的引擎，开发者的目标是在有限的计算能力和存储空间中实现相对复杂的游戏玩法。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/Rp9bVYq.png\" width=\"80%\">\n</div>\n<p>随着整个电子游戏行业的发展人们发现可以重复利用某些代码并把一些概念分离抽象出来，这就形成了早期的游戏引擎。公认的游戏引擎之父是 John Carmack，他开发的 ** 重返德军总部 (Wolfenstein 3D, 1992)** 可以认为是第一款通过游戏引擎开发的游戏。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ec9OQSH.png\" width=\"80%\">\n</div>\n<p>John Carmack 后来还开发了<strong>毁灭战士 (Doom)</strong>，并以此定义了 FPS 这一游戏类型。他还通过授权的方式允许其它公司开发商业游戏，这也了奠定了游戏引擎的商业模式。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2pdoa39.png\" width=\"80%\">\n</div>\n<p>现代游戏引擎的出现则要归功于 GPU 的发展。随着对图形渲染需求的增加，人们开发出了 GPU 这样的计算硬件将图形运算从 CPU 逻辑运算分离出来。通过对高度并行化图形运算的优化，人们第一次实现了全程的 3D 游戏。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pfZwOBv.png\" width=\"80%\">\n</div>\n<p>计算能力的提高不仅提升了游戏画面的质量，也为游戏系统开发提出了各种各样的挑战。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/7vMSgOK.png\" width=\"80%\">\n</div>\n<p>今天的游戏引擎已经有一个庞大的门类，很多游戏开发商甚至有着自己专门开发的游戏引擎。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vHxoWHZ.png\" width=\"80%\">\n</div>\n<p>除了游戏引擎外也有很多公司和团队专精某一个子系统的功能，包括物理仿真、声学仿真、渲染等等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vXBmOWQ.png\" width=\"80%\">\n</div>\n<h2 id=\"whats-game-engine\"><a class=\"anchor\" href=\"#whats-game-engine\">#</a> What's Game Engine?</h2>\n<p>Wiki 中关于游戏引擎的概念过于笼统和抽象，在本课程中我们则将游戏引擎定义为实现虚拟世界整套技术的基础，同时也是展示人们创意的舞台。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ztp81oi.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/m5uchfV.png\" width=\"80%\">\n</div>\n<p>游戏引擎是一个非常复杂的系统，即使是非常简单的游戏也需要系统的不同组件相互协作才能实现基本的游戏功能，比如说渲染系统在屏幕上绘制图像、物理系统模拟人物战斗的过程、控制系统实现玩家和角色的交互、联网系统实现多人互动等等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/AlB6Z0K.png\" width=\"80%\">\n</div>\n<p>同时需要特别强调的是游戏引擎不等于渲染系统，实际上渲染只占现代游戏引擎的一小部分内容。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/BadOm7U.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/OFKOBYH.png\" width=\"80%\">\n</div>\n<p>游戏引擎的目标是在有限的计算资源和带宽下尽可能对现实世界进行实时模拟。实时性是游戏引擎和图形学其它研究的重要区别之一，大部分游戏特效的计算都要压缩在 1 ms 左右。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YtnoTi5.png\" width=\"80%\">\n</div>\n<p>游戏引擎的用户也不仅仅是游戏开发者，现代游戏引擎可以服务于设计师和工程师作为一种生产力工具。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/YeKoJXB.png\" width=\"80%\">\n</div>\n<p>对于开发者，游戏引擎需要提供具有高拓展性的 API 以满足不同类型游戏的开发需求。同时游戏引擎也需要考虑协作性以方便团队之间相互沟通合作。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/ehvfYQm.png\" width=\"80%\">\n</div>\n<p>游戏引擎还需要考虑技术更新换代后向前的兼容性，因此架构设计对于游戏引擎尤为重要。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/tM4vj3J.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/VSFuCew.png\" width=\"80%\">\n</div>\n<h2 id=\"how-to-study\"><a class=\"anchor\" href=\"#how-to-study\">#</a> How to Study？</h2>\n<p>那么如何学好游戏引擎呢？由于系统的复杂性，游戏引擎几乎包含了整个计算科学的知识体系。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/vgzHadP.png\" width=\"80%\">\n</div>\n<p>不过在本课程中我们更关注于游戏引擎的知识框架和体系结构，不会专攻于某些技术的细枝末节。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k7kIfCT.png\" width=\"80%\">\n</div>\n<h2 id=\"course-content\"><a class=\"anchor\" href=\"#course-content\">#</a> Course Content</h2>\n<p>本课程会涉及现代游戏引擎的体系架构、渲染系统、动画系统、物理系统、游戏性架构、特效系统等。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/NCEAbQD.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/uLdcAuG.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/k6AQ7wq.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UG1owVb.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/pudUXwN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/KKckU21.png\" width=\"80%\">\n</div>\n<p>为了实现游戏引擎，课程中还会介绍各种常用的工具。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/dNjD9G0.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IFPvx9S.png\" width=\"80%\">\n</div>\n<p>同时，本课程也会介绍一些业界的前沿技术。</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UXL31W5.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/9ye5TVN.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/UqtoXHD.png\" width=\"80%\">\n</div>\n<h2 id=\"course-logistics\"><a class=\"anchor\" href=\"#course-logistics\">#</a> Course Logistics</h2>\n<p>最后，本课程的官方资源如下：</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/gwmYgnh.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/fIHuH4O.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/IhZE4i6.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/t6JMszL.png\" width=\"80%\">\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/FYHBVDf.png\" width=\"80%\">\n</div>\n<p>感谢课程团队的无私奉献！</p>\n<div align=center>\n<img data-src=\"https://search.pstatic.net/common?src=https://i.imgur.com/2wKUZdy.png\" width=\"80%\">\n</div>\n<h2 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW9VNHkxUjdLbT9zcG1faWRfZnJvbT0zMzMuMTAwNy50b3BfcmlnaHRfYmFyX3dpbmRvd19jdXN0b21fY29sbGVjdGlvbi5jb250ZW50LmNsaWNr\">Lecture 01：Overview of Game Engine</span></li>\n</ul>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/",
            "url": "https://sakurame.eu.org/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/",
            "title": "games104笔记",
            "date_published": "2023-06-24T05:50:39.000Z",
            "content_html": "<h3 id=\"一-games104的几个主要点\"><a class=\"anchor\" href=\"#一-games104的几个主要点\">#</a> 一、 games104 的几个主要点</h3>\n<ol>\n<li>basic elements，讲清楚游戏有几层，怎么入手，都有哪些模块</li>\n<li>渲染系统，怎么把那么多渲染相关的 texture、material、model 拼在一起，偏工程化</li>\n<li>动画系统</li>\n<li>物理系统</li>\n<li>gameplay，事件系统、脚本系统、怎么做图形化</li>\n<li>特效系统，例如烟等、AI 系统、相机系统</li>\n<li>工具链，例如反射、数据格式（数据格式兼容等）</li>\n<li>网络同步（状态同步、帧同步）</li>\n<li>相对前沿的概念（Motion Matching、PCG、DOP（面向数据的编程）、job system、luman、nanite 等）</li>\n</ol>\n<p>游戏引擎和工业软件例如 CAD、建筑软件等有很多共通点，但是每个引擎都会根据自己的需求做定制 游戏引擎仍然是跑的最远的，因为在商业上被充分竞争。</p>\n<h3 id=\"二-游戏引擎架构\"><a class=\"anchor\" href=\"#二-游戏引擎架构\">#</a> 二、游戏引擎架构</h3>\n<p>工具层、功能层（动画、绘制、物理、脚本等）、资源层、核心层（工具箱）、平台层（主要是做跨平台的，输入设备（鼠标手表等），操作系统上，硬件平台等）、第三方组件层（Physx、音乐库等）</p>\n<p>资源层会把所有的格式都转换成引擎自己的格式，这种格式通常是 GPU 高效的，也会把那些无效的信息给扔掉。 现代游戏引擎中，最核心的功能是数据资源之间的关联（reference） GUID: 每一个资产的唯一识别号。 handle 系统：是每一个资产的管理，看这个资源还是否存在， GC 系统：基本上掉帧的大部分原因都是 GC 资源加载和卸载：在游戏过程中，资源是实时的加载和卸载的。 延迟加载：先加载一些模糊的贴图，粗糙的物体，等一阵子再加载细节较多的资源。 tick：每帧都需要更新的内容：一般先 ticklogic，再去 tickrender。 function 层（功能层）：并行计算 core 层：数学库，矩阵加减乘除、数据结构（数组、链表、二叉树等，这一部分要引擎自己写，如果不自己写会产生很多内存碎片）、内存管理 CPU 的缓存经常是游戏的卡点（想起来苹果的 CPU 缓存就比较大） 平台层：不同平台的路径（反斜杠，回车符）等都不同、mac 上用的是 metal，windows 用的是 dx 等，要用 RHI 给他全屏蔽掉。硬件架构不同，如果想要把各个平台的特性都用起来，也是一个很麻烦的 越底层的代码越稳定，稳定以后可能几年都不会改，例如 platform 和 core 层</p>\n<h3 id=\"三-如何构建游戏世界\"><a class=\"anchor\" href=\"#三-如何构建游戏世界\">#</a> 三、如何构建游戏世界</h3>\n<p>物体分为动态物、静态物、还有环境 也可以分为属性和行为。</p>\n<p>一开始游戏引擎是面向对象的游戏引擎，但是有些物体是较难区分福字关系的，例如军舰继承自船，坦克继承自车，但是水陆两栖登陆艇就很难继承了。因此就有了 ECS，是 Component Base 的思想，把枪拆成多个组件，例如消音器、瞄准镜等，也可以把 AI 模块、模型模块、物理模块、旋转变换等都变成组件。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/components_in_unity_and_unreal.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/components_in_unity_and_unreal.png\" alt=\"商业引擎的component\" /></a></p>\n<p>游戏世界由 GameObject 组成，而每一个 GO 都是由 Components 组成</p>\n<p>event 机制就是观察者模式，当事件发生时，告知所有注册过的 component</p>\n<p>世界场景分为多个 cell，划分了很多格子，当场景分布不均匀时，格子也是不均匀的。而且格子是一种二叉树式的 hierarchy 式的管理方式。</p>\n<p>event 系统需要保证消息发送是又先后顺序的，因此需要有一个 “邮局系统”，所有的消息都会发送到这个邮局，然后再由邮局系统第二天发送给目标 object</p>\n<ol>\n<li>everything is an object</li>\n<li>gameobject 由 component 组成</li>\n<li>gameobject 的状态是通过 tick loop 来更新的</li>\n<li>game object 和其他对象交互的方式是通过 event 机制（观察者模式）</li>\n<li>gameobject 是通过 hierarchy cell 来管理的。</li>\n</ol>\n<p>如果 tick 时间过长怎么办：一般会用 deferred tick，把爆炸的计算分散到各个帧里面算，做延迟 tick。 tick 时渲染线程和逻辑线程怎么同步：tickrender 主要做数据准备，ticklogic 会比 tickrender 早一些。</p>\n<p>component 的缺点：如果只用组件的话效率会比较低，所以得把所有的 component 放在一起 tick。另外 component 之间也需要消息通讯。</p>\n<p>event 怎么调试：不停地加 log。。。。 动画和物理相互影响时怎么处理：一开始用动画差值的方式，后面使用物理计算。因为物理计算相对复杂。动画插值相对快速，这样能保证效率和效果都还不错。</p>\n<h3 id=\"四-游戏引擎的渲染实践\"><a class=\"anchor\" href=\"#四-游戏引擎的渲染实践\">#</a> 四、游戏引擎的渲染实践</h3>\n<p>游戏渲染的几个挑战：</p>\n<ol>\n<li>游戏场景是十分复杂的。</li>\n<li>需要对现代的硬件架构十分熟悉，硬件架构</li>\n<li>越来越高的帧率要求和分辨率，同时要求较快的绘制速度。</li>\n<li>CPU、带宽和内存的限制</li>\n</ol>\n<p>渲染的 outline： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/render_outline.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/render_outline.png\" alt=\"渲染的outline\" /></a></p>\n<p>texture sampling, 绘制一个像素点，需要采样两层 mipmap，每个 mipmap 采样 4 个像素点。</p>\n<p>SIMD 和 SIMT：SIMD 是单指令多数据，例如计算 vec4 的加减法 SIMT 是单指令多线程，例如计算 100 次 vec4 的加减乘除，重要的是 100 次</p>\n<p>为什么每个顶点都要有自己的 normal：因为形状边缘在插值的时候，可能会出现法线偏移的问题。</p>\n<p>renderable 里面有 mesh、material、texture 和 shader，都是数据</p>\n<p>而每个绘制物体（例如人）可能会用到很多材质，头的材质和身体的材质可能不同，因此引入了 submesh 的概念，每一个 submesh 都拥有自己的材质，存储的是 index 和 vertex、material 的 offset。 为了节省空间，引擎使用的是 pool，例如 material pool，然后每个 submesh 存储的都是 pool 中的索引。</p>\n<p>因为切换 material 很费时间，所以游戏引擎会 sort 所有的材质，把相同材质放在一起绘制。</p>\n<p>visibility culling 是对每一个物体计算 BBOX 或者 OBB，然后使用 BVH 加速结构，做层级剔除。因为 BVH 对动态物体比较友好，更新较快。</p>\n<p>目前模型的表达正在从 model 变成 cluster-based mesh pipeline</p>\n<p>radiance：辐射度，辐射出去的能量 irradiance：入射的能量</p>\n<p>shader 管理：游戏引擎的 shader 数量会非常多，经常会有很多 ubershader，然后通过 uber 生成更多的可执行 shader。同时 ubershader 也会是跨平台的。</p>\n<p>lightmap 是给整个场景的光照 pack 到一张大的 atlas 中，这个 lightmap 包含整个场景的 SH 所以通常会比较大。 而 lightprob 则是在 lightmap 上做进一步的改进，每一个 lightprob 都存着周围的光照信息。</p>\n<p>而 IBL 则是给整个环境一个光照图，中间有一些 diffuse 的光照，也有一些 specular 的光照结果。</p>\n<p>PBR MR 模型：相对更容易理解 PBR SG 模型：相对更灵活</p>\n<h3 id=\"六-大气-地形和云\"><a class=\"anchor\" href=\"#六-大气-地形和云\">#</a> 六、大气、地形和云</h3>\n<p>地形渲染：使用 heightfield（等高图），然后用网格（meshgred）叠加高度图计算生成地形。但是这种方法很难</p>\n<p>地形的 T Junction：当相邻的两个 mesh，其中有一个 mesh 的 LOD 高一些，另一个 LOD 低一些，导致两个 mesh 相接处无法紧密结合时，就会出现 T Junction，解决这个的办法只能是把另一块 mesh 也细分成和另一个相同的三角形、或者把比较细的那块 mesh stishing 到另一个 mesh 上，形成退化三角形。</p>\n<p>使用 quad tree 来表示地形（而不是 triangle 的方法）</p>\n<p>另一种表示地形的方法是使用纯三角形表达，因为 quad tree 的三角形数量太多了，而使用三角形则会使顶点数少一个数量级。</p>\n<p>地形通常要和 hull shader、domain shader 等相关，现在升级成了 mesh shader</p>\n<p>地形通常会用很多个 texture，用很多个 material，然后通过一个系数做插值，常用的方法是根据不同 texture 的 heightmap 来做插值，控制插值的系数。 有时候通常使用视差贴图来保证凹凸感。 目前地形渲染已经使用 virtual texture 一统天下了，VT 如果能喝 DMA 或者 DirectStorage 结合起来的话，texture 就可以不经过 CPU 和内存，直接加载到 GPU 然后解压到显存</p>\n<p>另外整个场景在绘制的时候会遇到浮点数精度误差，导致会出现两个相距很近的物体 z 值会相互打架。好的解决办法是，把物体用 “相对于摄像机的距离” 进行渲染。</p>\n<p>树和草的渲染：使用 billboard 再加上 decorator，让树和草显示出多样性。</p>\n<p>一般 decals 也直接 bake 到 VT 上面了。</p>\n<p>体积云：使用一张 weather texture，表示云的厚度，再添加 noise function，例如 perlin noise 或者 worley noise，这两个加起来就能做体积云了。然后使用 raymarching 的方法，去判断是否已经 git 到云，直到 hit 到云，以及什么时候走出云，然后在做云里面的累计。</p>\n<h3 id=\"七-游戏中的渲染管线-后处理和其他的一切\"><a class=\"anchor\" href=\"#七-游戏中的渲染管线-后处理和其他的一切\">#</a> 七、游戏中的渲染管线、后处理和其他的一切</h3>\n<p>AO 的常用的算法：SSAO、HBAO、GTAO 和 RTAO</p>\n<p>HeightFog 和 depth fog 现代游戏引擎用的是 Voxel based Volumetric Fog。 fog 3d texture 的分辨率是 160x90，是因为屏幕分辨率是 16x9</p>\n<p>走样（Aliasing）分为好几种，一个是锯齿，另一个是高光的闪烁，还有就是 texture 采样精度不足导致的纹理扭曲。所有的 Aliasing 都是采样率不足导致的。应对方法是超采样。</p>\n<p>bloom：解决的是光晕的问题 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/bloom.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/bloom.png\" alt=\"bloom\" /></a> tone Mapping：是为了解决曝光过亮或者曝光过暗的问题。相当于把 HDR 映射到 LDR 区域。ACES 则是一种调节过的 tone mapping 的曲线，效果更好，</p>\n<p>color grading：有点像滤镜，通常使用 lut 实现，把颜色从一个颜色映射到另一种颜色。这个是提升游戏质量，效果最重要的后处理方式。 [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/color%20grading.png\" alt=\"color grading\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvY29sb3I=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/color</span> grading.png)</p>\n<p>frame graph 和 unity 的 SRP 一样，都是用来显示各个 renderpass 的前后依赖关系，从而让大家知道整个渲染流程是怎样的，有利于 debug</p>\n<p><a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/ue_render_pipeline.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/ue_render_pipeline.png\" alt=\"ue5_render pipeline\" /></a></p>\n<h3 id=\"八-游戏引擎的动画系统\"><a class=\"anchor\" href=\"#八-游戏引擎的动画系统\">#</a> 八、游戏引擎的动画系统</h3>\n<p>视觉残留现象是游戏动画的基础。 2D 动画：就是一些图片拼接起来，如果想要流畅，则可以使用 2d 录制 3d 动画，然后抠图抠出来。</p>\n<p>动画的挑战：动画的自然感、动画的计算效率、动画需要和玩家及时交互。</p>\n<p>live2D：通过把一个人物拆分成多个组件，例如头发，眼睛，衣服等，然后把所有的图元生成一些控制网格，通过编辑这些控制网格来编辑 keyframe 动画。</p>\n<p>3D 动画：顶点动画：把每一个顶点随着时间的变化存成一个动画，通常用于飘荡的旗帜等效果。这些动画数据一般存在一个 texture 上。叫做 vertex animation texture。</p>\n<p>morph target animation：一般用于人脸的动画，一般蒙皮动画用在人脸上会很不自然，morph target animation 有几个关键点权重，然后通过 key poses 来插值。</p>\n<p>2D skinned animation：类似 3d，把 2D 也通过骨骼来驱动</p>\n<p>physics based animation：通过物理模拟动画中的衣料、IK 等。</p>\n<p>为什么不用 T-Pose：因为 Tpose 会导致肩的地方精度不够，收到挤压</p>\n<p>欧拉角的问题：必须要有 xyz 的旋转顺序</p>\n<p>欧拉角导致的万向节：可以用来保证方向是稳定的。但是会导致坐标轴退化（x 和 y 轴共轴），另外是很难插值，真实世界也不会绕着 xyz 轴旋转，会沿着任意轴旋转。</p>\n<p>四元数只能在三维空间中使用，可以使用群伦证明</p>\n<p>动画压缩：因为每一帧都需要存储每一个 joint 的 scale、translation 和 rotation，如果游戏里有很多动画，则需要的存储空间是非常大的。这样是不可接受的，可行的办法就是，把 scale 都存成 1，trans 也都把不变的给删掉。 另一种办法就是，只存关键帧，计算关键帧插值出来的动画和原始动画做比较，如果小于一定阈值，则保存这个关键帧，这样保存出来的关键帧是非均匀的。</p>\n<p>catmull-Rom 曲线：通过四个控制点，决定 P1 和 P2 之间的曲线，如下图所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/catmull-Rom%E6%9B%B2%E7%BA%BF.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/catmull-Rom%E6%9B%B2%E7%BA%BF.png\" alt=\"catmull-Rom曲线\" /></a> 动画压缩也可以通过缩减浮点数，使用 16bit 整数来表示浮点数。</p>\n<p>但是动画压缩有一个问题，就是会导致末端骨骼的精度不够，所以需要用一个 error Compensation 来评估动画对精度的敏感度。</p>\n<h3 id=\"九-高级动画技术\"><a class=\"anchor\" href=\"#九-高级动画技术\">#</a> 九、高级动画技术</h3>\n<p>动画状态机：action state machine，动画之间的切换需要使用插值，插值的方式有很多种插值曲线。不同的插值曲线的效果是不同的。</p>\n<p>layered ASM：角色的上半身有一套状态机，角色的中间用一套状态机，下半身也有一套状态机。中间是分开的。而现代游戏引擎使用的是动画树（Animation Blend Tree) [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/action%20blend%20tree.png\" alt=\"动画树\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYWN0aW9u\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/action</span> blend tree.png) 动画树就是 layered ASM 的超集，可以把所有的节点都按照树形结构结合在一起。UE 的动画树是做的相对比较好的。</p>\n<p>IK：其实就是一个稳定三角形，计算膝盖处的位置，如下图所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/two_bone_IK.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/two_bone_IK.png\" alt=\"two bone IK\" /></a> 但是该方法求得的解空间是一个圆，所以需要美术给一个方向，最后的 IK 是在这个方向上得到最终的解。</p>\n<p>Multi-Joint IK：相对比较难的，因为有无穷多解，需要依次做下面几个事情：</p>\n<ol>\n<li>先确定所有的骨骼长度能否达到目标点</li>\n<li>确定所有的骨骼折了以后是否过长而无法达到目标点，如下所示 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/multi_joint_IK_liminate.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/multi_joint_IK_liminate.png\" alt=\"multi-joint IK limit\" /></a></li>\n<li>根据人体每根骨骼的旋转约束，来保证 IK 的结算是自然的。 Heuristics Algorithm IK（例如 CCD IK）：具体思路就是从最末端节点沿着目标点做旋转，然后不断迭代。 但是只纯 IK 会有问题，可能最末端的骨骼弯曲的很严重，但是前面的骨骼还没弯曲就已经达到最后的结果了。所以 IK 最开始的时候会有一个圆圈确定大致范围，先做一次迭代，然后逐渐缩小圆圈半径，如下所示 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/CCD_IK.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/CCD_IK.png\" alt=\"CCD_IK\" /></a></li>\n</ol>\n<p>另一种 CCD_IK 的约束方法就是每一个骨骼都有一个最大旋转角度，保证旋转的角度不会过于畸形。</p>\n<p>FABRIKF：是一种通过位移来最终达到效果的算法。该方法就是说，要先把末端骨骼直接通过平移和旋转挪到目标点上，然后再依次向上迭代。然后再把整个骨骼链反过来，先把头端骨骼连接到之前的骨骼圆点，再依次向末端骨骼移动迭代。反复迭代几次最终达到效果。 FABRIKF 也会出现骨骼约束的问题。也是会通过旋转角或者平移范围来做约束。</p>\n<p>IK 存在多个末端节点：使用 jacobian 矩阵解决。</p>\n<p>IK 目前存在的问题：</p>\n<ol>\n<li>自碰撞和自冲突</li>\n<li>IK 无法提前预知，例如在遇到门或者小洞时，人需要提前蹲下，IK 无法做到</li>\n<li>IK 无法做到人体自然的动作，</li>\n</ol>\n<p>整个动画管线如下所示： animation pipeline： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/animation_pipeline.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/animation_pipeline.png\" alt=\"animation pipeline\" /></a></p>\n<p>Facial Action Unit：把人的表情归类到 46 类表情，因为很多表情是对称的，所以到最后归纳为 28 个常用的 AU。然后通过 blending 来表示动画。真实的 AU 保存的是一些表情某个区域相对于 neutral pose 的区别。从而可以对面部做局部控制</p>\n<p>面部表情一般是通过 morth target animation + 蒙皮动画 蒙皮动画用来做眼睛移动等动作，morth target animation 用来模拟肌肉，或者通过 UV 来表示动画。</p>\n<h3 id=\"十-物理系统的基础理论和算法\"><a class=\"anchor\" href=\"#十-物理系统的基础理论和算法\">#</a> 十、物理系统的基础理论和算法</h3>\n<p>游戏中的物体分为几类：</p>\n<ol>\n<li>静态 Actor：无法移动的例如墙，地板等</li>\n<li>动态 actor：一些动态的物体，可以符合物理碰撞规律的，例如弹珠撞到了一个石头，石头会动。</li>\n<li>trigger：当任何一个 acter 前面，其他的物体会作出相应的反应，例如自动门。</li>\n<li>反物理规律的：例如人在推箱子，但是推力没有设置好，箱子一下子就飞出去了。或者是有一些游戏机关，地板在不断的上下移动。让玩家上去。</li>\n</ol>\n<p>Actor Shapes： 球（Spheres，用来表示球类物体，桌球等），胶囊（Capsules，用来表示人物）, 盒子（Box，一些相对复杂的形体，例如城墙），凸包（Convex Meshes，一般用来表示石头等）、三角形（Triangle Mesh，一般用来表示房子，动态物体一般不适用这个，因为复杂度太高）、高度图（Height Field，一般用来表示地形）</p>\n<p>一个物体一般都要设置质量或者密度。 还需要指定质心位置。 物理材质：一般会设置一个物体表面的摩擦力数值、以及弹性值</p>\n<p>游戏世界中的力：重力、拉力、摩擦力、冲力（Impulse，例如爆炸产生的力）</p>\n<p>物理引擎中，力可能是会频繁发生变化的，例如一个小球在做圆周运动，但是因为引擎是按时间更新的，且更新的时候不知道这个圆会做圆周运动，所以给的力经常会慢一拍，从而导致圆周运动不收敛，如下图所示：</p>\n<p><a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/euler_method.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/euler_method.png\" alt=\"euler method\" /></a> <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/forward_euler_method.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/forward_euler_method.png\" alt=\"euler method\" /></a></p>\n<p>该问题的解决办法：隐式欧拉法：使用未来的力预测未来的位置，但是会导致能量衰减。在物理引擎里面能量衰减可解释（例如摩擦力） <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/implicit_euler_method.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/implicit_euler_method.png\" alt=\"euler method\" /></a></p>\n<p>物理引擎更常用的方法是半隐式欧拉法 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/semi-implicit-Euler-method.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/semi-implicit-Euler-method.png\" alt=\"semi-implicit-euler-method\" /></a></p>\n<p>刚体动力学：质量、速度、加速度、动量、 旋转 R（使用旋转矩阵或者四元数表达）、 角速度（Angular Velocity）在物体的任意一不通过轴心的点，然后这个点有一个切向速度，把这个点和轴连在一起形成了一个方向，使用右手法则做一个叉积，就可以得到旋转轴的方向。这样可以同时表达旋转轴、切向速度和旋转方向，如下所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/angular_velocity.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/angular_velocity.png\" alt=\"angular velocity\" /></a></p>\n<p>角加速度（Angular Acceleration）角速度出于 dt 就是角加速度了。</p>\n<p>转动惯量（Rotational Inertia）</p>\n<p>角动量（Angular Momentum）角动量是守恒的，例如花样滑冰在旋转的时候，张开手转的慢。</p>\n<p>力矩（Torque）：一个方向和叉乘一个力方向的轴，表示能够推动一个物体的力，通常在汽车中使用</p>\n<p>碰撞检测：：</p>\n<p>使用 BVH 快速检测碰撞 使用 sort and sweep 来做碰撞检测，该方法优势在于只要把物体都提前排序以后，只移动少部分物体，效率会非常高。 [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/broad%20phase%20sort%20and%20sweep.png\" alt=\"broad phase sort and sweep\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYnJvYWQ=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/broad</span> phase sort and sweep.png)</p>\n<p>物体求交： 圆、胶囊等求交相对简单 凸包的求交使用 Minkowski 和和 Minkowski difference 来判断。Minkowski difference 肯定会经过圆点，使用 GJK 算法找到圆点 另一种算法是通过判断是否存在一条边能把两个物体分开 [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/separating%20axis%20theorem2d.png\" alt=\"separating axis\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvc2VwYXJhdGluZw==\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/separating</span> axis theorem2d.png)</p>\n<p>碰撞检测后的处理：添加一个新的力。</p>\n<p>物理引擎会对世界中的物体做分组。从而不管那些不受影响的组，从而加速计算。</p>\n<p>CCD（continue collision Detection）连续性碰撞检测，类似原神须弥的 G 点</p>\n<p>物理引擎的 deterministic：要求在不同的终端设备上，物理模拟出的效果是一致的，结果必须一致，否则会影响到玩家体验。包括浮点数误差等。</p>\n<h3 id=\"十一-物理系统高级应用\"><a class=\"anchor\" href=\"#十一-物理系统高级应用\">#</a> 十一、物理系统高级应用</h3>\n<p>character controller： 主要是对角色做控制，一般把角色当成一个胶囊，或者两层胶囊（外层胶囊是防止角色距离墙壁太近导致看到墙壁后的东西。 再比如角色在走楼梯的时候，要提前将角色向上移动一个小距离 再比如角色在爬坡的时候，超过一定角度会先上去再掉下来。 再比如一个人在电梯上，当电梯下降的时候，人可能会发生抖动，这个时候的解决办法是把人和物体绑定到一起。</p>\n<p>布娃娃系统（Ragdoll）：如果没有布娃娃系统 一个人在台阶上被打死，可能只播放骨骼动画，而没有掉下去的动画，上半身会悬空，闲得很假</p>\n<p>布娃娃系统实现的方法就是把人体的主要骨骼标记出来，然后由 TA 对各个 joint 做约束。布娃娃系统是通过对各个 joint 做物理运算实现的。</p>\n<p>在实际引擎中，一般是会把 ragdoll 和蒙皮动画放在一起做 blending 实现的。</p>\n<p>衣料模拟：最开始的是通过骨骼来模拟和驱动衣料的动画。这样是比较快的。 另一种方法是通过 ragdoll 的方式，让几根骨骼驱动衣料，然后通过物理算骨骼的动画 效果最好的办法是基于 mesh 的衣料动画，physics mesh 一般会比 render mesh 稀疏很多，然后 render mesh 通过 physics mesh 插值生成。而且 physics mesh 会有运动的约束权重，例如人身上的披风，靠近肩膀的地方能移动的范围会比较有限，而靠近下面的披风 mesh 约束会小很多。 衣料的物理模型实现是通过弹簧质点模拟实现的。他有两个力，一个是弹性产生的力，另外会有一个能量消耗力（damping）。 [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/clothsolver_mass-spring%20system.png\" alt=\"cloth solver\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvY2xvdGhzb2x2ZXJfbWFzcy1zcHJpbmc=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/clothsolver_mass-spring</span> system.png)</p>\n<p>verlet 积分：是基于半隐式积分</p>\n<p>目前布料的结算经常用的是 Position Based Dynamic 去结算，如下图所示： [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/cloth%20solver%20position%20based%20dynamics.png\" alt=\"position based dynamic\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvY2xvdGg=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/cloth</span> solver position based dynamics.png)</p>\n<p>布料模拟的另一个问题是布料的自穿插。解决办法是使用最大速度的限制。或者把布料的物理模拟加厚</p>\n<p>破坏系统： 在构建 mesh 的时候就用 hierarchy 的方式把 mesh 分割成几个碎片，每一个碎片之间有一个 connection，这个 connection 是有权重的，用来表示受到多大的力才会发生破裂。 voronoi 算法：在一个地方随机撒一些种子，然后生成到每两个点相同距离的线。在生成碎片的时候，可以基于 voronoi 算法定义不同的策略。例如玻璃一般是从中心开始碎，而有的地方碎片会密一些。</p>\n<p>载具系统： 一个车有四个轮子组成，每个轮子都是一个弹簧系统 车还有引擎作为动力， 轮子上有摩擦力 轮子上的悬挂有悬挂力</p>\n<p>另外汽车上的重心对汽车的影响很大。重心靠前时就容易翻车。</p>\n<p>坦克则需要模拟履带 飞机则需要空气动力学知识。</p>\n<p>PBD 和 XPBD（把载具、衣料、碰撞等全都变成一种约束，用雅克比矩阵求解约束） PBD 的好处在于速度很快，而且效果比较好。</p>\n<h3 id=\"十二-游戏中的粒子和声音系统特效\"><a class=\"anchor\" href=\"#十二-游戏中的粒子和声音系统特效\">#</a> 十二、游戏中的粒子和声音系统（特效）</h3>\n<p>粒子发射器： 会有很多发射器，每一个发射器发射粒子，所有的发射器打包叫做粒子系统。 每一个粒子都是会受到力的作用的，例如重力，风的阻力，粒子的运动轨迹受到粒子的速度，受力影响。 粒子还会有颜色的变化。 粒子也可以有碰撞检测，例如打铁花，掉落的铁屑落到地上会有弹落。</p>\n<p>billboard 粒子：通过一系列有动画的 billboard 来模拟粒子，例如明日之后里面的火焰</p>\n<p>mesh 粒子：每一个粒子都是一个 mesh，这样可以做出随机感很强的粒子。</p>\n<p>Ribbon 粒子：粒子形成的是一条光带，例如光剑（魔法剑）挥剑的轨迹。这种会有一些粒子的时空滞留感。一般使用样条曲线插值来形成 Ribbon 粒子。</p>\n<p>粒子渲染最大的问题：半透明问题。例如半透明物体的排序。例如按照粒子发射器做 sort</p>\n<p>渲染粒子的优化方法：将粒子渲染做降分辨率</p>\n<p>GPU 粒子：GPU 很适合做粒子，因为粒子的数量庞大，同时计算简单。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GPU_particles.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GPU_particles.png\" alt=\"GPU particles\" /></a> 粒子有专门的一个数据机构，有一个 alive Particles List 还有一个 dead list，每当一个粒子死亡，需要从 alive list 移到 deadlist 里面，而 emiter 每发射一个粒子，需要从 deadlist 把相应的粒子拿出来放到 alive list 里面，GPU 每帧只需要对 alive list 里面的粒子做模拟即可。</p>\n<p>粒子的计算跟视角无关，即使看不到的粒子也需要每帧计算，只是不需要绘制了而已。 GPU 粒子可以把物理模拟，排序，视锥裁剪、depth buffer collision 等都放到 GPU 上做。GPU 上的粒子排序是使用的 mergesort，这个是可以并发执行的。</p>\n<p>大量的人也可以用粒子系统实现。使用 Animated Particle Mesh，只不过在人物的粒子系统中，没有用物理模拟，而是用的动画状态机实现。还有鸟群，鱼群的实现。这里面使用 SDF 来辅助控制碰撞。</p>\n<p>音效系统： 声音分为音调、音量和音色，音色本质是不同基波和不同幅度的音波叠加起来的效果，因此理论上人耳听不到的高频音也会对音色产生影响。 理论上声音的采样率只要大于两倍音频即可保证无损，但因为音色的影响，采样频率需要稍高一些，保证高频音也能采样到。</p>\n<p>MP3 只支持立体音，不支持 5.1 立体环绕音，而且 Mp3 有专利墙，所以大部分时候使用 OGG 格式。</p>\n<p>声音的渲染系统： listener 的位置，速度还有朝向 声音的空间感：主要是利用两个耳朵接受到的声音大小，声音到达的时间差距，音色等 声音的 power 是音强的平方，</p>\n<p>声音的衰弱：这个时候使用 attenuation shape 来模拟声音的衰弱，例如高音喇叭使用的是喇叭形的衰弱。小溪使用的是胶囊的衰弱场。</p>\n<p>引擎还需要处理声波，在有障碍物时的声音</p>\n<p>声音的混响：例如骑马通过一个桥洞。混响包含干音（就是直接的声音）、声音的回音，声音的拖尾。 多普勒效应：当声源在移动的时候，声音的效果是不一样的。 声音的采集：一般是在录音室中对整个空间的声场做采集 在 3A 大作里面，会设置很多个音源。来模拟环境音。</p>\n<h3 id=\"十三-引擎工具链基础\"><a class=\"anchor\" href=\"#十三-引擎工具链基础\">#</a> 十三、引擎工具链基础</h3>\n<p>所见即所得的工具链 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/game_engine_runtime_framework.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/game_engine_runtime_framework.png\" alt=\"game engine runtime framework\" /></a></p>\n<p>引擎工具链的本质是要连接各个特色的人，把大家连接到一起协作，例如美术，策划，程序员连接到一起。</p>\n<p>游戏引擎最开始的系统叫做 GUI 系统，GUI 系统由 immediate Mode，所见即所得的绘制。还有一种叫 Retained Mode，将所有要绘制的东西放到类似 commandbuffer 里面，如果绘制内容不变的话则不改变 commandbuffer。现在大部分都是 Retained Mode GUI</p>\n<p>Retained Mode GUI 有很多设计方式，例如 MVC，MVVM 等， 其中 MVC 架构的思想是只能通过 model 来改变 view，而 view 不能改变 model，用户的操作只能通过 controller 来改变 model。这种方式只有 “单行线”，容易管理。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/MVC.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/MVC.png\" alt=\"MVC\" /></a></p>\n<p>还有一个设计模式是 MVP：就是把 Controller 编程 persenter，作为中间者。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/MVP.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/MVP.png\" alt=\"MVP\" /></a></p>\n<p>MVVM 模型，把 persenter 换成 viewmodel 只不过他中间用的是 binding 机制，view 就只有 XML，是艺术家来写的，viewmodel 是把 xml 和 model 绑定到一起的作用，是一种数据转换。model 拥有自己的数据。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/mvvm.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/mvvm.png\" alt=\"MVVM\" /></a></p>\n<p>在写工具的时候，最好不用自己写的 GUI，而是使用现成的工具例如 QT 等。</p>\n<p>数据的序列化：就是把当前的数据变成可以保存成文件的格式。或者可以变成可以网络传输的数据格式。例如存成 txt 或者 json，都是序列化操作。 如果能存储成 binary mode 的话，文件的大小会小很多。</p>\n<p>工具链还会遇到一个问题，就是数据会有很多重复，例如有十个一模一样的房子，但是会有一些微小的差别。这个时候，如果存十个 binary 就会有很多浪费。常用的技术是数据的继承，例如添加一个 xxx.mat 告诉引擎我们要从 xxx.mat 把所有的数据拷贝过来，然后再去新增别的数据即可。</p>\n<p>如何做到资产版本的兼容性：例如新版本引擎可以导入老版本引擎的资产，或者老版本引擎可以导入新版本引擎的资产。 怎么处理：少的值新增一个默认值，多的值不处理。 或者给每一个资产定义一个单调递增的 guid</p>\n<p>工具链的鲁棒性：</p>\n<ol>\n<li>怎么做 undo 和 redo</li>\n<li>工具 crash 了怎么办 使用命令设计模式，command 需要原子化，然后把所有的 command 都保存到磁盘上。 每一个 command 都需要有 revoke 和 invoke，还需要有一个 uid 建议提前在工具链中集成 command 系统，这样可以使我们工具链非常干净。 command 系统最主要的三个操作是 add、delete 和 update。</li>\n</ol>\n<p>如何处理工具链中各个资源格式不同的问题： 使用 schema：将所有复杂的数据都拆分成一些 “原子数据”，schema 更像是一个分子式，是一个描述物体的格式，schema 通常是一个 xml，而且要有继承关系，例如军人的 schema 可以继承自人的 schema。同时还需要能够相互 reference 数据。能够把数据关联在一起。</p>\n<p><a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/schema_define.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/schema_define.png\" alt=\"schema define\" /></a></p>\n<p>工具还有一个能力就是要给不同的人给不同的 View，例如不能给美术弧度，而是要给角度，要给调色板而不是 RGB 数值。</p>\n<p>工具链还需要 “所见即所得” 具体的做法是直接复用引擎代码，例如下面的引擎架构 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/game_tools_framework.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/game_tools_framework.png\" alt=\"game tools framework\" /></a></p>\n<p>工具链还需要有 “play in Editor” 功能，就是直接在编辑器里面运行游戏。</p>\n<p>工具链还需要有可扩展性，例如插件功能，可以让第三方开发者使用插件功能编写自己的插件。</p>\n<p>工具链开发需要有很强的软件工程能力，以及非常熟悉游戏制作过程。</p>\n<h3 id=\"十四-引擎工具链高级概念和应用\"><a class=\"anchor\" href=\"#十四-引擎工具链高级概念和应用\">#</a> 十四、引擎工具链高级概念和应用</h3>\n<p>World Editor 引擎需要支持多个 viewport，因为可能会出现画中画。 同时世界编辑器还需要针对不同的美术去做选择性的编辑，例如把锁定某些东西不可编辑。让美术专注于自己的领域。 世界编辑器还需要 Content Browser，需要可以浏览所有的资产，也可以检索资产。</p>\n<p>鼠标选取功能：使用 Ray Casting 来实现物体选取。</p>\n<p>Height Brush 功能：能够通过笔刷来生成地形的高度。最好能够给美术提供一个能够自己导入笔刷的功能</p>\n<p>instance Brush：能够通过刷子来快速的生成物体 instance。</p>\n<p>能够有环境系统，例如路上不能长树。这需要一套 Rule System，然后使用这么一个 Rule System 使用 PCG 的方法生成出来。</p>\n<p>World Editor 还需要有插件系统，而且需要支持多个插件共存。还有 plugin 的版本系统。</p>\n<p>游戏引擎的叙事系统：包含每个物体的时间线，然后多个物体的时间线放在一起会有动画或者叙事系统。</p>\n<p>反射系统：就是能够让程序可以动态修改他的数据结构和方法。如下所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/reflection_demo.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/reflection_demo.png\" alt=\"reflection\" /></a> C++ 如何实现反射：三步骤</p>\n<ol>\n<li>在代码里面确定需要反射的类型和成员变量等</li>\n<li>生成编译代码，提供 accessors 去获取函数和成员变量</li>\n<li>通过 &lt;string, accessor&gt; 的 map 去管理所有的 accessors</li>\n</ol>\n<p>现在我们的 C++ 代码一定需要 GPL 去对编码做编译。例如 Clang，获取他的 AST（抽象语法树）。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/reflection_generate_schema_from_AST.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/reflection_generate_schema_from_AST.png\" alt=\"reflection AST\" /></a> 我们通过定义一些描述词，把希望做反射的数据结构描述一下，这个通过宏来实现。clang 有一个__attribute__, 它里面有一个叫 annotate 的关键字，他可以给我们的变量打标记，如下所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/reflection_add_attribute.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/reflection_add_attribute.png\" alt=\"reflection attribute\" /></a></p>\n<p>visual script system：主要是解决编程语言的可扩展性。丢掉 hard code method，可以动态增加方法。</p>\n<p>code rendering：代码渲染：能够自动的把 xml 或者可视化图转换成代码，这种方式可以把代码和数据区分开。可以使用第三方插件 Mustache</p>\n<p>协同编辑：类似协同编辑文档。通过划分区域。或者 asset 分层等方式来实现。或者（one file per actor）但是这样会产生非常多的小文件。 协同编辑最终的状态是，每一个人可以实时看到别人的编辑结果，这其实是一个网络同步问题。这需要将对所有命令原子化。</p>\n<p>引擎和 DCC 工具在相互抢工作，例如 DCC 工具想要做一些引擎 runtime 的事情，引擎想要做类似手 K 动画的功能。</p>\n<h3 id=\"十五-引擎的gameplay\"><a class=\"anchor\" href=\"#十五-引擎的gameplay\">#</a> 十五、引擎的 gameplay</h3>\n<p>gameplay 是一个需要快速迭代的东西，引擎在做的时候，需要支持玩法快速迭代。 一般使用 event 来控制物体之间的交互，中间有很多细节，例如使用 callback function 来实现 event 系统，但是注册了 callback 以后，要保证 owner 不为空。 gameplay 还需要消息分发机制。 event 在设计的时候会设计一个 queue，然后在 queue 中对 event 做分类，然后通过 batch 保证 event 的并行化。（一个 ring buffer）</p>\n<p>event 系统最好不要默认先后顺序，而是默认下一帧前保证所有的 event 都已经完成了。</p>\n<p>游戏的 hotfix：需要使用脚本来做热更新，C<ins> 较难使用热更新。并且脚本语言有利于开发效率，crash 也不会影响到 C</ins>。例如 lua、python 等 hotfix 的实现方式就是把脚本的函数指针换一下，这个时候要注意全局变量的处理。</p>\n<p>可视化脚本（蓝图系统）：就是一个把 float 等类型编程不同颜色的点，然后连起来编程的一类系统。</p>\n<p>3C 系统（character、control、camera） character 系统就是人物和环境的交互，运动，动画等 control 就是键盘、鼠标、各种外设的交互和控制。如何变得敏捷和丝滑。例如射击游戏瞄准时的吸附系统，还有手柄的反馈系统。 camera 实际上是要和玩家绑定到一起，但是实际上相机并不是严格跟着玩家的，还是在不断移动和旋转，特别是 2.5D 游戏。有可能随着玩家的移动旋转的时候，相机旋转的浮动更大。</p>\n<h3 id=\"十六-引擎的基础ai\"><a class=\"anchor\" href=\"#十六-引擎的基础ai\">#</a> 十六、引擎的基础 AI</h3>\n<p>游戏中的 AI 导航系统：</p>\n<ol>\n<li>需要对世界有一个表达，例如 map representation， 1.1 waypoint network：把所有的岔路口放一些节点，这样会形成一个网络图。AI 寻路的时候会首先寻找距离最近的节点或者路。这种方法的问题在于玩家总是会往路中间走。即使路很宽 1.2 grid：使用稠密的 triangle、square、hexagon 来表示地图，例如文明 5 就是用六边形表达。这种方法非常好实现，也容易 debug，他的缺点是存储空间较为浪费。而且寻路的效率也是比较低的，而且无法寻路有层叠关系的路，例如桥上和桥下。 1.3 navigation mesh：把地图上所有可通行的区域用一个一个的 polygon 都连起来。相比较 waypoint 和 grid，他对地图的覆盖是面覆盖代替点覆盖和线覆盖（可以是三角形也可以是别的凸多边形）。若果是凹多边形则有可能会经过一个不可行区域。但是这种方法不能做飞行系统的寻路。 1.4 sparse otree：空间寻路的实现需要使用 sparse voxel octree。但是他对存储空间要求比较高。</li>\n<li>path finding： 寻路就是在 representation 形成的 graph 中寻找最短路径。dijkstra 算法。但是 dijkstra 算法相对准确，实际寻路的时候不需要一个非常严格短的路径。这个时候就需要 A<em> 算法。A</em> 算法是基于 dijkstra 算法衍生出来的寻路算法，他的思路是，在寻路的过程中不仅需要考虑已走的距离，还要考虑预测到目标点的距离，寻找一个两者相加和最小的点继续往前迭代。并且找到目标点后直接中断算法。从而达到加速的目的。</li>\n<li>path smoothing： 只有 1,2 点会导致路径发生 zigzag，会有些奇怪，要拐很多弯路，这里面可以使用烟囱算法来做 smoothing（funnel algorithm），具体思路就是连着一个点，判断目标点是在该点烟囱的左边、右边还是中间，如果是中间的话就直接走直线，如果在左边的话，就照着最左边的路走。</li>\n<li>steering：是为了解决一个问题，就是之前的寻路是立即生效的，但是遇到动作缓慢的物体，例如汽车拥有加速度和减速度，他在运行的时候无法走直线，实际走的是弧线。 常见的 steering 动作如下图所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/steering_behaviors.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/steering_behaviors.png\" alt=\"steering behaviors\" /></a></li>\n</ol>\n<p>4.1 Seek Flee 追和逃，有一个目标点，追和逃</p>\n<p>4.2 VelocityMatch 在起步的时候要加速，快到目标点的时候要减速。这个时候需要根据距离目标点的距离反向算出加速度和速度。 4.3 align 朝向一致，例如一群鱼群，朝向要一致。</p>\n<p>crowd 系统，当有鱼群、人群、羊群的时候会有这么一个系统。微观方法上就是每个鱼都有斥力、引力和朝向，要保证鱼之间不会离得很远，也不会离得很近。同时鱼群的方向也要一致。在宏观上要有一个路径或者规则。 群体行为要避免碰撞（通过相互之间的斥力来解决，或者给每一个障碍物添加一个 SDF，sdf 越小斥力越大）</p>\n<p>速度互斥算法：当发现对面来了物体，且速度会相撞，则会改变自己的速度。</p>\n<p>behavior tree：在游戏中会有行为树来控制 AI，行为树相比较状态机，拓扑结构更加清晰，行为树的例子如下： [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/behavior%20tree.png\" alt=\"behavior tree\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYmVoYXZpb3I=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/behavior</span> tree.png) [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/behavior%20tree2.png\" alt=\"behavior tree2\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYmVoYXZpb3I=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/behavior</span> tree2.png)</p>\n<p>Sequence:Sequence 就是按顺序执行，例如先执行门是否关着，如果关着就开门，开门后开枪。</p>\n<p>Selector：Selector 就是依次选择执行，如下所示 [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Behavior%20tree%20Selector.png\" alt=\"behavior tree selector\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvQmVoYXZpb3I=\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/Behavior</span> tree Selector.png)</p>\n<p>Parallel: 同时发生并执行的事情，例如一面开枪一面走路。</p>\n<h3 id=\"十七-引擎的高级ai\"><a class=\"anchor\" href=\"#十七-引擎的高级ai\">#</a> 十七、引擎的高级 AI</h3>\n<p>Hierarchical task network（HTN） 行为树的局限性是不直观。HTN 是从任务目标出发，就像人类一样去做一个计划。是一种将大目标拆分成各个小目标，然后再拆分成更小的目标。 Sensor 是为了从环境里面抓取状态 Property 是每个玩家自己主观上对世界的感知 HTN Domain 是一个任务系统 Planner 是去做计划，但是这个计划很可能会随着 World State 变化而变化 Runner 是执行计划 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/HTN_Framework.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/HTN_Framework.png\" alt=\"HTN_Framework\" /></a></p>\n<p>Task 分为几种 Primitive Task 是包含 Preconditions、Action 和 Effects 三个部分的任务。 Compound Task 是在 Primitive 的基础上有一个任务执行的优先级，优先看 A，如果 A 满足了就执行 A，不满足然后再看 B，举例如下所示</p>\n<p><a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/compound_task.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/compound_task.png\" alt=\"Compound Task\" /></a></p>\n<p>相比较行为树，HTN 就是把所有东西分成 Task，planning 就是去规划这些 task，因为在执行 task 的时候可能会出现意料之外的情况，所以 run 的时候会动态改变 task 序列。叫做 run 时候的 replan</p>\n<p>HTN 的执行效率比行为树高，因为不需要每次都从 root 节点 tick，他是一个更 High level 的算法。HTN 的缺点在于在做好 plan 的时候，可能会因为策划的配置失误或者长时间的迭代，没有执行下一个任务。这个时候就需要程序员做一些静态检查工具来帮助完成</p>\n<p>Goal-Oriented Action Planning（GOAP）基于目标的动作规划 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP.png\" alt=\"GOAP\" /></a> 只不过分为 ACtionSet 和 Goal Set, 其中 GoalSet 中的 Goal 有 Precondition 和 Priority， 和 BT 和 HTN 的区别在于，GOAP 是把目标明确出来，而 BT 和 HTN 则是将目标隐含在自己的树状结构中 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_GoalSet.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_GoalSet.png\" alt=\"GOAP GoalSet\" /></a></p>\n<p>GOAP 的 Action Set 是有 cost 的，如下所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_Actionset.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_Actionset.png\" alt=\"GOAP ActionSet\" /></a></p>\n<p>GOAP 在执行的时候是以目标为主，倒叙思考，例如我要活着是个目标，然后我中毒了，我得喝解药这又是一个目标，然后为了达到喝解药这个目标要做哪些 action。 然后 Action Cost 和 state 组成了一个图，distance 是 cost，Edge 是 Action，Node 是 Combination state <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_State_Actino_Cost_Graph.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_State_Actino_Cost_Graph.png\" alt=\"GOAP\" /></a></p>\n<p>Monte Carlo Tree Search： 围棋就是使用了类似的方法，首先要把落子的可能性做数学建模，首先要把整个局面抽象成一个 State，然后构建蒙特卡洛 Tree，在下子以后重新构建一个蒙特卡洛 Tree。 在模拟的过程中，会有一个 Default Policy 在里面，去判断本次落子的赢面大概有多大。然后选取一个赢面概率最大的节点，再去往下查找赢面。 在查找的时候，使用的方法是 UCB（upper confidence Bounds），优先选择深度迭代，但是如果发现自己的探索广度小于父亲的一定比例，则需要优先广度搜索，如下所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/upper_confidence_bounds.png\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/upper_confidence_bounds.png\" alt=\"upper_confidence_bounds\" /></a></p>\n<p>Machine Learning ： 马尔科夫链基于概率的状态机来做。 强化学习中，经常先训练一个局部最优解，然后还要不断和别的训练结果左后互博，如下所示： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/train_renforce_learning_AI.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/train_renforce_learning_AI.PNG\" alt=\"Reenforence\" /></a></p>\n<h3 id=\"十八-网络游戏的基础架构\"><a class=\"anchor\" href=\"#十八-网络游戏的基础架构\">#</a> 十八、网络游戏的基础架构</h3>\n<p>网络游戏遇到的挑战：延迟，丢包，掉线，外挂，同步，不同设备上的兼容性和一致性，多人并发度以及多人并发下的效率。 网络的七层结构： [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/internet_OSI%20Model.PNG\" alt=\"OSI Model\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvaW50ZXJuZXRfT1NJ\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/internet_OSI</span> Model.PNG)</p>\n<p>游戏中使用的网络协议一般是 reliable UDP 协议。因为 TCP 不是一个时间稳定的协议，而 UDP 虽然很快但是却不够可靠。 ARQ：实际上就是在 UDP 上使用滑动窗口协议，确认哪些包没有收到，如果没有收到就重新发一下包，保证不丢包。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/online_game_xor.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/online_game_xor.PNG\" alt=\"xor\" /></a></p>\n<p>reliable UDP 其实就做了两件事，一个是使用滑动窗口协议保证不丢包，链接稳定，另一个是使用 FEC 保证丢包以后可以恢复。</p>\n<p>RTT：时钟校准和时钟同步： 给服务器发一个包，然后让服务器再返回一个包，计算中间的时间差值。有一个 NTP 算法可以做这么一件事情。</p>\n<p>在封装网络协议之上，使用 RPC 来给客户端程序员使用，更为方便。</p>\n<p>游戏网络架构：</p>\n<p>P2P 架构：两个电脑联机到一起，或者一个网吧，可以两个人互为服务器，例如红警，w3 等</p>\n<p>Dedicated Server：有一个 Host Server，会更稳定一些，并且需要大型商业服务器。</p>\n<p>游戏同步技术</p>\n<ol>\n<li>snapshot 同步：客户端只负责传输当前客户端的数据给服务器，服务器收集所有的数据再算，保证了大家数据的绝对一致性。因为很多快照，服务器会比较卡，所以一般服务器是 10 帧，客户端是 30 帧，剩余的帧都是插值出来的。同时因为有很多快照，数据量可能会比较大，所以一般会使用 diff 来存储快照。 snapshot 的问题在于浪费了大量客户端的算力，而且对服务器的带宽需求较大。一般只有在局域网内使用。</li>\n<li>帧同步：锁步执行：所有的客户端都把数据汇总给服务器，然后由服务器将所有数据分发给各个客户端做计算，理论上各个客户端的计算结果应该是相同的，服务器只起到了转发数据的作用 2.1 initialization：在一开始进入游戏的时候，一定要确保各个玩家的数据都是相同的，例如王者荣耀进入游戏时候的 init。 2.2 服务器分发数据给客户端，并且执行同步 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/Deterministic_lockstep.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Deterministic_lockstep.PNG\" alt=\"deterministic lockstep\" /></a></li>\n</ol>\n<p>但是这个图有个问题，就是一个人会卡着所有的人，（例如 dota）一种优化方法就是每 100ms 就要收一次消息，像公交车一样，等不到也要出发，例如下面一张图： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/bucket_synchronization.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/bucket_synchronization.PNG\" alt=\"bucket synchronization\" /></a> 帧同步有一个关键点，就是游戏的确定性，就是物理引擎，vector 等数学库，浮点精度一定要有一致性。</p>\n<p>浮点数误差保证：使用分数 cos、sin 等使用查表法。 game state 也尽量弄成确定性的事情。 随机数的种子也要一致。</p>\n<p>即使使用了帧同步，也会出现网络抖动和延迟的情况，这个时候一般客户端会 cache 一两帧服务器发来的数据。然后使用插值的方式做 smooth。</p>\n<p>快照策略：一般会把渲染帧和逻辑帧分开，然后本地会在拿到服务器数据后在本地做一个快照，然后在掉线 10 秒户重新从快照的地方将所有算力用来计算逻辑。部分游戏的服务器也会保存一些快照，保证玩家掉线后直接给玩家当前状态。游戏的观战和回放也会使用帧同步的快照技术。</p>\n<p>帧同步的外挂问题：因为帧同步基本要保证每一个客户端都保存了所有玩家的所有状态，如果有战争迷雾的话，很容易写一些透视挂。</p>\n<ol>\n<li>状态同步：</li>\n</ol>\n<p>大部分的 MMORPG 都用的状态同步。</p>\n<p>不会把玩家所有的信息都传输给服务器，而是每个人只发送自己的一部分数据，而服务器是拥有所有玩家的状态的，在计算完以后会把一部分的数据（玩家的状态）发送个各个玩家。</p>\n<p>Authorized：玩家自己的电脑，玩家只提出自己的动作 Server：会收集所有玩家的动作。然后计算结果后，将结果发送给各个玩家。 Replicated：在其他玩家的电脑模拟某个玩家。是一个玩家的复制。玩家的状态则是由服务端计算得到的。</p>\n<p>状态同步通常会有一个延迟，因为需要把数据发送给 server，然后 server 再发送到客户端，这个时候客户端会有一个 overwatch，有一个预测。 <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/state_syc_compare.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/state_syc_compare.PNG\" alt=\"state_sync_compare\" /></a></p>\n<h3 id=\"十九-网络游戏的进阶架构\"><a class=\"anchor\" href=\"#十九-网络游戏的进阶架构\">#</a> 十九、网络游戏的进阶架构</h3>\n<p>因为延迟导致的抖动：可以通过 buffer 和插值来修复，这种方法虽然可以让动作很平滑但是这种方法会导致延迟更高，而且这种延迟会导致碰撞游戏出现问题。</p>\n<p>外插值可以解决碰撞游戏的问题。但是外插针需要预测未来的状态。 PVB 算法： [<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Projective%20Velocity%20Blending.PNG\" alt=\"Projective Velocity Blending\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvUHJvamVjdGl2ZQ==\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/Projective</span> Velocity Blending.PNG)</p>\n<p>[<img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Projective%20Velocity%20Blending2.PNG\" alt=\"Projective Velocity Blending2\" />](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvUHJvamVjdGl2ZQ==\">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/Projective</span> Velocity Blending2.PNG)</p>\n<p>一般符合物理学规律的游戏（例如战舰大战）使用外插针 一般比较敏捷，不符合物理规律的游戏使用内插针，也有把两个糅合在一起的用法。</p>\n<p>射击游戏的射击判定一般放在客户端，因为可以避免网络延迟，这样会很容易写外挂。服务器端也做检测会检测外挂。</p>\n<p>射击判断放在服务器端可能会有比较大的延迟，需要使用 Lag Compensation（延迟补偿）解决： 把状态的时钟往回拨，根据服务器端的数据做猜测。这种方法会导致在竞技游戏中不公平。</p>\n<p>动画前摇（可以给网络同步争取时间）</p>\n<p>MMO 的架构： <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/MMO_Architecture.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/MMO_Architecture.PNG\" alt=\"MMO_Architecture\" /></a></p>\n<p>MMO 链接服务器以前会先链接 Login Server，然后会链接 GateWay 要先保证账号是没问题的，其次保证不会被 DDOS 攻击。 Lobby：再经过 GateWay 后会进入游戏大厅，他相当于一个缓冲池。让所有用户都在这里等。 Character Server：专门负责所有玩家的属性数据，例如发邮件，血量，装备等。 Trading System：安全性和原子性要求很高， Social System：拉黑，拉小群聊天 游戏数据库会使用 redis 内存数据库 分布式服务器：主要是数据访问，网络的复杂性，数据的传输，数据的一致性。 负载均衡：要有哈希算法。</p>\n<p>带宽优化： 浮点数优化，例如把 xyz 优化成 x 和 y，double 变成 float，或者对游戏分区，然后再用定点数优化。 分区一般是把世界分成多个 cell，或者使用十字链表。</p>\n<p>反作弊：</p>\n<ol>\n<li>检查内存，抓用户的数据，把数据改了。单机游戏一般这么做，防止办法都是客户端加壳， 数据做混淆，</li>\n<li>修改本地存储文件，例如把一些材质修改成透明材质，这样就有透视挂了，一般对本地文件数值做哈希校验。</li>\n<li>网络包截获并修改。一般应对方法就是对网络包做加密，使用不对称加密算法一个公钥一个私钥，在最开始使用速度最慢但是最安全的 ssh 传输公钥。</li>\n<li>AI 作弊：比较难识别。</li>\n</ol>\n<p>开放世界：</p>\n<ol>\n<li>把世界分成很多 zoning，把世界分成几个小块，一般会用四叉树，一般每一个 zoning 会有一个自己的边界（border），数据的加载也会有一个延迟和阈值。只有超过一定阈值才会销毁另一个 zone 里面的数据。</li>\n<li>instancing</li>\n<li>replication：我将每一个 character 放到多个平行世界里面，分成多个层。例如天刀在押镖时候的不同服务器。</li>\n</ol>\n<h3 id=\"二十-面向数据编程和任务系统\"><a class=\"anchor\" href=\"#二十-面向数据编程和任务系统\">#</a> 二十、面向数据编程和任务系统</h3>\n<p>worker 架构：<a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/thread_fork_join.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/thread_fork_join.PNG\" alt=\"fork_join\" /></a></p>\n<p>Coroutine 概念：相比较切换线程，Coroutine 本质就是用了个调用栈，没有上下文切换，开销小得多， <a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/coroutine.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/coroutine.PNG\" alt=\"coroutine\" /></a></p>\n<p>Fiber-Based-Job-System JobSystem：</p>\n<p>OOP 的问题：继承的深度通常会很深，而且很多操作可能既可以在父类里面做，也可以在子类中做。</p>\n<p><a href=\"https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/performance_everything.PNG\"><img data-src=\"https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/performance_everything.PNG\" alt=\"performance\" /></a></p>\n<p>对 Shadowmap 做 reproj，或者做 culling shadowmap 本质是用视空间的精度对光空间的精度做采样。</p>\n",
            "tags": [
                "游戏引擎"
            ]
        },
        {
            "id": "https://sakurame.eu.org/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/",
            "url": "https://sakurame.eu.org/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/",
            "title": "游戏引擎架构（开坑）",
            "date_published": "2023-05-01T14:21:14.000Z",
            "content_html": "<h1 id=\"导论\"><a class=\"anchor\" href=\"#导论\">#</a> 导论</h1>\n<p>虽然各个游戏引擎的结构和时间细节千差万别，但无论是可公开授权使用的引擎，还是私有的内部引擎，都呈现出一些粗粒度的模式。几乎所有的游戏引擎都含有一组常见的核心组件，例如渲染引擎，碰撞及物理引擎，动画系统，音频系统，游戏世界对象模型，人工智能系统等。而这些组件内也开始呈现一些半标准的设计方案。</p>\n<p><em><strong>一些基本的假设（读者）</strong></em></p>\n<p>对 C++（多数游戏开发者所选择的编程语言）有充分理解，并明白一些基本的软件工程原理。同时，也假设读者懂得一些线性代数，三维矢量，矩阵，三角学（知识）。读者最好事先能了解一些实时及事件驱动编程的基本概念。但无需担心，本笔记会结合本书，简明扼要的重温这些内容，也会提供适当的参考资料供读者学习</p>\n<h2 id=\"典型游戏团队的结构\"><a class=\"anchor\" href=\"#典型游戏团队的结构\">#</a> 典型游戏团队的结构</h2>\n<h3 id=\"工程师\"><a class=\"anchor\" href=\"#工程师\">#</a> 工程师</h3>\n<p>工程师设计并实现软件，使游戏及工具得以运行。有时候，工程师分为两类，<strong>运行时</strong>程序员（runtime programmer）和<strong>工具</strong>程序员（tool programmer）。运行时程序员制作引擎和游戏本身；工具程序员则制作离线工具，供整个团队使用，以提高团队的工作效率。</p>\n<p>资深工程师有时候会被赋予技术领导的角色。比如，首席工程师（lead engineer）通常仍会设计及编写代码，但同时协助管理团队的各项安排，并决定项目整体的技术方向。从人力资源的角度来说，首席工程师有时候也会直接管理下属。</p>\n<p>有的公司设有一位或多位技术总监（technical director, TD），负责从较高层面监督一个或多个项目，确保团队能注意到潜在的技术难点，业界走势，新技术等。某些工作室可能还有一个和工程技术相关的最高职位，这就是首席技术官（chief technical officer, CTO），CTO 类似整个工作室的技术总监，并履行公司的重要行政职务。</p>\n<h3 id=\"艺术家\"><a class=\"anchor\" href=\"#艺术家\">#</a> 艺术家</h3>\n<ul>\n<li>概念艺术家（concept artist）通过素描或绘画，让团队了解游戏预设的最终面貌。概念艺术家的工作始于游戏开发的概念阶段，一般会在项目的整个生命周期里持续担任美术指导。游戏成品的屏幕截图常会不可思议的贴近概念艺术图（concept art）</li>\n<li>三维建模师（3D modeler）为游戏世界的所有事物制作三维几何模型。这类人员通常会细分为两类：前景建模师（foreground modeler）及背景建模师（background modeler）。前景建模师负责制作物体，角色，载具（vehicle），武器以及其他游戏中的对象。而背景建模师则制作背景几何模型（如地形，建筑物，桥梁等）。</li>\n<li>纹理艺术家（texture artist）制作称为纹理（texture）的二维影像。这些纹理用来贴附于三维模型之上，以增加模型的细节和真实感。</li>\n<li>灯光师（lighting artist）布置游戏世界的静态和动态光源，并通过颜色，亮度，光源方向等进行设定，以增强模型的细节和真实感。</li>\n<li>动画师（animator）为游戏中的角色及物体加上动作。如同动画电影制作，在游戏制作过程中，动画师充当演员。但是，游戏动画师必须具有一些独特的技巧，以制作符合游戏引擎技术的动画。</li>\n<li>动画捕捉演员（motion capture actor）提供一些原始的动作数据。这些数据由动画师整理后，置于游戏中。</li>\n<li>音效设计师（sound designer）与工程师紧密合作，制作并混合游戏中的音效及音乐。</li>\n<li>配音演员（voice actor）为游戏角色配音。</li>\n<li>作曲家（composer）为游戏创作音乐。</li>\n</ul>\n<h3 id=\"游戏设计师\"><a class=\"anchor\" href=\"#游戏设计师\">#</a> 游戏设计师</h3>\n<p>游戏设计师（game designer）负责设计玩家体验的互动部分，这部分一般称为<strong>游戏性</strong>。不同种类的游戏设计师，从事不同细致程度的工作。有些（一般为资深的）游戏设计师在宏观层面上设定故事的主线，整体的章节或关卡的顺序，玩家的高层次目标。其他游戏设计师则在虚拟游戏世界的个别关卡或地域上工作，例如设定那些地点会出现敌人，放置武器及药物等补给品，设计谜题元素等。其他游戏设计师会在非常技术性的层面上和游戏性工程师（gameplay engineer）紧密合作。部分游戏设计师是工程师出身，他们希望能主动的决定游戏的玩法。</p>\n<p>有些游戏团队会聘请一位到多位作家（writer）。游戏作家们的工作范畴很宽。例如，与资深游戏设计师合作编制故事的主线，甚至包括编写每句对话。</p>\n<p>如同其他游戏专业领域，有些资深游戏设计师也会负责管理团队。很多游戏团队设有游戏总监（game director）一职，负责监督游戏设计的各个方面，帮助管理各项安排，并保证每位游戏设计师的设计在整个游戏中具有一致性。资深游戏设计师有时候会转行为制作人。</p>\n<h3 id=\"制作人\"><a class=\"anchor\" href=\"#制作人\">#</a> 制作人</h3>\n<p>在不同的工作室里，制作人（producer）的角色不尽相同。有些负责管理开发进度，并同时承担人力资源经理的职责。有些主要做资深游戏设计师的工作。有些作为开发团队和商业部门（财政，法律，市场策划等）之间的联系人。有些甚至完全没有制作人。</p>\n<h3 id=\"其他工作人员\"><a class=\"anchor\" href=\"#其他工作人员\">#</a> 其他工作人员</h3>\n<p>游戏开发团队通常需要一支非常重要的支持团队，包括工作室的行政管理团队，市场策划团队（或一个与市场研究公司联系的团队），行政人员以及 IT 部门。IT 部门负责为整个团队采购，安装及配置软硬件，并提供技术支持。</p>\n<h3 id=\"发行商及工作室\"><a class=\"anchor\" href=\"#发行商及工作室\">#</a> 发行商及工作室</h3>\n<p>游戏的市场策划，制造和分销，通常由发行商（publisher）负责，而非开发游戏的工作室本身。发行商通常是大企业。很多游戏工作室并不隶属于个别发行商，这些工作室把他们制作的游戏，卖给出最好条件的发行商。还有一些工作室让单一发行商独家代理他们的游戏，其形式可以是签署长期发行合同，或是成为发行商全资拥有的子公司。第一方开发商（first-party publisher）是指游戏工作室直接隶属于游戏主机生产商。这些工作室独家为母公司的游戏硬件制作游戏。</p>\n<h2 id=\"游戏是什么\"><a class=\"anchor\" href=\"#游戏是什么\">#</a> 游戏是什么</h2>\n",
            "tags": [
                "游戏引擎"
            ]
        }
    ]
}