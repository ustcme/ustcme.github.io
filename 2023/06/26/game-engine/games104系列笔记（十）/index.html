<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Sakura" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Sakura" type="application/atom+xml"><link rel="alternate" type="application/json" title="Sakura" href="https://sakurame.eu.org/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"/><link rel="dns-prefetch" href="https://unpkg.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.11"><link rel="modulepreload" href="/js/chunk-IUZCWEMQ.js"></link><link rel="modulepreload" href="/js/chunk-L5W3LNJ7.js"></link><link rel="modulepreload" href="/js/chunk-RR3NPWS6.js"></link><link rel="modulepreload" href="/js/chunk-T4SGHXZP.js"></link><link rel="modulepreload" href="/js/copy-tex-57F64HUY.js"></link><link rel="modulepreload" href="/js/index.esm-SW5I2P7Z.js"></link><link rel="modulepreload" href="/js/post-7WIGIAYE.js"></link><link rel="modulepreload" href="/js/quicklink-NZZC7HLM.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="modulepreload" href="/js/tcomments-GJZ3AF6Z.js"></link><link rel="preload" href="https://ptpimg.me/032jxg.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/oh0zkj.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/ysg110.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/5515ea.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/sb71ea.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/7a00lf.jpg" as="image" fetchpriority="high"><meta name="keywords" content="游戏引擎"/><meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (&lt;a href=&quot;https://games104.boomingtech.com/en/&quot;&gt;GAMES 104: Modern Game Engine-Theory and Practice&lt;/a&gt;) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的基本概念。&lt;br /&gt;"/><link rel="canonical" href="https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"><title>games104系列笔记（十）</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">games104系列笔记（十）</h1><div class="meta"><span class="item" title="创建时间：2023-06-26 12:59:11"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-06-26T12:59:11+08:00">2023-06-26</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>17k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>15 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sakura's Blog</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://ptpimg.me/032jxg.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/oh0zkj.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/ysg110.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/5515ea.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/sb71ea.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/7a00lf.jpg&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/game-engine/" itemprop="item" rel="index" title="分类于游戏引擎实践"><span itemprop="name">游戏引擎实践<meta itemprop="position" content="0"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="Sakura"/><meta itemprop="description" content=", 一个专注于技术和思考分享的博客"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura"/></span><div class="body md" itemprop="articleBody"><blockquote>
<p>这个系列是 GAMES104 - 现代游戏引擎：从入门到实践 (<a target="_blank" rel="noopener" href="https://games104.boomingtech.com/en/">GAMES 104: Modern Game Engine-Theory and Practice</a>) 的同步课程笔记。本课程会介绍现代游戏引擎所涉及的系统架构、技术点以及引擎系统相关的知识。本节课主要介绍游戏引擎中物理系统的基本概念。<br />
<span id="more"></span></p>
</blockquote>
<h2 id="introduction"><a class="anchor" href="#introduction">#</a> Introduction</h2>
<p>物理系统是游戏引擎的重要组成部分。在游戏中玩家和整个游戏世界的互动都是依赖于物理系统的实现，同时在现代游戏中大量的粒子效果也都是通过物理系统来进行驱动的。显然物理系统非常复杂，甚至于有很多公司专门去研究物理引擎的高效实现。而在本课程中我们同样把物理系统拆分成两节，这一节课主要介绍物理引擎的基本概念而在下一节课中则会更多地讨论游戏业界更前沿的物理仿真技术。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/kBtO48C.png">https://search.pstatic.net/common?src=https://i.imgur.com/kBtO48C.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="physics-actors-and-shapes"><a class="anchor" href="#physics-actors-and-shapes">#</a> Physics Actors and Shapes</h2>
<h3 id="actor"><a class="anchor" href="#actor">#</a> Actor</h3>
<p>在物理引擎中根据对象自身的特点我们可以把它划分为静态对象、动态对象等。其中静态对象是指在仿真过程中不会发生改变的对象，比如说游戏中的地面、墙壁等等；与之对应的是动态对象，它们的运动状态会在游戏过程中动态地进行变化，而且它们的运动过程需要符合相应的动力学模型。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/Xm6vnN2.png">https://search.pstatic.net/common?src=https://i.imgur.com/Xm6vnN2.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/n4ymCuO.png">https://search.pstatic.net/common?src=https://i.imgur.com/n4ymCuO.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>除此之外游戏角色和场景的互动还需要相应的 trigger，它可以用来改变对象的各种状态。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/RYJljH5.png">https://search.pstatic.net/common?src=https://i.imgur.com/RYJljH5.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>最后一个常见的物理对象是 kinematics，它是指不完全基于物理法则的物理对象，但往往与玩法高度相关。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/sF9z84D.png">https://search.pstatic.net/common?src=https://i.imgur.com/sF9z84D.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>不同类型的物理对象其特点可以总结如下：</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/VZF7ebZ.png">https://search.pstatic.net/common?src=https://i.imgur.com/VZF7ebZ.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="actor-shapes"><a class="anchor" href="#actor-shapes">#</a> Actor Shapes</h3>
<p>物理对象最重要的属性是它的<strong>形状 (shape)</strong>。比较规则和简单的形状可以通过解析的方法来进行描述：</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/OYUnVaF.png">https://search.pstatic.net/common?src=https://i.imgur.com/OYUnVaF.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/I8417Jw.png">https://search.pstatic.net/common?src=https://i.imgur.com/I8417Jw.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/KzXZQLv.png">https://search.pstatic.net/common?src=https://i.imgur.com/KzXZQLv.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/1olcNZG.png">https://search.pstatic.net/common?src=https://i.imgur.com/1olcNZG.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/6Gv80w8.png">https://search.pstatic.net/common?src=https://i.imgur.com/6Gv80w8.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/Cah4m9l.png">https://search.pstatic.net/common?src=https://i.imgur.com/Cah4m9l.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/VrigtIo.png">https://search.pstatic.net/common?src=https://i.imgur.com/VrigtIo.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在进行物理仿真时我们首先会把物理对象进行一定的包裹，使用相对简单的几何形状来近似复杂的模型。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/cbWhC6f.png">https://search.pstatic.net/common?src=https://i.imgur.com/cbWhC6f.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="shape-properties"><a class="anchor" href="#shape-properties">#</a> Shape Properties</h3>
<p>在形状的基础上我们还需要对一些物理量进行定义，包括对象的质量或密度、质心以及物理材质等。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/Ro34OGj.png">https://search.pstatic.net/common?src=https://i.imgur.com/Ro34OGj.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/LrIqo9U.png">https://search.pstatic.net/common?src=https://i.imgur.com/LrIqo9U.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/xllUzcI.png">https://search.pstatic.net/common?src=https://i.imgur.com/xllUzcI.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="forces-and-movements"><a class="anchor" href="#forces-and-movements">#</a> Forces and Movements</h2>
<h3 id="forces"><a class="anchor" href="#forces">#</a> Forces</h3>
<p>** 力 (force)** 是改变物体运动状态的原因。在物理引擎中我们同样需要力来驱动整个游戏世界的仿真过程，其中常见的类型包括重力、摩擦力等。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/7xkerkT.png">https://search.pstatic.net/common?src=https://i.imgur.com/7xkerkT.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>另一种常用的仿真方式是使用<strong>冲量 (impulse)</strong>，它比较适合用来模拟物体运动状态发生剧烈变化的情况。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/j7rpf29.png">https://search.pstatic.net/common?src=https://i.imgur.com/j7rpf29.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="movements"><a class="anchor" href="#movements">#</a> Movements</h3>
<p>有了力或者冲量后就可以利用牛顿运动定律来驱动物体的运动了。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/ZR6pKyo.png">https://search.pstatic.net/common?src=https://i.imgur.com/ZR6pKyo.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/ADGa3zS.png">https://search.pstatic.net/common?src=https://i.imgur.com/ADGa3zS.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在物理引擎中一般无法使用解析的方式来计算物体的运动，因此我们需要一些数值计算方法来进行求解。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/Tk1YJZ8.png">https://search.pstatic.net/common?src=https://i.imgur.com/Tk1YJZ8.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/F6Tt6d1.png">https://search.pstatic.net/common?src=https://i.imgur.com/F6Tt6d1.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在进行数值积分时，我们可以把时间间隔设置成一个比较小的值然后对被积函数进行累加来近似实际的积分。具体来说，在计算物体的运动轨迹时我们首先计算物体在当前位置上受到的力并且积分得到加速度，然后再利用加速度来更新速度以及物体的位置。这种计算物体运动轨迹的方法称为<strong> Euler 方法 (Euler's method)</strong>，也称为<strong>显式积分 (explicit integration)</strong>。Euler 方法实现起来非常简单，但需要注意的是它的本质是使用物体的当前状态来估计下一时刻的运动状态，此时系统的能量是不守恒的。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/by4T9LW.png">https://search.pstatic.net/common?src=https://i.imgur.com/by4T9LW.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/KsAsvAg.png">https://search.pstatic.net/common?src=https://i.imgur.com/KsAsvAg.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/BqGJCpA.png">https://search.pstatic.net/common?src=https://i.imgur.com/BqGJCpA.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>为了提高数值积分的稳定性，人们还开发出了 ** 隐式积分 (implicit integration)** 的技术。隐式积分的实现也很简单，只需要在求解加速度和速度时使用下一时刻而不是当前时刻的值即可，同时可以证明此时系统的能量会不断衰减。当然这又引入了另一个问题，即如何计算系统在下一时刻的物理量，这在很多情况下是比较困难的。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/YHGHQVD.png">https://search.pstatic.net/common?src=https://i.imgur.com/YHGHQVD.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/iL8tssw.png">https://search.pstatic.net/common?src=https://i.imgur.com/iL8tssw.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在游戏引擎中更常用的积分方法是<strong>半隐式 Euler 方法 (semi-implicit Euler's method)</strong>，即在计算加速度时使用当前时刻的力推导下一时刻的速度，而在计算位置时使用刚才计算出的速度再更新位置。半隐式方法有非常高的数值稳定性，广泛应用于各种类型的物理仿真中。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/8WeSzpc.png">https://search.pstatic.net/common?src=https://i.imgur.com/8WeSzpc.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/5DqUf1w.png">https://search.pstatic.net/common?src=https://i.imgur.com/5DqUf1w.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="rigid-body-dynamics"><a class="anchor" href="#rigid-body-dynamics">#</a> Rigid Body Dynamics</h2>
<p>有了牛顿定律和数值积分算法就可以开始进行物理仿真了，其中最简单的情况是<strong>质点动力学 (particle dynamics)</strong>。在质点动力学中所有的物体都被抽象为没有具体形状的质点，此时我们只需要按照牛顿定律更新质点的运动状态即可。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/ROnupqR.png">https://search.pstatic.net/common?src=https://i.imgur.com/ROnupqR.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在游戏引擎中更为常见的仿真场景是<strong>刚体动力学 (rigid body dynamics)</strong>。和质点动力学不同，刚体动力学仿真需要考虑物体自身的形状，也因此需要在质点运动的基础上引入刚体旋转的相关概念。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/7Sy9Rz2.png">https://search.pstatic.net/common?src=https://i.imgur.com/7Sy9Rz2.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="orientation"><a class="anchor" href="#orientation">#</a> Orientation</h3>
<p>刚体的 ** 朝向 (orientation)** 可以使用一个旋转矩阵或者四元数来表示，它表示刚体当前姿态相对于初始姿态的旋转。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/8G908wr.png">https://search.pstatic.net/common?src=https://i.imgur.com/8G908wr.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="angular-velocity"><a class="anchor" href="#angular-velocity">#</a> Angular Velocity</h3>
<p>** 角速度 (angular velocity)** 表示刚体绕某个旋转轴旋转的速度，需要注意的是在描述角速度时必须要指明旋转轴。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/2rxwk0r.png">https://search.pstatic.net/common?src=https://i.imgur.com/2rxwk0r.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="angular-acceleration"><a class="anchor" href="#angular-acceleration">#</a> Angular Acceleration</h3>
<p>** 角加速度 (angular acceleration)** 类似于加速度，不过它描述的是角速度的变化。这里需要说明的是角速度的变化不仅包括绕当前轴转速的变化，它还包括旋转轴发生变化的情况。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/bS0yLoP.png">https://search.pstatic.net/common?src=https://i.imgur.com/bS0yLoP.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="rotational-inertia"><a class="anchor" href="#rotational-inertia">#</a> Rotational Inertia</h3>
<p>** 转动惯量 (rotational inertia)** 类似于质量，它描述了刚体抵抗旋转的能力。转动惯量与质量的一大区别在于转动惯量不是一个常数而是一个张量 (矩阵)，当刚体的朝向发生改变时需要利用旋转矩阵来计算当前姿态下的转动惯量；同时转动惯量也与刚体上的质量分布密切相关。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/4Bqa8Ec.png">https://search.pstatic.net/common?src=https://i.imgur.com/4Bqa8Ec.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/3RwVNDp.png">https://search.pstatic.net/common?src=https://i.imgur.com/3RwVNDp.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="angular-momentum"><a class="anchor" href="#angular-momentum">#</a> Angular Momentum</h3>
<p>** 角动量 (angular momentum)** 则描述了刚体旋转的状态，它是转动惯量与角速度的乘积。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/XrraRKH.png">https://search.pstatic.net/common?src=https://i.imgur.com/XrraRKH.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="torque"><a class="anchor" href="#torque">#</a> Torque</h3>
<p>当外力不通过刚体的质心时会产生<strong>力矩 (torque)</strong>，从而导致刚体发生旋转。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/XiK4Efj.png">https://search.pstatic.net/common?src=https://i.imgur.com/XiK4Efj.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在质点动力学的基础上把旋转部分也考虑进来对物体的运动状态进行更新就得到了刚体动力学的仿真方法。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/3eCei78.png">https://search.pstatic.net/common?src=https://i.imgur.com/3eCei78.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="applicationbilliard-dynamics"><a class="anchor" href="#applicationbilliard-dynamics">#</a> Application：Billiard Dynamics</h3>
<p>以台球游戏模拟为例，我们假设台球自身与桌面没有摩擦，这样台球的运动可以简化为二维平面运动。在进行仿真时需要把球杆给予台球的力 (冲量) 移动到球心来计算台球沿球杆方向的速度；同时这种移动还会对台球施加一个力矩使台球产生旋转，因此也需要更新台球的角速度。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/fxJYjLJ.png">https://search.pstatic.net/common?src=https://i.imgur.com/fxJYjLJ.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="collision-detection"><a class="anchor" href="#collision-detection">#</a> Collision Detection</h2>
<p>在进行刚体仿真时我们需要考虑不同刚体之间的相互作用，也即所谓的碰撞问题。要求解碰撞问题的第一步是对刚体碰撞进行检测，目前在物理引擎中注意是使用两阶段的检测方法。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/mqBFg6T.png">https://search.pstatic.net/common?src=https://i.imgur.com/mqBFg6T.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/D54gen6.png">https://search.pstatic.net/common?src=https://i.imgur.com/D54gen6.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="broad-phase"><a class="anchor" href="#broad-phase">#</a> Broad Phase</h3>
<p>显然场景中大部分的物体是不会同时发生接触的，因此所谓的 broad phase 就是只利用物体的 bounding box 来快速筛选出可能发生碰撞的物体。目前物理引擎中常用的碰撞检测包括<strong>空间划分 (space partitioning)<strong> 以及</strong> sort and sweep</strong> 两类方法。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/CbCNGlM.png">https://search.pstatic.net/common?src=https://i.imgur.com/CbCNGlM.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h4 id="bvh-tree"><a class="anchor" href="#bvh-tree">#</a> BVH Tree</h4>
<p>我们在介绍渲染技术时就介绍过空间划分的相关概念，它的思想是把场景中的物体使用一个树状的数据结构进行管理从而加速判断物体是否相交的过程。BVH 是空间划分的经典算法，它使用一棵二叉树来管理场景中所有物体的 bounding box。BVH 的特点是它可以通过动态更新节点来描述场景中物体的变化，因此可以快速地检测场景中的 bounding box 可能存在的碰撞。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/BTn69Gr.png">https://search.pstatic.net/common?src=https://i.imgur.com/BTn69Gr.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/GU83kZ1.png">https://search.pstatic.net/common?src=https://i.imgur.com/GU83kZ1.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h4 id="sort-and-sweep"><a class="anchor" href="#sort-and-sweep">#</a> Sort and Sweep</h4>
<p>sort and sweep 是使用排序来检测碰撞的算法。它的思想非常直观：对于使用 AABB 进行表示的 bounding box，两个 bounding box 出现碰撞时必然会导致它们的边界产生了重叠，而判断是否出现重叠则可以通过对 bounding box 的边界进行排序来进行计算。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/OPbcj3y.png">https://search.pstatic.net/common?src=https://i.imgur.com/OPbcj3y.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/fhDlpvI.png">https://search.pstatic.net/common?src=https://i.imgur.com/fhDlpvI.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="narrow-phase"><a class="anchor" href="#narrow-phase">#</a> Narrow Phase</h3>
<p>筛选出可能发生碰撞的物体后就需要对它们进行实际的碰撞检测，这个阶段称为 narrow phase。除了进一步判断刚体是否相交外，在 narrow phase 中一般还需要去计算交点、相交深度以及方向等信息。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/tvh33wy.png">https://search.pstatic.net/common?src=https://i.imgur.com/tvh33wy.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>目前在 narrow phase 中一般会使用相交测试、Minkowski 距离以及分离轴等方法。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/KxjbSBY.png">https://search.pstatic.net/common?src=https://i.imgur.com/KxjbSBY.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h4 id="basic-shape-intersection-test"><a class="anchor" href="#basic-shape-intersection-test">#</a> Basic Shape Intersection Test</h4>
<p>对于一些简单的几何形状可以使用解析的方法来判断它们是否相交并且计算交点的信息。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/jdQ6Q0i.png">https://search.pstatic.net/common?src=https://i.imgur.com/jdQ6Q0i.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/P2BCxgg.png">https://search.pstatic.net/common?src=https://i.imgur.com/P2BCxgg.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/YxlKkkm.png">https://search.pstatic.net/common?src=https://i.imgur.com/YxlKkkm.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h4 id="minkowski-difference-based-methods"><a class="anchor" href="#minkowski-difference-based-methods">#</a> Minkowski Difference-based Methods</h4>
<p>对于凸多边形的情况则可以使用 **Minkowski 差异 (Minkowski distance)<strong> 来判断它们是否相交。在介绍 Minkowski 距离之前首先要引入</strong> Minkowski 和 (Minkowski sum)** 的概念：对于两个点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，它们的 Minkowski 和定义为两个集合中任意一对矢量相加后得到的新的点集。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/35TVcQX.png">https://search.pstatic.net/common?src=https://i.imgur.com/35TVcQX.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/y3nee7s.png">https://search.pstatic.net/common?src=https://i.imgur.com/y3nee7s.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/d4a88wl.png">https://search.pstatic.net/common?src=https://i.imgur.com/d4a88wl.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/OojulLx.png">https://search.pstatic.net/common?src=https://i.imgur.com/OojulLx.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>对于凸多边形，它们的 Minkowski 和也必为一个凸多边形，而且这个新多边形的顶点也是原始多边形顶点的和。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/2rfDCYz.png">https://search.pstatic.net/common?src=https://i.imgur.com/2rfDCYz.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>在此基础上我们定义点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的 Minkowski 差异为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">-B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 的 Minkowski 和，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊖</mo><mi>B</mi><mo>=</mo><mi>A</mi><mo>⊕</mo><mo stretchy="false">(</mo><mo>−</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \ominus B = A \oplus (-B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊖</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/7SjNI4Y.png">https://search.pstatic.net/common?src=https://i.imgur.com/7SjNI4Y.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>可以证明当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 相交时，原点必位于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊖</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \ominus B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊖</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 中。这样判断两个凸多边形是否相交的问题就转化为判断原点是否位于凸多边形<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊖</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \ominus B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊖</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 中的问题，这种问题一般可以使用 GJK 算法来求解。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/6Ei7LyQ.png">https://search.pstatic.net/common?src=https://i.imgur.com/6Ei7LyQ.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>GJK 算法的主要流程如下：</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/SjZ3MV1.png">https://search.pstatic.net/common?src=https://i.imgur.com/SjZ3MV1.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/kyRrnrg.png">https://search.pstatic.net/common?src=https://i.imgur.com/kyRrnrg.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/9bV8uAH.png">https://search.pstatic.net/common?src=https://i.imgur.com/9bV8uAH.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/UZUcRfZ.png">https://search.pstatic.net/common?src=https://i.imgur.com/UZUcRfZ.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/i8bw17o.png">https://search.pstatic.net/common?src=https://i.imgur.com/i8bw17o.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>当 GJK 算法判断出两个凸多边形相交后还可以进一步计算交点以及深度等信息。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/gmOENC1.png">https://search.pstatic.net/common?src=https://i.imgur.com/gmOENC1.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/2mf7Jtd.png">https://search.pstatic.net/common?src=https://i.imgur.com/2mf7Jtd.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/XZA74cV.png">https://search.pstatic.net/common?src=https://i.imgur.com/XZA74cV.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h4 id="separating-axis-theorem"><a class="anchor" href="#separating-axis-theorem">#</a> Separating Axis Theorem</h4>
<p>** 分离轴定理 (separating axis theorem, SAT)** 同样是一种计算凸多边形相交的算法，它的思想是平面上任意两个互不相交的图形我们必然可以找到一条直线将它们分隔在两端。对于凸多边形还可以进一步证明必然存在以多边形顶点定义的直线来实现这样的分隔，因此判断凸多边形相交就等价于寻找这样的分隔直线。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/M7bO9gx.png">https://search.pstatic.net/common?src=https://i.imgur.com/M7bO9gx.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/G5cTsoH.png">https://search.pstatic.net/common?src=https://i.imgur.com/G5cTsoH.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/38sHteu.png">https://search.pstatic.net/common?src=https://i.imgur.com/38sHteu.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>使用 SAT 判断凸多边形是否相交时需要分别对两个图形的边进行遍历，然后判断另一个图形上的每个顶点是否落在边的同一侧。只要发现存在一条边可以分隔两个图形即说明它们互不相交，否则继续遍历直到用尽所有的边，此时两个图形必然是相交的。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/UhbV4EU.png">https://search.pstatic.net/common?src=https://i.imgur.com/UhbV4EU.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/MxNpdwC.png">https://search.pstatic.net/common?src=https://i.imgur.com/MxNpdwC.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>当图形的位置发生变化时还可以从上一次检测得到的分离轴开始重新进行检测，这样可以进一步提高算法的效率。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/BtCn8ib.png">https://search.pstatic.net/common?src=https://i.imgur.com/BtCn8ib.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>对于三维图形的情况则不仅需要考虑面和面的分隔关系，还要考虑边和边的分隔关系。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/uBGMWHF.png">https://search.pstatic.net/common?src=https://i.imgur.com/uBGMWHF.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="collision-resolution"><a class="anchor" href="#collision-resolution">#</a> Collision Resolution</h2>
<p>完成碰撞检测后就需要对发生碰撞的刚体进行处理，使它们相互分开。目前刚体的碰撞主要有三种处理思路，分别是 penalty force、velocity constraints 以及 position constraints，本节课我们主要介绍前两种处理方法。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/izyNrfE.png">https://search.pstatic.net/common?src=https://i.imgur.com/izyNrfE.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/af5kMU1.png">https://search.pstatic.net/common?src=https://i.imgur.com/af5kMU1.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="applying-penalty-force"><a class="anchor" href="#applying-penalty-force">#</a> Applying Penalty Force</h3>
<p><strong>penalty force</strong> 是最直观的碰撞处理方法，它的思想是当两个物体相交后沿反方向分别施加一个排斥力把它们推开。这种方法要求设置比较大的排斥力以及很小的积分时间间隔，否则容易出现非常不符合直觉的碰撞效果，因此现代物理引擎中几乎不会使用 penalty force 来处理刚体碰撞问题。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/P9yMWHK.png">https://search.pstatic.net/common?src=https://i.imgur.com/P9yMWHK.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="solving-velocity-constraints"><a class="anchor" href="#solving-velocity-constraints">#</a> Solving Velocity Constraints</h3>
<p>目前物理引擎中主流的刚体碰撞处理算法是基于 Lagrangian 力学的求解方法，它会把刚体之间的碰撞和接触转换为系统的约束，然后求解约束优化问题。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/tosTRin.png">https://search.pstatic.net/common?src=https://i.imgur.com/tosTRin.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/ucyeaYT.png">https://search.pstatic.net/common?src=https://i.imgur.com/ucyeaYT.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/o3XzgqS.png">https://search.pstatic.net/common?src=https://i.imgur.com/o3XzgqS.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="scene-query"><a class="anchor" href="#scene-query">#</a> Scene Query</h2>
<p>除了上面介绍过的内容外，在游戏中我们往往还需要对场景中的物体进行一些查询，这些查询操作也需要物理引擎的支持。</p>
<h3 id="raycast"><a class="anchor" href="#raycast">#</a> Raycast</h3>
<p><strong>raycast</strong> 是非常基本的查询操作，我们希望能够获取某条射线在场景中击中的物体。实际上在光线追踪中就大量使用了 raycast 的相关操作，而在物理引擎中 raycast 也有大量的应用，比如说子弹击中目标就是使用 raycast 来实现的。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/iMFQdMo.png">https://search.pstatic.net/common?src=https://i.imgur.com/iMFQdMo.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/pjDUDRG.png">https://search.pstatic.net/common?src=https://i.imgur.com/pjDUDRG.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/vv4M7iu.png">https://search.pstatic.net/common?src=https://i.imgur.com/vv4M7iu.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="sweep"><a class="anchor" href="#sweep">#</a> Sweep</h3>
<p><strong>sweep</strong> 与 raycast 类似，不过在 sweep 中需要使用有一定几何形态的物体取击中场景中的其它物体。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/YuM4lA0.png">https://search.pstatic.net/common?src=https://i.imgur.com/YuM4lA0.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/VqGbEOV.png">https://search.pstatic.net/common?src=https://i.imgur.com/VqGbEOV.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="overlap"><a class="anchor" href="#overlap">#</a> Overlap</h3>
<p>另一种常用的操作是<strong> overlap</strong>，此时我们需要判断场景中的物体是否位于某个几何形状中。overlap 与碰撞检测非常类似，不过 overlap 一般只会使用简单的几何体来进行检测。像游戏中爆炸效果的检测就是使用 overlap 来实现的。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/B2mIhJY.png">https://search.pstatic.net/common?src=https://i.imgur.com/B2mIhJY.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/udCfXRz.png">https://search.pstatic.net/common?src=https://i.imgur.com/udCfXRz.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="collision-group"><a class="anchor" href="#collision-group">#</a> Collision Group</h3>
<p>在物理引擎中还需要额外注意对场景中的物体进行分组，这样可以提高各种物理仿真算法的效率。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/3uu4yB2.png">https://search.pstatic.net/common?src=https://i.imgur.com/3uu4yB2.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h2 id="efficiency-accuracy-and-determinism"><a class="anchor" href="#efficiency-accuracy-and-determinism">#</a> Efficiency, Accuracy, and Determinism</h2>
<p>本节课最后讨论了物理仿真中的一些其它技巧。</p>
<h3 id="simulation-optimization"><a class="anchor" href="#simulation-optimization">#</a> Simulation Optimization</h3>
<p>我们知道物理仿真是极其消耗计算资源的，如果在所有时刻都对场景中的物体进行模拟会造成计算资源的浪费。因此一种常用的手段是把场景中的物体划分为若干个 island，当 island 内没有外力作用时就对它们进行休眠，这样就可以节约计算资源。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/CQkD7Sl.png">https://search.pstatic.net/common?src=https://i.imgur.com/CQkD7Sl.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/JQrKbtm.png">https://search.pstatic.net/common?src=https://i.imgur.com/JQrKbtm.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="continuous-collision-detection"><a class="anchor" href="#continuous-collision-detection">#</a> Continuous Collision Detection</h3>
<p>当物体运动的速度过快时可能会出现一个物体之间穿过另一个物体的现象，此时可以使用 CCD 的相关方法来进行处理。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/7kE1JVx.png">https://search.pstatic.net/common?src=https://i.imgur.com/7kE1JVx.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/nljc4CS.png">https://search.pstatic.net/common?src=https://i.imgur.com/nljc4CS.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/8yp0TpG.png">https://search.pstatic.net/common?src=https://i.imgur.com/8yp0TpG.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/1ntB36F.png">https://search.pstatic.net/common?src=https://i.imgur.com/1ntB36F.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<h3 id="deterministic-simulation"><a class="anchor" href="#deterministic-simulation">#</a> Deterministic Simulation</h3>
<p>在进行物理仿真时还需要考虑仿真结果的确定性。尽管在编程时我们使用的都是同一套物理定律，在程序运行阶段由于帧率、计算顺序以及浮点数精度等问题容易出现同一个场景在不同终端上产生不同的模拟结果。</p>
<p>&lt;div align=center&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/eh7I1IX.png">https://search.pstatic.net/common?src=https://i.imgur.com/eh7I1IX.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;img src=&quot;<a target="_blank" rel="noopener" href="https://search.pstatic.net/common?src=https://i.imgur.com/XD9JJJZ.png">https://search.pstatic.net/common?src=https://i.imgur.com/XD9JJJZ.png</a>&quot; width=&quot;80%&quot;&gt;<br />
&lt;/div&gt;</p>
<p>总而言之，物理仿真仍然是比较困难的。在现代游戏引擎中还有很多开放问题待我们进行解决。</p>
<h2 id="reference"><a class="anchor" href="#reference">#</a> Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16U4y117VU/?spm_id_from=333.788">Lecture 10：Physics System – Basic Concepts</a></li>
</ul>
<div class="tags"><a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" rel="tag"><i class="ic i-tag"></i>游戏引擎</a></div></div><footer><div class="meta"><span class="icon"><i class="ic i-eye"></i></span><span>此文章已被阅读次数:</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2023/06/26/game-engine/games104系列笔记（十）/">正在加载...</span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2024-03-13 00:01:09" itemprop="dateModified" datetime="2024-03-13T00:01:09+08:00">2024-03-13</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/bitcoin.png" alt="Sakura 比特币"/><p>比特币</p></div><div><img loading="lazy" data-src="/assets/monero.png" alt="Sakura monero"/><p>monero</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>Sakura<i class="ic i-at"><em>@</em></i>Sakura</li><li class="link"><strong>本文链接：</strong><a href="https://sakurame.eu.org/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/" title="games104系列笔记（十）">https://sakurame.eu.org/2023/06/26/game-engine/games104系列笔记（十）/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;ptpimg.me&#x2F;56p569.jpg" title="games104系列笔记（九）"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>游戏引擎实践</span><h3>games104系列笔记（九）</h3></a></div><div class="item right"><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;ptpimg.me&#x2F;56p569.jpg" title="games104系列笔记（十一）"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>游戏引擎实践</span><h3>games104系列笔记（十一）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">1.</span> <span class="toc-text"> Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#physics-actors-and-shapes"><span class="toc-number">2.</span> <span class="toc-text"> Physics Actors and Shapes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#actor"><span class="toc-number">2.1.</span> <span class="toc-text"> Actor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#actor-shapes"><span class="toc-number">2.2.</span> <span class="toc-text"> Actor Shapes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shape-properties"><span class="toc-number">2.3.</span> <span class="toc-text"> Shape Properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forces-and-movements"><span class="toc-number">3.</span> <span class="toc-text"> Forces and Movements</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forces"><span class="toc-number">3.1.</span> <span class="toc-text"> Forces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#movements"><span class="toc-number">3.2.</span> <span class="toc-text"> Movements</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rigid-body-dynamics"><span class="toc-number">4.</span> <span class="toc-text"> Rigid Body Dynamics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#orientation"><span class="toc-number">4.1.</span> <span class="toc-text"> Orientation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#angular-velocity"><span class="toc-number">4.2.</span> <span class="toc-text"> Angular Velocity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#angular-acceleration"><span class="toc-number">4.3.</span> <span class="toc-text"> Angular Acceleration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rotational-inertia"><span class="toc-number">4.4.</span> <span class="toc-text"> Rotational Inertia</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#angular-momentum"><span class="toc-number">4.5.</span> <span class="toc-text"> Angular Momentum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#torque"><span class="toc-number">4.6.</span> <span class="toc-text"> Torque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicationbilliard-dynamics"><span class="toc-number">4.7.</span> <span class="toc-text"> Application：Billiard Dynamics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collision-detection"><span class="toc-number">5.</span> <span class="toc-text"> Collision Detection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#broad-phase"><span class="toc-number">5.1.</span> <span class="toc-text"> Broad Phase</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bvh-tree"><span class="toc-number">5.1.1.</span> <span class="toc-text"> BVH Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-and-sweep"><span class="toc-number">5.1.2.</span> <span class="toc-text"> Sort and Sweep</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#narrow-phase"><span class="toc-number">5.2.</span> <span class="toc-text"> Narrow Phase</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#basic-shape-intersection-test"><span class="toc-number">5.2.1.</span> <span class="toc-text"> Basic Shape Intersection Test</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#minkowski-difference-based-methods"><span class="toc-number">5.2.2.</span> <span class="toc-text"> Minkowski Difference-based Methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#separating-axis-theorem"><span class="toc-number">5.2.3.</span> <span class="toc-text"> Separating Axis Theorem</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collision-resolution"><span class="toc-number">6.</span> <span class="toc-text"> Collision Resolution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#applying-penalty-force"><span class="toc-number">6.1.</span> <span class="toc-text"> Applying Penalty Force</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solving-velocity-constraints"><span class="toc-number">6.2.</span> <span class="toc-text"> Solving Velocity Constraints</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scene-query"><span class="toc-number">7.</span> <span class="toc-text"> Scene Query</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#raycast"><span class="toc-number">7.1.</span> <span class="toc-text"> Raycast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sweep"><span class="toc-number">7.2.</span> <span class="toc-text"> Sweep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlap"><span class="toc-number">7.3.</span> <span class="toc-text"> Overlap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collision-group"><span class="toc-number">7.4.</span> <span class="toc-text"> Collision Group</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#efficiency-accuracy-and-determinism"><span class="toc-number">8.</span> <span class="toc-text"> Efficiency, Accuracy, and Determinism</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#simulation-optimization"><span class="toc-number">8.1.</span> <span class="toc-text"> Simulation Optimization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#continuous-collision-detection"><span class="toc-number">8.2.</span> <span class="toc-text"> Continuous Collision Detection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deterministic-simulation"><span class="toc-number">8.3.</span> <span class="toc-text"> Deterministic Simulation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">9.</span> <span class="toc-text"> Reference</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/" rel="bookmark" title="游戏引擎架构（开坑）">游戏引擎架构（开坑）</a></li><li ><a href="/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/" rel="bookmark" title="games104笔记">games104笔记</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="bookmark" title="games104系列笔记（一）">games104系列笔记（一）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="bookmark" title="games104系列笔记（二）">games104系列笔记（二）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" rel="bookmark" title="games104系列笔记（三）">games104系列笔记（三）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" rel="bookmark" title="games104系列笔记（四）">games104系列笔记（四）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" rel="bookmark" title="games104系列笔记（五）">games104系列笔记（五）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/" rel="bookmark" title="games104系列笔记（六）">games104系列笔记（六）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/" rel="bookmark" title="games104系列笔记（七）">games104系列笔记（七）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/" rel="bookmark" title="games104系列笔记（八）">games104系列笔记（八）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/" rel="bookmark" title="games104系列笔记（九）">games104系列笔记（九）</a></li><li  class="active"><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/" rel="bookmark" title="games104系列笔记（十）">games104系列笔记（十）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/" rel="bookmark" title="games104系列笔记（十一）">games104系列笔记（十一）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/" rel="bookmark" title="games104系列笔记（十二）">games104系列笔记（十二）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/" rel="bookmark" title="games104系列笔记（十三）">games104系列笔记（十三）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/" rel="bookmark" title="games104系列笔记（十四）">games104系列笔记（十四）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/" rel="bookmark" title="games104系列笔记（十五）">games104系列笔记（十五）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/" rel="bookmark" title="games104系列笔记（十六）">games104系列笔记（十六）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/" rel="bookmark" title="games104系列笔记（十七）">games104系列笔记（十七）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/" rel="bookmark" title="games104系列笔记（十八）">games104系列笔记（十八）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/" rel="bookmark" title="games104系列笔记（十九）">games104系列笔记（十九）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/" rel="bookmark" title="games104系列笔记（二十）">games104系列笔记（二十）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%B8%80%EF%BC%89/" rel="bookmark" title="games104系列笔记（二一）">games104系列笔记（二一）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89/" rel="bookmark" title="games104系列笔记（二二）">games104系列笔记（二二）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="Sakura" src="/assets/avatar.jpg"/><p class="name" itemprop="name">Sakura</p><div class="description" itemprop="description">一个专注于技术和思考分享的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">77</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">25</span><span class="name">标签</span></a></div></nav><div class="social"><a href="mailto:mail@sakurame.eu.org" class="item email" title="mailto:mail@sakurame.eu.org"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li><li class="item"><a href="/privacy/" rel="section"><i class="ic i-user"></i>隐私政策</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-sakura"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/privacy/" title="分类于隐私保护指北">隐私保护指北</a></div><span><a href="/2024/03/14/privacy/Canokey%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97-%E6%8C%81%E7%BB%AD%E8%B8%A9%E5%9D%91%E4%B8%AD/">Canokey不完全食用指南--持续踩坑中</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/">games104系列笔记（八）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/09/17/hello-world/">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/privacy/" title="分类于隐私保护指北">隐私保护指北</a></div><span><a href="/2023/06/09/privacy/the-pgp-problem/">the-pgp-problem</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2023/07/11/basic-theory/A-Topologically-Informed-Hyperstreamline/">A_Topologically-Informed_Hyperstreamline</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/privacy/" title="分类于隐私保护指北">隐私保护指北</a></div><span><a href="/2023/05/25/privacy/%E9%9A%90%E7%A7%81%E4%BF%9D%E6%8A%A4%E6%8C%87%E5%8D%97%EF%BC%88%E9%95%BF%E6%9C%9F%E7%BF%BB%E8%AF%91%E9%A1%B9%E7%9B%AE%EF%BC%89/">隐私保护指南（长期翻译项目）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2023/08/10/basic-theory/A-Flow-guided-Streamline-Seeding-Strategy/">A_Flow-guided_Streamline_Seeding_Strategy</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/thinking/" title="分类于思考随笔记录">思考随笔记录</a></div><span><a href="/2023/08/28/thinking/united-93%E4%B9%8B%E6%80%9D/">united_93之思</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2023/08/17/basic-theory/Methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3D-seismic-images/">Methods_to_compute_fault_images_extract_fault_surfaces_and_estimate_fault_throws_from_3D_seismic_images</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/">games104系列笔记（十一）</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">Sakura @ Sakura's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.6m 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">24:12</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div><br/><span style="display:inline;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:var(--grey-5);"><a target="_blank" href="https://icp.gov.moe/?keyword=20233555">萌ICP备20233555号 </a><br/><a target="_blank" href="https://beian.mps.gov.cn/#/query/webSearch?code=能躺在床上摸鱼摆烂是一天中最幸福的时刻"><img loading="lazy" decoding="async" data-src="/assets/search.png" style="max-width: 2em;display:inline;" width="20" height="20" alt="备案"/>能躺在床上摸鱼摆烂是一天中最幸福的时刻</a></span><div style="width: 100%;text-align:center;"><span id="time"></span></div><script>function createtime() {
    const n = new Date("2023/04/23 00:00:00");
    now.setTime(now.getTime() + 250), days = (now - n) / 1e3 / 60 / 60 / 24, dnum = Math.floor(days), hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum, hnum = Math.floor(hours), 1 == String(hnum).length && (hnum = "0" + hnum), minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum, mnum = Math.floor(minutes), 1 == String(mnum).length && (mnum = "0" + mnum), seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum, snum = Math.round(seconds), 1 == String(snum).length && (snum = "0" + snum), document.getElementById("time").innerHTML = "小破站已经在风雨飘摇中苟活" + dnum + " 天 " + hnum + " 小时 " + mnum + " 分 " + snum + " 秒"
}

const now = new Date;
setInterval("createtime()", 250)</script></div><div class="deng-box"><div class="deng"><div class="xian"></div><div class="deng-a"><div class="deng-b"><div class="deng-t">一</div></div></div><div class="shui shui-a"><div class="shui-c"></div><div class="shui-b"></div></div></div></div><div class="deng-box1"><div class="deng"><div class="xian"></div><div class="deng-a"><div class="deng-b"><div class="deng-t">十</div></div></div><div class="shui shui-a"><div class="shui-c"></div><div class="shui-b"></div></div></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2023/06/26/game-engine/games104系列笔记（十）/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0&amp;features=default,fetch" defer></script><script src="/js/siteInit.js?v=0.4.11" type="module" fetchpriority="high" defer></script></body></html>