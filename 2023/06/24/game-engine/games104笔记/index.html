<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="Sakura" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Sakura" type="application/atom+xml"><link rel="alternate" type="application/json" title="Sakura" href="https://sakurame.eu.org/feed.json"/><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"/><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"/><link rel="dns-prefetch" href="https://unpkg.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.3.6"><script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.js"></script><link rel="stylesheet" href="/css/twikoo.css?v=0.3.6"><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.40/dist/twikoo.all.min.js"></script><meta name="keywords" content="游戏引擎"/><link rel="canonical" href="https://sakurame.eu.org/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/"><title>games104笔记</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">games104笔记</h1><div class="meta"><span class="item" title="创建时间：2023-06-24 13:50:39"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-06-24T13:50:39+08:00">2023-06-24</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>32k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>29 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sakura's Blog</a></li></ul><ul class="right" id="rightNav"><li class="item theme" @click="changeThemeByBtn"><i class="ic" :class="{'i-sun': !themeStatus,'i-moon': themeStatus}"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" data-background-image="https://ptpimg.me/623909.jpg"></li><li class="item" data-background-image="https://ptpimg.me/949571.jpg"></li><li class="item" data-background-image="https://ptpimg.me/46g25q.jpg"></li><li class="item" data-background-image="https://ptpimg.me/763frg.jpg"></li><li class="item" data-background-image="https://ptpimg.me/p4z097.jpg"></li><li class="item" data-background-image="https://ptpimg.me/u3j8yl.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/game-engine/" itemprop="item" rel="index" title="分类于游戏引擎实践"><span itemprop="name">游戏引擎实践<meta itemprop="position" content="0"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sakurame.eu.org/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="Sakura"/><meta itemprop="description" content=", 一个专注于技术和思考分享的博客"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura"/></span><div class="body md" itemprop="articleBody"><h3 id="一-games104的几个主要点"><a class="anchor" href="#一-games104的几个主要点">#</a> 一、 games104 的几个主要点</h3>
<ol>
<li>basic elements，讲清楚游戏有几层，怎么入手，都有哪些模块</li>
<li>渲染系统，怎么把那么多渲染相关的 texture、material、model 拼在一起，偏工程化</li>
<li>动画系统</li>
<li>物理系统</li>
<li>gameplay，事件系统、脚本系统、怎么做图形化</li>
<li>特效系统，例如烟等、AI 系统、相机系统</li>
<li>工具链，例如反射、数据格式（数据格式兼容等）</li>
<li>网络同步（状态同步、帧同步）</li>
<li>相对前沿的概念（Motion Matching、PCG、DOP（面向数据的编程）、job system、luman、nanite 等）</li>
</ol>
<p>游戏引擎和工业软件例如 CAD、建筑软件等有很多共通点，但是每个引擎都会根据自己的需求做定制 游戏引擎仍然是跑的最远的，因为在商业上被充分竞争。</p>
<h3 id="二-游戏引擎架构"><a class="anchor" href="#二-游戏引擎架构">#</a> 二、游戏引擎架构</h3>
<p>工具层、功能层（动画、绘制、物理、脚本等）、资源层、核心层（工具箱）、平台层（主要是做跨平台的，输入设备（鼠标手表等），操作系统上，硬件平台等）、第三方组件层（Physx、音乐库等）</p>
<p>资源层会把所有的格式都转换成引擎自己的格式，这种格式通常是 GPU 高效的，也会把那些无效的信息给扔掉。 现代游戏引擎中，最核心的功能是数据资源之间的关联（reference） GUID: 每一个资产的唯一识别号。 handle 系统：是每一个资产的管理，看这个资源还是否存在， GC 系统：基本上掉帧的大部分原因都是 GC 资源加载和卸载：在游戏过程中，资源是实时的加载和卸载的。 延迟加载：先加载一些模糊的贴图，粗糙的物体，等一阵子再加载细节较多的资源。 tick：每帧都需要更新的内容：一般先 ticklogic，再去 tickrender。 function 层（功能层）：并行计算 core 层：数学库，矩阵加减乘除、数据结构（数组、链表、二叉树等，这一部分要引擎自己写，如果不自己写会产生很多内存碎片）、内存管理 CPU 的缓存经常是游戏的卡点（想起来苹果的 CPU 缓存就比较大） 平台层：不同平台的路径（反斜杠，回车符）等都不同、mac 上用的是 metal，windows 用的是 dx 等，要用 RHI 给他全屏蔽掉。硬件架构不同，如果想要把各个平台的特性都用起来，也是一个很麻烦的 越底层的代码越稳定，稳定以后可能几年都不会改，例如 platform 和 core 层</p>
<h3 id="三-如何构建游戏世界"><a class="anchor" href="#三-如何构建游戏世界">#</a> 三、如何构建游戏世界</h3>
<p>物体分为动态物、静态物、还有环境 也可以分为属性和行为。</p>
<p>一开始游戏引擎是面向对象的游戏引擎，但是有些物体是较难区分福字关系的，例如军舰继承自船，坦克继承自车，但是水陆两栖登陆艇就很难继承了。因此就有了 ECS，是 Component Base 的思想，把枪拆成多个组件，例如消音器、瞄准镜等，也可以把 AI 模块、模型模块、物理模块、旋转变换等都变成组件。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/components_in_unity_and_unreal.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/components_in_unity_and_unreal.png" alt="商业引擎的component" /></a></p>
<p>游戏世界由 GameObject 组成，而每一个 GO 都是由 Components 组成</p>
<p>event 机制就是观察者模式，当事件发生时，告知所有注册过的 component</p>
<p>世界场景分为多个 cell，划分了很多格子，当场景分布不均匀时，格子也是不均匀的。而且格子是一种二叉树式的 hierarchy 式的管理方式。</p>
<p>event 系统需要保证消息发送是又先后顺序的，因此需要有一个 “邮局系统”，所有的消息都会发送到这个邮局，然后再由邮局系统第二天发送给目标 object</p>
<ol>
<li>everything is an object</li>
<li>gameobject 由 component 组成</li>
<li>gameobject 的状态是通过 tick loop 来更新的</li>
<li>game object 和其他对象交互的方式是通过 event 机制（观察者模式）</li>
<li>gameobject 是通过 hierarchy cell 来管理的。</li>
</ol>
<p>如果 tick 时间过长怎么办：一般会用 deferred tick，把爆炸的计算分散到各个帧里面算，做延迟 tick。 tick 时渲染线程和逻辑线程怎么同步：tickrender 主要做数据准备，ticklogic 会比 tickrender 早一些。</p>
<p>component 的缺点：如果只用组件的话效率会比较低，所以得把所有的 component 放在一起 tick。另外 component 之间也需要消息通讯。</p>
<p>event 怎么调试：不停地加 log。。。。 动画和物理相互影响时怎么处理：一开始用动画差值的方式，后面使用物理计算。因为物理计算相对复杂。动画插值相对快速，这样能保证效率和效果都还不错。</p>
<h3 id="四-游戏引擎的渲染实践"><a class="anchor" href="#四-游戏引擎的渲染实践">#</a> 四、游戏引擎的渲染实践</h3>
<p>游戏渲染的几个挑战：</p>
<ol>
<li>游戏场景是十分复杂的。</li>
<li>需要对现代的硬件架构十分熟悉，硬件架构</li>
<li>越来越高的帧率要求和分辨率，同时要求较快的绘制速度。</li>
<li>CPU、带宽和内存的限制</li>
</ol>
<p>渲染的 outline： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/render_outline.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/render_outline.png" alt="渲染的outline" /></a></p>
<p>texture sampling, 绘制一个像素点，需要采样两层 mipmap，每个 mipmap 采样 4 个像素点。</p>
<p>SIMD 和 SIMT：SIMD 是单指令多数据，例如计算 vec4 的加减法 SIMT 是单指令多线程，例如计算 100 次 vec4 的加减乘除，重要的是 100 次</p>
<p>为什么每个顶点都要有自己的 normal：因为形状边缘在插值的时候，可能会出现法线偏移的问题。</p>
<p>renderable 里面有 mesh、material、texture 和 shader，都是数据</p>
<p>而每个绘制物体（例如人）可能会用到很多材质，头的材质和身体的材质可能不同，因此引入了 submesh 的概念，每一个 submesh 都拥有自己的材质，存储的是 index 和 vertex、material 的 offset。 为了节省空间，引擎使用的是 pool，例如 material pool，然后每个 submesh 存储的都是 pool 中的索引。</p>
<p>因为切换 material 很费时间，所以游戏引擎会 sort 所有的材质，把相同材质放在一起绘制。</p>
<p>visibility culling 是对每一个物体计算 BBOX 或者 OBB，然后使用 BVH 加速结构，做层级剔除。因为 BVH 对动态物体比较友好，更新较快。</p>
<p>目前模型的表达正在从 model 变成 cluster-based mesh pipeline</p>
<p>radiance：辐射度，辐射出去的能量 irradiance：入射的能量</p>
<p>shader 管理：游戏引擎的 shader 数量会非常多，经常会有很多 ubershader，然后通过 uber 生成更多的可执行 shader。同时 ubershader 也会是跨平台的。</p>
<p>lightmap 是给整个场景的光照 pack 到一张大的 atlas 中，这个 lightmap 包含整个场景的 SH 所以通常会比较大。 而 lightprob 则是在 lightmap 上做进一步的改进，每一个 lightprob 都存着周围的光照信息。</p>
<p>而 IBL 则是给整个环境一个光照图，中间有一些 diffuse 的光照，也有一些 specular 的光照结果。</p>
<p>PBR MR 模型：相对更容易理解 PBR SG 模型：相对更灵活</p>
<h3 id="六-大气-地形和云"><a class="anchor" href="#六-大气-地形和云">#</a> 六、大气、地形和云</h3>
<p>地形渲染：使用 heightfield（等高图），然后用网格（meshgred）叠加高度图计算生成地形。但是这种方法很难</p>
<p>地形的 T Junction：当相邻的两个 mesh，其中有一个 mesh 的 LOD 高一些，另一个 LOD 低一些，导致两个 mesh 相接处无法紧密结合时，就会出现 T Junction，解决这个的办法只能是把另一块 mesh 也细分成和另一个相同的三角形、或者把比较细的那块 mesh stishing 到另一个 mesh 上，形成退化三角形。</p>
<p>使用 quad tree 来表示地形（而不是 triangle 的方法）</p>
<p>另一种表示地形的方法是使用纯三角形表达，因为 quad tree 的三角形数量太多了，而使用三角形则会使顶点数少一个数量级。</p>
<p>地形通常要和 hull shader、domain shader 等相关，现在升级成了 mesh shader</p>
<p>地形通常会用很多个 texture，用很多个 material，然后通过一个系数做插值，常用的方法是根据不同 texture 的 heightmap 来做插值，控制插值的系数。 有时候通常使用视差贴图来保证凹凸感。 目前地形渲染已经使用 virtual texture 一统天下了，VT 如果能喝 DMA 或者 DirectStorage 结合起来的话，texture 就可以不经过 CPU 和内存，直接加载到 GPU 然后解压到显存</p>
<p>另外整个场景在绘制的时候会遇到浮点数精度误差，导致会出现两个相距很近的物体 z 值会相互打架。好的解决办法是，把物体用 “相对于摄像机的距离” 进行渲染。</p>
<p>树和草的渲染：使用 billboard 再加上 decorator，让树和草显示出多样性。</p>
<p>一般 decals 也直接 bake 到 VT 上面了。</p>
<p>体积云：使用一张 weather texture，表示云的厚度，再添加 noise function，例如 perlin noise 或者 worley noise，这两个加起来就能做体积云了。然后使用 raymarching 的方法，去判断是否已经 git 到云，直到 hit 到云，以及什么时候走出云，然后在做云里面的累计。</p>
<h3 id="七-游戏中的渲染管线-后处理和其他的一切"><a class="anchor" href="#七-游戏中的渲染管线-后处理和其他的一切">#</a> 七、游戏中的渲染管线、后处理和其他的一切</h3>
<p>AO 的常用的算法：SSAO、HBAO、GTAO 和 RTAO</p>
<p>HeightFog 和 depth fog 现代游戏引擎用的是 Voxel based Volumetric Fog。 fog 3d texture 的分辨率是 160x90，是因为屏幕分辨率是 16x9</p>
<p>走样（Aliasing）分为好几种，一个是锯齿，另一个是高光的闪烁，还有就是 texture 采样精度不足导致的纹理扭曲。所有的 Aliasing 都是采样率不足导致的。应对方法是超采样。</p>
<p>bloom：解决的是光晕的问题 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/bloom.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/bloom.png" alt="bloom" /></a> tone Mapping：是为了解决曝光过亮或者曝光过暗的问题。相当于把 HDR 映射到 LDR 区域。ACES 则是一种调节过的 tone mapping 的曲线，效果更好，</p>
<p>color grading：有点像滤镜，通常使用 lut 实现，把颜色从一个颜色映射到另一种颜色。这个是提升游戏质量，效果最重要的后处理方式。 [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/color%20grading.png" alt="color grading" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvY29sb3I=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/color</span> grading.png)</p>
<p>frame graph 和 unity 的 SRP 一样，都是用来显示各个 renderpass 的前后依赖关系，从而让大家知道整个渲染流程是怎样的，有利于 debug</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/ue_render_pipeline.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/ue_render_pipeline.png" alt="ue5_render pipeline" /></a></p>
<h3 id="八-游戏引擎的动画系统"><a class="anchor" href="#八-游戏引擎的动画系统">#</a> 八、游戏引擎的动画系统</h3>
<p>视觉残留现象是游戏动画的基础。 2D 动画：就是一些图片拼接起来，如果想要流畅，则可以使用 2d 录制 3d 动画，然后抠图抠出来。</p>
<p>动画的挑战：动画的自然感、动画的计算效率、动画需要和玩家及时交互。</p>
<p>live2D：通过把一个人物拆分成多个组件，例如头发，眼睛，衣服等，然后把所有的图元生成一些控制网格，通过编辑这些控制网格来编辑 keyframe 动画。</p>
<p>3D 动画：顶点动画：把每一个顶点随着时间的变化存成一个动画，通常用于飘荡的旗帜等效果。这些动画数据一般存在一个 texture 上。叫做 vertex animation texture。</p>
<p>morph target animation：一般用于人脸的动画，一般蒙皮动画用在人脸上会很不自然，morph target animation 有几个关键点权重，然后通过 key poses 来插值。</p>
<p>2D skinned animation：类似 3d，把 2D 也通过骨骼来驱动</p>
<p>physics based animation：通过物理模拟动画中的衣料、IK 等。</p>
<p>为什么不用 T-Pose：因为 Tpose 会导致肩的地方精度不够，收到挤压</p>
<p>欧拉角的问题：必须要有 xyz 的旋转顺序</p>
<p>欧拉角导致的万向节：可以用来保证方向是稳定的。但是会导致坐标轴退化（x 和 y 轴共轴），另外是很难插值，真实世界也不会绕着 xyz 轴旋转，会沿着任意轴旋转。</p>
<p>四元数只能在三维空间中使用，可以使用群伦证明</p>
<p>动画压缩：因为每一帧都需要存储每一个 joint 的 scale、translation 和 rotation，如果游戏里有很多动画，则需要的存储空间是非常大的。这样是不可接受的，可行的办法就是，把 scale 都存成 1，trans 也都把不变的给删掉。 另一种办法就是，只存关键帧，计算关键帧插值出来的动画和原始动画做比较，如果小于一定阈值，则保存这个关键帧，这样保存出来的关键帧是非均匀的。</p>
<p>catmull-Rom 曲线：通过四个控制点，决定 P1 和 P2 之间的曲线，如下图所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/catmull-Rom%E6%9B%B2%E7%BA%BF.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/catmull-Rom%E6%9B%B2%E7%BA%BF.png" alt="catmull-Rom曲线" /></a> 动画压缩也可以通过缩减浮点数，使用 16bit 整数来表示浮点数。</p>
<p>但是动画压缩有一个问题，就是会导致末端骨骼的精度不够，所以需要用一个 error Compensation 来评估动画对精度的敏感度。</p>
<h3 id="九-高级动画技术"><a class="anchor" href="#九-高级动画技术">#</a> 九、高级动画技术</h3>
<p>动画状态机：action state machine，动画之间的切换需要使用插值，插值的方式有很多种插值曲线。不同的插值曲线的效果是不同的。</p>
<p>layered ASM：角色的上半身有一套状态机，角色的中间用一套状态机，下半身也有一套状态机。中间是分开的。而现代游戏引擎使用的是动画树（Animation Blend Tree) [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/action%20blend%20tree.png" alt="动画树" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYWN0aW9u">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/action</span> blend tree.png) 动画树就是 layered ASM 的超集，可以把所有的节点都按照树形结构结合在一起。UE 的动画树是做的相对比较好的。</p>
<p>IK：其实就是一个稳定三角形，计算膝盖处的位置，如下图所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/two_bone_IK.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/two_bone_IK.png" alt="two bone IK" /></a> 但是该方法求得的解空间是一个圆，所以需要美术给一个方向，最后的 IK 是在这个方向上得到最终的解。</p>
<p>Multi-Joint IK：相对比较难的，因为有无穷多解，需要依次做下面几个事情：</p>
<ol>
<li>先确定所有的骨骼长度能否达到目标点</li>
<li>确定所有的骨骼折了以后是否过长而无法达到目标点，如下所示 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/multi_joint_IK_liminate.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/multi_joint_IK_liminate.png" alt="multi-joint IK limit" /></a></li>
<li>根据人体每根骨骼的旋转约束，来保证 IK 的结算是自然的。 Heuristics Algorithm IK（例如 CCD IK）：具体思路就是从最末端节点沿着目标点做旋转，然后不断迭代。 但是只纯 IK 会有问题，可能最末端的骨骼弯曲的很严重，但是前面的骨骼还没弯曲就已经达到最后的结果了。所以 IK 最开始的时候会有一个圆圈确定大致范围，先做一次迭代，然后逐渐缩小圆圈半径，如下所示 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/CCD_IK.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/CCD_IK.png" alt="CCD_IK" /></a></li>
</ol>
<p>另一种 CCD_IK 的约束方法就是每一个骨骼都有一个最大旋转角度，保证旋转的角度不会过于畸形。</p>
<p>FABRIKF：是一种通过位移来最终达到效果的算法。该方法就是说，要先把末端骨骼直接通过平移和旋转挪到目标点上，然后再依次向上迭代。然后再把整个骨骼链反过来，先把头端骨骼连接到之前的骨骼圆点，再依次向末端骨骼移动迭代。反复迭代几次最终达到效果。 FABRIKF 也会出现骨骼约束的问题。也是会通过旋转角或者平移范围来做约束。</p>
<p>IK 存在多个末端节点：使用 jacobian 矩阵解决。</p>
<p>IK 目前存在的问题：</p>
<ol>
<li>自碰撞和自冲突</li>
<li>IK 无法提前预知，例如在遇到门或者小洞时，人需要提前蹲下，IK 无法做到</li>
<li>IK 无法做到人体自然的动作，</li>
</ol>
<p>整个动画管线如下所示： animation pipeline： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/animation_pipeline.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/animation_pipeline.png" alt="animation pipeline" /></a></p>
<p>Facial Action Unit：把人的表情归类到 46 类表情，因为很多表情是对称的，所以到最后归纳为 28 个常用的 AU。然后通过 blending 来表示动画。真实的 AU 保存的是一些表情某个区域相对于 neutral pose 的区别。从而可以对面部做局部控制</p>
<p>面部表情一般是通过 morth target animation + 蒙皮动画 蒙皮动画用来做眼睛移动等动作，morth target animation 用来模拟肌肉，或者通过 UV 来表示动画。</p>
<h3 id="十-物理系统的基础理论和算法"><a class="anchor" href="#十-物理系统的基础理论和算法">#</a> 十、物理系统的基础理论和算法</h3>
<p>游戏中的物体分为几类：</p>
<ol>
<li>静态 Actor：无法移动的例如墙，地板等</li>
<li>动态 actor：一些动态的物体，可以符合物理碰撞规律的，例如弹珠撞到了一个石头，石头会动。</li>
<li>trigger：当任何一个 acter 前面，其他的物体会作出相应的反应，例如自动门。</li>
<li>反物理规律的：例如人在推箱子，但是推力没有设置好，箱子一下子就飞出去了。或者是有一些游戏机关，地板在不断的上下移动。让玩家上去。</li>
</ol>
<p>Actor Shapes： 球（Spheres，用来表示球类物体，桌球等），胶囊（Capsules，用来表示人物）, 盒子（Box，一些相对复杂的形体，例如城墙），凸包（Convex Meshes，一般用来表示石头等）、三角形（Triangle Mesh，一般用来表示房子，动态物体一般不适用这个，因为复杂度太高）、高度图（Height Field，一般用来表示地形）</p>
<p>一个物体一般都要设置质量或者密度。 还需要指定质心位置。 物理材质：一般会设置一个物体表面的摩擦力数值、以及弹性值</p>
<p>游戏世界中的力：重力、拉力、摩擦力、冲力（Impulse，例如爆炸产生的力）</p>
<p>物理引擎中，力可能是会频繁发生变化的，例如一个小球在做圆周运动，但是因为引擎是按时间更新的，且更新的时候不知道这个圆会做圆周运动，所以给的力经常会慢一拍，从而导致圆周运动不收敛，如下图所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/euler_method.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/euler_method.png" alt="euler method" /></a> <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/forward_euler_method.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/forward_euler_method.png" alt="euler method" /></a></p>
<p>该问题的解决办法：隐式欧拉法：使用未来的力预测未来的位置，但是会导致能量衰减。在物理引擎里面能量衰减可解释（例如摩擦力） <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/implicit_euler_method.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/implicit_euler_method.png" alt="euler method" /></a></p>
<p>物理引擎更常用的方法是半隐式欧拉法 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/semi-implicit-Euler-method.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/semi-implicit-Euler-method.png" alt="semi-implicit-euler-method" /></a></p>
<p>刚体动力学：质量、速度、加速度、动量、 旋转 R（使用旋转矩阵或者四元数表达）、 角速度（Angular Velocity）在物体的任意一不通过轴心的点，然后这个点有一个切向速度，把这个点和轴连在一起形成了一个方向，使用右手法则做一个叉积，就可以得到旋转轴的方向。这样可以同时表达旋转轴、切向速度和旋转方向，如下所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/angular_velocity.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/angular_velocity.png" alt="angular velocity" /></a></p>
<p>角加速度（Angular Acceleration）角速度出于 dt 就是角加速度了。</p>
<p>转动惯量（Rotational Inertia）</p>
<p>角动量（Angular Momentum）角动量是守恒的，例如花样滑冰在旋转的时候，张开手转的慢。</p>
<p>力矩（Torque）：一个方向和叉乘一个力方向的轴，表示能够推动一个物体的力，通常在汽车中使用</p>
<p>碰撞检测：：</p>
<p>使用 BVH 快速检测碰撞 使用 sort and sweep 来做碰撞检测，该方法优势在于只要把物体都提前排序以后，只移动少部分物体，效率会非常高。 [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/broad%20phase%20sort%20and%20sweep.png" alt="broad phase sort and sweep" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYnJvYWQ=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/broad</span> phase sort and sweep.png)</p>
<p>物体求交： 圆、胶囊等求交相对简单 凸包的求交使用 Minkowski 和和 Minkowski difference 来判断。Minkowski difference 肯定会经过圆点，使用 GJK 算法找到圆点 另一种算法是通过判断是否存在一条边能把两个物体分开 [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/separating%20axis%20theorem2d.png" alt="separating axis" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvc2VwYXJhdGluZw==">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/separating</span> axis theorem2d.png)</p>
<p>碰撞检测后的处理：添加一个新的力。</p>
<p>物理引擎会对世界中的物体做分组。从而不管那些不受影响的组，从而加速计算。</p>
<p>CCD（continue collision Detection）连续性碰撞检测，类似原神须弥的 G 点</p>
<p>物理引擎的 deterministic：要求在不同的终端设备上，物理模拟出的效果是一致的，结果必须一致，否则会影响到玩家体验。包括浮点数误差等。</p>
<h3 id="十一-物理系统高级应用"><a class="anchor" href="#十一-物理系统高级应用">#</a> 十一、物理系统高级应用</h3>
<p>character controller： 主要是对角色做控制，一般把角色当成一个胶囊，或者两层胶囊（外层胶囊是防止角色距离墙壁太近导致看到墙壁后的东西。 再比如角色在走楼梯的时候，要提前将角色向上移动一个小距离 再比如角色在爬坡的时候，超过一定角度会先上去再掉下来。 再比如一个人在电梯上，当电梯下降的时候，人可能会发生抖动，这个时候的解决办法是把人和物体绑定到一起。</p>
<p>布娃娃系统（Ragdoll）：如果没有布娃娃系统 一个人在台阶上被打死，可能只播放骨骼动画，而没有掉下去的动画，上半身会悬空，闲得很假</p>
<p>布娃娃系统实现的方法就是把人体的主要骨骼标记出来，然后由 TA 对各个 joint 做约束。布娃娃系统是通过对各个 joint 做物理运算实现的。</p>
<p>在实际引擎中，一般是会把 ragdoll 和蒙皮动画放在一起做 blending 实现的。</p>
<p>衣料模拟：最开始的是通过骨骼来模拟和驱动衣料的动画。这样是比较快的。 另一种方法是通过 ragdoll 的方式，让几根骨骼驱动衣料，然后通过物理算骨骼的动画 效果最好的办法是基于 mesh 的衣料动画，physics mesh 一般会比 render mesh 稀疏很多，然后 render mesh 通过 physics mesh 插值生成。而且 physics mesh 会有运动的约束权重，例如人身上的披风，靠近肩膀的地方能移动的范围会比较有限，而靠近下面的披风 mesh 约束会小很多。 衣料的物理模型实现是通过弹簧质点模拟实现的。他有两个力，一个是弹性产生的力，另外会有一个能量消耗力（damping）。 [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/clothsolver_mass-spring%20system.png" alt="cloth solver" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvY2xvdGhzb2x2ZXJfbWFzcy1zcHJpbmc=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/clothsolver_mass-spring</span> system.png)</p>
<p>verlet 积分：是基于半隐式积分</p>
<p>目前布料的结算经常用的是 Position Based Dynamic 去结算，如下图所示： [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/cloth%20solver%20position%20based%20dynamics.png" alt="position based dynamic" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvY2xvdGg=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/cloth</span> solver position based dynamics.png)</p>
<p>布料模拟的另一个问题是布料的自穿插。解决办法是使用最大速度的限制。或者把布料的物理模拟加厚</p>
<p>破坏系统： 在构建 mesh 的时候就用 hierarchy 的方式把 mesh 分割成几个碎片，每一个碎片之间有一个 connection，这个 connection 是有权重的，用来表示受到多大的力才会发生破裂。 voronoi 算法：在一个地方随机撒一些种子，然后生成到每两个点相同距离的线。在生成碎片的时候，可以基于 voronoi 算法定义不同的策略。例如玻璃一般是从中心开始碎，而有的地方碎片会密一些。</p>
<p>载具系统： 一个车有四个轮子组成，每个轮子都是一个弹簧系统 车还有引擎作为动力， 轮子上有摩擦力 轮子上的悬挂有悬挂力</p>
<p>另外汽车上的重心对汽车的影响很大。重心靠前时就容易翻车。</p>
<p>坦克则需要模拟履带 飞机则需要空气动力学知识。</p>
<p>PBD 和 XPBD（把载具、衣料、碰撞等全都变成一种约束，用雅克比矩阵求解约束） PBD 的好处在于速度很快，而且效果比较好。</p>
<h3 id="十二-游戏中的粒子和声音系统特效"><a class="anchor" href="#十二-游戏中的粒子和声音系统特效">#</a> 十二、游戏中的粒子和声音系统（特效）</h3>
<p>粒子发射器： 会有很多发射器，每一个发射器发射粒子，所有的发射器打包叫做粒子系统。 每一个粒子都是会受到力的作用的，例如重力，风的阻力，粒子的运动轨迹受到粒子的速度，受力影响。 粒子还会有颜色的变化。 粒子也可以有碰撞检测，例如打铁花，掉落的铁屑落到地上会有弹落。</p>
<p>billboard 粒子：通过一系列有动画的 billboard 来模拟粒子，例如明日之后里面的火焰</p>
<p>mesh 粒子：每一个粒子都是一个 mesh，这样可以做出随机感很强的粒子。</p>
<p>Ribbon 粒子：粒子形成的是一条光带，例如光剑（魔法剑）挥剑的轨迹。这种会有一些粒子的时空滞留感。一般使用样条曲线插值来形成 Ribbon 粒子。</p>
<p>粒子渲染最大的问题：半透明问题。例如半透明物体的排序。例如按照粒子发射器做 sort</p>
<p>渲染粒子的优化方法：将粒子渲染做降分辨率</p>
<p>GPU 粒子：GPU 很适合做粒子，因为粒子的数量庞大，同时计算简单。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GPU_particles.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GPU_particles.png" alt="GPU particles" /></a> 粒子有专门的一个数据机构，有一个 alive Particles List 还有一个 dead list，每当一个粒子死亡，需要从 alive list 移到 deadlist 里面，而 emiter 每发射一个粒子，需要从 deadlist 把相应的粒子拿出来放到 alive list 里面，GPU 每帧只需要对 alive list 里面的粒子做模拟即可。</p>
<p>粒子的计算跟视角无关，即使看不到的粒子也需要每帧计算，只是不需要绘制了而已。 GPU 粒子可以把物理模拟，排序，视锥裁剪、depth buffer collision 等都放到 GPU 上做。GPU 上的粒子排序是使用的 mergesort，这个是可以并发执行的。</p>
<p>大量的人也可以用粒子系统实现。使用 Animated Particle Mesh，只不过在人物的粒子系统中，没有用物理模拟，而是用的动画状态机实现。还有鸟群，鱼群的实现。这里面使用 SDF 来辅助控制碰撞。</p>
<p>音效系统： 声音分为音调、音量和音色，音色本质是不同基波和不同幅度的音波叠加起来的效果，因此理论上人耳听不到的高频音也会对音色产生影响。 理论上声音的采样率只要大于两倍音频即可保证无损，但因为音色的影响，采样频率需要稍高一些，保证高频音也能采样到。</p>
<p>MP3 只支持立体音，不支持 5.1 立体环绕音，而且 Mp3 有专利墙，所以大部分时候使用 OGG 格式。</p>
<p>声音的渲染系统： listener 的位置，速度还有朝向 声音的空间感：主要是利用两个耳朵接受到的声音大小，声音到达的时间差距，音色等 声音的 power 是音强的平方，</p>
<p>声音的衰弱：这个时候使用 attenuation shape 来模拟声音的衰弱，例如高音喇叭使用的是喇叭形的衰弱。小溪使用的是胶囊的衰弱场。</p>
<p>引擎还需要处理声波，在有障碍物时的声音</p>
<p>声音的混响：例如骑马通过一个桥洞。混响包含干音（就是直接的声音）、声音的回音，声音的拖尾。 多普勒效应：当声源在移动的时候，声音的效果是不一样的。 声音的采集：一般是在录音室中对整个空间的声场做采集 在 3A 大作里面，会设置很多个音源。来模拟环境音。</p>
<h3 id="十三-引擎工具链基础"><a class="anchor" href="#十三-引擎工具链基础">#</a> 十三、引擎工具链基础</h3>
<p>所见即所得的工具链 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/game_engine_runtime_framework.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/game_engine_runtime_framework.png" alt="game engine runtime framework" /></a></p>
<p>引擎工具链的本质是要连接各个特色的人，把大家连接到一起协作，例如美术，策划，程序员连接到一起。</p>
<p>游戏引擎最开始的系统叫做 GUI 系统，GUI 系统由 immediate Mode，所见即所得的绘制。还有一种叫 Retained Mode，将所有要绘制的东西放到类似 commandbuffer 里面，如果绘制内容不变的话则不改变 commandbuffer。现在大部分都是 Retained Mode GUI</p>
<p>Retained Mode GUI 有很多设计方式，例如 MVC，MVVM 等， 其中 MVC 架构的思想是只能通过 model 来改变 view，而 view 不能改变 model，用户的操作只能通过 controller 来改变 model。这种方式只有 “单行线”，容易管理。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/MVC.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/MVC.png" alt="MVC" /></a></p>
<p>还有一个设计模式是 MVP：就是把 Controller 编程 persenter，作为中间者。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/MVP.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/MVP.png" alt="MVP" /></a></p>
<p>MVVM 模型，把 persenter 换成 viewmodel 只不过他中间用的是 binding 机制，view 就只有 XML，是艺术家来写的，viewmodel 是把 xml 和 model 绑定到一起的作用，是一种数据转换。model 拥有自己的数据。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/mvvm.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/mvvm.png" alt="MVVM" /></a></p>
<p>在写工具的时候，最好不用自己写的 GUI，而是使用现成的工具例如 QT 等。</p>
<p>数据的序列化：就是把当前的数据变成可以保存成文件的格式。或者可以变成可以网络传输的数据格式。例如存成 txt 或者 json，都是序列化操作。 如果能存储成 binary mode 的话，文件的大小会小很多。</p>
<p>工具链还会遇到一个问题，就是数据会有很多重复，例如有十个一模一样的房子，但是会有一些微小的差别。这个时候，如果存十个 binary 就会有很多浪费。常用的技术是数据的继承，例如添加一个 xxx.mat 告诉引擎我们要从 xxx.mat 把所有的数据拷贝过来，然后再去新增别的数据即可。</p>
<p>如何做到资产版本的兼容性：例如新版本引擎可以导入老版本引擎的资产，或者老版本引擎可以导入新版本引擎的资产。 怎么处理：少的值新增一个默认值，多的值不处理。 或者给每一个资产定义一个单调递增的 guid</p>
<p>工具链的鲁棒性：</p>
<ol>
<li>怎么做 undo 和 redo</li>
<li>工具 crash 了怎么办 使用命令设计模式，command 需要原子化，然后把所有的 command 都保存到磁盘上。 每一个 command 都需要有 revoke 和 invoke，还需要有一个 uid 建议提前在工具链中集成 command 系统，这样可以使我们工具链非常干净。 command 系统最主要的三个操作是 add、delete 和 update。</li>
</ol>
<p>如何处理工具链中各个资源格式不同的问题： 使用 schema：将所有复杂的数据都拆分成一些 “原子数据”，schema 更像是一个分子式，是一个描述物体的格式，schema 通常是一个 xml，而且要有继承关系，例如军人的 schema 可以继承自人的 schema。同时还需要能够相互 reference 数据。能够把数据关联在一起。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/schema_define.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/schema_define.png" alt="schema define" /></a></p>
<p>工具还有一个能力就是要给不同的人给不同的 View，例如不能给美术弧度，而是要给角度，要给调色板而不是 RGB 数值。</p>
<p>工具链还需要 “所见即所得” 具体的做法是直接复用引擎代码，例如下面的引擎架构 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/game_tools_framework.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/game_tools_framework.png" alt="game tools framework" /></a></p>
<p>工具链还需要有 “play in Editor” 功能，就是直接在编辑器里面运行游戏。</p>
<p>工具链还需要有可扩展性，例如插件功能，可以让第三方开发者使用插件功能编写自己的插件。</p>
<p>工具链开发需要有很强的软件工程能力，以及非常熟悉游戏制作过程。</p>
<h3 id="十四-引擎工具链高级概念和应用"><a class="anchor" href="#十四-引擎工具链高级概念和应用">#</a> 十四、引擎工具链高级概念和应用</h3>
<p>World Editor 引擎需要支持多个 viewport，因为可能会出现画中画。 同时世界编辑器还需要针对不同的美术去做选择性的编辑，例如把锁定某些东西不可编辑。让美术专注于自己的领域。 世界编辑器还需要 Content Browser，需要可以浏览所有的资产，也可以检索资产。</p>
<p>鼠标选取功能：使用 Ray Casting 来实现物体选取。</p>
<p>Height Brush 功能：能够通过笔刷来生成地形的高度。最好能够给美术提供一个能够自己导入笔刷的功能</p>
<p>instance Brush：能够通过刷子来快速的生成物体 instance。</p>
<p>能够有环境系统，例如路上不能长树。这需要一套 Rule System，然后使用这么一个 Rule System 使用 PCG 的方法生成出来。</p>
<p>World Editor 还需要有插件系统，而且需要支持多个插件共存。还有 plugin 的版本系统。</p>
<p>游戏引擎的叙事系统：包含每个物体的时间线，然后多个物体的时间线放在一起会有动画或者叙事系统。</p>
<p>反射系统：就是能够让程序可以动态修改他的数据结构和方法。如下所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/reflection_demo.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/reflection_demo.png" alt="reflection" /></a> C++ 如何实现反射：三步骤</p>
<ol>
<li>在代码里面确定需要反射的类型和成员变量等</li>
<li>生成编译代码，提供 accessors 去获取函数和成员变量</li>
<li>通过 &lt;string, accessor&gt; 的 map 去管理所有的 accessors</li>
</ol>
<p>现在我们的 C++ 代码一定需要 GPL 去对编码做编译。例如 Clang，获取他的 AST（抽象语法树）。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/reflection_generate_schema_from_AST.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/reflection_generate_schema_from_AST.png" alt="reflection AST" /></a> 我们通过定义一些描述词，把希望做反射的数据结构描述一下，这个通过宏来实现。clang 有一个__attribute__, 它里面有一个叫 annotate 的关键字，他可以给我们的变量打标记，如下所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/reflection_add_attribute.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/reflection_add_attribute.png" alt="reflection attribute" /></a></p>
<p>visual script system：主要是解决编程语言的可扩展性。丢掉 hard code method，可以动态增加方法。</p>
<p>code rendering：代码渲染：能够自动的把 xml 或者可视化图转换成代码，这种方式可以把代码和数据区分开。可以使用第三方插件 Mustache</p>
<p>协同编辑：类似协同编辑文档。通过划分区域。或者 asset 分层等方式来实现。或者（one file per actor）但是这样会产生非常多的小文件。 协同编辑最终的状态是，每一个人可以实时看到别人的编辑结果，这其实是一个网络同步问题。这需要将对所有命令原子化。</p>
<p>引擎和 DCC 工具在相互抢工作，例如 DCC 工具想要做一些引擎 runtime 的事情，引擎想要做类似手 K 动画的功能。</p>
<h3 id="十五-引擎的gameplay"><a class="anchor" href="#十五-引擎的gameplay">#</a> 十五、引擎的 gameplay</h3>
<p>gameplay 是一个需要快速迭代的东西，引擎在做的时候，需要支持玩法快速迭代。 一般使用 event 来控制物体之间的交互，中间有很多细节，例如使用 callback function 来实现 event 系统，但是注册了 callback 以后，要保证 owner 不为空。 gameplay 还需要消息分发机制。 event 在设计的时候会设计一个 queue，然后在 queue 中对 event 做分类，然后通过 batch 保证 event 的并行化。（一个 ring buffer）</p>
<p>event 系统最好不要默认先后顺序，而是默认下一帧前保证所有的 event 都已经完成了。</p>
<p>游戏的 hotfix：需要使用脚本来做热更新，C<ins> 较难使用热更新。并且脚本语言有利于开发效率，crash 也不会影响到 C</ins>。例如 lua、python 等 hotfix 的实现方式就是把脚本的函数指针换一下，这个时候要注意全局变量的处理。</p>
<p>可视化脚本（蓝图系统）：就是一个把 float 等类型编程不同颜色的点，然后连起来编程的一类系统。</p>
<p>3C 系统（character、control、camera） character 系统就是人物和环境的交互，运动，动画等 control 就是键盘、鼠标、各种外设的交互和控制。如何变得敏捷和丝滑。例如射击游戏瞄准时的吸附系统，还有手柄的反馈系统。 camera 实际上是要和玩家绑定到一起，但是实际上相机并不是严格跟着玩家的，还是在不断移动和旋转，特别是 2.5D 游戏。有可能随着玩家的移动旋转的时候，相机旋转的浮动更大。</p>
<h3 id="十六-引擎的基础ai"><a class="anchor" href="#十六-引擎的基础ai">#</a> 十六、引擎的基础 AI</h3>
<p>游戏中的 AI 导航系统：</p>
<ol>
<li>需要对世界有一个表达，例如 map representation， 1.1 waypoint network：把所有的岔路口放一些节点，这样会形成一个网络图。AI 寻路的时候会首先寻找距离最近的节点或者路。这种方法的问题在于玩家总是会往路中间走。即使路很宽 1.2 grid：使用稠密的 triangle、square、hexagon 来表示地图，例如文明 5 就是用六边形表达。这种方法非常好实现，也容易 debug，他的缺点是存储空间较为浪费。而且寻路的效率也是比较低的，而且无法寻路有层叠关系的路，例如桥上和桥下。 1.3 navigation mesh：把地图上所有可通行的区域用一个一个的 polygon 都连起来。相比较 waypoint 和 grid，他对地图的覆盖是面覆盖代替点覆盖和线覆盖（可以是三角形也可以是别的凸多边形）。若果是凹多边形则有可能会经过一个不可行区域。但是这种方法不能做飞行系统的寻路。 1.4 sparse otree：空间寻路的实现需要使用 sparse voxel octree。但是他对存储空间要求比较高。</li>
<li>path finding： 寻路就是在 representation 形成的 graph 中寻找最短路径。dijkstra 算法。但是 dijkstra 算法相对准确，实际寻路的时候不需要一个非常严格短的路径。这个时候就需要 A<em> 算法。A</em> 算法是基于 dijkstra 算法衍生出来的寻路算法，他的思路是，在寻路的过程中不仅需要考虑已走的距离，还要考虑预测到目标点的距离，寻找一个两者相加和最小的点继续往前迭代。并且找到目标点后直接中断算法。从而达到加速的目的。</li>
<li>path smoothing： 只有 1,2 点会导致路径发生 zigzag，会有些奇怪，要拐很多弯路，这里面可以使用烟囱算法来做 smoothing（funnel algorithm），具体思路就是连着一个点，判断目标点是在该点烟囱的左边、右边还是中间，如果是中间的话就直接走直线，如果在左边的话，就照着最左边的路走。</li>
<li>steering：是为了解决一个问题，就是之前的寻路是立即生效的，但是遇到动作缓慢的物体，例如汽车拥有加速度和减速度，他在运行的时候无法走直线，实际走的是弧线。 常见的 steering 动作如下图所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/steering_behaviors.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/steering_behaviors.png" alt="steering behaviors" /></a></li>
</ol>
<p>4.1 Seek Flee 追和逃，有一个目标点，追和逃</p>
<p>4.2 VelocityMatch 在起步的时候要加速，快到目标点的时候要减速。这个时候需要根据距离目标点的距离反向算出加速度和速度。 4.3 align 朝向一致，例如一群鱼群，朝向要一致。</p>
<p>crowd 系统，当有鱼群、人群、羊群的时候会有这么一个系统。微观方法上就是每个鱼都有斥力、引力和朝向，要保证鱼之间不会离得很远，也不会离得很近。同时鱼群的方向也要一致。在宏观上要有一个路径或者规则。 群体行为要避免碰撞（通过相互之间的斥力来解决，或者给每一个障碍物添加一个 SDF，sdf 越小斥力越大）</p>
<p>速度互斥算法：当发现对面来了物体，且速度会相撞，则会改变自己的速度。</p>
<p>behavior tree：在游戏中会有行为树来控制 AI，行为树相比较状态机，拓扑结构更加清晰，行为树的例子如下： [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/behavior%20tree.png" alt="behavior tree" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYmVoYXZpb3I=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/behavior</span> tree.png) [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/behavior%20tree2.png" alt="behavior tree2" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvYmVoYXZpb3I=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/behavior</span> tree2.png)</p>
<p>Sequence:Sequence 就是按顺序执行，例如先执行门是否关着，如果关着就开门，开门后开枪。</p>
<p>Selector：Selector 就是依次选择执行，如下所示 [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Behavior%20tree%20Selector.png" alt="behavior tree selector" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvQmVoYXZpb3I=">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/Behavior</span> tree Selector.png)</p>
<p>Parallel: 同时发生并执行的事情，例如一面开枪一面走路。</p>
<h3 id="十七-引擎的高级ai"><a class="anchor" href="#十七-引擎的高级ai">#</a> 十七、引擎的高级 AI</h3>
<p>Hierarchical task network（HTN） 行为树的局限性是不直观。HTN 是从任务目标出发，就像人类一样去做一个计划。是一种将大目标拆分成各个小目标，然后再拆分成更小的目标。 Sensor 是为了从环境里面抓取状态 Property 是每个玩家自己主观上对世界的感知 HTN Domain 是一个任务系统 Planner 是去做计划，但是这个计划很可能会随着 World State 变化而变化 Runner 是执行计划 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/HTN_Framework.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/HTN_Framework.png" alt="HTN_Framework" /></a></p>
<p>Task 分为几种 Primitive Task 是包含 Preconditions、Action 和 Effects 三个部分的任务。 Compound Task 是在 Primitive 的基础上有一个任务执行的优先级，优先看 A，如果 A 满足了就执行 A，不满足然后再看 B，举例如下所示</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/compound_task.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/compound_task.png" alt="Compound Task" /></a></p>
<p>相比较行为树，HTN 就是把所有东西分成 Task，planning 就是去规划这些 task，因为在执行 task 的时候可能会出现意料之外的情况，所以 run 的时候会动态改变 task 序列。叫做 run 时候的 replan</p>
<p>HTN 的执行效率比行为树高，因为不需要每次都从 root 节点 tick，他是一个更 High level 的算法。HTN 的缺点在于在做好 plan 的时候，可能会因为策划的配置失误或者长时间的迭代，没有执行下一个任务。这个时候就需要程序员做一些静态检查工具来帮助完成</p>
<p>Goal-Oriented Action Planning（GOAP）基于目标的动作规划 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP.png" alt="GOAP" /></a> 只不过分为 ACtionSet 和 Goal Set, 其中 GoalSet 中的 Goal 有 Precondition 和 Priority， 和 BT 和 HTN 的区别在于，GOAP 是把目标明确出来，而 BT 和 HTN 则是将目标隐含在自己的树状结构中 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_GoalSet.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_GoalSet.png" alt="GOAP GoalSet" /></a></p>
<p>GOAP 的 Action Set 是有 cost 的，如下所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_Actionset.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_Actionset.png" alt="GOAP ActionSet" /></a></p>
<p>GOAP 在执行的时候是以目标为主，倒叙思考，例如我要活着是个目标，然后我中毒了，我得喝解药这又是一个目标，然后为了达到喝解药这个目标要做哪些 action。 然后 Action Cost 和 state 组成了一个图，distance 是 cost，Edge 是 Action，Node 是 Combination state <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_State_Actino_Cost_Graph.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/GOAP_State_Actino_Cost_Graph.png" alt="GOAP" /></a></p>
<p>Monte Carlo Tree Search： 围棋就是使用了类似的方法，首先要把落子的可能性做数学建模，首先要把整个局面抽象成一个 State，然后构建蒙特卡洛 Tree，在下子以后重新构建一个蒙特卡洛 Tree。 在模拟的过程中，会有一个 Default Policy 在里面，去判断本次落子的赢面大概有多大。然后选取一个赢面概率最大的节点，再去往下查找赢面。 在查找的时候，使用的方法是 UCB（upper confidence Bounds），优先选择深度迭代，但是如果发现自己的探索广度小于父亲的一定比例，则需要优先广度搜索，如下所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/upper_confidence_bounds.png"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/upper_confidence_bounds.png" alt="upper_confidence_bounds" /></a></p>
<p>Machine Learning ： 马尔科夫链基于概率的状态机来做。 强化学习中，经常先训练一个局部最优解，然后还要不断和别的训练结果左后互博，如下所示： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/train_renforce_learning_AI.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/train_renforce_learning_AI.PNG" alt="Reenforence" /></a></p>
<h3 id="十八-网络游戏的基础架构"><a class="anchor" href="#十八-网络游戏的基础架构">#</a> 十八、网络游戏的基础架构</h3>
<p>网络游戏遇到的挑战：延迟，丢包，掉线，外挂，同步，不同设备上的兼容性和一致性，多人并发度以及多人并发下的效率。 网络的七层结构： [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/internet_OSI%20Model.PNG" alt="OSI Model" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvaW50ZXJuZXRfT1NJ">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/internet_OSI</span> Model.PNG)</p>
<p>游戏中使用的网络协议一般是 reliable UDP 协议。因为 TCP 不是一个时间稳定的协议，而 UDP 虽然很快但是却不够可靠。 ARQ：实际上就是在 UDP 上使用滑动窗口协议，确认哪些包没有收到，如果没有收到就重新发一下包，保证不丢包。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/online_game_xor.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/online_game_xor.PNG" alt="xor" /></a></p>
<p>reliable UDP 其实就做了两件事，一个是使用滑动窗口协议保证不丢包，链接稳定，另一个是使用 FEC 保证丢包以后可以恢复。</p>
<p>RTT：时钟校准和时钟同步： 给服务器发一个包，然后让服务器再返回一个包，计算中间的时间差值。有一个 NTP 算法可以做这么一件事情。</p>
<p>在封装网络协议之上，使用 RPC 来给客户端程序员使用，更为方便。</p>
<p>游戏网络架构：</p>
<p>P2P 架构：两个电脑联机到一起，或者一个网吧，可以两个人互为服务器，例如红警，w3 等</p>
<p>Dedicated Server：有一个 Host Server，会更稳定一些，并且需要大型商业服务器。</p>
<p>游戏同步技术</p>
<ol>
<li>snapshot 同步：客户端只负责传输当前客户端的数据给服务器，服务器收集所有的数据再算，保证了大家数据的绝对一致性。因为很多快照，服务器会比较卡，所以一般服务器是 10 帧，客户端是 30 帧，剩余的帧都是插值出来的。同时因为有很多快照，数据量可能会比较大，所以一般会使用 diff 来存储快照。 snapshot 的问题在于浪费了大量客户端的算力，而且对服务器的带宽需求较大。一般只有在局域网内使用。</li>
<li>帧同步：锁步执行：所有的客户端都把数据汇总给服务器，然后由服务器将所有数据分发给各个客户端做计算，理论上各个客户端的计算结果应该是相同的，服务器只起到了转发数据的作用 2.1 initialization：在一开始进入游戏的时候，一定要确保各个玩家的数据都是相同的，例如王者荣耀进入游戏时候的 init。 2.2 服务器分发数据给客户端，并且执行同步 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/Deterministic_lockstep.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Deterministic_lockstep.PNG" alt="deterministic lockstep" /></a></li>
</ol>
<p>但是这个图有个问题，就是一个人会卡着所有的人，（例如 dota）一种优化方法就是每 100ms 就要收一次消息，像公交车一样，等不到也要出发，例如下面一张图： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/bucket_synchronization.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/bucket_synchronization.PNG" alt="bucket synchronization" /></a> 帧同步有一个关键点，就是游戏的确定性，就是物理引擎，vector 等数学库，浮点精度一定要有一致性。</p>
<p>浮点数误差保证：使用分数 cos、sin 等使用查表法。 game state 也尽量弄成确定性的事情。 随机数的种子也要一致。</p>
<p>即使使用了帧同步，也会出现网络抖动和延迟的情况，这个时候一般客户端会 cache 一两帧服务器发来的数据。然后使用插值的方式做 smooth。</p>
<p>快照策略：一般会把渲染帧和逻辑帧分开，然后本地会在拿到服务器数据后在本地做一个快照，然后在掉线 10 秒户重新从快照的地方将所有算力用来计算逻辑。部分游戏的服务器也会保存一些快照，保证玩家掉线后直接给玩家当前状态。游戏的观战和回放也会使用帧同步的快照技术。</p>
<p>帧同步的外挂问题：因为帧同步基本要保证每一个客户端都保存了所有玩家的所有状态，如果有战争迷雾的话，很容易写一些透视挂。</p>
<ol>
<li>状态同步：</li>
</ol>
<p>大部分的 MMORPG 都用的状态同步。</p>
<p>不会把玩家所有的信息都传输给服务器，而是每个人只发送自己的一部分数据，而服务器是拥有所有玩家的状态的，在计算完以后会把一部分的数据（玩家的状态）发送个各个玩家。</p>
<p>Authorized：玩家自己的电脑，玩家只提出自己的动作 Server：会收集所有玩家的动作。然后计算结果后，将结果发送给各个玩家。 Replicated：在其他玩家的电脑模拟某个玩家。是一个玩家的复制。玩家的状态则是由服务端计算得到的。</p>
<p>状态同步通常会有一个延迟，因为需要把数据发送给 server，然后 server 再发送到客户端，这个时候客户端会有一个 overwatch，有一个预测。 <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/state_syc_compare.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/state_syc_compare.PNG" alt="state_sync_compare" /></a></p>
<h3 id="十九-网络游戏的进阶架构"><a class="anchor" href="#十九-网络游戏的进阶架构">#</a> 十九、网络游戏的进阶架构</h3>
<p>因为延迟导致的抖动：可以通过 buffer 和插值来修复，这种方法虽然可以让动作很平滑但是这种方法会导致延迟更高，而且这种延迟会导致碰撞游戏出现问题。</p>
<p>外插值可以解决碰撞游戏的问题。但是外插针需要预测未来的状态。 PVB 算法： [<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Projective%20Velocity%20Blending.PNG" alt="Projective Velocity Blending" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvUHJvamVjdGl2ZQ==">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/Projective</span> Velocity Blending.PNG)</p>
<p>[<img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/Projective%20Velocity%20Blending2.PNG" alt="Projective Velocity Blending2" />](<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZmxhcmVzbmkvQ0dfbGVhcm5pbmdfbm90ZS9ibG9iL21hc3Rlci9nYW1lczEwNCVFNyVBQyU5NCVFOCVBRSVCMC9pbWFnZXMvUHJvamVjdGl2ZQ==">https://github.com/cloudflaresni/CG_learning_note/blob/master/games104 笔记 /images/Projective</span> Velocity Blending2.PNG)</p>
<p>一般符合物理学规律的游戏（例如战舰大战）使用外插针 一般比较敏捷，不符合物理规律的游戏使用内插针，也有把两个糅合在一起的用法。</p>
<p>射击游戏的射击判定一般放在客户端，因为可以避免网络延迟，这样会很容易写外挂。服务器端也做检测会检测外挂。</p>
<p>射击判断放在服务器端可能会有比较大的延迟，需要使用 Lag Compensation（延迟补偿）解决： 把状态的时钟往回拨，根据服务器端的数据做猜测。这种方法会导致在竞技游戏中不公平。</p>
<p>动画前摇（可以给网络同步争取时间）</p>
<p>MMO 的架构： <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/MMO_Architecture.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/MMO_Architecture.PNG" alt="MMO_Architecture" /></a></p>
<p>MMO 链接服务器以前会先链接 Login Server，然后会链接 GateWay 要先保证账号是没问题的，其次保证不会被 DDOS 攻击。 Lobby：再经过 GateWay 后会进入游戏大厅，他相当于一个缓冲池。让所有用户都在这里等。 Character Server：专门负责所有玩家的属性数据，例如发邮件，血量，装备等。 Trading System：安全性和原子性要求很高， Social System：拉黑，拉小群聊天 游戏数据库会使用 redis 内存数据库 分布式服务器：主要是数据访问，网络的复杂性，数据的传输，数据的一致性。 负载均衡：要有哈希算法。</p>
<p>带宽优化： 浮点数优化，例如把 xyz 优化成 x 和 y，double 变成 float，或者对游戏分区，然后再用定点数优化。 分区一般是把世界分成多个 cell，或者使用十字链表。</p>
<p>反作弊：</p>
<ol>
<li>检查内存，抓用户的数据，把数据改了。单机游戏一般这么做，防止办法都是客户端加壳， 数据做混淆，</li>
<li>修改本地存储文件，例如把一些材质修改成透明材质，这样就有透视挂了，一般对本地文件数值做哈希校验。</li>
<li>网络包截获并修改。一般应对方法就是对网络包做加密，使用不对称加密算法一个公钥一个私钥，在最开始使用速度最慢但是最安全的 ssh 传输公钥。</li>
<li>AI 作弊：比较难识别。</li>
</ol>
<p>开放世界：</p>
<ol>
<li>把世界分成很多 zoning，把世界分成几个小块，一般会用四叉树，一般每一个 zoning 会有一个自己的边界（border），数据的加载也会有一个延迟和阈值。只有超过一定阈值才会销毁另一个 zone 里面的数据。</li>
<li>instancing</li>
<li>replication：我将每一个 character 放到多个平行世界里面，分成多个层。例如天刀在押镖时候的不同服务器。</li>
</ol>
<h3 id="二十-面向数据编程和任务系统"><a class="anchor" href="#二十-面向数据编程和任务系统">#</a> 二十、面向数据编程和任务系统</h3>
<p>worker 架构：<a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/thread_fork_join.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/thread_fork_join.PNG" alt="fork_join" /></a></p>
<p>Coroutine 概念：相比较切换线程，Coroutine 本质就是用了个调用栈，没有上下文切换，开销小得多， <a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/coroutine.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/coroutine.PNG" alt="coroutine" /></a></p>
<p>Fiber-Based-Job-System JobSystem：</p>
<p>OOP 的问题：继承的深度通常会很深，而且很多操作可能既可以在父类里面做，也可以在子类中做。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cloudflaresni/CG_learning_note/blob/master/games104%E7%AC%94%E8%AE%B0/images/performance_everything.PNG"><img data-src="https://github.com/cloudflaresni/CG_learning_note/raw/master/games104%E7%AC%94%E8%AE%B0/images/performance_everything.PNG" alt="performance" /></a></p>
<p>对 Shadowmap 做 reproj，或者做 culling shadowmap 本质是用视空间的精度对光空间的精度做采样。</p>
<div class="tags"><a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" rel="tag"><i class="ic i-tag"></i>游戏引擎</a></div></div><footer><div class="meta"><span class="icon"><i class="ic i-eye"></i></span><span>此文章已被阅读次数:</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="2023/06/24/game-engine/games104笔记/">正在加载...</span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2024-03-13 00:01:09" itemprop="dateModified" datetime="2024-03-13T00:01:09+08:00">2024-03-13</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/assets/bitcoin.png" alt="Sakura 比特币"/><p>比特币</p></div><div><img data-src="/assets/monero.png" alt="Sakura monero"/><p>monero</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>Sakura<i class="ic i-at"><em>@</em></i>Sakura</li><li class="link"><strong>本文链接：</strong><a href="https://sakurame.eu.org/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/" title="games104笔记">https://sakurame.eu.org/2023/06/24/game-engine/games104笔记/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/06/11/vcbstudio/VapourSynth%E5%9F%BA%E7%A1%80/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;ptpimg.me&#x2F;3oyvmv.jpg" title="VapourSynth基础"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>视频压制技术</span><h3>VapourSynth基础</h3></a></div><div class="item right"><a href="/2023/06/24/computer-graphic/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;ptpimg.me&#x2F;5422e1.jpg" title="光线追踪精粹笔记"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>计算机图形学</span><h3>光线追踪精粹笔记</h3></a></div></div><div class="wrap" id="tcomments"></div><script type="text/javascript" data-pjax="data-pjax">setTimeout(function () {
    twikoo.init({
        envId: 'https://elonmask-blog-commit.hf.space',
        el: '#tcomments',
        region: ''
    })
}, 1000)</script></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-games104%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text"> 一、 games104 的几个主要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text"> 二、游戏引擎架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%96%E7%95%8C"><span class="toc-number">3.</span> <span class="toc-text"> 三、如何构建游戏世界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%9A%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text"> 四、游戏引擎的渲染实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%A4%A7%E6%B0%94-%E5%9C%B0%E5%BD%A2%E5%92%8C%E4%BA%91"><span class="toc-number">5.</span> <span class="toc-text"> 六、大气、地形和云</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E5%90%8E%E5%A4%84%E7%90%86%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E5%88%87"><span class="toc-number">6.</span> <span class="toc-text"> 七、游戏中的渲染管线、后处理和其他的一切</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text"> 八、游戏引擎的动画系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text"> 九、高级动画技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text"> 十、物理系统的基础理论和算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text"> 十一、物理系统高级应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E5%92%8C%E5%A3%B0%E9%9F%B3%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%95%88"><span class="toc-number">11.</span> <span class="toc-text"> 十二、游戏中的粒子和声音系统（特效）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E5%BC%95%E6%93%8E%E5%B7%A5%E5%85%B7%E9%93%BE%E5%9F%BA%E7%A1%80"><span class="toc-number">12.</span> <span class="toc-text"> 十三、引擎工具链基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E5%BC%95%E6%93%8E%E5%B7%A5%E5%85%B7%E9%93%BE%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">13.</span> <span class="toc-text"> 十四、引擎工具链高级概念和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E5%BC%95%E6%93%8E%E7%9A%84gameplay"><span class="toc-number">14.</span> <span class="toc-text"> 十五、引擎的 gameplay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9F%BA%E7%A1%80ai"><span class="toc-number">15.</span> <span class="toc-text"> 十六、引擎的基础 AI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-%E5%BC%95%E6%93%8E%E7%9A%84%E9%AB%98%E7%BA%A7ai"><span class="toc-number">16.</span> <span class="toc-text"> 十七、引擎的高级 AI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">17.</span> <span class="toc-text"> 十八、网络游戏的基础架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D-%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BF%9B%E9%98%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">18.</span> <span class="toc-text"> 十九、网络游戏的进阶架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81-%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A8%8B%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.</span> <span class="toc-text"> 二十、面向数据编程和任务系统</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li ><a href="/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/" rel="bookmark" title="游戏引擎架构（开坑）">游戏引擎架构（开坑）</a></li><li  class="active"><a href="/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/" rel="bookmark" title="games104笔记">games104笔记</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="bookmark" title="games104系列笔记（一）">games104系列笔记（一）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="bookmark" title="games104系列笔记（二）">games104系列笔记（二）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" rel="bookmark" title="games104系列笔记（三）">games104系列笔记（三）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/" rel="bookmark" title="games104系列笔记（四）">games104系列笔记（四）</a></li><li ><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/" rel="bookmark" title="games104系列笔记（五）">games104系列笔记（五）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/" rel="bookmark" title="games104系列笔记（六）">games104系列笔记（六）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/" rel="bookmark" title="games104系列笔记（七）">games104系列笔记（七）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/" rel="bookmark" title="games104系列笔记（八）">games104系列笔记（八）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/" rel="bookmark" title="games104系列笔记（九）">games104系列笔记（九）</a></li><li ><a href="/2023/06/26/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/" rel="bookmark" title="games104系列笔记（十）">games104系列笔记（十）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/" rel="bookmark" title="games104系列笔记（十一）">games104系列笔记（十一）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/" rel="bookmark" title="games104系列笔记（十二）">games104系列笔记（十二）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/" rel="bookmark" title="games104系列笔记（十三）">games104系列笔记（十三）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/" rel="bookmark" title="games104系列笔记（十四）">games104系列笔记（十四）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/" rel="bookmark" title="games104系列笔记（十五）">games104系列笔记（十五）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/" rel="bookmark" title="games104系列笔记（十六）">games104系列笔记（十六）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/" rel="bookmark" title="games104系列笔记（十七）">games104系列笔记（十七）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/" rel="bookmark" title="games104系列笔记（十八）">games104系列笔记（十八）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/" rel="bookmark" title="games104系列笔记（十九）">games104系列笔记（十九）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/" rel="bookmark" title="games104系列笔记（二十）">games104系列笔记（二十）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%B8%80%EF%BC%89/" rel="bookmark" title="games104系列笔记（二一）">games104系列笔记（二一）</a></li><li ><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E4%BA%8C%EF%BC%89/" rel="bookmark" title="games104系列笔记（二二）">games104系列笔记（二二）</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Sakura" data-src="/assets/avatar.jpg"/><p class="name" itemprop="name">Sakura</p><div class="description" itemprop="description">一个专注于技术和思考分享的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">76</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">25</span><span class="name">标签</span></a></div></nav><div class="social"><a href="mailto:mail@sakurame.eu.org" class="item email" rel="noopener" title="mailto:mail@sakurame.eu.org" target="_blank"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li><li class="item"><a href="/privacy/" rel="section"><i class="ic i-user"></i>隐私政策</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-sakura"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/24/computer-graphic/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E7%B2%BE%E7%B2%B9%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/06/11/vcbstudio/VapourSynth%E5%9F%BA%E7%A1%80/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">games104系列笔记（一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2023/05/17/vcbstudio/%E5%BC%80%E6%BA%90%E4%B8%80%E4%B8%8B%E5%BD%93%E5%88%9D%E5%8E%8B%E5%88%B6%E7%BB%84%E5%85%A5%E7%BB%84%E8%80%83%E8%AF%95%E7%9A%84%E7%AD%94%E5%8D%B7/">开源一下当初压制组入组考试的答卷</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2024/05/12/basic-theory/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">人工智能现代方法（第四版）读书笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2024/03/29/computer-graphic/PBRT%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%AA%E4%BA%BA%E7%B2%BE%E6%A0%A1%E7%89%88%E7%BF%BB%E8%AF%91%EF%BC%88%E9%95%BF%E6%9C%9F%E8%AE%A1%E5%88%92%E9%A1%B9%E7%9B%AE%EF%BC%89/">PBRT第四版个人精校版翻译（长期计划项目）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2023/06/09/vcbstudio/%E7%86%9F%E6%82%89VapourSynth/">熟悉VapourSynth</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2023/08/10/basic-theory/A-Flow-guided-Streamline-Seeding-Strategy/">A_Flow-guided_Streamline_Seeding_Strategy</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2024/03/16/vcbstudio/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%80%E5%88%87%E7%9A%84%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86BD/">第二章一切的起点——认识BD</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2024/03/16/vcbstudio/%E7%AC%AC%E5%85%AD%E7%AB%A0VS%E5%9F%BA%E7%A1%80%E6%BB%A4%E9%95%9C/">第六章VS基础滤镜</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/">games104系列笔记（十九）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/thinking/" title="分类于思考随笔记录">思考随笔记录</a></div><span><a href="/2023/06/06/thinking/%E5%AF%BC%E5%B8%88%E4%B8%8E%E5%AD%A6%E7%94%9F%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E6%95%B4%E7%90%86%E8%87%AA%E9%80%BC%E4%B9%8E%EF%BC%89/">导师与学生的关系（整理自逼乎）</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"><li class="item" v-for="com in coms"><a v-bind:href="root + com.href" data-pjax-state="data-pjax-state"><span class="breadcrumb">{{com.nick}} @ {{com.time}}</span><span>{{com.text}}<br/></span></a></li></ul></div></div><div class="status"><div class="copyright">&copy; 2023 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">Sakura @ Sakura's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">1.6m 字</span><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">24:11</span></div><div class="powered-by">基于 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & Theme.<a href="https://github.com/theme-shoka-x/hexo-theme-shokaX/" rel="noopener" target="_blank">ShokaX</a></div><br/><span style="display:inline;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;"><a target="_blank" href="https://icp.gov.moe/?keyword=20233555">萌ICP备20233555号 </a><br/><a target="_blank" href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=能躺在床上摸鱼摆烂是一天中最幸福的时刻"><img src="/assets/search.png" style="max-width: 2em;display:inline;" width="20" height="20"/>能躺在床上摸鱼摆烂是一天中最幸福的时刻</a></span><div style="width: 100%;text-align:center;"><span id="time"></span></div><script>function createtime() {
    const n = new Date("2023/04/23 00:00:00");
    now.setTime(now.getTime() + 250), days = (now - n) / 1e3 / 60 / 60 / 24, dnum = Math.floor(days), hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum, hnum = Math.floor(hours), 1 == String(hnum).length && (hnum = "0" + hnum), minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum, mnum = Math.floor(minutes), 1 == String(mnum).length && (mnum = "0" + mnum), seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum, snum = Math.round(seconds), 1 == String(snum).length && (snum = "0" + snum), document.getElementById("time").innerHTML = "小破站已经在风雨飘摇中苟活" + dnum + " 天 " + hnum + " 小时 " + mnum + " 分 " + snum + " 秒"
}

const now = new Date;
setInterval("createtime()", 250)</script></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">可爱的猫猫踩了本站 <span id="busuanzi_value_site_pv"></span> 只猫爪印</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">可爱的猫猫来了又走了 <span id="busuanzi_value_site_uv"></span> 只</span></div><div class="deng-box"><div class="deng"><div class="xian"></div><div class="deng-a"><div class="deng-b"><div class="deng-t">一</div></div></div><div class="shui shui-a"><div class="shui-c"></div><div class="shui-b"></div></div></div></div><div class="deng-box1"><div class="deng"><div class="xian"></div><div class="deng-a"><div class="deng-b"><div class="deng-t">十</div></div></div><div class="shui shui-a"><div class="shui-c"></div><div class="shui-b"></div></div></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
        path: `2023/06/24/game-engine/games104笔记/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,
    chart: false,
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.0.2/pace.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/algoliasearch/4.12.1/algoliasearch-lite.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/instantsearch.js/4.39.0/instantsearch.production.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/quicklink/2.2.0/quicklink.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/??jquery/3.5.1/jquery.min.js,fancybox/3.5.7/jquery.fancybox.min.js,justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" async></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/KaTeX/0.15.2/contrib/copy-tex.min.js" async></script><script src="/js/app.js?v=0.3.6"></script><script data-pjax type="module">
            let comments = []
           twikoo.getRecentComments({
           envId: "https://elonmask-blog-commit.hf.space",
           pageSize: 10
           }).then(function (res) {
                res.forEach(function (item) {
                    let cText = item.commentText
                    if (item.commentText.length > 50) {
                        cText = item.commentText.substring(0,50)+'...'
                    }
                    const siteLink = item.url + "#" + item.id
                    comments.push({
                        href: siteLink,
                        nick: item.nick,
                        time: item.relativeTime,
                        text: cText
                    })
                });
                Vue.createApp({
                  data() {
                      return {
                          coms: comments,
                          root: ''
                      }
                  }
                  }).mount('#new-comment')
            }).catch(function (err) {
                console.error(err)
            })
        </script></body></html>