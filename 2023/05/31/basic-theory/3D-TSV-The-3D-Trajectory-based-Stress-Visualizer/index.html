<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="alternate" href="/rss.xml" title="Sakura" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Sakura" type="application/atom+xml"><link rel="alternate" type="application/json" title="Sakura" href="https://sakurame.eu.org/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" media="none" onload="this.media='all'"><link rel="modulepreload" href="/js/siteInit.js"><link rel="modulepreload" href="/js/nyx-player-D4XW5YGM.js"><link rel="modulepreload" href="/js/copy-tex-FNUH3BHN.js"><link rel="modulepreload" href="/js/post-XNYTJ3DF.js"><link rel="modulepreload" href="/js/chunk-47WMQ3OW.js"><link rel="modulepreload" href="/js/tcomments-EMIGMNV5.js"><link rel="modulepreload" href="/js/chunk-HBYXA5U5.js"><link rel="modulepreload" href="/js/index.esm-4MKEQDJB.js"><link rel="modulepreload" href="/js/chunk-JZTZ6WT3.js"><link rel="modulepreload" href="/js/chunk-PBBKQNAG.js"><link rel="stylesheet" href="/css/siteInit.css" media="none" onload="this.media='all'"><link rel="preload" href="https://ptpimg.me/gzt9vt.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/35h5vq.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/e8k2yf.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/5515ea.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/9x13r6.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/2m9g2v.jpg" as="image" fetchpriority="high"><meta name="keywords" content="张量可视化"><meta name="description" content="一个专注于技术和思考分享的博客"><link rel="canonical" href="https://sakurame.eu.org/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/"><link rel="stylesheet" href="/css/post.css?v=0.5.0"><link rel="stylesheet" href="/css/mermaid.css?v=0.5.0"><!-- 临时处理--><link rel="stylesheet" media="none" onload="this.media='all'" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css"><title>3D-TSV_The_3D_Trajectory-based_Stress_Visualizer</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">3D-TSV_The_3D_Trajectory-based_Stress_Visualizer</h1><div class="meta"><span class="item" title="创建时间：2023-05-31 23:40:45"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-05-31T23:40:45+08:00">2023-05-31</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>63k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>57 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">testName</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://ptpimg.me/gzt9vt.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/35h5vq.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/e8k2yf.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/5515ea.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/9x13r6.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/2m9g2v.jpg&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement="" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/basic-theory/" itemprop="item" rel="index" title="分类于计算机基础理论"><span itemprop="name">计算机基础理论<meta itemprop="position" content="0"></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sakurame.eu.org/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="Sakura"><meta itemprop="description" content=", 一个专注于技术和思考分享的博客"></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura"></span><div class="body md" itemprop="articleBody"><h1 id="3d-tsv-the-3d-trajectory-based-stress-visualizer"><a class="anchor" href="#3d-tsv-the-3d-trajectory-based-stress-visualizer">#</a> <strong>3D-TSV: The 3D Trajectory-based Stress Visualizer</strong></h1>
<p>3D-TSV: 基于三维轨迹的应力展示器</p>
<p>We present the 3D Trajectory-based Stress Visualizer (3D-TSV), a visual analysis tool for the exploration of the principal stress directions in 3D solids under load. 3D-TSV provides a modular and generic implementation of key algorithms required for a trajectory-based visual analysis of principal stress directions, including the automatic seeding of space-filling stress lines, their extraction using numerical schemes, their mapping to an effective renderable representation, and rendering options to convey structures with special mechanical properties. In the design of 3D-TSV, several perceptual challenges have been addressed when simultaneously visualizing three mutually orthogonal stress directions via lines. We present a novel algorithm for generating a space-filling and evenly spaced set of mutually orthogonal lines. The algorithm further considers the locations of lines to obtain a more regular appearance, and enables the extraction of a level-of-detail representation with adjustable sparseness of the trajectories along a certain stress direction. To convey ambiguities in the orientation of the principal stress directions, the user can select a combined visualization of two principal directions via oriented ribbons. Additional depth cues improve the perception of the spatial relationships between trajectories. 3D-TSV is accessible to end users via a C++- and OpenGLbased rendering frontend that is seamlessly connected to a MatLab-based extraction backend. The code (BSD license) of 3D-TSV as well as scripts to make ANSYS and ABAQUS simulation results accessible to the 3D-TSV backend are publicly available.</p>
<p>本文介绍了基于轨迹的三维应力可视化工具 (3D-TSV)，它是一种可视化分析工具，用于探索载荷作用下三维实体中的主应力方向。3D-TSV 提供了基于轨迹的主应力方向可视分析所需的关键算法的模块化和通用实现，包括自动播种填充空间的应力线、使用数值方案提取应力线、将其映射到有效的可渲染表示以及渲染选项以传达具有特殊力学特性的结构。在 3D-TSV 的设计中，当通过直线同时可视化三个相互垂直的应力方向时，已经解决了几个感知挑战。我们提出了一种新的算法来生成空间填充和等间距的相互垂直的线集。该算法进一步考虑了线的位置，以获得更规则的外观，并能够提取沿特定应力方向的轨迹稀疏性可调的细节层次表示。为了传达主应力方向的模糊性，用户可以通过定向条带选择两个主应力方向的组合可视化。额外的深度线索改善了对轨迹之间空间关系的感知。最终用户可以通过基于 C++ 和 OpenGL 的渲染前端访问 3D-TSV，该前端无缝连接到基于 MATLAB 的提取后端。3D-TSV 的代码 (BSD 许可证) 以及使 3D-TSV 后端可以访问 Ansys 和 ABAQUS 模拟结果的脚本是公开可用的。</p>
<h2 id="introduction"><a class="anchor" href="#introduction">#</a> Introduction</h2>
<p>Techniques for visualizing the three mutually orthogonal principal stress directions in 3D solids under load are important in a number of use cases in computational mechanics. In civil engineering such visualizations are used to develop and assess strategies for steel reinforcement of concrete support structures [38]. In mechanical engineering, where often massive components like engines and pumps are considered, one is interested in how forces “find” their way through these components. The development of lightweight load bearing structures is investigated in e.g., aerospace engineering, here stress directions provide the first indicators where structures can be hollowed [22, 23, 5]. In bio-mechanics, such techniques are used to show tension and compression pathways simultaneously, and compare different structural designs regarding their mechanical properties [8]. For an overview of stress tensor visualization, we refer to the recent review article by Hergl et al [12].</p>
<p>在计算力学的许多用例中，可视化三维实体中三个相互垂直的主应力方向的技术在计算力学中是很重要的。在土木工程中，这种可视化被用于制定和评估混凝土支撑结构的钢筋加固策略 [38]。在机械工程中，经常考虑发动机和泵等大型部件，人们感兴趣的是力如何通过这些部件 “找到” 途径。轻量级承重结构的发展被研究在例如航空航天工程中，在这里，应力方向提供了结构可以被掏空的第一个指标 [22，23，5]。在生物力学中，这种技术被用来同时显示拉伸和压缩路径，并比较不同的结构设计的机械性能 [8]。关于应力张量可视化的概述，我们参考 Hergl 等人最近的综述文章 [12]。</p>
<p>An informative visualization of the stress directions in a 3D solid can be achieved via principal stress lines (PSLs), i.e., integral curves in 3D space along the principal stress directions. PSLs are effective in communicating the pathways along which external loads are transmitted, and they show the mutual relationships between the different principal stress directions [8, 43]. In computational engineering,PSLs are used in particular to show where and how loads are internally redirected and deflected. Such visualizations are necessary for a first qualitative analysis, before a quantitative analysis of certain regions using derived scalar stress measures is commonly performed.</p>
<p>三维实体中应力方向的信息可视化可以通过主应力线 (PSL) 实现，即三维空间中沿主应力方向的积分曲线。PSL 在传递外部载荷的路径上是有效的，它们显示了不同主应力方向之间的相互关系 [8，43]。在计算工程中，PSL 特别用于显示负载在哪里以及如何在内部重定向和偏转。在通常使用导出的标量应力测量对某些区域进行定量分析之前，这种可视化对于第一次定性分析是必要的。</p>
<p>However, in computational mechanics stress trajectory visualizations are used in a rather inconsistent way, and, to the best of our knowledge, no standard tool for such an analysis exists. In many research groups in computational mechanics, own software packages for showing one particular principal stress direction starting at randomly selected locations are used. Often, CFD tools for flow visualization are used to show streamlines in a single principal stress direction field. Visualization tools that are able to show all principal stress directions simultaneously are rare, and also available post-processing tools do not offer this functionality.</p>
<p>然而，在计算力学中，应力轨迹可视化的使用方式相当不一致，而且据我们所知，还没有标准的工具来进行这种分析。在计算力学的许多研究小组中，使用自己的软件包来显示从随机选择的位置开始的一个特定的主应力方向。通常，用于流动可视化的 CFD 工具被用来显示单个主应力方向场中的流线。能够同时显示所有主应力方向的可视化工具很少，而且可用的后处理工具也不提供这一功能。</p>
<p>One reason preventing a wider adoption of such tools is visual clutter and occlusions that are produced when showing the different types of PSLs simultaneously. Due to their mutual orthogonality, the visualizations appear irregular and unstructured, and perceptual coherence breaks up even for sparse sets of trajectories. While this effect can be reduced by starting trajectories from narrow regions and following only a single type of PSLs, this leaves large sub-domains uncovered and does not show the mutual variations of the stress directions. In general, clutter can be reduced by visualizing the single stress directions side-byside, yet juxtaposition makes it difficult to effectively relate the three mutual orthogonal stress directions to each other.</p>
<p>阻碍这种工具广泛采用的一个原因是，当同时显示不同类型的 PSL 时，会产生视觉混乱和遮挡。由于它们的相互正交性，可视化看起来不规则和无结构，即使是稀疏的轨迹集，知觉一致性也会中断。虽然这种影响可以通过从狭窄区域开始轨迹并只跟随一种类型的 PSL 来减小，但这会留下较大的子域，并且没有显示应力方向的相互变化。一般来说，可以通过并排显示单个应力方向来减少混乱，但并列很难有效地将三个相互垂直的应力方向相互关联。</p>
<h2 id="contribution"><a class="anchor" href="#contribution">#</a> Contribution</h2>
<p><img loading="lazy" src="https://ptpimg.me/00u84w.png" alt=""></p>
<p>Figure 1: (a) The 3D Trajectory-based Stress Visualizer generates a space-filling and evenly spaced set of principal stress lines (PSLs) in a 3D domain. (b) It supports a regular appearance by considering already selected lines when locating new seed points.(c,d) To reduce clutter, the density of PSLs can be adapted in a hierarchical manner. (d) Ambiguities in the assignment of stress types to directions are visualized by merging two principal stress directions into ribbons. Different scalar stress measures (d) can be mapped to color.</p>
<p>图 1：(A) 基于轨迹的 3D 应力显像器在 3D 域中生成一组空间填充和均匀分布的主应力线 (PSL)。(B) 在定位新的种子点时，通过考虑已经选择的线来支持规则外观。(c，d) 为了减少杂乱，可以以分层的方式调整 PSL 的密度。(D) 通过将两个主应力方向合并成条带，可以直观地看出方向的应力类型分配的模糊性。可以将不同的标量应力测量 (D) 映射到颜色。</p>
<p>This paper presents the 3D Trajectory-based Stress Visualizer (3D-TSV), a system and methodology for the visual analysis of the PSLs in 3D stress fields. Figure 1 gives an overview of the visualization options provided by 3D-TSV. With 3D-TSV, we release a system that supports a comprehensive integral line-based analysis of 3D stress fields. To achieve this, 3D-TSV builds upon existing techniques for line seeding in vector fields [16, 27], and it extends them towards the specific use case by considering simultaneously the three principal stress directions in the seeding process. 3D-TSV is designed to achieve improved regularity of the extracted PSLs, i.e., it aims for a grid-like structure where PSLs roughly intersect, uniformly cover the domain, and reveal symmetries in the underlying fields. To achieve this, in the sequential seeding process every new seed point is located on an existing PSL belonging to a different principal stress direction. As proposed for streamlines in [16, 27], the seeding process is parameterized using different distance thresholds for each type of PSL, which allows controlling separately the sparseness of the PSLs of each type. We use this possibility to enable a level-of-detail (LoD) visualization that combines a dense seeding of a selected PSL type with a seeding at a user-selected sparseness level of the respective other PSLs.</p>
<p>本文介绍了基于轨迹的三维应力可视化系统 (3D-TSV)，它是三维应力场中 PSL 可视化分析的系统和方法。图 1 概述了 3D-TSV 提供的可视化选项。通过 3D-TSV，我们发布了一个系统，该系统支持基于线的 3D 应力场的全面积分分析。为了实现这一点，3D-TSV 建立在现有的矢量场 [16，27] 中线播种技术的基础上，并通过同时考虑播种过程中的三个主应力方向，将它们扩展到特定的用例。3D-TSV 旨在改善提取的 PSL 的规律性，即它的目标是形成一种网格状结构，其中 PSL 大致相交，均匀覆盖区域，并揭示底层场的对称性。为了实现这一点，在顺序播种过程中，每个新的种子点都位于属于不同主应力方向的现有 PSL 上。如在 [16，27] 中为流水线提出的，种子过程使用针对每种类型的 PSL 的不同距离阈值来参数化，这允许单独控制每种类型的 PSL 的稀疏性。我们使用这种可能性来实现细节级别 (LOD) 可视化，其将所选 PSL 类型的密集播种与用户选择的相应其他 PSL 的稀疏级别的播种相结合。</p>
<p>To ease integration into existing systems and accessibility to end users, 3D-TSV is implemented as a client server tool connecting a MatLab PSL extraction backend with an OpenGL rendering frontend. The backend extracts trajectories from a given stress field using parameters that are either specified via the GUI that is built into the renderer, or a configuration file. We have chosen a MatLab backend due to the popularity of MatLab in mechanical engineering, and, thus, to enable engineers to easily integrate new model representations and algorithms. Currently, 3D-TSV works with hexahedral simulation grids, including MatLab code for trilinear and inverse distance-based interpolation of stress tensors in such grids. If other types of basis functions are used, the corresponding MatLab functions simply need to be exchanged. Due to the cell adjacency structure that is built internally to efficiently find the next cell during trajectory integration in deformed hexahedral grids, other cell types can be supported with only minor additional effort.</p>
<p>为了便于与现有系统的集成和最终用户的使用，3D-TSV 被实现为一个连接 MatLab PSL 提取后端和 OpenGL 渲染前端的客户服务器工具。后端从一个给定的应力场中提取轨迹，所使用的参数可以通过渲染器中的 GUI 或者配置文件来指定。由于 MatLab 在机械工程中的普及，我们选择了 MatLab 后端，从而使工程师能够轻松地整合新的模型表示和算法。目前，3D-TSV 适用于六面体仿真网格，包括 MatLab 代码，用于在此类网格中进行三线和基于反距离的应力张量插值。如果使用其他类型的基础函数，只需要交换相应的 MatLab 函数。由于在变形六面体网格的轨迹整合过程中，内部建立的单元相邻结构可以有效地找到下一个单元，因此只需稍加努力就可以支持其他单元类型。</p>
<p>The frontend renders whatever set of lines that is sent from the backend using advanced rendering options such as depth cues, outlines, as well as ambient occlusion effects to improve the perception of the spatial relationships between trajectories. Furthermore, the user can select to visualize one pair of stress directions via ribbons. Ribbons follow one of the selected directions and twist according to the other one, and they can effectively convey regions where the assignment of the eigenvector directions to the type of PSL (i.e., major, medium, or minor) changes.</p>
<p>前端使用高级渲染选项 (如深度提示、轮廓以及环境光遮挡效果) 渲染从后端发送的任何线条集，以改善对轨迹之间空间关系的感知。此外，用户可以选择通过色带可视化一对应力方向。条带沿着一个选择的方向并根据另一个方向扭曲，它们可以有效地传达特征向量方向对 PSL 类型 (即，主要、中等或次要) 的分配发生变化的区域。</p>
<p>To summarize, the contributions of this work are</p>
<p>• an advanced and publicly available tool for trajectorybased stress tensor visualization supporting stress fields on arbitrary hexahedral grids,</p>
<p>• the adaptation of evenly spaced line seeding to create a space-filling set of PSLs with improved regularity,</p>
<p>• an adaptive level-of-detail visualization using varying PSL density and visual mappings to lines and ribbons.</p>
<p>总而言之，这项工作的贡献是。</p>
<p>・支持任意六面体网格上应力场的基于轨迹的应力张量可视化的先进且公开可用的工具，</p>
<p>・调整均匀排列的线路播种，以创造一套规律性更好的填充空间的 PSL，</p>
<p>・使用不同的 PSL 密度和到线条和色带的视觉映射，实现自适应的细节层次可视化。</p>
<p>The application of 3D-TSV is demonstrated in a number of experiments using datasets with different shapes and stress states. The code of 3D-TSV is made publicly available under a BSD license, and published on <a target="_blank" rel="noopener" href="https://github.com/Junpeng-Wang-TUM/3D-TSV">https://github.com/Junpeng-Wang-TUM/3D-TSV</a>. In video1, the seeding of trajectories by 3D-TSV is compared to the seeding of trajectories separately in each principal stress direction field via evenly spaced seeding [16]. 3D-TSV can be used as client server system as described (see video2 ), or as standalone tool solely in MatLab providing rudimentary visualization options (see video3 ). Also the frontend can be used standalone, reading the PSL specific information from "psl.dat" files (see video4 ). Thus, any other backend can be used to generate PSLs and let the frontend visualize them. We also provide a script written in the ANSYS built-in language APDL, which automatically converts the result of an ANSYS finite element stress analysis into the format required by the 3D-TSV backend (see video5 ). To support the output from ABAQUS, the mesh information needs to be read from the ABAQUS input file (".inp"), and the stress data can be acquired from the result file (".rpt"). We provide datasets, description and configuration files, as well as scripts for all use cases of 3D-TSV on the publicly available GitHub repository.</p>
<p>使用不同形状和应力状态的数据集进行了大量的实验，展示了 3D-TSV 的应用。3D-TSV 的代码在 BSD 许可下公开提供，并在 <a target="_blank" rel="noopener" href="https://github.com/Junpeng-Wang-TUM/3D-TSV">https://github.com/Junpeng-Wang-TUM/3D-TSV</a>. 上发布。在视频 1 中，3D-TSV 的轨迹播种与通过均匀间隔播种分别在每个主应力方向场中播种轨迹进行了比较 [16]。3D-TSV 可用作所述的客户端服务器系统 (见视频 2)，或仅在提供基本可视化选项的 MATLAB 中用作独立工具 (见视频 3)。此外，前端还可以独立使用，从 \“psl.dat\” 文件读取 PSL 特定信息 (请参阅 VIDEO4)。因此，任何其他后台都可以用于生成 PSL，并让前端可视化它们。我们还提供了一个用 ANSYS 内置语言 APDL 编写的脚本，该脚本自动将 ANSYS 有限元应力分析的结果转换为 3D-TSV 后端所需的格式 (见 VIDEO5)。为了支持 ABAQUS 的输出，需要从 ABAQUS 输入文件 (\“.inp\”) 读取网格信息，并且可以从结果文件 (\“.rpt\”) 获取应力数据。我们在公开可用的 GitHub 资源库上提供 3D-TSV 所有用例的数据集、描述和配置文件以及脚本。</p>
<h2 id="related-work"><a class="anchor" href="#related-work">#</a> <strong>Related work</strong></h2>
<p>相关工作</p>
<p><strong>Stress Tensor Field Visualization.</strong> Stress tensor field visualization can be classified into trajectory-, glyph- and topology-based methods [21, 12]. Trajectory-based methods choose the PSLs as visual abstractions of the stress field, focusing on the directional structure of the principal stresses.Delmarcelle and Hesselink [6] introduced the concept of hyperstreamlines, a visual mapping of the medium and minor principal stresses onto a tube surface with a single selected major PSL as centerline. Dick et al [8] trace the major and minor PSLs from randomly distributed seed points in the loading area of the solid object, and different types of stress state like tension and compression are distinguished by color. In order to identify and visualize regions where stress trajectories are of rotational or hyperbolic behavior, Oster et al [28] proposed the concept of tensor core lines in 3D second-order tensor fields. Hotz et al [15] smear out dye along the PSLs using line integral convolution. In this way, a density field is generated that resembles a grid-like structure. This approach provides a global overview of a 2D stress distribution, yet an extension to 3D is problematic due to the generation of a dense volumetric field.</p>
<p><strong>应力张量场的可视化</strong>。应力张量场的可视化可分为基于轨迹、字形和拓扑的方法 [21, 12]。Delmarcelle 和 Hesselink [6] 提出了超流线的概念，即以单个选定的主要 PSL 为中心线，将中、小主应力可视化地映射到管面上。Dick 等人 [8] 从固体物体的加载区域中随机分布的种子点追踪主要和次要的 PSLs，不同类型的应力状态如拉伸和压缩通过颜色来区分。为了识别和可视化应力轨迹为旋转或双曲行为的区域，Oster 等人 [28] 提出了三维二阶张量场中张量核心线的概念。Hotz 等人 [15] 使用线积分卷积沿 PSL 抹出染料。通过这种方式，产生了一个类似于网格状结构的密度场。这种方法提供了二维应力分布的全局概况，但由于生成了密集的体积场，扩展到三维是有问题的。</p>
<p>It’s worth noting that even though stresses are frequently simulated and analysed in engineering applications, the use of trajectory-based visualizations that consider the whole stress field as a tensor field instead of several scalar fields are not commonplace. In particular, such functionality seems neither provided by any of the well-established software packages for stress simulation, like ABAQUS and ANSYS, nor by dedicated environments for visualizing finite-element simulation results [24, 44].</p>
<p>值得注意的是，尽管应力在工程应用中经常被模拟和分析，但基于轨迹的可视化的使用并不常见，这种可视化将整个应力场视为张量场，而不是几个标量场。特别是，这种功能似乎既不是由 ABAQUS 和 Ansys 等任何成熟的应力模拟软件包提供的，也不是由用于可视化有限元模拟结果的专用环境提供的 [24，44]。</p>
<p>Glyph-based methods, on the other hand, depict the stress field by a set of well-designed geometric primitives – so-called tensor glyphs. Tensor glyphs were originally designed for glyph-based diffusion tensor visualization [19], and later adapted to visualize positive definite tensors [18], general symmetric tensors [34], as well as asymmetric tensors[35, 11]. Glyph-based techniques are problematic when used to visualize 3D stress fields, due to their inherent occlusion effects. Specific placement strategies can be used to reduce the number of glyphs and occlusions thereof [20, 14]. Tensor glyphs are effective in showing the local stress states, but they cannot effectively communicate the global structure of stress lines. Patel and Laidlaw [30] proposed to guide the placement of glyphs by principal trajectories in the underlying field, and thus to provide a better understanding of the global relationships in this field.</p>
<p>另一方面，基于字形的方法通过一组精心设计的几何基元 -- 所谓的张量字形来描述应力场。张量字形最初是为基于字形的扩散张量可视化而设计的 [19]，后来改编为可视化正定张量 [18]、一般对称张量 [34] 以及不对称张量 [35, 11]。由于其固有的闭塞效应，基于字形的技术在用于可视化三维应力场时是有问题的。具体的放置策略可以用来减少字形的数量和遮挡 [20, 14]。张量字形在显示局部应力状态方面是有效的，但它们不能有效地传达应力线的全局结构。Patel 和 Laidlaw [30] 提出通过底层领域的主要轨迹来指导字形的放置，从而更好地理解这个领域的全局关系。</p>
<p>Topology-based approaches for stress tensor visualization abstract from the depiction of stress directions and focus on revealing specific topological characteristics of the tensor field. Delmarcelle and Hesselink [7, 13] studied the topology of symmetric 2D and 3D tensor fields, and introduced the fundamental concepts of degenerate points and topological skeletons. Zheng and Pang [49], and later Roy et al [33], discussed the robust extraction of these topological features.</p>
<p>Zobel and Scheuermann proposed the notion of extremal points to analyze the complete invariant part of the tensor [50]. Raith et al presented a general approach for the generation of separating surfaces in the invariant space [32].</p>
<p>Palacios et al introduced the eigenvalue manifold and visualized the 3D eigenvectors as curve surfaces [29]. Qu et al [31] further generalized the concepts of degenerate curves and neutral surfaces to a unified framework called mode surfaces.</p>
<p>基于拓扑结构的应力张量可视化方法从应力方向的描述中抽象出来，重点是揭示张量场的特定拓扑特征。Delmarcelle 和 Hesselink [7, 13] 研究了对称的二维和三维张量场的拓扑结构，并介绍了退化点和拓扑骨架的基本概念。Zheng 和 Pang [49]，以及后来的 Roy 等人 [33]，讨论了这些拓扑学特征的稳健提取。Zobel 和 Scheuermann 提出了极值点的概念来分析张量的完整不变部分 [50]。Raith 等人提出了一种在不变空间中生成分离面的一般方法 [32]。Palacios 等人介绍了特征值流形，并将三维特征向量可视化为曲线面 [29]。Qu 等人 [31] 进一步将退化曲线和中性曲面的概念概括为一个统一的框架，称为模式曲面。</p>
<p><strong>Streamline Seeding</strong>. Seeding strategies to control the density and placement of trajectories in vector fields are widely used in flow visualization. Turk and Banks [39] and Jobard and Lefer [16] were the first to introduce seeding strategies for generating evenly spaced sets of streamlines in 2D vector field. Numerous extensions and improvements of these concepts have been proposed since then. In particular, Vilanova et al [41] proposed an extension of the approach by Jobard and Lefer to diffusion tensor fields, which detects the distance between the new streamline and the existing ones during the tracing process. They demonstrate the generation of evenly distributed streamlines, however, the approach suffers from ‘unfinished’ streamlines that are caused by an artificial stopping criterion and only considers a single eigenvector field at a time. For 3D flow visualization, dedicated approaches and frameworks have been developed to reduce the visual clutter and occlusion of densely distributed streamlines in 3D fields [47, 4, 48, 17]. However, these techniques do not fit our goal of visualizing PSLs and their mutual relationships, which requires considering three sets of orthogonal PSLs simultaneously.</p>
<p><strong>流线播种</strong>。控制矢量场中轨迹密度和位置的播种策略被广泛用于流动可视化中。Turk 和 Banks [39] 以及 Jobard 和 Lefer [16] 首先介绍了用于在二维矢量场中生成均匀间隔的流线集的播种策略。此后，这些概念的大量扩展和改进被提出。特别是 Vilanova 等人 [41] 提出了 Jobard 和 Lefer 的方法在扩散张量场的扩展，在追踪过程中检测新流线和现有流线之间的距离。他们证明了均匀分布的流线的生成，然而，该方法存在由人工停止标准引起的 "未完成" 的流线，并且每次只考虑一个特征向量场。对于三维流的可视化，已经开发了专门的方法和框架来减少三维场中密集分布的流线的视觉杂乱和遮挡 [47, 4, 48, 17]。然而，这些技术并不适合我们对 PSL 及其相互关系进行可视化的目标，这需要同时考虑三组正交的 PSLs。</p>
<p><strong>Streamline Visualization</strong>. Illuminated streamlines are often used as a means of visualizing streamlines in a 3D environment. The streamlines are mapped to tubes and then shaded, e.g., using the Blinn-Phong shading model [3]. Early work on illuminated streamlines was done by Zöckler et al [51] and Mattausch et al [27]. Stoll et al [37] extended this work by introducing stylized line primitives, rendered by a hybrid CPU-GPU renderer. Liu [26] presented the DOXIV, a prototype framework for high-performance visual analysis of large flow data. Volpe [42] first introduced the concept of streamribbons for flow field visualization</p>
<p><strong>流线的可视化</strong>。照明流线经常被用作三维环境中流线可视化的一种手段。流线被映射到管子上，然后进行着色，例如，使用 Blinn-Phong 的着色模型 [3]。Zöckler 等人 [51] 和 Mattausch 等人 [27] 做了关于照明流线的早期工作。Stoll 等人 [37] 通过引入风格化的线条基元，由 CPU-GPU 混合渲染器渲染，扩展了这项工作。Liu [26] 提出了 DOXIV，这是一个用于对大流量数据进行高性能可视化分析的原型框架。Volpe [42] 首次为流场可视化引入了流带的概念。</p>
<p><strong>Hexahedral Meshing</strong>. An alternative approach to PSL-based stress field visualization is to generate a frame field from the principal stress field first and employ field-aligned hexahedral meshing to produce orthogonal edges that follow PSLs. The edges of such hex-meshes can follow the directions of PSLs excellently in situations where degenerate points are not present and the stress lines show low degrees of convergence and divergence. However, when guided with frame fields corresponding to realistic load situations, yet still much more benign than those demonstrated in this work, it is an unsolved problem to reliably produce an all-hex mesh. Hexahedral-dominant meshing has been resorted as an intermediate solution. For instance, Wu et al [46] propose a conforming stress-guided lattice structure by combining topology optimization with the field-guided polyhedral meshing algorithm from [9]. Arora et al [1] generate similar structural designs via the guidance of the principal stress field, where they modify the stress field to get a smooth frame field. However, hexahedral-dominant meshes often contain either T-junctions or non-hexahedral elements with non-orthgonal edges, significantly deviating from the PSLs and are, thus, not applicable for stress field analysis either.</p>
<p><strong>六面体网格划分</strong>。基于 PSL 的应力场可视化的另一种方法是首先从主应力场生成一个框架场，然后采用场对准的六面体网格划分来产生遵循 PSL 的正交边缘。这种六面体网格的边缘在不存在退化点的情况下可以很好地遵循 PSL 的方向，而且应力线的收敛和发散程度很低。然而，当用对应于现实荷载情况的框架场引导时，但仍比本工作中所展示的要良性得多，要可靠地产生一个全六面体网格是一个未解决的问题。六面体为主的网格划分已经被作为一种中间解决方案而采用。例如，Wu 等人 [46] 通过将拓扑优化与 [9] 中的场引导多面体网格划分算法相结合，提出了一种符合应力引导的网格结构。Arora 等人 [1] 通过主应力场的引导产生类似的结构设计，他们修改应力场以获得平滑的框架场。然而，六面体为主的网格往往包含 T 形交叉点或具有非正交边缘的非六面体元素，大大偏离了 PSL，因此，也不适用于应力场分析。</p>
<h2 id="stress-tensor-directions"><a class="anchor" href="#stress-tensor-directions">#</a> <strong>Stress Tensor Directions</strong></h2>
<p>应力张量方向</p>
<p>At each point in a 3D solid under load, the stress state is fully described by the stress vectors for three mutually orthogonal orientations. The second-order stress tensor</p>
<p>在负载下的三维实体的每一点上，应力状态完全由三个相互正交的方向的应力向量来描述。二阶应力张量</p>
T = \left[ {\matrix{ { {\sigma _{xx} } } &amp; { {\tau _{xy} } } &amp; { {\tau _{xz} } } \cr { {\tau _{xy} } } &amp; { {\sigma _{yy} } } &amp; 
{ {\tau _{yz} } } \cr { {\tau _{xz} } } &amp; 
{ {\tau _{yz} } } &amp; 
{ {\sigma _{zz} } } \cr } } \right]

<p>contains these vectors for the axes of a Cartesian coordinate system. T is symmetric since the shear stresses given by the off-diagonal elements in T are equal on mutually orthogonal planes. The principal stress directions of the stress tensor indicate the three mutually orthogonal directions along which the shear stresses vanish. These directions are given by the eigenvectors of T , with magnitudes given by the corresponding eigenvalues. The signs of the principal stress magnitudes classify the stresses into tension (positive sign) or compression (negative sign). However, since there are three principal stresses acting at each point, the classification is with respect to a specific direction</p>
<p>包含直角坐标系的轴的这些向量。T 是对称的，因为 T 中的非对角线元素给出的剪应力在相互正交的平面上是相等的。应力张量的主应力方向表示剪应力消失的三个互为正交的方向。这些方向由 T 的特征向量给出，其大小由相应的特征值给出。主应力大小的符号将应力分为拉伸（正符号）和压缩（负符号）。然而，由于有三个主应力作用在每个点上，所以分类是针对一个特定的方向而言的</p>
<p>In descending order, the three eigenvalues of T represent the major  , medium  and minor principal stresses, with the corresponding eigenvectors indicating the principal stress directions at each point in the 3D solid. The trajectories along these directions are called the principal stress lines (PSLs). They are computed by numerically integrating massless particles in each single (normalized) eigenvector field.</p>
<p>按降序排列，T 的三个特征值分别表示大、中、小主应力，对应的特征向量表示三维实体中每个点的主应力方向。沿这些方向的轨迹称为主应力线 (PSL)。它们是通过对每个单一 (归一化) 特征向量场中的无质量粒子进行数值积分来计算的。</p>
<p>In general, $ <ruby>\sigma _1},{\sigma _2},{\sigma _3} $ are mutually unequal, and the eigenvectors are linearly independent and even mutually orthogonal due to the symmetry of T . However, so-called degenerate points can exist where two or more eigenvalues are equal. In the vicinity of these points, which are classified by $ {\sigma _1} = {\sigma _2} &gt; {\sigma _3}or{\sigma _1} &gt; {\sigma _2} = \sigma _3<rp>(</rp><rt>6 $ , the PSL direction cannot be decided. Therefore, when tracing along a principal stress direction, we test whether the eigenvalue $ {\sigma _i</rt><rp>)</rp></ruby>$ corresponding to this direction is too close to another eigenvalue  $ <ruby>\sigma _j} $ $ \deg  = {1 \over 2}\left| { { { {\sigma _i} - {\sigma _j} } \over { {\sigma _i} + {\sigma _j} } } } \right| &lt; {10<rp>(</rp><rt>{ - 6</rt><rp>)</rp></ruby>} $. If this is the case and the angle between the PSL tangents at the current and next integration point is too large, the integration is stopped. Furthermore, we provide the option to map deg to the color of a PSL via a color table (see Sec. 4.3), so that the proximity to a degenerate point is indicated. PSL integration is also stopped when the next integration point is located on a boundary face, the point is closer to a previous point on the same trajectory than a predefined distance threshold (i.e., to avoid running into closed orbits), or the number of integration steps reaches the pre-defined threshold.</p>
<p>通常，$ <ruby>\sigma _1},{\sigma _2},{\sigma _3}$ <rt></rt>是<rp> (</rp><rt>6$</rt><rp>)</rp> 互不相等的<rp> (</rp><rt>分类的点附近，不能</rt><rp>)</rp>，<rt></rt>并且由于<rp> (</rp><rt>确定 PS</rt><rp>)</rp>T<rt></rt> 的对称性<rp> (</rp><rt>L 的方向</rt><rp>)</rp>，<rt></rt>特征向量是线性独立的<rp> (</rp><rt>因此，当沿着主应力方</rt><rp>)</rp>，<rt></rt>甚至是相互正交的<rp> (</rp><rt>向追踪时，我们测</rt><rp>)</rp>。<rt></rt>然而<rp> (</rp><rt>试与</rt><rp>)</rp>，<rt></rt>在两个或多<rp> (</rp><rt>该方向对应</rt><rp>)</rp> 个特征值相等的地方可能存在<rp> (</rp><rt>的特征值是否与另一个特征值</rt><rp>)</rp> 所<rp> (</rp><rt>$</rt><rp>)</rp> 谓的简并点<rp> (</rp><rt>{\sig</rt><rp>)</rp>。<rt></rt>在这<rp> (</rp><rt>ma</rt><rp>)</rp> 些按<rp> (</rp><rt>_j</rt><rp>)</rp> $ {\sigma _1} = {\sigma _2} &gt; {\sigma _3}or{\sigma _1} &gt; {\sigma _2} = \sigma _3<rt></rt></ruby>$ 太接近，即 $ \deg  = <ruby>1 \over 2}\left| { { { {\sigma _i} - {\sigma _j} } \over { {\sigma _i} + {\sigma _j} } } } \right| &lt; {10<rp>(</rp><rt>{ - 6</rt><rp>)</rp></ruby>} $ 如果是这样，并且当前积分点和下一个积分点的 PSL 切线之间的夹角太大，则停止积分。此外，我们还提供了通过颜色表将 deg 映射到 PSL 颜色的选项 (参见 Sec。4.3)，从而表示接近于一个简并点。当下一个积分点位于边界面上、该点比预定距离阈值更接近同一轨迹上的前一点时 (即，为了避免撞上闭合轨道)、或者积分步数达到预定阈值时，PSL 积分也被停止。</p>
<p>The integration of PSLs requires to select seed points from which they start until they arrive at a degenerate point or the boundary. While uniform seeding in the entire domain is used as the default option, the user can select seeding from the boundary vertices as well as the vertices where loads are applied. Furthermore, different integration schemes can be used for PSL tracing, including the 1st-order Euler method, and the 2nd- and 4th-order Runge-Kutta methods, where the fixed integration step size $ \delta $ is used for Cartesian meshes, and an adaptive $ \delta $ for unstructured hexahedral meshes. In each integration step, the stress tensor T is interpolated, and the eigenvalues and eigenvectors are computed from the interpolated tensor. If none of the mentioned stopping criteria holds, the next step is performed in the direction with the least deviation from the previous direction.</p>
<p>PSL 的集成需要选择种子点，从这些种子点开始，直到它们到达退化点或边界。虽然整个领域的均匀播种被用作默认选项，但用户可以选择从边界顶点以及施加载荷的顶点播种。此外，不同的积分方案可用于 PSL 追踪，包括一阶欧拉方法、二阶和四阶 Runge-Kutta 方法，其中固定积分步长 $ \delta $ 用于笛卡尔网格，而自适应 $ \delta $ 用于非结构化六面体网格。在每个积分步骤中，应力张量 T 被内插，特征值和特征向量从内插的张量中计算出来。如果上述停止标准都不成立，则在与前一方向偏差最小的方向上进行下一步。</p>
<h2 id="psl-seeding-and-level-of-detail"><a class="anchor" href="#psl-seeding-and-level-of-detail">#</a> <strong>PSL Seeding and Level of Detail</strong></h2>
<p>PSL 播种和细节水平</p>
<p>Finding a set of PSLs that effectively convey the principal stress directions in 3D stress fields requires to consider perceptual issues related to the visualization of large sets of trajectories. While in principle the PSLs of a single type, i.e., major, medium, or minor, can be visualized separately using techniques from flow visualization, in a stress field the different types of PSLs need to be shown simultaneously to understand their mutual interplay. However, an effective and efficient visual analysis is hindered by the mutual orthogonality of the different types, which is perceived as a disordered state even when a low number of PSLs is shown. Our proposed seeding strategy cannot completely avoid this problem, but it has some built-in regularity due to enforced PSL intersections.</p>
<p>要找到一套能有效表达三维应力场中主应力方向的 PSL，需要考虑与大组轨迹的可视化有关的感知问题。虽然原则上单一类型的 PSLs，即主要的、中等的或次要的，可以用流动可视化的技术分别进行可视化，但在应力场中，不同类型的 PSLs 需要同时显示，以了解它们的相互作用。然而，有效和高效的视觉分析受阻于不同类型的相互正交性，即使在显示低数量的 PSL 时，也被认为是一种无序状态。我们提出的播种策略不能完全避免这个问题，但由于强制的 PSL 相交，它有一些内在的规律性。</p>
<p><img loading="lazy" src="https://ptpimg.me/p6yop1.png" alt=""></p>
<p>Figure 2: Starting from a set of seeds with empty valence [0 0], the sampling process is performed until all the seed valences have been turned to [1 1]. The ocher and blue lines are the major and minor PSLs.</p>
<p>图 2：从一组空价 [0 0] 的种子开始，进行采样过程，直到所有的种子价都变成 [1 1]。赭色和蓝色的线是主要和次要的 PSL</p>
<h3 id="evenly-spaced-psl-seeding"><a class="anchor" href="#evenly-spaced-psl-seeding">#</a> <strong>Evenly Spaced PSL Seeding</strong></h3>
<p>均匀分布的 PSL 播种</p>
<p>The proposed seeding strategy builds upon the evenly spaced streamline seeding approach by Jobard and Lefer [16], and extends this approach in several ways to account for the application to PSLs. For the sake of clarity, we describe the strategy in the context of 2D stress fields, yet it will become clear that the extension to 3D is straightforward.However, when applied in 3D, the resulting PSL structures show a fundamental difference. Unlike in 2D, where due to the intersections between major and minor PSLs a fairly regular grid-like structure is generated, such intersections are rare or do not exist at all when seeding PSLs in 3D. This counteracts the impression of a consistent grid-like structure and results in a rather disordered appearance. We propose a seeding strategy that weakens this effect, but it needs to be considered that due to the nature of PSLs in 3D stress fields a globally consistent 3D grid-like structure is impossible to achieve in general.</p>
<p>所提出的播种策略建立在 Jobard 和 Lefer [16] 的匀速流线播种方法的基础上，并以几种方式扩展了这种方法，以说明对 PSL 的应用。为了清楚起见，我们在二维应力场的背景下描述该策略，然而很明显，扩展到三维是直截了当的。然而，当应用于三维时，所产生的 PSL 结构显示出根本的不同。与二维不同的是，由于主要 PSL 和次要 PSL 之间的交叉，产生了一个相当有规律的网格状结构，而在三维中播种 PSL 时，这种交叉点很少或根本不存在。这抵消了一致的网格状结构的印象，导致了相当无序的外观。我们提出了一种削弱这种影响的播种策略，但需要考虑到由于三维应力场中 PSL 的性质，一般来说，全局一致的三维网格状结构是不可能实现的。</p>
<p>Our method builds upon the selection of new seed points in the spirit of Jobard and Lefer, where the potential candidates are those points which are at least a prescribed distance away from any already extracted PSL. Of these candidates, the one with minimum distance is selected and a new trajectory is started at that point. In contrast, in our approach the distance is always wrt. the initial seed point, so that the PSLs grow around that point instead of being seeded at vastly different locations.</p>
<p>我们的方法基于 Jobard 和 Lefer 的精神选择新的种子点，其中潜在的候选点是那些与任何已经提取的 PSL 至少有一个规定距离的点。在这些候选点中，选择距离最小的一个，并从该点开始一个新的轨迹。相比之下，在我们的方法中，距离总是相对于初始种子点而言的，因此，PSL 围绕该点生长，而不是在巨大的不同位置播种。</p>
<p>To adapt the seeding strategy to the situation of different types of PSLs, we first introduce the concept of seed valence. In 2D, the seed valence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ϑ</span></span></span></span> is a 2 × 1 binary array, which is associated to each seed point to indicate whether and of which type PSLs have been traced from this point. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ϑ</span></span></span></span>can take on four different bit combinations, i.e., empty seed [0 0] (passed by no PSL), solid seed [1 1] (passed by both major and minor PSLs) and semi-empty seed [1 0] (only passed by major PSL) or [0 1] (only passed by minor PSL). The sampling process is repeated until all valences of all possible seed points become solid [1 1]. With this definition of seed valence, the sampling process is performed iteratively, by using the seed valence to characterize the state of each seed point at a specific iteration. To ensure that the generated PSLs are space-filling, the initial candidate seed points (with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ϑ</span></span></span></span> = [0 0]) are located at the vertices of a space-filling Cartesian grid (step 0 in Figure 2).</p>
<p>为了使种子策略适应不同类型 PSL 的情况，我们首先引入了种子价的概念，在 2D 中，种子价<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ϑ</span></span></span></span> 是一个 2×1 的二进制数组，它与每个种子点相关联，以指示是否以及哪种类型的 PSL 已经从这一点被跟踪。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ϑ</span></span></span></span> 可以采用四种不同的比特组合，即空种子<a href="%E6%97%A0PSL%E4%BC%A0%E9%80%92"> 0 0</a>、实心种子<a href="%E7%94%B1%E4%B8%BB%E8%A6%81%E5%92%8C%E6%AC%A1%E8%A6%81PSL%E4%BC%A0%E9%80%92"> 1 1</a> 和半空种子<a href="%E4%BB%85%E7%94%B1%E4%B8%BB%E8%A6%81PSL%E4%BC%A0%E9%80%92"> 1 0</a> 或<a href="%E4%BB%85%E7%94%B1%E6%AC%A1%E8%A6%81PSL%E4%BC%A0%E9%80%92"> 0 1</a>。重复采样过程，直到所有可能的种子点的所有价数都变为实数 [11]。有了这个种子价的定义，通过使用种子价来表征每个种子点在特定迭代中的状态，采样过程被迭代地执行。为了确保生成的 PSL 是空间填充的，初始候选种子点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϑ</mi></mrow><annotation encoding="application/x-tex">\vartheta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ϑ</span></span></span></span> [0 0]) 位于填充空间的笛卡尔网格的顶点 (图 2 中的步骤 0)。</p>
<p>Seeding starts by selecting one of the candidate seed points and tracing the major and minor PSLs from it (Step 1 in Figure 2), setting $\vartheta $ = [1 1] at this point. Per default, the system starts with the seed point closest to the center of the bounding box of the domain, to preserve an existing plane symmetry of the stress field in the PSLs (see Figure 10 and Figure 11). Then, all candidate seed points with $\vartheta $ not equal to [1 1] are re-classified with respect to the currently existing PSLs. To exclude candidates too close to an existing major or minor PSL, $\vartheta $ of these candidates is set to [1 0] or [0 1], respectively. If a point is classified as [1 0] or [0 1] and closer to a minor or major PSL, respectively, its valence is set to [1 1]. The distance between a point and a PSL is computed as the minimum distance between the point and any of the integration points on the PSL. Proximity is decided via a distance threshold ", which also controls the density of the extracted PSLs.</p>
<p>种子设定开始于选择一个候选种子点并从中跟踪主要和次要 PSL (图 2 中的步骤 1)，在该点设置 $\vartheta $ =[11]。默认情况下，系统从最靠近区域边界框中心的种子点开始，以保留 PSL 中应力场的现有平面对称性 (参见图 10 和图 11)。然后，相对于当前存在的 PSL，对 $\vartheta $ 不等于 [11] 的所有候选种子点进行重新分类。为了排除与现有主要或次要 PSL 太接近的候选点，将这些候选点中的 $\vartheta $ 分别设置为 [1 0] 或 [0 1]。如果一个点被分类为 [1 0] 或 [0 1]，并且分别更接近于小调或大调 PSL，则其价设为 [1 1]。点与 PSL 之间的距离计算为该点与 PSL 上的任一积分点之间的最小距离。邻近度由距离阈值决定，该阈值还控制提取的 PSL 的密度。</p>
<p>To obtain a more regular PSL structure, each re-classified candidate point is re-located (i.e., merged) to the position of the closest integration point on the PSL causing its classification. This creates an "empty" band around the PSLs where no candidate seed point exists. The merging operation enforces that newly selected seed points lie on an existing PSL, so that the final PSL structure appears more regular and less cluttered (see Figure 3 for a comparison to the seeding approach by Jobard and Lefer). By placing the initial seed point in a region deemed important, the user can specifically enforce regularity in this region.</p>
<p>为了获得更规则的 PSL 结构，每个重新分类的候选点被重新定位 (即合并) 到导致其分类的 PSL 上最接近的积分点的位置。这在不存在候选种子点的 PSL 周围创建了一个 “空” 带。合并操作强制新选择的种子点位于现有的 PSL 上，因此最终的 PSL 结构看起来更规则、更整洁 (参见图 3，与 Jobard 和 Lefer 的种子方法进行比较)。通过将初始种子点放置在被认为重要的区域中，用户可以在该区域中具体实施规律性。</p>
<p>If the last computed PSL was a major or a minor PSL, then the next seed point is selected from the set of candidates with $\vartheta $ = [1 0] or [0 1], respectively. Thus, we alternate the order of major and minor PSL extraction to obtain a uniform distribution of both types. Of all these, the one closest to the initial seed point is selected as the new seed point, and the respectively transverse PSL is computed. The entire procedure is then restarted until no more candidate is available (see steps 2-5 in Figure 2).</p>
<p>如果最后计算的 PSL 是大 PSL 或小 PSL，则分别从具有 $\vartheta $ =[1 0] 或 [0 1] 的候选集合中选择下一个种子点。因此，我们交替主要和次要 PSL 提取的顺序，以获得两种类型的均匀分布。在所有这些点中，选择最接近初始种子点的一个作为新的种子点，并计算各自的横向 PSL。然后重新启动整个过程，直到没有更多的候选者可用 (参见图 2 中的步骤 2-5)。</p>
<p><img loading="lazy" src="https://ptpimg.me/av39tg.png" alt=""></p>
<p>Figure 3: PSLs in a bridge under load (see Figure 9 for the simulated load conditions). Major (ocher), medium (green) and minor (blue) PSLs generated by (top) separate seeding as proposed by [16] in each principal stress direction field, and (bottom) by our method. Note that since the stress field is not strictly symmetric, the PSL set shows some asymmetry.</p>
<p>图 3：负载下桥梁中的 PSL (模拟负载条件见图 9)。在每个主应力方向场中，由文 [16] 提出的 (顶部) 分开播种产生的大 (赭色)、中等 (绿色) 和次要 (蓝色) PSL，以及 (底部) 由我们的方法产生的 PSL。请注意，由于应力场不是严格对称的，因此 PSL 集显示出一些不对称性。</p>
<p>We further consider the situation where some empty seed points may get too close (measured by $\varepsilon $) to the other type of existing PSLs after they are merged to the current PSL, e.g., the seed valence $\vartheta $ of some empty seed points become [1 0] after merging them to the newly traced major PSL. However, it can also happen that some of these merged seed points might be close to some of the existing minor PSLs, which would unavoidably cause inappropriate placement of minor PSLs in the final visualization. Given this, we identify those semi-empty seed points after merging, and compute the distances of them to the corresponding type of PSLs. If there are distances less than $\varepsilon $, the valences of these seed points are set to [11]. By simply making $\vartheta $ a binary array with three elements referring to the major, medium and minor PSL, the proposed seeding strategy can be lifted to 3D.</p>
<p>我们进一步考虑了一些空种子点在合并到当前 PSL 后可能与另一种类型的现有 PSL 过于接近的情况（由 $\varepsilon $ 定义）。例如，一些空种子点合并到新跟踪的主 PSL 后的种子价 $\vartheta $ 变为 [1 0]。但也可能发生这样的情况，即合并后的一些种子点可能接近一些现有的小 PSL，这将不可避免地导致小 PSL 在最终可视化中放置不当。在此情况下，我们识别合并后的半空种子点，并计算它们到相应类型的 PSL 的距离。如果距离小于 $\varepsilon $ ，则将这些种子点的价数设置为 [11]。通过简单地使 $\vartheta $ 成为具有涉及主要、中等和次要 PSL 的三个元素的二进制数组，所提出的播种策略可以提升到三维</p>
<h3 id="psl-lod-structure"><a class="anchor" href="#psl-lod-structure">#</a> <strong>PSL LoD Structure</strong></h3>
<p>PSL LOD 结构</p>
<p>To change the density of the generated PSLs, the seeding process can simply be re-run with an appropriately set distance threshold $\varepsilon $. The larger this threshold is, the less PSLs are extracted. However, the different sets of PSLs that are generated for different thresholds are not nested, i.e., the PSLs at a coarser representation with lower PSL density are not a subset of the PSLs at a representation with higher density. Therefore, in an exploration session where the user interactively selects different PSL LoDs, there are abrupt changes when transitioning from one level to another. To avoid this, we propose to generate a nested PSL hierarchy.</p>
<p>为了改变所生成的 PSL 的密度，可以简单地使用适当设置的距离阈值 $\varepsilon $ 来重新运行种子设定过程。该阈值越大，提取的 PSL 就越少。然而，针对不同阈值生成的不同 PSL 集合是不嵌套的，即处于较低 PSL 密度的较粗表示处的 PSL 不是具有较高密度的表示处的 PSL 的子集。因此，在用户交互地选择不同 PSL LOD 的探索会话中，当从一个级别转换到另一个级别时，存在突然变化。为了避免这种情况，我们建议生成嵌套的 PSL 层次结构。</p>
<p>The basic idea underlying the construction of a nested hierarchy is to let the PSLs at a level with higher PSL density ’grow out’ sequentially from the PSLs at a lower density level. As a side effect, this enables saving computations by progressively computing a new level from the previous coarser level. For a given set of PSLs that have been generated with distance threshold <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> , the refined set of PSLs according to a distance threshold <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _1} &lt; {\varepsilon _0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is computed as follows: Firstly, the candidate seed points are reset to their initial positions. Secondly, the candidate seed points are merged to the existing PSLs according to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> , to create “empty” bands around the existing PSLs. The valences are updated accordingly to [1 0], [0 1] or [1 1] depending on the types of PSL they are merged to. After this, some nonsolid seeds are left, because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is larger than <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> . With these seeds the seeding is subsequently performed, including the iteration of seed point selection, PSL computation, and reclassification as described in subsection 4.1.</p>
<p>构建嵌套分层结构的基本思想是让具有较高 PSL 密度的 PSL 从较低密度水平的 PSL 顺序生长出来。作为一个副作用，这可以通过从上一个较粗的级别逐步计算新的级别来节省计算。对于给定的距离阈值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的 PSL 集合，根据距离阈值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _1} &lt; {\varepsilon _0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 计算 PSL 的精化集合如下：首先，将候选种子点重置到它们的初始位置，然后根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 将候选种子点合并到现有的 PSL，在现有的 PSL 周围创建” 空 “带。根据它们合并到的 PSL 类型，相应地将价更新为 [1 0]、[0 1] 或 [1 1]。在此之后，留下一些非实心种子，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{\varepsilon _1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 。利用这些种子，随后执行种子播种，包括种子点选择的迭代、PSL 计算和重新分类，如第 4.1 节所述。</p>
<p>To generate a full LoD PSL hierarchy, the user defines the minimum distance threshold " and the number M of levels to construct. Then, the distance thresholds of each level are computed as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mi>ε</mi><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>:</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">{2^{(M - k)} }\varepsilon ,k = 1:M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span><span class="mord mathnormal">ε</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> from coarse to fine, and the hierarchy is constructed progressively from the coarsest resolution level (see 1st and 2nd rows in Figure 4).To compute a PSL structure with different types of PSLs at different LoDs, the distance thresholds for each PSL type are first selected by the user, and then the multi-type LoD is computed by alternatively considering the different PSL types with their respective distances.</p>
<p>为了生成完整的 LOD PSL 层次结构，用户定义了最小距离阈值和要构建的级数 M。然后，每个级别的距离阈值被计算为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mi>ε</mi><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>:</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">{2^{(M - k)} }\varepsilon ,k = 1:M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span><span class="mord mathnormal">ε</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 从粗略到精细，并且该层次是从最粗的分辨率级别逐步构建的 (参见图 4 中的第一行和第二行)。为了计算在不同 LOD 处具有不同类型的 PSL 的 PSL 结构，用户首先为每种 PSL 类型选择距离阈值，然后通过交替地考虑不同的 PSL 类型及其各自的距离来计算多类型的 LOD。</p>
<h3 id="ribbon-based-stress-visualization"><a class="anchor" href="#ribbon-based-stress-visualization">#</a> <strong>Ribbon-based Stress Visualization</strong></h3>
<p>基于功能区的应力可视化</p>
<p>Instead of rendering lines, the user can select a PSL type (i.e., major, medium, minor) and visualize ribbon-shaped geometry [40] that is centered at the PSLs of the selected type and twists according to the direction of another stress type (see Figure 5 a,b). At each integration point along a PSL of the selected type, two lines with adjustable length are traced forward and backward along the other direction. The lines’ endpoints at subsequent integration points are connected to form a ribbon. It is worth noting that the constructed ribbons don’t coincide with streamsurfaces that are integrated from a PSL along one other stress direction. As shown by Raith et al [32], such surface might not even exist, i.e., when integrating from two points on the same PSL over a certain length along another stress direction, the two endpoints are not lying on a PSL in general. The mapping of two principal stress directions to a ribbon geometry is conceptually similar to the well-known hyperstreamlines [6], i.e., a mapping of two principal stress directions to a tube centered at the PSL along the third direction.</p>
<p>用户可以选择一个 PSL 类型（即主要的、中等的、次要的）来代替渲染线，并可视化带状几何体 [40]，该几何体以所选类型的 PSL 为中心，根据另一应力类型的方向进行扭曲（见图 5 a,b）。在沿选定类型的 PSL 的每个积分点上，沿另一方向向前和向后追踪两条长度可调的线。在随后的积分点上，这些线的端点被连接起来，形成一条带子。值得注意的是，所构建的带状结构与从 PSL 沿另一应力方向整合的流面并不重合。正如 Raith 等人 [32] 所示，这样的表面甚至可能不存在，也就是说，当从同一 PSL 上的两点沿另一应力方向积分一定长度时，两端点一般不位于 PSL 上。两个主应力方向到带状几何的映射在概念上类似于著名的超流线 [6]，即两个主应力方向到以 PSL 为中心沿第三个方向的管的映射。</p>
<p><img loading="lazy" src="https://ptpimg.me/pz3339.png" alt=""></p>
<p>Figure 5: When a PSL goes through a degenerate point (a), the ribbon-shaped geometry shows a sudden twist (b).(c) Behaviour of the eigenvalues along the ribbon’s center PSL, from which the ribbon’s direction and orientation is determined.</p>
<p>图 5：当 PSL 经过一个退化点时（a），带状几何体显示出突然的扭曲（b）。（c）沿带状中心 PSL 的特征值的行为，从这里可以确定带状的方向和方位。</p>
<p>We let the user select a visualization using ribbons to convey changes in the assignment of the eigenvector directions to the type of PSL in the vicinity of degenerate points.When a ribbon is formed as described, flips often occur in the vicinity of a degenerate point (see Figure 5 (c)). This is because the two directions can exchange their classification as major, medium, and minor, since this depends only on their position in the sorted sequence of eigenvalues. Thus, ribbons provide an additional visual cue to indicate topological changes of the PSLs in the vicinity of degenerate points.</p>
<p>我们让用户选择一种可视化的方式，使用丝带来表达在退化点附近的特征向量方向与 PSL 类型的分配变化。当丝带按所述形成时，翻转经常发生在退化点附近（见图 5（c））。这是因为两个方向可以交换它们的分类为主要、中等和次要，因为这只取决于它们在特征值排序序列中的位置。因此，丝带提供了一个额外的视觉线索来表明退化点附近的 PSL 的拓扑变化。</p>
<p>Figure 6 compares the options to visualize principal stress directions via ribbons and lines, and combine them into a single visualization. As can be seen, twists in the ribbon geometry effectively hint to regions where degenerate points might exist. For lines, 3D-TSV can map the degeneracy measure introduced in Sec. 3 to color. An interesting observation is that high degeneracy and flips thereof frequently occur close to the object boundaries when Cartesian simulation meshes are used. These flips occur due to the well-known inaccuracies at curved boundaries that are represented by hexahedral simulation elements in a Cartesian grid.</p>
<p>图 6 比较了通过带状和线状来显示主应力方向的选项，并将它们结合到一个单一的可视化中。可以看出，带状几何中的扭曲有效地提示了可能存在退化点的区域。对于线，3D-TSV 可以将第 3 节中介绍的退行性措施映射到颜色上。一个有趣的观察是，当使用笛卡尔模拟网格时，高退行性和其翻转经常发生在物体边界附近。这些翻转的发生是由于众所周知的弯曲边界的不精确性，这些边界是由笛卡尔网格中的六面体模拟元素表示的。</p>
<p><img loading="lazy" src="https://ptpimg.me/j3u1jp.png" alt=""></p>
<p>Figure 6: Top: Ribbons are aligned along the minor PSLs and twist according to the medium principal stress direction.Middle: Minor PSLs with degeneracy measure mapped from blue (low) to red (high). Bottom: A visualization using lines for minor PSLs and ribbons for major PSLs.</p>
<p>图 6：顶部：丝带沿着次要的 PSLs 排列，并根据中度主应力方向进行扭曲： 次要的 PSLs，其退化程度从蓝色（低）映射到红色（高）。底部： 用线条表示次要的 PSL，用带子表示主要的 PSL，这是一种可视化的方法。</p>
<h2 id="system-implementation"><a class="anchor" href="#system-implementation">#</a> <strong>System Implementation</strong></h2>
<p>系统实施</p>
<p>To implement the communication between the C++ visualization frontend and the MatLab extraction backend, the messaging library ZeroMQ is utilized, which can be used for communication over a wide variety of protocols, like TCP/IP. 3D-TSV relies on the request-reply pattern implemented in ZeroMQ, where the frontend issues a new request to the backend when the user changes simulation settings in the graphical user interface, and the backend sends back a reply as soon as the simulation is finished in order to notify the frontend of the availability of new data.</p>
<p>为了实现 C++ 可视化前端和 MatLab 提取后端之间的通信，我们利用了消息传递库 ZeroMQ，它可以用于各种协议的通信，如 TCP/IP。3D-TSV 依赖于 ZeroMQ 中实现的请求 - 回复模式，当用户在图形用户界面中改变仿真设置时，前端向后端发出新的请求，而后端在仿真结束后立即发回回复，以通知前端新数据的可用性。</p>
<p>The reason why we turned to MatLab instead of C++ for the implementation of the backend is, on the one hand, that the sampling method is an inherently sequential algorithm.</p>
<p>我们之所以采用 MatLab 而不是 C++ 来实现后端，一方面是由于抽样方法是一种固有的顺序性算法。</p>
<p>Thus, it cannot benefit significantly from multi-threaded PSL tracing or GPU parallelization. On the other hand, MatLab is widely spread in engineering, where most of our collaborators regarding stress visualization come from, and the engineers tend to use mainstream commercial software they are already familiar with to finish the design iteration quickly. In this case, they can run the MatLab backend independently without any complicated compilation and setup process. To this end, we also provide a slim MatLab visualization implementation, which can provide users a fast and easy way to explore the stress field, while discarding some more complex hardware-accelerated features from the C++ frontend, like depth cues or ambient occlusion <a target="_blank" rel="noopener" href="http://effects.It">effects.It</a> is worth noting that also the rendering frontend can be used standalone, by reading trajectories from a file specifying the exchange format regarding PSL type and LoD representation.</p>
<p>因此，它不能从多线程的 PSL 跟踪或 GPU 并行化中明显受益。另一方面，MatLab 在工程领域广泛传播，我们关于应力可视化的合作者大多来自工程领域，工程师们倾向于使用他们已经熟悉的主流商业软件来快速完成设计迭代。在这种情况下，他们可以独立运行 MatLab 后端，而不需要任何复杂的编译和设置过程。为此，我们还提供了一个纤细的 MatLab 可视化实现，它可以为用户提供一个快速简单的方法来探索应力场，同时放弃了 C++ 前端的一些更复杂的硬件加速功能，如深度提示或环境遮挡效果。值得注意的是，渲染前端也可以独立使用，通过从一个文件中读取轨迹，指定关于 PSL 类型和 LoD 表示的交换格式。</p>
<h3 id="numerical-psl-integration"><a class="anchor" href="#numerical-psl-integration">#</a> <strong>Numerical PSL Integration</strong></h3>
<p>数值化的 PSL 集成</p>
<p>3D-TSV is designed to support the visualization of PSLs in solids discretized by hexahedral grids, where the stress tensors are given at the grid vertices. When computing PSLs in Cartesian grids, component-wise trilinear interpolation of the tensors is used during numerical line integration. In deformed hexahedral cells, tensor interpolation is performed via inverse distance weighting [36].</p>
<p>3D-TSV 被设计用来支持六面体网格离散的固体的 PSLs 的可视化，其中应力张量在网格顶点给出。当在直角坐标网格中计算 PSL 时，在数值线积分过程中使用张量的分量三线性插值。在变形六面体单元中，张量插值是通过反距离加权进行的 [36]。</p>
<p>To integrate PSLs in Cartesian grids, the system provides fixed-step integration schemes with user adjustable stepsize of at least half the cell diameter. In deformed hexahedralgrids, a different approach is taken since the size of the simulation elements can vary, and with a constant stepsize the risk increases that multiple cells smaller than this size are missed in one single integration step. To reduce this risk, the integration stepsize is automatically adapted to the size (i.e., the length of the shortest edge) of the cell at the current integration point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{P_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> . These values are pre-computed and stored per cell. In each integration step, the size s of the current cell is read and multiplied by a user selected scaling factor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">{\delta _s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> . <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">{\delta _s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> can be made smaller than 1 to obtain more accurate PSLs. With the stepsize s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">{\delta _s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> , the PSL is integrated from the current point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{P_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> in cell <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> to the new point Pi+1. Then, the integration process is restarted with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> and the cell <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> containing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>为了在直角坐标网格中集成 PSL，系统提供了固定步长的集成方案，用户可以调整至少一半的单元直径的步长。在变形六面体网格中，要采取不同的方法，因为模拟元素的尺寸可能会变化，如果采用恒定的步长，那么在一个单一的积分步骤中会遗漏多个小于此尺寸的单元，风险会增加。为了减少这种风险，积分步长会自动适应当前积分点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{P_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 处的单元大小（即最短边的长度）。这些值是预先计算的，并存储在每个单元中。在每个积分步骤中，当前单元的尺寸 s 被读取并乘以用户选择的比例因子 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">{\delta _s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">{\delta _s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 可以小于 1，以获得更精确的 PSLs。通过步长 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">{\delta _s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> ，PSL 从单元格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 中的当前点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{P_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 积分到新点 Pi+1。然后，以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 和包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 的单元格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 重新开始积分过程。</p>
<p>To find <img loading="lazy" src="https://ptpimg.me/d0e00k.png" alt="">, it is first tested whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> is still contained in  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> . The following in-out criterion is used to test whether a point is located in a hexahedral cell: Given a hexahedral element with the centers and out-facing normal of its 6 faces<img loading="lazy" src="https://ptpimg.me/6cxtuc.png" alt=""> Any point P0 in the interior or on the boundary of the element satisfies max(arccos(<img loading="lazy" src="https://ptpimg.me/h23iyc.png" alt="">, see Figure 7a. In practice, the criterion is slightly relaxed to max(arccos(<img loading="lazy" src="https://ptpimg.me/zqr456.png" alt="">, to account for non-planar cell faces, i.e., a slight variation of the normal vectors across the faces.</p>
<p>要找到<img loading="lazy" src="https://ptpimg.me/d0e00k.png" alt="">，首先要测试 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 是否仍然包含在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 中。下面的 in-out 标准用来测试一个点是否位于一个六面体单元中： 给定一个六面体元素，其 6 个面的中心和朝外的法线为<img loading="lazy" src="https://ptpimg.me/3j48u3.png" alt="">元素内部或边界上的任何一点 P0 都满足 max (arccos (<img loading="lazy" src="https://ptpimg.me/h23iyc.png" alt="">，见图 7a。在实践中，该标准略微放宽为 max (arccos (<img loading="lazy" src="https://ptpimg.me/zqr456.png" alt="">，以考虑到非平面的细胞面，即法向量在各面的轻微变化。</p>
<p>If $${e_i}$$ does not contain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> , the cell <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> needs to be determined. To this end, we further test whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> lies in any of the adjacent cells <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{adj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> . For each cell, the set of adjacent cells as well as the adjacency type, i.e., face-, edge-, and vertex-adjacency, is pre-computed and stored. In case <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> is not within $ {e_i} $ or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{adj } }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> , we scale down the step size via a dichotomy strategy, i.e., $ {P_{i + 1} } $ = ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{ P_{i + 1} }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> + Pi) /2, until $ {P_{i + 1}} $ is located in $ {e_i} $ or it’s adjacent cells $ { e_{adj } } $.</p>
<p>如果 $${e_i}$$ 不包含 PI+1，则需要确定单元格 $ {e_{i + 1} } $。为此，我们进一步测试 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 是否位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的任意相邻单元格 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{adj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 中。对于每个小区，预计算并存储相邻小区的集合以及邻接类型，即面邻接、边邻接和顶点邻接。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 不在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{adj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 内，我们通过二分法策略缩小步长，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> =( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> +PI)/_2，直到 PI+1 位于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 或其相邻单元 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{adj}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 内。</p>
<p>In the case where  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span>  are connected by a single edge or vertex, it may still happen that cells are skipped when going from  ${P_i} $ to   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> . In this situation, stepsize refinement is performed multiple times until the cell  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> shares a face with   <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>  or is below a user-selected threshold. The latter situation is encountered when the PSL goes through a cell vertex or edge, so that face-adjacency cannot be determined.</p>
<p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 由单个边或顶点连接的情况下，当从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{P_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 转到  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{P_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 时，仍可能发生单元跳过。在这种情况下，执行多次步长细化，直到单元 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">{e_{i + 1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">{e_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 共享一个面或低于用户选择的阈值。当 PSL 穿过小区顶点或边缘时，会遇到后一种情况，从而无法确定面邻接。</p>
<p><img loading="lazy" src="https://ptpimg.me/m9q07x.png" alt=""></p>
<p>Figure 8: (a) The deformed hexahedral simulation mesh. (b) A PSL (blue trajectory) in the simulated stress field. It is ensured that every next integration point is in the previous cell or in a cell adjacent to the previous cell. (c) Same as (b), but now every next integration point is in a face-adjacent cell.</p>
<p>图 8：(A) 变形的六面体模拟网格。(B) 模拟应力场中的 PSL (蓝色轨迹)。确保每个下一个积分点都在前一个单元中或在与前一个单元相邻的单元中。(C) 与 (B) 相同，但现在每个下一个集成点都在一个面相邻的单元格中。</p>
<p>In Figure 8, for the given mesh two PSLs that have been extracted without and with additional stepsize refinement are compared. As can be seen, cells that would be skipped when using only face-to-face adjacency are now determined and considered in the integration.</p>
<p>在图 8 中，对于给定的网格，比较了在没有额外步长细化和经过额外步长细化的情况下提取的两个 PSL。可以看到，当仅使用面对面邻接时将被跳过的信元现在被确定并且在集成中被考虑。</p>
<h3 id="rendering"><a class="anchor" href="#rendering">#</a> <strong>Rendering</strong></h3>
<p>渲染</p>
<p>The line and ribbon primitives are rendered in a stylized fashion similar to the techniques by Zöckler et al [51], Stoll et al [37] and Mattausch et al [27], using default colors, halos and depth cues as shown in the first three images in Figure 1. Focus PSLs and contextual ribbons are rendered in ocher and blue, respectively. The base color is modulated using Blinn-Phong shading [3, 51], which assumes a point light source at the world space position of the viewer (i.e., a head light).</p>
<p>线条和带状基元以类似于 Zöckler 等人 [51]、Stoll 等人 [37] 和 Mattausch 等人 [27] 的技术的风格化方式进行渲染，使用默认的颜色、光晕和深度线索，如图 1 中的前三张图像所示。焦点 PSL 和背景色带分别用赭石色和蓝色渲染。基色使用 Blinn-Phong shading [3, 51] 进行调制，它假定在观看者的世界空间位置有一个点光源（即头灯）。</p>
<p>The user can interactively change the color mapping— also separately for each PSL type—and can in particular switch to a mapping of some scalar quantity to color, as indicated in the last image in Figure 1 using the scalar von Mises stress measure. The scalar values are issued via the backend as per-vertex attributes. The standard color scheme we use for the different principal stress directions (blue, green, ocher) is the ‘3-class Set2’ transfer function from ColorBrewer7 . It is colorblind safe and print friendly.</p>
<p>用户可以交互式地改变颜色映射 -- 也可以为每个 PSL 类型分别改变 -- 特别是可以切换到一些标量与颜色的映射，如图 1 中最后一张图片中使用的标量冯 - 米塞斯应力测量。标量值是通过后端作为每个顶点的属性发布的。我们为不同的主应力方向（蓝色、绿色、赭色）使用的标准颜色方案是 ColorBrewer7 的 "3 类 Set2" 转移函数。它是色盲安全的，也是打印友好的。</p>
<p>For enhanced depth perception, depth cues are added, i.e., with increasing distance to the camera, fragments are increasingly desaturated. A translucent simulation mesh outline hull can be rendered together with the stress field data in order to hint at the extents of the simulation domain.</p>
<p>为了增强深度感知，增加了深度提示，即随着与摄像机距离的增加，碎片会越来越不饱和。一个半透明的模拟网格轮廓可以和应力场数据一起渲染，以提示模拟域的范围。</p>
<h3 id="3d-tsv-settings"><a class="anchor" href="#3d-tsv-settings">#</a> <strong>3D-TSV Settings</strong></h3>
<p>3D-TSV 设置</p>
<p>3D-TSV provides a number of parameters that can be changed by the user to control the generation of PSLs.</p>
<p>3D-TSV 提供了一些用户可以改变的参数来控制 PSL 的生成。</p>
<p><img loading="lazy" src="https://ptpimg.me/230n8v.png" alt=""></p>
<p>Figure 9: The solid objects used in this work and the applied external loads. Red and blue arrows indicate the loading positions and directions, black regions indicate fixed boundaries. A finite-element-based elasticity analysis has been used to compute the stress field for each model under the predicted loads. The unstructured hexahedral meshes ‘Parts’ and ’Bearing’ are courtesy of [25] and [10], respectively. All other meshes are Cartesian meshes. ‘Arched Bridge’ and ’Rod’ are courtesy of [2] and [10], respectively. All simulated stress fields are made publicly available.</p>
<p>图 9：本工作中使用的实体物体和应用的外部载荷。红色和蓝色箭头表示加载位置和方向，黑色区域表示固定边界。基于有限元的弹性分析已被用于计算每个模型在预测载荷下的应力场。非结构化的六面体网格 "零件" 和 "轴承" 分别由 [25] 和 [10] 提供。所有其他网格都是笛卡尔网格。拱形桥 "和" 杆 " 分别由 [2] 和 [10] 提供。所有模拟的应力场都是公开的。</p>
<p><img loading="lazy" src="https://ptpimg.me/kb4q91.png" alt=""></p>
<p>Table 1 Model and performance statistics.  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{D_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>  is the length of the shortest dimension of the bounding box of the stress field.</p>
<p>表 1 模型和性能统计。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">{D_0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 是应力场边界盒的最短尺寸的长度。</p>
<p>These parameters include the merging threshold " and the number of levels M introduced in subsection 4.1 and subsection 4.2, respectively. Another set of parameters enables a user-guided interaction with the PSL distribution, including sliders for controlling the LoD resolution of major, medium and minor PSLs. In addition, the user can select the two PSL types that are used to generate ribbons. Via a drop-down menu, the user can select a scalar stress measures that are mapped to PSL color using a transfer function. The backend provides different stress components, such as the principal stress amplitudes, von Mises stress, and the six Cartesian stress components.</p>
<p>这些参数包括 4.1 小节和 4.2 小节中分别介绍的合并阈值 " 和水平数 M。另一组参数使用户可以在指导下与 PSL 分布互动，包括控制主要、中等和次要 PSL 的 LoD 分辨率的滑块。此外，用户可以选择用于生成色带的两种 PSL 类型。通过一个下拉菜单，用户可以选择一个标量的应力测量，用一个转移函数映射到 PSL 颜色。后台提供不同的应力成分，如主应力振幅、冯 - 米塞斯应力和六个笛卡尔应力成分。</p>
<h2 id="results"><a class="anchor" href="#results">#</a> <strong>Results</strong></h2>
<p>结论</p>
<p>In all of our experiments, PSL generation is performed on the CPU, i.e., a workstation running Ubuntu 20.04 with an AMD Ryzen 9 3900X @3.80GHz CPU and 32GB RAM.</p>
<p>Rendering is done on an NVIDIA RTX 2070 SUPER GPU with 8GB of on-chip memory. The rendering times are always below 10 milliseconds. The data sets we use in our experiments are shown in Figure 9. The stress fields are simulated by a finite element method (FEM), using the solid objects under the shown load conditions. Table 1 lists the numbers of simulation elements of each of the data sets, the seed points that are used to generate the PSLs, the number of generated PSLs, and the time required for PSL generation.</p>
<p>在我们所有的实验中，PSL 的生成是在 CPU 上进行的，即运行 Ubuntu 20.04 的工作站，配备 AMD Ryzen 9 3900X @3.80GHz CPU 和 32GB RAM。渲染是在具有 8GB 片上内存的 NVIDIA RTX 2070 SUPER GPU 上进行的。渲染时间总是低于 10 毫秒。我们在实验中使用的数据集如图 9 所示。应力场是通过有限元方法（FEM）模拟的，在所示的负载条件下使用实体物体。表 1 列出了每个数据集的模拟元素的数量，用于生成 PSL 的种子点，生成的 PSL 的数量，以及生成 PSL 所需的时间。</p>
<p>For the three models ’Bridge’, ’Cantilever’ and ’Rod’, we demonstrate the improvements of the proposed seeding strategy over evenly spaced streamline seeding. 3D-TSV is used to visually analyze the stress fields in ’Femur’ and ’Bracket’. These two data sets that are frequently seen in structural design and optimization [45]. Finally, we consider the two mechanical parts ’Bearing’ and ’Parts1’ to demonstrate the application of 3D-TSV to unstructured hexahedral simulation meshes.</p>
<p>对于 ' 桥'、' 悬臂 ' 和' 杆 ' 三个模型，我们证明了所提出的播种策略比均匀间隔的流线播种的改进。3D-TSV 被用来直观地分析 "股骨" 和 "支架" 的应力场。这两个在结构设计和优化中经常出现的数据集 [45]。最后，我们考虑了两个机械零件 ' 轴承 ' 和' 零件 1'，以展示 3D-TSV 在非结构化六面体仿真网格中的应用。</p>
<p><img loading="lazy" src="https://ptpimg.me/40ncyk.png" alt=""></p>
<p>Figure 10: PSLs in the ‘Cantilever’ stress field. PSLs by the proposed seeding strategy (left) and evenly spaced streamline seeding (right).</p>
<p>图 10："悬臂" 应力场中的 PSLs。通过建议的播种策略（左）和均匀间隔的流线播种（右）的 PSLs。</p>
<p>Figs. 10 and 11 emphasize the improvements by the proposed seeding strategy regarding the regularity of the extracted set of PSLs. 3D-TSV generates a fairly uniform space-filling PSL structure, which, in particular, maintains the symmetry of the stress field in ’Cantilever’. Evenly spaced streamline seeding, on the other hand, generates a far less regular design which introduces severe visual clutter.</p>
<p>图 10 和 11 强调了所提出的播种策略对提取的 PSL 集的规律性的改进。3D-TSV 产生了一个相当均匀的空间填充 PSL 结构，特别是保持了 "悬臂" 的应力场的对称性。另一方面，均匀间隔的流线播种则产生了一个不太规则的设计，引入了严重的视觉杂乱。</p>
<p>The visualization also highlights the importance of showing different PSL types simultaneously. In the analyzed tensor field, the signs of the eigenvalues along the major and minor PSLs are mostly positive and negative, respectively.This means that the major PSLs are mainly under tension and the minor PSLs mainly under compression. Thus, either of both effects could be shown by visualizing one PSL type, but not both.</p>
<p>这种可视化也突出了同时显示不同 PSL 类型的重要性。在分析的张量场中，沿着主要和次要的 PSL 的特征值的符号大多是正的和负的。这意味着主要的 PSL 主要是在张力下，次要的 PSL 主要是在压缩下。因此，这两种效应中的任何一种都可以通过观察一种 PSL 类型来显示，但不能同时显示。</p>
<p>Figure 12 (top) shows the space-filling PSLs in the stress field in the interior of ’Bracket’. From the boundary condition in Figure 9, we see that the structure is mainly under tension. Thus, we choose to show the major PSLs at the higher level of detail (L2) and the minor PSLs at lower level L1 (see Figure 12 (bottom)). The minor PSLs are shown via ribbons, with the medium principal stress direction indicating the twist. This enables a fine granular analysis of the major principal stress directions, and simultaneously provide a coarse representation of the other principal directions. A similar setting has been selected to visualize the stress directions in ’Femur’ (see Figure 1).</p>
<p>图 12（上）显示了 "支架" 内部应力场中的空间填充 PSL。从图 9 中的边界条件，我们看到该结构主要处于拉伸状态。因此，我们选择在较高的细节层次（L2）显示主要的 PSL，在较低的层次 L1 显示次要的 PSL（见图 12（底部））。次要的 PSL 是通过带子显示的，中主应力方向表示扭曲。这使得主要主应力方向的分析更加精细，同时提供了其他主应力方向的粗略表示。在 "股骨" 中也选择了类似的设置来显示应力方向（见图 1）。</p>
<p><img loading="lazy" src="https://ptpimg.me/847c76.png" alt=""></p>
<p>Figure 11: Top: PSLs showing the principal stress directions in ‘Rod’. Bottom: PSLs in ‘Rod’ from a different view. Left: PSLs computed by 3D-TSV. Right: PSLs computed via evenly spaced seeding as proposed by [16].</p>
<p>图 11：顶部：PSL 显示 "棒" 的主应力方向。底部： 从不同角度看 "棒" 的 PSLs。左图：由 3D-TSV 计算的 PSLs。右图： 根据 [16] 的建议，通过匀速播种计算的 PSLs。</p>
<p><img loading="lazy" src="https://ptpimg.me/43v910.png" alt=""></p>
<p>Figure 12: Stress field in ‘Bracket’. Top: PSLs at the finest level (according to Table 1). Bottom: major / minor PSLs at the third (L3) / first (L1) level of detail.</p>
<p>图 12："支架" 的应力场。顶部：最细级别的 PSL（根据表 1）。底部：第三层（L3）/ 第一层（L1）细节的主要 / 次要 PSLs。</p>
<p>3D-TSV works with Cartesian meshes and deformed hexahedral meshes, which are both frequently used in mechanical engineering applications. Here we use the stress fields due to external loads in the interior of ‘Bearing’ and ‘Parts1’, to demonstrate the capability of 3D-TSV. As shown in Figure 9, especially in ‘Bearing’ the element sizes change considerably over the 3D domain. The distribution of PSLs of ‘Bearing’ is shown in Figure 13 (top), and the bottom image shows the combination of major at the third level of detail (L3) and minor at L1, where the minor PSLs are shown via ribbons. The full distribution of PSLs of ‘Parts1’ can be seen in the Figure 14 (left), on the right the minor PSLs at L3 and major PSLs at L2 are shown simultaneously, where the major PSLs are rendered via ribbons.</p>
<p>3D-TSV 可以使用直角坐标网格和变形六面体网格，这两种网格在机械工程应用中经常使用。这里我们用 "轴承" 和 "零件 1" 内部的外部载荷引起的应力场来证明 3D-TSV 的能力。如图 9 所示，特别是在 "轴承" 中，元素的尺寸在三维域中变化很大。图 13 显示了 'Bearing' 的 PSL 分布（上图），下图显示了第三层细节（L3）的主要元素和 L1 的次要元素的组合，其中次要的 PSL 通过带子显示。图 14（左）显示了 'Parts1' 的全部 PSL 分布，右图同时显示了 L3 的次要 PSL 和 L2 的主要 PSL，其中主要 PSL 是通过色带呈现的。</p>
<p><img loading="lazy" src="https://ptpimg.me/p6jy8u.png" alt=""></p>
<p>Figure 13: Stress field in ‘Bearing’. Top: PSLs at the finest level (according to Table 1). Bottom: major / minor PSLs at the third (L3) / first (L1) level of detail. Ribbons are along the minor PSLs and twist according to medium principal stress direction.</p>
<p>图 13："轴承" 的应力场。顶部：最细级别的 PSL（根据表 1）。底部：第三层（L3）/ 第一层（L1）的主要 / 次要 PSL 的细节。丝带是沿着次要的 PSLs，并根据中度主应力方向进行扭曲。</p>
<p><img loading="lazy" src="https://ptpimg.me/3cp186.jpg" alt=""></p>
<p>Figure 14: Stress fields in ‘Parts1’. Left: PSLs at the finest level. Right: major / minor PSLs at L2 / L3. Ribbons are along the major PSLs and twist according to medium principal stress direction.</p>
<p>图 14："Parts1" 的应力场。左图：最细级别的 PSLs。右图：L2/L3 的主要 / 次要 PSLs。丝带是沿着主要的 PSLs，并根据中度主应力方向进行扭曲。</p>
<h2 id="conclusion-and-future-work"><a class="anchor" href="#conclusion-and-future-work">#</a> <strong>Conclusion and Future Work</strong></h2>
<p>结论和未来工作</p>
<p>In this paper, we have introduced 3D-TSV, a tool for visualizing the principal stress directions in 3D solids under load. 3D-TSV makes use of a novel seeding strategy, to generate a space-filling and evenly spaced set of PSLs. By considering all three types of PSLs simultaneously in the construction process, the regularity of the resulting PSL structure is improved. By incorporating different merging thresholds for each PSL type into the construction process, a consistent multi-resolution hierarchy is formed, which can be utilized to show different PSL types with different resolutions simultaneously. Efficient rendering options for lines and ribbons on the GPU enable interactive analysis of large sets of PSLs.</p>
<p>在本文中，我们介绍了 3D-TSV，一个用于可视化三维实体在负载下的主应力方向的工具。3D-TSV 利用了一种新的播种策略，生成了一组充满空间和均匀间隔的 PSLs。通过在构建过程中同时考虑所有三种类型的 PSL，所产生的 PSL 结构的规则性得到了改善。通过将每种 PSL 类型的不同合并阈值纳入构建过程，形成了一致的多分辨率层次，可以利用它来同时显示不同分辨率的 PSL 类型。在 GPU 上对线和带的高效渲染选项可以实现对大型 PSL 集的交互式分析。</p>
<p>In the future, we intend to couple 3D-TSV with load simulation processes, so that dynamic changes of the stress field can be instantly monitored. Therefore, we will analyze whether the intrinsically iterative parts of the algorithm can be parallelized on modern multi-threading architectures. Furthermore, we are interested in using space-filling evenly spaced seeding to guide the material growth in topology optimization. Topology optimization seeks to distribute material in a way that makes the object resistant to external loads. To automatically generate support structures that follow the major stress directions and eventually can form a 3D gridlike structure, we aim at combining our seeding strategy with the automatic growth process underlying topology optimization.</p>
<p>在未来，我们打算将 3D-TSV 与载荷模拟过程结合起来，这样就可以即时监测应力场的动态变化。因此，我们将分析该算法的内在迭代部分是否可以在现代多线程架构上并行化。此外，我们对使用空间填充的匀速播种来指导拓扑优化中的材料生长感兴趣。拓扑优化寻求以一种使物体抵抗外部载荷的方式分配材料。为了自动生成遵循主要应力方向的支撑结构，并最终能够形成三维网格状结构，我们旨在将我们的播种策略与拓扑优化的自动生长过程相结合。</p>
<div class="tags"><a href="/tags/%E5%BC%A0%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag"><i class="ic i-tag"></i>张量可视化</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/">ローディング...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-03-13 00:01:09" itemprop="dateModified" datetime="2024-03-13T00:01:09+08:00">2024-03-13</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" src="/assets/bitcoin.avif" alt="Sakura 比特币"><p>比特币</p></div><div><img loading="lazy" src="/assets/monero.avif" alt="Sakura monero"><p>monero</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>Sakura<i class="ic i-at"><em>@</em></i>Sakura</li><li class="link"><strong>本文链接：</strong><a href="https://sakurame.eu.org/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/" title="3D-TSV_The_3D_Trajectory-based_Stress_Visualizer">https://sakurame.eu.org/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/30/thinking/%E5%85%B3%E4%BA%8Ept%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BB%E8%A6%81%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B4%E7%90%86%EF%BC%89/" rel="prev" itemprop="url" data-background-image="https://ptpimg.me/5afurn.jpg" title="关于pt的一点思考（主要来自于互联网整理）"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>思考随笔记录</span><h3>关于pt的一点思考（主要来自于互联网整理）</h3></a></div><div class="item right"><a href="/2023/06/04/computer-graphic/3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%AE%9D%E5%85%B8DirectX12%E9%BE%99%E4%B9%A6/" rel="next" itemprop="url" data-background-image="https://ptpimg.me/6c200j.jpg" title="3D游戏开发宝典DirectX12龙书"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>计算机图形学</span><h3>3D游戏开发宝典DirectX12龙书</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#3d-tsv-the-3d-trajectory-based-stress-visualizer"><span class="toc-number">1.</span> <span class="toc-text"> 3D-TSV: The 3D Trajectory-based Stress Visualizer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">1.1.</span> <span class="toc-text"> Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#contribution"><span class="toc-number">1.2.</span> <span class="toc-text"> Contribution</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#related-work"><span class="toc-number">1.3.</span> <span class="toc-text"> Related work</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stress-tensor-directions"><span class="toc-number">1.4.</span> <span class="toc-text"> Stress Tensor Directions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#psl-seeding-and-level-of-detail"><span class="toc-number">1.5.</span> <span class="toc-text"> PSL Seeding and Level of Detail</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#evenly-spaced-psl-seeding"><span class="toc-number">1.5.1.</span> <span class="toc-text"> Evenly Spaced PSL Seeding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#psl-lod-structure"><span class="toc-number">1.5.2.</span> <span class="toc-text"> PSL LoD Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ribbon-based-stress-visualization"><span class="toc-number">1.5.3.</span> <span class="toc-text"> Ribbon-based Stress Visualization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system-implementation"><span class="toc-number">1.6.</span> <span class="toc-text"> System Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#numerical-psl-integration"><span class="toc-number">1.6.1.</span> <span class="toc-text"> Numerical PSL Integration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rendering"><span class="toc-number">1.6.2.</span> <span class="toc-text"> Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3d-tsv-settings"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 3D-TSV Settings</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#results"><span class="toc-number">1.7.</span> <span class="toc-text"> Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conclusion-and-future-work"><span class="toc-number">1.8.</span> <span class="toc-text"> Conclusion and Future Work</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/28/basic-theory/UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="UNIX系统编程：通信，并发和线程">UNIX系统编程：通信，并发和线程</a></li><li><a href="/2023/04/30/basic-theory/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89/" rel="bookmark" title="算法导论第四版（持续）">算法导论第四版（持续）</a></li><li><a href="/2023/05/16/basic-theory/%E9%9D%A2%E5%90%91cloudflare%E7%9A%84%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA-1%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%9C%89ssl%E8%AF%81%E4%B9%A6%E7%9A%84wordpress%E5%8D%9A%E5%AE%A2/" rel="bookmark" title="面向cloudflare的网站搭建,1分钟快速启动一个有ssl证书的wordpress博客">面向cloudflare的网站搭建,1分钟快速启动一个有ssl证书的wordpress博客</a></li><li><a href="/2023/05/22/basic-theory/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/" rel="bookmark" title="动手学深度学习第二版笔记">动手学深度学习第二版笔记</a></li><li><a href="/2023/05/26/basic-theory/Glyphs-for-General-Second-Order-2D-and-3D-Tensors/" rel="bookmark" title="Glyphs_for_General_Second-Order_2D_and_3D_Tensors">Glyphs_for_General_Second-Order_2D_and_3D_Tensors</a></li><li><a href="/2023/05/29/basic-theory/fundamentals-of-reservoir-engineering/" rel="bookmark" title="fundamentals_of_reservoir_engineering">fundamentals_of_reservoir_engineering</a></li><li class="active"><a href="/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/" rel="bookmark" title="3D-TSV_The_3D_Trajectory-based_Stress_Visualizer">3D-TSV_The_3D_Trajectory-based_Stress_Visualizer</a></li><li><a href="/2023/07/09/basic-theory/%E9%9B%85%E6%80%9D%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%89%88/" rel="bookmark" title="雅思备考笔记整理归纳长期更新版">雅思备考笔记整理归纳长期更新版</a></li><li><a href="/2023/07/11/basic-theory/A-Topologically-Informed-Hyperstreamline/" rel="bookmark" title="A_Topologically-Informed_Hyperstreamline">A_Topologically-Informed_Hyperstreamline</a></li><li><a href="/2023/07/11/basic-theory/Over-Two-Decades-of-Integration-Based-Geometric-Flow-Visualization/" rel="bookmark" title="Over_Two_Decades_of_Integration-Based_Geometric_Flow_Visualization">Over_Two_Decades_of_Integration-Based_Geometric_Flow_Visualization</a></li><li><a href="/2023/08/09/basic-theory/Creating-Evenly-Spaced-Streamlines-of-Arbitrary-Density/" rel="bookmark" title="Creating_Evenly-Spaced_Streamlines_of_Arbitrary_Density">Creating_Evenly-Spaced_Streamlines_of_Arbitrary_Density</a></li><li><a href="/2023/08/10/basic-theory/A-Flow-guided-Streamline-Seeding-Strategy/" rel="bookmark" title="A_Flow-guided_Streamline_Seeding_Strategy">A_Flow-guided_Streamline_Seeding_Strategy</a></li><li><a href="/2023/08/16/basic-theory/Detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features/" rel="bookmark" title="Detecting_faults_and_channels_while_enhancing_seismic_structural_and_stratigraphic_features">Detecting_faults_and_channels_while_enhancing_seismic_structural_and_stratigraphic_features</a></li><li><a href="/2023/08/17/basic-theory/Methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3D-seismic-images/" rel="bookmark" title="Methods_to_compute_fault_images_extract_fault_surfaces_and_estimate_fault_throws_from_3D_seismic_images">Methods_to_compute_fault_images_extract_fault_surfaces_and_estimate_fault_throws_from_3D_seismic_images</a></li><li><a href="/2023/09/08/basic-theory/Water-Injection-Optimization-Using-Historical-Production-and-Seismic-Data/" rel="bookmark" title="Water_Injection_Optimization_Using_Historical_Production_and_Seismic_Data">Water_Injection_Optimization_Using_Historical_Production_and_Seismic_Data</a></li><li><a href="/2024/03/19/basic-theory/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%8C%87%E5%8D%97PMBOK%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%83%E7%89%88%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A0%87%E5%87%86/" rel="bookmark" title="项目管理知识体系指南PMBOK指南第七版项目管理标准(长期持续更新中)">项目管理知识体系指南PMBOK指南第七版项目管理标准(长期持续更新中)</a></li><li><a href="/2024/03/29/computer-graphic/PBRT%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%AA%E4%BA%BA%E7%B2%BE%E6%A0%A1%E7%89%88%E7%BF%BB%E8%AF%91%EF%BC%88%E9%95%BF%E6%9C%9F%E8%AE%A1%E5%88%92%E9%A1%B9%E7%9B%AE%EF%BC%89/" rel="bookmark" title="PBRT第四版个人精校版翻译（长期计划项目）">PBRT第四版个人精校版翻译（长期计划项目）</a></li><li><a href="/2024/05/12/basic-theory/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="人工智能现代方法（第四版）读书笔记">人工智能现代方法（第四版）读书笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="Sakura" src="/assets/avatar.avif"><p class="name" itemprop="name">Sakura</p><div class="description" itemprop="description">一个专注于技术和思考分享的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">77</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/auveggry" class="item github" title="https://github.com/auveggry"><i class="ic i-github"></i></a><a href="mailto:mail@sakurame.eu.org" class="item email" title="mailto:mail@sakurame.eu.org"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li><li class="item"><a href="/privacy/" rel="section"><i class="ic i-user"></i>隐私政策</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-sakura"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/04/computer-graphic/3D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%AE%9D%E5%85%B8DirectX12%E9%BE%99%E4%B9%A6/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/30/thinking/%E5%85%B3%E4%BA%8Ept%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BB%E8%A6%81%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B4%E7%90%86%EF%BC%89/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div><div id="player"></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/privacy/" title="分类于隐私保护指北">隐私保护指北</a></div><span><a href="/2024/03/14/privacy/Canokey%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97-%E6%8C%81%E7%BB%AD%E8%B8%A9%E5%9D%91%E4%B8%AD/">Canokey不完全食用指南--持续踩坑中</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/">games104系列笔记（十六）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2024/03/19/basic-theory/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%8C%87%E5%8D%97PMBOK%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%83%E7%89%88%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A0%87%E5%87%86/">项目管理知识体系指南PMBOK指南第七版项目管理标准(长期持续更新中)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2024/03/16/vcbstudio/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%88%9D%E7%BA%A7%E8%A7%86%E9%A2%91%E7%91%95%E7%96%B5%E4%BF%AE%E5%A4%8D/">第九章初级视频瑕疵修复</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/">games104系列笔记（十五）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2023/06/09/vcbstudio/%E7%86%9F%E6%82%89VapourSynth/">熟悉VapourSynth</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2023/08/16/basic-theory/Detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features/">Detecting_faults_and_channels_while_enhancing_seismic_structural_and_stratigraphic_features</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/28/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/">games104系列笔记（十一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/thinking/" title="分类于思考随笔记录">思考随笔记录</a></div><span><a href="/2022/05/28/thinking/%E4%B8%89%E5%B9%B4%E4%B9%8B%E9%9A%8F%E7%AC%94/">三年之随笔</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/24/game-engine/games104%E7%AC%94%E8%AE%B0/">games104笔记</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><!--!= partial('_partials/header.pug', {}, {cache: true})--></div></footer></div><script data-config="" type="text/javascript">var LOCAL = {
    ispost: true,
    path: `2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    }
};
</script><script src="/js/siteInit.js?v=0.5.0" type="module" fetchpriority="high" defer=""></script></body></html>