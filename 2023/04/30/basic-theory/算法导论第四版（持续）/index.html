<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="alternate" href="/rss.xml" title="Sakura" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Sakura" type="application/atom+xml"><link rel="alternate" type="application/json" title="Sakura" href="https://sakurame.eu.org/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" media="none" onload="this.media='all'"><link rel="modulepreload" href="/js/siteInit.js"><link rel="modulepreload" href="/js/nyx-player-D4XW5YGM.js"><link rel="modulepreload" href="/js/copy-tex-FNUH3BHN.js"><link rel="modulepreload" href="/js/post-XNYTJ3DF.js"><link rel="modulepreload" href="/js/chunk-47WMQ3OW.js"><link rel="modulepreload" href="/js/tcomments-EMIGMNV5.js"><link rel="modulepreload" href="/js/chunk-HBYXA5U5.js"><link rel="modulepreload" href="/js/index.esm-4MKEQDJB.js"><link rel="modulepreload" href="/js/chunk-JZTZ6WT3.js"><link rel="modulepreload" href="/js/chunk-PBBKQNAG.js"><link rel="stylesheet" href="/css/siteInit.css" media="none" onload="this.media='all'"><link rel="preload" href="https://ptpimg.me/e8k2yf.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/5344ez.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/e8k2yf.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/6461y9.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/2m9g2v.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://ptpimg.me/r129au.jpg" as="image" fetchpriority="high"><meta name="keywords" content="翻译"><meta name="description" content="一个专注于技术和思考分享的博客"><link rel="canonical" href="https://sakurame.eu.org/2023/04/30/basic-theory/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89/"><link rel="stylesheet" href="/css/post.css?v=0.5.0"><link rel="stylesheet" href="/css/mermaid.css?v=0.5.0"><!-- 临时处理--><link rel="stylesheet" media="none" onload="this.media='all'" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css"><title>算法导论第四版（持续）</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">算法导论第四版（持续）</h1><div class="meta"><span class="item" title="创建时间：2023-04-30 17:29:40"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-04-30T17:29:40+08:00">2023-04-30</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>84k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>1:17</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">testName</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://ptpimg.me/e8k2yf.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/5344ez.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/e8k2yf.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/6461y9.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/2m9g2v.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://ptpimg.me/r129au.jpg&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement="" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/basic-theory/" itemprop="item" rel="index" title="分类于计算机基础理论"><span itemprop="name">计算机基础理论<meta itemprop="position" content="0"></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sakurame.eu.org/2023/04/30/basic-theory/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="Sakura"><meta itemprop="description" content=", 一个专注于技术和思考分享的博客"></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sakura"></span><div class="body md" itemprop="articleBody"><p>算法导论第四版</p>
<p>Perface</p>
<p>Not so long ago, anyone who had heard the word “algorithm” was almost certainly a computer scientist or mathematician. With computers having become prevalent in our modern lives, however, the term is no longer esoteric. If you look around your home, you’ll find algorithms running in the most mundane places: your microwave oven, your washing machine, and, of course, your computer. You ask algorithms to make recommendations to you: what music you might like or what route to take when driving. Our society, for better or for worse, asks algorithms to suggest sentences for convicted criminals. You even rely on algorithms to keep you alive, or at least not to kill you: the control systems in your car or in medical equipment.1 The word “algorithm” appears somewhere in the news seemingly every day.</p>
<p>不久前，任何听到 "算法" 一词的人几乎肯定是计算机科学家或数学家。然而，随着计算机在我们的现代生活中变得普遍，这个词不再是深奥的了。如果你看看你的家，你会发现算法在最平凡的地方运行：你的微波炉，你的洗衣机，当然，还有你的电脑。你要求算法向你提出建议：你可能会喜欢什么音乐，或者开车时应该走什么路线。我们的社会，无论好坏，都要求算法对被定罪的罪犯提出判刑建议。你甚至依靠算法来维持你的生命，或至少不杀死你：你的汽车或医疗设备中的控制系统。算法这个词，每天都出现在我们生活中的方方面面。</p>
<p>Therefore, it behooves you to understand algorithms not just as a student or practitioner of computer science, but as a citizen of the world. Once you understand algorithms, you can educate others about what algorithms are, how they operate, and what their limitations are.</p>
<p>因此，不仅作为计算机科学的学生或从业人员，而且作为世界公民，你有必要了解算法。一旦你理解了算法，你就可以教导别人什么是算法，它们如何运作，以及局限性是什么。</p>
<p>This book provides a comprehensive introduction to the modern study of computer algorithms. It presents many algorithms and covers them in considerable depth, yet makes their design accessible to all levels of readers. All the analyses are laid out, some simple, some more involved. We have tried to keep explanations clear without sacrificing depth of coverage or mathematical rigor.</p>
<p>本书对计算机算法的现代研究进行了全面介绍。它介绍了许多算法，并对其进行了相当深入的论述，但又使它们的设计对所有层次的读者都易于接受。所有的分析都有布局，有些简单，有些比较复杂。我们试图在不牺牲覆盖深度或数学严谨性的情况下保持解释的清晰。</p>
<p>Each chapter presents an algorithm, a design technique, an application area, or a related topic. Algorithms are described in English and in a pseudocode designed to be readable by anyone who has done a little programming. The book contains 231 figures—many with multiple parts—illustrating how the algorithms work. Since we emphasize efficiency as a design criterion, we include careful analyses of the running times of the algorithms.</p>
<p>每一章介绍一种算法、一种设计技术、一个应用领域或一个相关的主题。算法是用英文和伪代码描述的，旨在让任何做过一点编程的人都能读懂。本书包含 231 个数字 -- 许多有多个部分 -- 说明了算法的工作原理。由于我们强调效率是一种设计标准，我们包括对算法运行时间的仔细分析。</p>
<p>The text is intended primarily for use in undergraduate or graduate courses in algorithms or data structures. Because it discusses engineering issues in algorithm design, as well as mathematical aspects, it is equally well suited for self-study by technical professionals.</p>
<p>本教材主要用于算法或数据结构的本科生或研究生课程。因为它讨论了算法设计中的工程问题以及数学方面的问题，所以它同样适合于专业技术人员的自学。</p>
<p>In this, the fourth edition, we have once again updated the entire book. The changes cover a broad spectrum, including new chapters and sections, color illustrations, and what we hope you’ll find to be a more engaging writing style.</p>
<p>在这第四版中，我们再次更新了整本书。这些变化涵盖了广泛的范围，包括新的章节，彩色插图，以及我们希望你会发现的更有吸引力的写作风格。</p>
<p>To the teacher</p>
<p>We have designed this book to be both versatile and complete. You should find it useful for a variety of courses, from an undergraduate course in data structures up through a graduate course in algorithms. Because we have provided considerably more material than can fit in a typical one-term course, you can select the material that best supports the course you wish to teach.</p>
<p>我们将这本书设计得既通用又完整。你应该发现它对各种课程都很有用，从数据结构的本科课程到算法的研究生课程。因为我们提供的材料比典型的一学期课程所能容纳的要多得多，你可以选择最能支持你想教的课程的材料。</p>
<p>You should find it easy to organize your course around just the chapters you need. We have made chapters relatively self-contained, so that you need not worry about an unexpected and unnecessary dependence of one chapter on another. Whereas in an undergraduate course, you might use only some sections from a chapter, in a graduate course, you might cover the entire chapter.</p>
<p>你应该发现，围绕你所需要的章节来安排你的课程是很容易的。我们使各章相对独立，这样你就不必担心某一章对另一章的意外和不必要的依赖。在本科生课程中，你可能只使用某一章的某些部分，而在研究生课程中，你可能会涉及整个章节。</p>
<p>We have included 931 exercises and 162 problems. Each section ends with exercises, and each chapter ends with problems. The exercises are generally short questions that test basic mastery of the material. Some are simple self-check thought exercises, but many are substantial and suitable as assigned homework. The problems include more elaborate case studies which often introduce new material. They often consist of several parts that lead the student through the steps required to arrive at a solution.</p>
<p>我们包括了 931 道练习和 162 个问题。每一节以练习结束，每一章以问题结束。练习一般都是测试对材料基本掌握情况的短问题。有些是简单的自我检查的思考练习，但许多是实质性的，适合作为指定的家庭作业。问题包括更详细的案例研究，通常会引入新材料。它们通常由几个部分组成，引导学生通过所需的步骤来达成解决方案。</p>
<p>As with the third edition of this book, we have made publicly available solutions to some, but by no means all, of the problems and exercises. You can find these solutions on our website, <a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/">http://mitpress.mit.edu/algorithms/</a>. You will want to check this site to see whether it contains the solution to an exercise or problem that you plan to assign. Since the set of solutions that we post might grow over time, we recommend that you check the site each time you teach the course.</p>
<p>与本书第三版一样，我们公开提供了一些问题和练习的解决方案，但绝不是全部。你可以在我们的网站上找到这些解决方案，<a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/%E3%80%82%E4%BD%A0%E8%A6%81%E6%A3%80%E6%9F%A5%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%EF%BC%8C%E7%9C%8B%E5%AE%83%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E4%BD%A0%E6%89%93%E7%AE%97%E5%B8%83%E7%BD%AE%E7%9A%84%E7%BB%83%E4%B9%A0%E6%88%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E5%8F%91%E5%B8%83%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%9A%8F%E7%9D%80%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%A8%E7%A7%BB%E8%80%8C%E5%A2%9E%E5%8A%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BB%BA%E8%AE%AE%E4%BD%A0%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%95%99%E6%8E%88%E8%AF%A5%E8%AF%BE%E7%A8%8B%E6%97%B6%E6%A3%80%E6%9F%A5%E8%AF%A5%E7%BD%91%E7%AB%99%E3%80%82">http://mitpress.mit.edu/algorithms/。你要检查这个网站，看它是否包含你打算布置的练习或问题的解决方案。由于我们发布的解决方案可能会随着时间的推移而增加，我们建议你在每次教授该课程时检查该网站。</a></p>
<p>We have starred (★) the sections and exercises that are more suitable for graduate students than for undergraduates. A starred section is not necessarily more difficult than an unstarred one, but it may require an understanding of more advanced mathematics. Likewise, starred exercises may require an advanced background or more than average creativity.</p>
<p>我们将更适合于研究生而不是本科生的章节和练习标上了星号（★）。带星的部分不一定比不带星的部分更难，但它可能需要对更高级的数学知识有所了解。同样地，带星的练习可能需要高级的背景或比一般人更高的创造力。</p>
<p>To the student</p>
<p>We hope that this textbook provides you with an enjoyable introduction to the field of algorithms. We have attempted to make every algorithm accessible and interesting. To help you when you encounter unfamiliar or difficult algorithms, we describe each one in a step-by-step manner. We also provide careful explanations of the mathematics needed to understand the analysis of the algorithms and supporting figures to help you visualize what is going on.</p>
<p>我们希望这本教科书能为你提供一个关于算法领域的愉快的介绍。我们试图让每一种算法都变得容易理解和有趣。为了在你遇到不熟悉或困难的算法时能够提供帮助，我们一步一步的描述每一种算法。并且还仔细解释了理解和分析算法所需的数学知识，并提供了辅助数字，以帮助你直观地了解所发生的事情。</p>
<p>Since this book is large, your class will probably cover only a portion of its material. Although we hope that you will find this book helpful to you as a course textbook now, we have also tried to make it comprehensive enough to warrant space on your future professional bookshelf.</p>
<p>由于这本书很大，你的课可能只涉及其中的一部分材料。尽管我们希望你会发现这本书现在作为课程教材对你有帮助，但我们也努力使它足够全面，以保证在你未来的专业领域上有足够的空间。</p>
<p>What are the prerequisites for reading this book?</p>
<p>You need some programming experience. In particular, you should understand recursive procedures and simple data structures, such as arrays and linked lists (although Section 10.2 covers linked lists and a variant that you may find new).</p>
<p>You should have some facility with mathematical proofs, and especially proofs by mathematical induction. A few portions of the book rely on some knowledge of elementary calculus. Although this book uses mathematics throughout, Part I and Appendices A–D teach you all the mathematical techniques you will need.</p>
<p>阅读本书的先决条件是什么？</p>
<p>你需要一些编程经验。特别是，你应该了解递归程序和简单的数据结构，如数组和链表（尽管第 10.2 节涵盖了链表和一个变体，你可能会觉得很新鲜）。</p>
<p>你应该对数学证明，特别是数学归纳法的证明有一定的掌握。本书的一些部分依赖于一些初级微积分的知识。尽管本书自始至终都在使用数学，但第一部分和附录 A-D 教你所有你需要的数学技术。</p>
<p>Our website, <a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/">http://mitpress.mit.edu/algorithms/</a>, links to solutions for some of the problems and exercises. Feel free to check your solutions against ours. We ask, however, that you not send your solutions to us.</p>
<p>我们的网站，<a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/%EF%BC%8C%E5%8C%85%E5%90%AB%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E8%AF%B7%E9%9A%8F%E6%97%B6%E5%AF%B9%E7%85%A7%E6%88%91%E4%BB%AC%E7%9A%84%E7%AD%94%E6%A1%88%E6%A3%80%E6%9F%A5%E4%BD%A0%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A6%81%E6%B1%82%E4%BD%A0%E4%B8%8D%E8%A6%81%E6%8A%8A%E4%BD%A0%E7%9A%84%E7%AD%94%E6%A1%88%E5%8F%91%E7%BB%99%E6%88%91%E4%BB%AC%E3%80%82">http://mitpress.mit.edu/algorithms/，包含一些问题和练习的解决方案。请随时对照我们的答案检查你的解答。然而，我们要求你不要把你的答案发给我们。</a></p>
<p>To the professional</p>
<p>The wide range of topics in this book makes it an excellent handbook on algorithms. Because each chapter is relatively self-contained, you can focus on the topics most relevant to you.</p>
<p>本书中广泛的主题使其成为一本优秀的算法手册。由于每一章都是相对独立的，你可以专注于与你最相关的主题。</p>
<p>Since most of the algorithms we discuss have great practical utility, we address implementation concerns and other engineering issues. We often provide practical alternatives to the few algorithms that are primarily of theoretical interest.</p>
<p>由于我们讨论的大多数算法都有很大的实际用途，我们解决了实施方面的问题和其他工程问题。我们经常为少数主要具有理论意义的算法提供实用的替代方案。</p>
<p>If you wish to implement any of the algorithms, you should find the translation of our pseudocode into your favorite programming language to be a fairly straightforward task. We have designed the pseudocode to present each algorithm clearly and succinctly. Consequently, we do not address error handling and other software-engineering issues that require specific assumptions about your programming environment. We attempt to present each algorithm simply and directly without allowing the idiosyncrasies of a particular programming language to obscure its essence. If you are used to 0-origin arrays, you might find our frequent practice of indexing arrays from 1 a minor stumbling block. You can always either subtract 1 from our indices or just overallocate the array and leave position 0 unused.</p>
<p>如果你想实现任何算法，你应该发现将我们的伪代码翻译成你最喜欢的编程语言是一个相当简单的任务。我们设计的伪代码清楚而简洁地展示了每一种算法。因此，我们不涉及错误处理和其他需要对你的编程环境进行具体假设的软件工程问题。我们试图简单而直接地介绍每一种算法，而不允许特定编程语言的特异性来掩盖其本质。如果你习惯于 0 源数组，你可能会发现我们经常从 1 开始索引数组的做法是一个小绊脚石。你可以随时从我们的索引中减去 1，或者直接对数组进行整体分配，让 0 的位置不使用。</p>
<p>We understand that if you are using this book outside of a course, then you might be unable to check your solutions to problems and exercises against solutions provided by an instructor. Our website, <a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/">http://mitpress.mit.edu/algorithms/</a>, links to solutions for some of the problems and exercises so that you can check your work. Please do not send your solutions to us.</p>
<p>我们理解，如果你在课程之外使用这本书，那么你可能无法将你的问题和练习的解决方案与教师提供的解决方案进行对照。我们的网站<a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%88%B0%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BB%A5%E4%BE%BF%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%A3%80%E6%9F%A5%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E3%80%82%E8%AF%B7%E4%B8%8D%E8%A6%81%E6%8A%8A%E4%BD%A0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%AF%84%E7%BB%99%E6%88%91%E4%BB%AC%E3%80%82"> http://mitpress.mit.edu/algorithms/，链接到一些问题和练习的解决方案，以便你可以检查你的工作。请不要把你的解决方案寄给我们。</a></p>
<p>To our colleagues</p>
<p>We have supplied an extensive bibliography and pointers to the current literature. Each chapter ends with a set of chapter notes that give historical details and references. The chapter notes do not provide a complete reference to the whole field of algorithms, however. Though it may be hard to believe for a book of this size, space constraints prevented us from including many interesting algorithms.</p>
<p>我们提供了一个广泛的书目和当前文献的引用。每一章的结尾都有一组章节说明，提供历史细节和参考资料。然而，这些章节说明并没有提供整个算法领域的完整参考。尽管对于这种规模的书来说，这可能很难让人相信，但由于篇幅的限制，我们无法包括许多有趣的算法。</p>
<p>Despite myriad requests from students for solutions to problems and exercises, we have adopted the policy of not citing references for them, removing the temptation for students to look up a solution rather than to discover it themselves.</p>
<p>尽管学生们无数次要求提供问题和练习的解决方案，但我们采取了不引用参考文献的政策，以消除学生查找解决方案而不是自己去发现的诱惑力。</p>
<p>Changes for the fourth edition</p>
<p>As we said about the changes for the second and third editions, depending on how you look at it, the book changed either not much or quite a bit. A quick look at the table of contents shows that most of the third-edition chapters and sections appear in the fourth edition. We removed three chapters and several sections, but we have added three new chapters and several new sections apart from these new chapters.</p>
<p>正如我们所说的第二版和第三版的变化，取决于你如何看待它，这本书的变化要么不大，要么相当大。快速浏览一下目录就会发现，第三版的大部分章节都出现在第四版中。我们删除了三章和几个章节，但除了这些新的章节外，我们还增加了三章和几个新的章节。</p>
<p>We kept the hybrid organization from the first three editions. Rather than organizing chapters only by problem domains or only according to techniques, this book incorporates elements of both. It contains technique-based chapters on divide-and-conquer, dynamic programming, greedy algorithms, amortized analysis, augmenting data structures, NP-completeness, and approximation algorithms. But it also has entire parts on sorting, on data structures for dynamic sets, and on algorithms for graph problems. We find that although you need to know how to apply techniques for designing and analyzing algorithms, problems seldom announce to you which techniques are most amenable to solving them.</p>
<p>我们保留了前三版中的混合组织方式。本书没有只按问题领域或只按技术来组织章节，而是结合了两者的要素。它包含了以技术为基础的章节，包括分而治之、动态编程、贪婪算法、摊销分析、增强数据结构、NP 完备性和近似算法。但它也有关于排序、动态集的数据结构和图问题的算法的整个部分。我们发现，尽管你需要知道如何应用技术来设计和分析算法，但问题很少向你宣布哪些技术最适合解决它们。</p>
<p>summary of the most significant general changes: Some of the changes in the fourth edition apply generally across the book, and some are specific to particular chapters or sections. Here is a</p>
<p>最重要的一般变化摘要。第四版中的一些变化普遍适用于全书，有些是针对特定章节的。下面是一个</p>
<p>We added 140 new exercises and 22 new problems. We also improved many of the old exercises and problems, often as the result of reader feedback. (Thanks to all readers who made suggestions.)</p>
<p>我们增加了 140 个新练习和 22 个新问题。我们还改进了许多旧的练习和问题，这通常是读者反馈的结果。(感谢所有提出建议的读者）。</p>
<p>We have color! With designers from the MIT Press, we selected a limited palette, devised to convey information and to be pleasing to the eye. (We are delighted to display red-black trees in—get this —red and black!) To enhance readability, defined terms, pseudocode comments, and page numbers in the index are in color.</p>
<p>我们有了颜色！在麻省理工学院出版社设计师的帮助下，我们选择了一个有限的调色板，旨在传达信息并使人赏心悦目。(我们很高兴地将红黑树以红黑相间的方式展示出来！) 为了提高可读性，索引中的定义术语、伪代码注释和页码都是彩色的。</p>
<p>Pseudocode procedures appear on a tan background to make them easier to spot, and they do not necessarily appear on the page of their first reference. When they don’t, the text directs you to the relevant page. In the same vein, nonlocal references to numbered equations, theorems, lemmas, and corollaries include the page number.</p>
<p>伪代码程序显示在棕褐色的背景上，以使它们更容易被发现，而且它们不一定出现在它们的第一个参考页上。当它们不出现时，文本会引导你到相关的页面。同样地，对编号的方程、定理、公理和推论的非局部引用也包括页码。</p>
<p>We removed topics that were rarely taught. We dropped in their entirety the chapters on Fibonacci heaps, van Emde Boas trees, and computational geometry. In addition, the following material was excised: the maximum-subarray problem, implementing pointers and objects, perfect hashing, randomly built binary search trees, matroids, push-relabel algorithms for maximum flow, the iterative fast Fourier transform method, the details of the simplex algorithm for linear programming, and integer factorization. You can find all the removed material on our website, <a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/">http://mitpress.mit.edu/algorithms/</a>.</p>
<p>我们删除了那些很少讲授的课题。我们把斐波那契堆、范 - 埃姆德 - 博阿斯树和计算几何这几章全部删除。此外，我们还删除了以下材料：最大子阵列问题、实现指针和对象、完美散列、随机构建的二进制搜索树、矩阵、最大流量的推标签算法、迭代快速傅里叶变换方法、线性编程的单纯算法的细节以及整数分解。你可以在我们的网站上找到所有删除的材料，<a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/%E3%80%82">http://mitpress.mit.edu/algorithms/。</a></p>
<p>We reviewed the entire book and rewrote sentences, paragraphs, and sections to make the writing clearer, more personal, and gender neutral. For example, the “traveling-salesman problem” in the previous editions is now called the “traveling-salesperson problem.” We believe that it is critically important for engineering and science, including our own field of computer science, to be welcoming to everyone. (The one place that stumped us is in Chapter 13, which requires a term for a parent’s sibling. Because the English language has no such gender-neutral term, we regretfully stuck with “uncle.”)</p>
<p>我们审查了整本书，并重写了句子、段落和章节，使文字更清晰、更有个性，并保持性别中立。例如，以前版本中的 "旅行推销员问题" 现在被称为 "旅行推销员问题"。我们相信，工程和科学，包括我们自己的计算机科学领域，对每个人都持欢迎态度是至关重要的。(有一个地方让我们感到困惑，那就是第 13 章，它要求对父母的兄弟姐妹有一个称呼。由于英语中没有这种性别中立的术语，我们很遗憾地使用了 "叔叔"。）</p>
<p>The chapter notes, bibliography, and index were updated, reflecting the dramatic growth of the field of algorithms since the third edition.</p>
<p>章节注释、参考书目和索引得到了更新，反映了自第三版以来算法领域的急剧增长。</p>
<p>We corrected errors, posting most corrections on our website of third-edition errata. Those that were reported while we were in full swing preparing this edition were not posted, but were corrected in this edition. (Thanks again to all readers who helped us identify issues.)</p>
<p>我们纠正了一些错误，在我们的网站上发布了大部分第三版勘误表的更正。那些在我们紧锣密鼓地准备本版时被报告的错误没有张贴出来，但在本版中得到了纠正。(再次感谢所有帮助我们发现问题的读者。）</p>
<p>The specific changes for the fourth edition include the following:</p>
<p>第四版的具体变化还包括以下内容。</p>
<p>We renamed Chapter 3 and added a section giving an overview of asymptotic notation before delving into the formal definitions.</p>
<p>我们重新命名了第三章，并在深入探讨正式定义之前增加了一节，对渐进式符号进行了概述。</p>
<p>Chapter 4 underwent substantial changes to improve its mathematical foundation and make it more robust and intuitive.</p>
<p>The notion of an algorithmic recurrence was introduced, and the topic of ignoring floors and ceilings in recurrences was addressed more rigorously. The second case of the master theorem incorporates polylogarithmic factors, and a rigorous proof of a “continuous” version of the master theorem is now provided. We also present the powerful and general AkraBazzi method (without proof).</p>
<p>第四章进行了大量的修改，以改善其数学基础，使其更加鲁棒和直观。引入了算法递归的概念，并更严格地处理了递归中忽略下限和上限的问题。主定理的第二种情况包含了多项因素，现在提供了主定理的 "连续" 版本的严格证明。我们还提出了强大而通用的 AkraBazzi 方法（没有证明）。</p>
<p>The deterministic order-statistic algorithm in Chapter 9 is slightly different, and the analyses of both the randomized and deterministic order-statistic algorithms have been revamped.</p>
<p>第九章中的确定性顺序统计学算法略有不同，对随机和确定性顺序统计学算法的分析都进行了修改。</p>
<p>In addition to stacks and queues, Section 10.1 discusses ways to store arrays and matrices.</p>
<p>除了堆栈和队列之外，第 10.1 节还讨论了存储数组和矩阵的方法。</p>
<p>Chapter 11 on hash tables includes a modern treatment of hash functions. It also emphasizes linear probing as an efficient method for resolving collisions when the underlying hardware implements caching to favor local searches.</p>
<p>关于哈希表的第 11 章包括对哈希函数的现代处理。它还强调，当底层硬件实施缓存以支持本地搜索时，线性探测是解决碰撞的有效方法。</p>
<p>To replace the sections on matroids in Chapter 15, we converted a problem in the third edition about offline caching into a full section.</p>
<p>Section 16.4 now contains a more intuitive explanation of the potential functions to analyze table doubling and halving.</p>
<p>Chapter 17 on augmenting data structures was relocated from Part III to Part V, reflecting our view that this technique goes beyond basic material.</p>
<p>Chapter 25 is a new chapter about matchings in bipartite graphs. It presents algorithms to find a matching of maximum cardinality, to solve the stable-marriage problem, and to find a maximumweight matching (known as the “assignment problem”).</p>
<p>Chapter 26, on task-parallel computing, has been updated with modern terminology, including the name of the chapter.</p>
<p>为了取代第 15 章中关于矩阵的章节，我们将第三版中关于离线缓存的一个问题转换成了一个完整的章节。</p>
<p>第 16.4 节现在包含了对分析表的加倍和减半的潜在函数的更直观的解释。</p>
<p>第 17 章关于增强数据结构的内容从第三部分移到了第五部分，反映了我们认为这种技术超越了基本材料。</p>
<p>第 25 章是一个新的章节，关于双子图的匹配。它提出了寻找最大 cardinality 匹配的算法，解决稳定婚姻问题，以及寻找最大权重匹配（被称为 "分配问题"）。</p>
<p>第 26 章，关于任务并行计算，已经用现代术语进行了更新，包括该章的名称。</p>
<p>Chapter 27, which covers online algorithms, is another new chapter. In an online algorithm, the input arrives over time, rather than being available in its entirety at the start of the algorithm. The chapter describes several examples of online algorithms, including determining how long to wait for an elevator before taking the stairs, maintaining a linked list via the move-to-front heuristic, and evaluating replacement policies for caches.</p>
<p>In Chapter 29, we removed the detailed presentation of the simplex algorithm, as it was math heavy without really conveying many algorithmic ideas. The chapter now focuses on the key aspect of how to model problems as linear programs, along with the essential duality property of linear programming.</p>
<p>Section 32.5 adds to the chapter on string matching the simple, yet powerful, structure of suffix arrays.</p>
<p>Chapter 33, on machine learning, is the third new chapter. It introduces several basic methods used in machine learning: clustering to group similar items together, weighted-majority algorithms, and gradient descent to find the minimizer of a function</p>
<p>第 27 章涉及在线算法，是另一个新章节。在一个在线算法中，输入是随着时间的推移而到达的，而不是在算法开始时就全部可用。 这一章描述了几个在线算法的例子，包括确定在走楼梯之前要等多久的电梯，通过移动到前面的启发式方法维护一个链接列表，以及评估缓存的替换策略。</p>
<p>在第 29 章中，我们删除了对单数算法的详细介绍，因为它的数学含量很高，而没有真正传达出许多算法思想。这一章现在集中在如何将问题建模为线性程序这一关键方面，以及线性编程的基本对偶性属性。</p>
<p>第 32.5 节在关于字符串匹配的章节中增加了简单而又强大的后缀数组结构。</p>
<p>第 33 章，关于机器学习，是第三个新的章节。它介绍了机器学习中使用的几种基本方法：将类似项目分组的聚类，加权多数算法，以及寻找函数最小值的梯度下降法。</p>
<p>Section 34.5.6 summarizes strategies for polynomial-time reductions to show that problems are NP-hard.</p>
<p>The proof of the approximation algorithm for the set-covering problem in Section 35.3 has been revised.</p>
<p>第 34.5.6 节总结了多项式时间还原的策略，以证明问题是 NP 难的。</p>
<p>第 35.3 节中关于集合覆盖问题的近似算法的证明已被修改。</p>
<p>Website</p>
<p>You can use our website, <a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/">http://mitpress.mit.edu/algorithms/</a>, to obtain supplementary information and to communicate with us. The website links to a list of known errors, material from the third edition that is not included in the fourth edition, solutions to selected exercises and problems, Python implementations of many of the algorithms in this book, a list explaining the corny professor jokes (of course), as well as other content, which we may add to. The website also tells you how to report errors or make suggestions.</p>
<p>你可以使用我们的网站，<a target="_blank" rel="noopener" href="http://mitpress.mit.edu/algorithms/%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF%E5%B9%B6%E4%B8%8E%E6%88%91%E4%BB%AC%E4%BA%A4%E6%B5%81%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E9%93%BE%E6%8E%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%8C%E7%AC%AC%E4%B8%89%E7%89%88%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%8C%85%E6%8B%AC%E5%9C%A8%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%AD%E7%9A%84%E6%9D%90%E6%96%99%EF%BC%8C%E9%80%89%E5%AE%9A%E7%9A%84%E7%BB%83%E4%B9%A0%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%9C%AC%E4%B9%A6%E4%B8%AD%E8%AE%B8%E5%A4%9A%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%A7%A3%E9%87%8A%E8%80%81%E5%A5%97%E7%9A%84%E6%95%99%E6%8E%88%E7%AC%91%E8%AF%9D%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%88%E5%BD%93%E7%84%B6%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%99%E4%BA%9B%E5%86%85%E5%AE%B9%E3%80%82%E8%AF%A5%E7%BD%91%E7%AB%99%E8%BF%98%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E6%8A%A5%E5%91%8A%E9%94%99%E8%AF%AF%E6%88%96%E6%8F%90%E5%87%BA%E5%BB%BA%E8%AE%AE%E3%80%82">http://mitpress.mit.edu/algorithms/，以获得补充信息并与我们交流。该网站链接到一个已知错误的列表，第三版中没有包括在第四版中的材料，选定的练习和问题的解决方案，本书中许多算法的 Python 实现，一个解释老套的教授笑话的列表（当然），以及其他内容，我们可能会添加到这些内容。该网站还告诉你如何报告错误或提出建议。</a></p>
<p>How we produced this book</p>
<p>Like the previous three editions, the fourth edition was produced in LATEX 2ε. We used the Times font with mathematics typeset using the MathTime Professional II fonts. As in all previous editions, we compiled the index using Windex, a C program that we wrote, and produced the bibliography using BIBTEX. The PDF files for this book were created on a MacBook Pro running macOS 10.14.</p>
<p>Our plea to Apple in the preface of the third edition to update MacDraw Pro for macOS 10 went for naught, and so we continued to draw illustrations on pre-Intel Macs running MacDraw Pro under the Classic environment of older versions of macOS 10. Many of the mathematical expressions appearing in illustrations were laid in with the psfrag package for LATEX 2ε.</p>
<p>与前三版一样，第四版是用 LATEX 2ε 制作的。我们使用 Times 字体，数学排版使用 MathTime Professional II 字体。与前几版一样，我们用自己编写的 C 语言程序 Windex 编译索引，并用 BIBTEX 制作书目。本书的 PDF 文件是在运行 macOS 10.14 的 MacBook Pro 上创建的。</p>
<p>我们在第三版的序言中恳请苹果公司为 macOS 10 更新 MacDraw Pro，但没有结果，因此我们继续在运行 MacDraw Pro 的英特尔之前的 Mac 上绘制插图，并在旧版 macOS 10 的经典环境下运行。插图中出现的许多数学表达式是用 LATEX 2ε 的 psfrag 软件包铺设的。</p>
<p>Acknowledgments for the fourth edition</p>
<p>We have been working with the MIT Press since we started writing the first edition in 1987, collaborating with several directors, editors, and production staff. Throughout our association with the MIT Press, their support has always been outstanding. Special thanks to our editors Marie Lee, who put up with us for far too long, and Elizabeth Swayze, who pushed us over the finish line. Thanks also to Director Amy Brand and to Alex Hoopes.</p>
<p>As in the third edition, we were geographically distributed while producing the fourth edition, working in the Dartmouth College Department of Computer Science; the MIT Computer Science and Artificial Intelligence Laboratory and the MIT Department of Electrical Engineering and Computer Science; and the Columbia University Department of Industrial Engineering and Operations Research, Department of Computer Science, and Data Science Institute.</p>
<p>During the COVID-19 pandemic, we worked largely from home. We thank our respective universities and colleagues for providing such supportive and stimulating environments. As we complete this book, those of us who are not retired are eager to return to our respective universities now that the pandemic seems to be abating.</p>
<p>Julie Sussman, P.P.A., came to our rescue once again with her technical copy-editing under tremendous time pressure. If not for Julie, this book would be riddled with errors (or, let’s say, many more errors than it has) and would be far less readable. Julie, we will be forever indebted to you. Errors that remain are the responsibility of the authors (and probably were inserted after Julie read the material).</p>
<p>Dozens of errors in previous editions were corrected in the process of creating this edition. We thank our readers—too many to list them all— who have reported errors and suggested improvements over the years.</p>
<p>We received considerable help in preparing some of the new material in this edition. Neville Campbell (unaffiliated), Bill Kuszmaul of MIT, and Chee Yap of NYU provided valuable advice regarding the treatment of recurrences in Chapter 4. Yan Gu of the University of California, Riverside, provided feedback on parallel algorithms in Chapter 26. Rob Shapire of Microsoft Research altered our approach to the material on machine learning with his detailed comments on Chapter 33. Qi Qi of MIT helped with the analysis of the Monty Hall problem (Problem C-1).</p>
<p>Molly Seaman and Mary Reilly of the MIT Press helped us select the color palette in the illustrations, and Wojciech Jarosz of Dartmouth College suggested design improvements to our newly colored figures.</p>
<p>Yichen (Annie) Ke and Linda Xiao, who have since graduated from Dartmouth, aided in colorizing the illustrations, and Linda also produced many of the Python implementations that are available on the book’s website.</p>
<p>Finally, we thank our wives—Wendy Leiserson, Gail Rivest, Rebecca Ivry, and the late Nicole Cormen—and our families. The patience and encouragement of those who love us made this project possible. We affectionately dedicate this book to them.</p>
<p>THOMAS H. CORMEN Lebanon, New Hampshire CHARLES E. LEISERSON Cambridge, Massachusetts RONALD L. RIVEST Cambridge, Massachusetts CLIFFORD STEIN New York, New York June, 2021</p>
<p>自 1987 年开始编写第一版以来，我们一直与麻省理工学院出版社合作，与多位导演、编辑和制作人员合作。在我们与麻省理工学院出版社合作的整个过程中，他们的支持一直都很出色。特别感谢我们的编辑玛丽 - 李（Marie Lee）和伊丽莎白 - 斯韦兹（Elizabeth Swayze），她们忍受了我们太长时间，把我们推到了终点线。还要感谢主任 Amy Brand 和 Alex Hoopes。</p>
<p>和第三版一样，在制作第四版时，我们的工作地点分布在达特茅斯学院计算机科学系；麻省理工学院计算机科学和人工智能实验室和麻省理工学院电子工程和计算机科学系；以及哥伦比亚大学工业工程和运筹学系、计算机科学系和数据科学研究所。</p>
<p>在 COVID-19 大流行期间，我们主要在家里工作。我们感谢我们各自的大学和同事提供的这种支持和刺激的环境。当我们完成这本书时，我们这些没有退休的人渴望回到我们各自的大学，现在大流行病似乎正在减弱。</p>
<p>Julie Sussman, P.P.A.，在巨大的时间压力下，再次为我们提供了技术性的文字编辑工作。如果没有朱莉，这本书将会错误百出（或者说，比它的错误多得多），可读性也会大打折扣。朱莉，我们将永远感激你。仍然存在的错误是作者的责任（可能是在朱莉阅读材料后插入的）。</p>
<p>在创建本版的过程中，以前版本中的几十个错误得到了纠正。我们感谢多年来报告错误和提出改进建议的读者 -- 太多了，无法一一列出。</p>
<p>在准备本版中的一些新材料时，我们得到了相当大的帮助。内维尔 - 坎贝尔（Neville Campbell），麻省理工学院的 Bill Kuszmaul 和纽约大学的 Chee Yap 在第四章中对复发的治疗提供了宝贵的建议。加州大学河滨分校的 Yan Gu 对第 26 章中的并行算法提供了反馈。微软研究院的 Rob Shapire 对第 33 章的详细评论，改变了我们对机器学习材料的处理方法。麻省理工学院的 Qi Qi 帮助我们分析了 Monty Hall 问题（问题 C-1）。</p>
<p>麻省理工学院出版社的 Molly Seaman 和 Mary Reilly 帮助我们选择了插图中的调色板，达特茅斯学院的 Wojciech Jarosz 对我们新的彩色图片提出了设计上的改进。</p>
<p>已经从达特茅斯大学毕业的 Yichen（Annie）Ke 和 Linda Xiao 帮助我们为插图上色，Linda 还制作了许多 Python 的实现，可以在本书的网站上看到。</p>
<p>最后，我们感谢我们的妻子 --Wendy Leiserson、Gail Rivest、Rebecca Ivry 和已故的 Nicole Cormen 以及我们的家人。那些爱我们的人的耐心和鼓励使这个项目成为可能。我们深情地将这本书献给他们。</p>
<p>/*******************************************************************************************************************************************************************************************************************************************************************************************************************************************/</p>
<p>Part I Foundations</p>
<p>Introduction</p>
<p>When you design and analyze algorithms, you need to be able to describe how they operate and how to design them. You also need some mathematical tools to show that your algorithms do the right thing and do it efficiently. This part will get you started. Later parts of this book will build upon this base.</p>
<p>Chapter 1 provides an overview of algorithms and their place in modern computing systems. This chapter defines what an algorithm is and lists some examples. It also makes a case for considering algorithms as a technology, alongside technologies such as fast hardware, graphical user interfaces, object-oriented systems, and networks.</p>
<p>In Chapter 2, we see our first algorithms, which solve the problem of sorting a sequence of n numbers. They are written in a pseudocode which, although not directly translatable to any conventional programming language, conveys the structure of the algorithm clearly enough that you should be able to implement it in the language of your choice. The sorting algorithms we examine are insertion sort, which uses an incremental approach, and merge sort, which uses a recursive technique known as “divide-and-conquer.” Although the time each requires increases with the value of n, the rate of increase differs between the two algorithms. We determine these running times in Chapter 2, and we develop a useful “asymptotic” notation to express them.</p>
<p>Chapter 3 precisely defines asymptotic notation. We’ll use asymptotic notation to bound the growth of functions—most often, functions that describe the running time of algorithms—from above and below. The chapter starts by informally defining the most commonly used asymptotic notations and giving an example of how to apply them.</p>
<p>It then formally defines five asymptotic notations and presents conventions for how to put them together. The rest of Chapter 3 is primarily a presentation of mathematical notation, more to ensure that your use of notation matches that in this book than to teach you new mathematical concepts.</p>
<p>Chapter 4 delves further into the divide-and-conquer method introduced in Chapter 2. It provides two additional examples of divideand-conquer algorithms for multiplying square matrices, including Strassen’s surprising method. Chapter 4 contains methods for solving recurrences, which are useful for describing the running times of recursive algorithms. In the substitution method, you guess an answer and prove it correct. Recursion trees provide one way to generate a guess. Chapter 4 also presents the powerful technique of the “master method,” which you can often use to solve recurrences that arise from divide-and-conquer algorithms. Although the chapter provides a proof of a foundational theorem on which the master theorem depends, you should feel free to employ the master method without delving into the proof. Chapter 4 concludes with some advanced topics.</p>
<p>Chapter 5 introduces probabilistic analysis and randomized algorithms. You typically use probabilistic analysis to determine the running time of an algorithm in cases in which, due to the presence of an inherent probability distribution, the running time may differ on different inputs of the same size. In some cases, you might assume that the inputs conform to a known probability distribution, so that you are averaging the running time over all possible inputs. In other cases, the probability distribution comes not from the inputs but from random choices made during the course of the algorithm. An algorithm whose behavior is determined not only by its input but by the values produced by a random-number generator is a randomized algorithm. You can use randomized algorithms to enforce a probability distribution on the inputs—thereby ensuring that no particular input always causes poor performance—or even to bound the error rate of algorithms that are allowed to produce incorrect results on a limited basis.</p>
<p>Appendices A–D contain other mathematical material that you will find helpful as you read this book. You might have seen much of the material in the appendix chapters before having read this book (although the specific definitions and notational conventions we use may differ in some cases from what you have seen in the past), and so you should think of the appendices as reference material. On the other hand, you probably have not already seen most of the material in Part I.</p>
<p>All the chapters in Part I and the appendices are written with a tutorial flavor.</p>
<p>当你设计和分析算法时，你需要能够描述它们是如何运作的以及如何设计它们。你还需要一些数学工具来证明你的算法做了正确的事情，而且做得很有效率。这一部分将让你开始。本书后面的部分将建立在这个基础上。</p>
<p>第 1 章概述了算法及其在现代计算系统中的地位。本章定义了什么是算法并列出了一些例子。它还提出了将算法视为一种技术的理由，与快速硬件、图形用户界面、面向对象系统和网络等技术并列。</p>
<p>在第 2 章中，我们看到了我们的第一个算法，它解决了对 n 个数字序列进行排序的问题。它们被写成了一个伪代码，虽然不能直接翻译成任何传统的编程语言，但它清楚地传达了算法的结构，你应该能够用你选择的语言来实现它。我们研究的排序算法是插入排序和合并排序，前者使用增量方法，后者使用被称为 "分而治之" 的递归技术。尽管每种算法所需的时间都随着 n 值的增加而增加，但这两种算法的增加率是不同的。我们在第二章中确定了这些运行时间，并开发了一个有用的 "渐近" 符号来表达它们。</p>
<p>第三章精确地定义了渐进式符号。我们将使用渐进符号来约束函数的增长 -- 最常见的是，描述算法运行时间的函数 -- 从上到下。本章首先非正式地定义了最常用的渐进式符号，并举例说明了如何应用它们。</p>
<p>然后，它正式定义了五个渐进式符号，并介绍了如何将它们放在一起的惯例。第三章的其余部分主要是对数学符号的介绍，更多的是为了确保你对符号的使用与本书一致，而不是为了教你新的数学概念。</p>
<p>第 4 章进一步探讨了第 2 章中介绍的除法和征服方法。它提供了两个额外的除法和征服算法的例子，用于相乘方阵，包括 Strassen 的令人惊讶的方法。第四章包含了解决递归的方法，这些方法对于描述递归算法的运行时间很有用。在替换法中，你猜测一个答案并证明其正确。递归树提供了一种产生猜测的方法。第四章还介绍了 "主方法" 这一强大的技术，你经常可以用它来解决分而治之算法中出现的递归问题。尽管本章提供了一个基础定理的证明，而主定理正是依赖于此，但你应该放心地使用主方法，而不必深入研究该证明。第 4 章以一些高级话题作结。</p>
<p>第 5 章介绍了概率分析和随机化算法。你通常使用概率分析来确定算法的运行时间，在这种情况下，由于存在固有的概率分布，在相同大小的不同输入上，运行时间可能不同。在某些情况下，你可能会假设输入符合一个已知的概率分布，因此，你是在所有可能的输入上平均计算运行时间。在其他情况下，概率分布不是来自输入，而是来自算法过程中的随机选择。一个算法的行为不仅由其输入决定，而且由随机数发生器产生的值决定，这就是随机化算法。你可以使用随机算法来强制执行输入的概率分布 -- 从而确保没有特定的输入总是导致糟糕的性能，或者甚至约束那些允许在有限的基础上产生不正确结果的算法的错误率。</p>
<p>附录 A-D 包含其他数学材料，你会发现这些材料在你阅读本书时很有帮助。在阅读本书之前，你可能已经看到了附录章节中的许多材料（尽管我们使用的具体定义和符号惯例在某些情况下可能与你过去看到的不同），因此你应该把附录看作是参考材料。另一方面，你可能还没有看过第一部分中的大部分材料。</p>
<p>第一部分的所有章节和附录都是以教程的形式编写的。</p>
<p>1 The Role of Algorithms in Computing</p>
<p>What are algorithms? Why is the study of algorithms worthwhile? What is the role of algorithms relative to other technologies used in computers? This chapter will answer these questions.</p>
<p>什么是算法？为什么对算法的研究是值得的？相对于计算机中使用的其他技术，算法的作用是什么？本章将回答这些问题。</p>
<p>1.1 Algorithms</p>
<p>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time. An algorithm is thus a sequence of computational steps that transform the input into the output.</p>
<p>非正式地讲，算法是任何定义明确的计算程序，它将一些数值或一组数值作为输入，在有限的时间内产生一些数值或一组数值作为输出。因此，一个算法是将输入转化为输出的一系列计算步骤。</p>
<p>You can also view an algorithm as a tool for solving a well-specified computational problem. The statement of the problem specifies in general terms the desired input/output relationship for problem instances, typically of arbitrarily large size. The algorithm describes a specific computational procedure for achieving that input/output relationship for all problem instances.</p>
<p>你也可以把算法看作是解决一个明确规定的计算问题的工具。问题的陈述在一般情况下指定了问题实例所需的输入 / 输出关系，通常是任意大小。算法描述了，为所有问题实例实现该输入 / 输出关系的具体计算过程。</p>
<p>As an example, suppose that you need to sort a sequence of numbers into monotonically increasing order. This problem arises frequently in practice and provides fertile ground for introducing many standard design techniques and analysis tools. Here is how we formally define the sorting problem:</p>
<p>作为一个例子，假设你需要将一串数字按单调递增的顺序排序。这个问题在实践中经常出现，为引入许多标准设计技术和分析工具提供了肥沃的土壤。下面是我们如何正式定义排序问题的。</p>
<p>Input: A sequence of n numbers 〈a1, a2, … , an〉.</p>
<p>Output: A permutation (reordering)  of the input sequence such that .</p>
<p>输入。一串 n 个数字 〈a1, a2, ..., an〉。</p>
<p>输出。一个输入序列的置换（重新排序），以便......。</p>
<p>Thus, given the input sequence 〈31, 41, 59, 26, 41, 58〉, a correct sorting algorithm returns as output the sequence 〈26, 31, 41, 41, 58, 59〉. Such an input sequence is called an instance of the sorting problem. In general, an instance of a problem1 consists of the input (satisfying whatever constraints are imposed in the problem statement) needed to compute a solution to the problem.</p>
<p>因此，给定输入序列〈31，41，59，26，41，58〉，一个正确的排序算法的输出是序列〈26，31，41，41，58，59〉。这样的输入序列被称为排序问题的一个实例。一般来说，一个问题的实例 1 包括计算该问题的解决方案所需的输入（满足问题陈述中的任何约束条件）。</p>
<p>Because many programs use it as an intermediate step, sorting is a fundamental operation in computer science. As a result, you have a large number of good sorting algorithms at your disposal. Which algorithm is best for a given application depends on—among other factors—the number of items to be sorted, the extent to which the items are already somewhat sorted, possible restrictions on the item values, the architecture of the computer, and the kind of storage devices to be used: main memory, disks, or even—archaically—tapes.</p>
<p>因为许多程序都把它作为中间步骤，所以排序是计算机科学中的一个基本操作。因此，你有大量的好的排序算法供你使用。哪种算法最适合给定的应用，取决于其他因素 -- 需要排序的项目数量、项目已被排序的程度、对项目价值的可能限制、计算机的结构，以及要使用的存储设备的种类：主存储器、磁盘，甚至是存档的磁带。</p>
<p>An algorithm for a computational problem is correct if, for every problem instance provided as input, it halts—finishes its computing in finite time—and outputs the correct solution to the problem instance. A correct algorithm solves the given computational problem. An incorrect algorithm might not halt at all on some input instances, or it might halt with an incorrect answer. Contrary to what you might expect, incorrect algorithms can sometimes be useful, if you can control their error rate. We’ll see an example of an algorithm with a controllable error rate in Chapter 31 when we study algorithms for finding large prime numbers. Ordinarily, however, we’ll concern ourselves only with correct algorithms.</p>
<p>对于一个计算问题的算法，如果对于每一个作为输入的问题实例，它都会停止 -- 在有限的时间内完成计算，并输出该问题实例的正确解，那么这个算法就是正确的。一个正确的算法可以解决给定的计算问题。一个不正确的算法在某些输入实例上可能根本不会停止，或者它可能以一个错误的答案停止。与你可能期望的相反，如果你能控制其错误率，不正确的算法有时是有用的。我们将在第 31 章研究寻找大素数的算法时看到一个错误率可控的算法的例子。然而，通常情况下，我们只关注正确的算法。</p>
<p>An algorithm can be specified in English, as a computer program, or even as a hardware design. The only requirement is that the specification must provide a precise description of the computational procedure to be followed.</p>
<p>一个算法可以用英语指定，作为一个计算机程序，甚至作为一个硬件设计。唯一的要求是，该规范必须对要遵循的计算程序进行精确的描述。</p>
<p>What kinds of problems are solved by algorithms?</p>
<p>Sorting is by no means the only computational problem for which algorithms have been developed. (You probably suspected as much when you saw the size of this book.) Practical applications of algorithms are ubiquitous and include the following examples:</p>
<p>排序决不是唯一一个已经开发出算法的计算问题。(当你看到这本书的篇幅时，你可能也怀疑过。) 算法的实际应用无处不在，包括以下例子。</p>
<p>The Human Genome Project has made great progress toward the goals of identifying all the roughly 30,000 genes in human DNA, determining the sequences of the roughly 3 billion chemical base pairs that make up human DNA, storing this information in databases, and developing tools for data analysis. Each of these steps requires sophisticated algorithms. Although the solutions to the various problems involved are beyond the scope of this book, many methods to solve these biological problems use ideas presented here, enabling scientists to accomplish tasks while using resources efficiently. Dynamic programming, as in Chapter 14, is an important technique for solving several of these biological problems, particularly ones that involve determining similarity between DNA sequences. The savings realized are in time, both human and machine, and in money, as more information can be extracted by laboratory techniques.</p>
<p>人类基因组计划已经在确定人类 DNA 中所有大约 3 万个基因，确定构成人类 DNA 的大约 30 亿个化学碱基对的序列，将这些信息存储在数据库中，以及开发数据分析工具等目标方面取得了巨大进展。这些步骤中的每一步都需要复杂的算法。尽管所涉及的各种问题的解决方案超出了本书的范围，但解决这些生物问题的许多方法都采用了这里提出的思路，使科学家在有效利用资源的同时完成任务。如第 14 章所述，动态编程是解决其中几个生物问题的重要技术，特别是涉及确定 DNA 序列之间相似性的问题。实现的节约是在时间上，包括人力和机器，以及在金钱上，因为可以通过实验室技术提取更多的信息。</p>
<p>The internet enables people all around the world to quickly access and retrieve large amounts of information. With the aid of clever algorithms, sites on the internet are able to manage and manipulate this large volume of data. Examples of problems that make essential use of algorithms include finding good routes on which the data travels (techniques for solving such problems appear in Chapter 22), and using a search engine to quickly find pages on which particular information resides (related techniques are in Chapters 11 and 32).</p>
<p>互联网使世界各地的人们能够快速访问和检索大量的信息。在聪明的算法的帮助下，互联网上的网站能够管理和操纵这些大量的数据。必须使用算法的问题的例子包括寻找数据传输的良好路线（解决此类问题的技术出现在第 22 章），以及使用搜索引擎快速找到特定信息所在的网页（相关技术出现在第 11 章和第 32 章）。</p>
<p>Electronic commerce enables goods and services to be negotiated and exchanged electronically, and it depends on the privacy of personal information such as credit card numbers, passwords, and bank statements. The core technologies used in electronic commerce include public-key cryptography and digital signatures (covered in Chapter 31), which are based on numerical algorithms and number theory.</p>
<p>电子商务使商品和服务可以通过电子方式进行谈判和交换，它依赖于个人信息的隐私，如信用卡号码、密码和银行账单。电子商务中使用的核心技术包括公钥密码学和数字签名（在第 31 章中涉及），它们都是基于数字算法和数论。</p>
<p>Manufacturing and other commercial enterprises often need to allocate scarce resources in the most beneficial way. An oil company might wish to know where to place its wells in order to maximize its expected profit. A political candidate might want to determine where to spend money buying campaign advertising in order to maximize the chances of winning an election. An airline might wish to assign crews to flights in the least expensive way possible, making sure that each flight is covered and that government regulations regarding crew scheduling are met. An internet service provider might wish to determine where to place additional resources in order to serve its customers more effectively. All of these are examples of problems that can be solved by modeling them as linear programs, which Chapter 29 explores.</p>
<p>制造业和其他商业企业经常需要以最有利的方式分配稀缺资源。一家石油公司可能希望知道把油井放在哪里，以使其预期利润最大化。一个政治候选人可能想确定在哪里花钱购买竞选广告，以便最大限度地提高赢得选举的机会。一家航空公司可能希望以最便宜的方式将机组人员分配到航班上，确保每个航班都被覆盖，并符合政府关于机组人员调度的规定。一个互联网服务提供商可能希望确定在哪里放置额外的资源，以便更有效地服务其客户。所有这些都是可以通过将其建模为线性程序来解决的问题的例子，第 29 章对此进行了探讨。</p>
<p>Although some of the details of these examples are beyond the scope of this book, we do give underlying techniques that apply to these problems and problem areas. We also show how to solve many specific problems, including the following:</p>
<p>尽管这些例子的一些细节超出了本书的范围，但我们确实给出了适用于这些问题和问题领域的基本技术。我们还展示了如何解决许多具体问题，包括以下问题。</p>
<p>You have a road map on which the distance between each pair of adjacent intersections is marked, and you wish to determine the shortest route from one intersection to another. The number of possible routes can be huge, even if you disallow routes that cross over themselves. How can you choose which of all possible routes is the shortest? You can start by modeling the road map (which is itself a model of the actual roads) as a graph (which we will meet in Part VI and Appendix B). In this graph, you wish to find the shortest path from one vertex to another. Chapter 22 shows how to solve this problem efficiently.</p>
<p>你有一张路线图，上面标明了每一对相邻交叉口之间的距离，你希望确定从一个交叉口到另一个交叉口的最短路线。可能的路线数量可能是巨大的，即使你不允许有交叉的路线。你如何选择所有可能的路线中哪条是最短的呢？你可以先把路线图（它本身就是实际道路的模型）建模为一个图（我们将在第六部分和附录 B 中见到）。在这个图中，你希望找到从一个顶点到另一个顶点的最短路径。第 22 章展示了如何有效地解决这个问题。</p>
<p>Given a mechanical design in terms of a library of parts, where each part may include instances of other parts, list the parts in order so that each part appears before any part that uses it. If the design comprises n parts, then there are n! possible orders, where n! denotes the factorial function. Because the factorial function grows faster than even an exponential function, you cannot feasibly generate each possible order and then verify that, within that order, each part appears before the parts using it (unless you have only a few parts). This problem is an instance of topological sorting, and Chapter 20 shows how to solve this problem efficiently.</p>
<p>给定一个机械设计的零件库，其中每个零件可能包括其他零件的实例，请按顺序列出零件，使每个零件出现在使用它的任何零件之前。如果设计包括 n 个零件，那么就有 n 个可能的顺序，其中 n！表示阶乘函数。因为阶乘函数的增长速度甚至超过了指数函数，所以你不可能生成每个可能的顺序，然后验证在这个顺序中，每个零件都出现在使用它的零件之前（除非你只有几个零件）。这个问题是拓扑排序的一个实例，第 20 章展示了如何有效解决这个问题。</p>
<p>A doctor needs to determine whether an image represents a cancerous tumor or a benign one. The doctor has available images of many other tumors, some of which are known to be cancerous and some of which are known to be benign. A cancerous tumor is likely to be more similar to other cancerous tumors than to benign tumors, and a benign tumor is more likely to be similar to other benign tumors. By using a clustering algorithm, as in Chapter 33, the doctor can identify which outcome is more likely.</p>
<p>医生需要确定一个图像是代表一个癌性肿瘤还是一个良性肿瘤。医生有许多其他肿瘤的图像，其中一些已知是癌性的，一些已知是良性的。癌性肿瘤可能与其他癌性肿瘤的相似度高于良性肿瘤，而良性肿瘤更可能与其他良性肿瘤相似。通过使用聚类算法（如第 33 章），医生可以确定哪种结果更有可能。</p>
<p>You need to compress a large file containing text so that it occupies less space. Many ways to do so are known, including “LZW compression,” which looks for repeating character sequences. Chapter 15 studies a different approach, “Huffman coding,” which encodes characters by bit sequences of various lengths, with characters occurring more frequently encoded by shorter bit sequences.</p>
<p>你需要压缩一个包含文本的大文件，以减少其占用的空间。有许多方法可以做到这一点，包括 "LZW 压缩"，它寻找重复的字符序列。第 15 章研究了一种不同的方法，即 "Huffman 编码"，它通过不同长度的比特序列对字符进行编码，其中出现频率较高的字符由较短的比特序列进行编码。</p>
<p>These lists are far from exhaustive (as you again have probably surmised from this book’s heft), but they exhibit two characteristics common to many interesting algorithmic problems:</p>
<p>这些清单远非详尽无遗（正如你从本书的篇幅中可能已经猜到的那样），但它们表现出许多有趣的算法问题的两个共同特征。</p>
<ol>
<li>
<p>They have many candidate solutions, the overwhelming majority of which do not solve the problem at hand. Finding one that does, or one that is “best,” without explicitly examining each possible solution, can present quite a challenge.</p>
</li>
<li>
<p>他们有许多候选解决方案，其中绝大多数都不能解决手头的问题。在没有明确检查每个可能的解决方案的情况下，找到一个可以解决的方案，或者一个 "最好的" 方案，可能是一个相当大的挑战。</p>
</li>
<li>
<p>They have practical applications. Of the problems in the above list, finding the shortest path provides the easiest examples. A transportation firm, such as a trucking or railroad company, has a financial interest in finding shortest paths through a road or rail network because taking shorter paths results in lower labor and fuel costs. Or a routing node on the internet might need to find the shortest path through the network in order to route a message quickly. Or a person wishing to drive from New York to Boston might want to find driving directions using a navigation app.</p>
</li>
<li>
<p>它们有实际的应用。在上述列表中的问题中，寻找最短路径提供了最简单的例子。一家运输公司，如卡车公司或铁路公司，在寻找通过公路或铁路网络的最短路径方面有经济利益，因为走更短的路径可以降低劳动力和燃料成本。或者互联网上的一个路由节点可能需要找到通过网络的最短路径，以便快速路由一个信息。或者一个希望从纽约开车到波士顿的人可能想用一个导航应用程序找到驾驶路线。</p>
</li>
</ol>
<p>Not every problem solved by algorithms has an easily identified set of candidate solutions. For example, given a set of numerical values representing samples of a signal taken at regular time intervals, the discrete Fourier transform converts the time domain to the frequency domain. That is, it approximates the signal as a weighted sum of sinusoids, producing the strength of various frequencies which, when summed, approximate the sampled signal. In addition to lying at the heart of signal processing, discrete Fourier transforms have applications in data compression and multiplying large polynomials and integers. Chapter 30 gives an efficient algorithm, the fast Fourier transform (commonly called the FFT), for this problem. The chapter also sketches out the design of a hardware FFT circuit.</p>
<p>并非每一个通过算法解决的问题都有一组容易识别的候选解决方案。例如，给定一组代表以固定时间间隔采集的信号样本的数值，离散傅里叶变换将时域转换为频域。也就是说，它将信号近似为正弦波的加权和，产生各种频率的强度，这些频率加起来就近似于采样信号。除了位于信号处理的核心之外，离散傅里叶变换还应用于数据压缩和大型多项式和整数的乘法。第 30 章给出了一种有效的算法，即快速傅里叶变换（通常称为 FFT），用于解决这个问题。该章还勾画了一个硬件 FFT 电路的设计。</p>
<p>Data structures</p>
<p>This book also presents several data structures. A data structure is a way to store and organize data in order to facilitate access and modifications. Using the appropriate data structure or structures is an important part of algorithm design. No single data structure works well for all purposes, and so you should know the strengths and limitations of several of them.</p>
<p>本书还介绍了几种数据结构。数据结构是一种存储和组织数据的方式，以便于访问和修改。使用适当的数据结构或结构是算法设计的一个重要部分。没有一种数据结构能很好地满足所有的目的，因此你应该了解其中几种结构的优点和局限性。</p>
<p>Technique</p>
<p>Although you can use this book as a “cookbook” for algorithms, you might someday encounter a problem for which you cannot readily find a published algorithm (many of the exercises and problems in this book, for example). This book will teach you techniques of algorithm design and analysis so that you can develop algorithms on your own, show that they give the correct answer, and analyze their efficiency. Different chapters address different aspects of algorithmic problem solving. Some chapters address specific problems, such as finding medians and order statistics in Chapter 9, computing minimum spanning trees in Chapter 21, and determining a maximum flow in a network in Chapter 24. Other chapters introduce techniques, such as divide-and-conquer in Chapters 2 and 4, dynamic programming in Chapter 14, and amortized analysis in Chapter 16.</p>
<p>尽管你可以把本书作为算法的 "食谱"，但有一天你可能会遇到一个你无法轻易找到已发表算法的问题（例如，本书中的许多练习和问题）。本书将教给你算法设计和分析的技术，这样你就可以自己开发算法，证明它们能给出正确的答案，并分析其效率。不同的章节涉及算法问题解决的不同方面。有些章节涉及具体问题，如第 9 章中寻找中位数和顺序统计，第 21 章中计算最小生成树，以及第 24 章中确定网络中的最大流量。其他章节介绍了一些技术，如第 2 章和第 4 章中的 "分而治之"，第 14 章中的动态编程，以及第 16 章的摊销分析。</p>
<p>Hard problems</p>
<p>Most of this book is about efficient algorithms. Our usual measure of efficiency is speed: how long does an algorithm take to produce its result? There are some problems, however, for which we know of no algorithm that runs in a reasonable amount of time. Chapter 34 studies an interesting subset of these problems, which are known as NP-complete.</p>
<p>本书的大部分内容都是关于高效算法的。我们通常衡量效率的标准是速度：一个算法需要多长时间来产生结果？然而，有一些问题，我们不知道有什么算法能在合理的时间内运行。第 34 章研究了这些问题的一个有趣的子集，它们被称为 NP-complete。</p>
<p>Why are NP-complete problems interesting? First, although no efficient algorithm for an NP-complete problem has ever been found, nobody has ever proven that an efficient algorithm for one cannot exist. In other words, no one knows whether efficient algorithms exist for NPcomplete problems. Second, the set of NP-complete problems has the remarkable property that if an efficient algorithm exists for any one of them, then efficient algorithms exist for all of them. This relationship among the NP-complete problems makes the lack of efficient solutions all the more tantalizing. Third, several NP-complete problems are similar, but not identical, to problems for which we do know of efficient algorithms. Computer scientists are intrigued by how a small change to the problem statement can cause a big change to the efficiency of the best known algorithm.</p>
<p>为什么 NP - 完备的问题是有趣的？首先，虽然从来没有发现过 NP-complete 问题的有效算法，但也没有人证明一个问题的有效算法不可能存在。换句话说，没有人知道 NP 完整问题是否存在有效算法。其次，NP - 不完全问题集有一个显著的特性，即如果其中任何一个问题存在有效算法，那么所有问题都存在有效算法。NP - 不完全问题之间的这种关系使得缺乏有效的解决方案变得更加诱人。第三，有几个 NP 不完全问题与我们已知的有效算法的问题相似，但不完全相同。计算机科学家们对问题陈述的一个小变化如何能导致最好的已知算法的效率发生巨大变化感到好奇。</p>
<p>As a concrete example, consider a delivery company with a central depot. Each day, it loads up delivery trucks at the depot and sends them around to deliver goods to several addresses. At the end of the day, each truck must end up back at the depot so that it is ready to be loaded for the next day. To reduce costs, the company wants to select an order of delivery stops that yields the lowest overall distance traveled by each truck. This problem is the well-known “traveling-salesperson problem,” and it is NP-complete. It has no known efficient algorithm. Under certain assumptions, however, we know of efficient algorithms that compute overall distances close to the smallest possible. Chapter 35 discusses such “approximation algorithms.”</p>
<p>作为一个具体的例子，考虑一个拥有中央仓库的快递公司。每天，该公司在仓库装上送货卡车，然后派它们到各地向几个地址送货。在一天结束的时候，每辆卡车都必须回到仓库，以便为第二天的装载做好准备。为了降低成本，该公司希望选择一个能使每辆卡车行驶的总距离最小的送货站顺序。这个问题就是众所周知的 "旅行销售人员问题"，它是 NP-complete。它没有已知的有效算法。然而，在某些假设下，我们知道一些有效的算法可以计算出接近最小的总距离。第 35 章讨论了这种 "近似算法"。</p>
<p>Alternative computing models</p>
<p>For many years, we could count on processor clock speeds increasing at a steady rate. Physical limitations present a fundamental roadblock to ever-increasing clock speeds, however: because power density increases superlinearly with clock speed, chips run the risk of melting once their clock speeds become high enough. In order to perform more computations per second, therefore, chips are being designed to contain not just one but several processing “cores.” We can liken these multicore computers to several sequential computers on a single chip. In other words, they are a type of “parallel computer.” In order to elicit the best performance from multicore computers, we need to design algorithms with parallelism in mind. Chapter 26 presents a model for “taskparallel” algorithms, which take advantage of multiple processing cores. This model has advantages from both theoretical and practical standpoints, and many modern parallel-programming platforms embrace something similar to this model of parallelism.</p>
<p>许多年来，我们可以指望处理器的时钟速度以稳定的速度增长。然而，物理上的限制给不断提高的时钟速度带来了根本性的障碍：由于功率密度随时钟速度超线性增长，一旦芯片的时钟速度变得足够高，就会有融化的风险。因此，为了每秒执行更多的计算，芯片被设计成不仅包含一个，而是多个处理 "内核"。我们可以把这些多核计算机比作单个芯片上的几个顺序计算机。换句话说，它们是一种 "并行计算机"。为了从多核计算机中获得最佳性能，我们需要在设计算法时考虑到并行性。第 26 章介绍了一个 "任务并行" 算法的模型，它利用了多个处理核心的优势。这个模型从理论和实践的角度来看都有优势，许多现代的并行编程平台都接受了类似于这种并行性模型的东西。</p>
<p>Most of the examples in this book assume that all of the input data are available when an algorithm begins running. Much of the work in algorithm design makes the same assumption. For many important realworld examples, however, the input actually arrives over time, and the algorithm must decide how to proceed without knowing what data will arrive in the future. In a data center, jobs are constantly arriving and departing, and a scheduling algorithm must decide when and where to run a job, without knowing what jobs will be arriving in the future.Traffic must be routed in the internet based on the current state, without knowing about where traffic will arrive in the future. Hospital emergency rooms make triage decisions about which patients to treat first without knowing when other patients will be arriving in the future and what treatments they will need. Algorithms that receive their input over time, rather than having all the input present at the start, are online algorithms, which Chapter 27 examines.</p>
<p>本书中的大多数例子都假定，当算法开始运行时，所有的输入数据都是可用的。算法设计中的许多工作也是这样假设的。然而，对于许多重要的现实世界的例子，输入实际上是随着时间的推移而到达的，算法必须在不知道未来会有什么数据到达的情况下决定如何进行。在数据中心，工作不断地到达和离开，调度算法必须决定何时何地运行工作，而不知道未来会有什么工作到达。流量必须根据当前的状态在互联网上进行路由，而不知道流量在未来会到达哪里。医院急诊室在不知道其他病人将来何时到达以及他们需要什么治疗的情况下，对哪些病人先进行分流决定。随着时间的推移接收其输入的算法，而不是一开始就有所有的输入，这就是在线算法，第 27 章将对此进行研究。</p>
<p>Exercises</p>
<p>1.1-1 Describe your own real-world example that requires sorting. Describe one that requires finding the shortest distance between two points.</p>
<p>1.1-1 描述你自己在现实世界中需要进行排序的例子。描述一个需要找到两点之间最短距离的例子。</p>
<p>1.1-2 Other than speed, what other measures of efficiency might you need to consider in a real-world setting?</p>
<p>1.1-2 除了速度之外，在现实世界中，你可能还需要考虑哪些衡量效率的标准？</p>
<p>1.1-3 Select a data structure that you have seen, and discuss its strengths and limitations.</p>
<p>1.1-4 How are the shortest-path and traveling-salesperson problems given above similar? How are they different? 1.1-5 Suggest a real-world problem in which only the best solution will do.</p>
<p>Then come up with one in which “approximately” the best solution is good enough.</p>
<p>1.1-6 Describe a real-world problem in which sometimes the entire input is available before you need to solve the problem, but other times the input is not entirely available in advance and arrives over time.</p>
<p>1.1-3 选择一个你见过的数据结构，并讨论其优点和局限性。</p>
<p>1.1-4 上面给出的最短路径和旅行销售人员问题有什么相似之处？它们有什么不同？1.1-5 提出一个只有最佳方案才能解决的现实问题。</p>
<p>然后想出一个 "大约" 是最好的解决方案的问题。</p>
<p>1.1-6 描述一个现实世界中的问题，在这个问题中，有时在你需要解决问题之前，所有的输入都是可用的，但其他时候，输入并不是完全可用的，而是随着时间的推移而到来的。</p>
<p>1.2 Algorithms as a technology</p>
<p>If computers were infinitely fast and computer memory were free, would you have any reason to study algorithms? The answer is yes, if for no other reason than that you would still like to be certain that your solution method terminates and does so with the correct answer.</p>
<p>如果计算机是无限快的，计算机内存是免费的，你还有理由研究算法吗？答案是肯定的，如果没有其他原因的话，你仍然希望确定你的求解方法能够终止，并且能够得到正确的答案。</p>
<p>If computers were infinitely fast, any correct method for solving a problem would do. You would probably want your implementation to be within the bounds of good software engineering practice (for example, your implementation should be well designed and documented), but you would most often use whichever method was the easiest to implement.</p>
<p>如果计算机的速度是无限的，那么任何正确的方法都可以解决问题。你可能希望你的实现是在良好的软件工程实践的范围内（例如，你的实现应该是精心设计和记录的），但你最常使用的是最容易实现的方法。</p>
<p>Of course, computers may be fast, but they are not infinitely fast.Computing time is therefore a bounded resource, which makes it precious. Although the saying goes, “Time is money,” time is even more valuable than money: you can get back money after you spend it, but once time is spent, you can never get it back. Memory may be inexpensive, but it is neither infinite nor free. You should choose algorithms that use the resources of time and space efficiently.</p>
<p>当然，计算机可能很快，但它们不是无限快的。因此，计算时间是一种有限制的资源，这使得它很珍贵。虽然有句话说，"时间就是金钱"，但时间比金钱更有价值：你可以在花完钱后拿回来，但一旦时间被花掉，你就永远无法拿回来了。内存可能很便宜，但它既不是无限的也不是免费的。你应该选择能有效利用时间和空间资源的算法。</p>
<p>Efficiency</p>
<p>Different algorithms devised to solve the same problem often differ dramatically in their efficiency. These differences can be much more significant than differences due to hardware and software.</p>
<p>为解决同一问题而设计的不同算法往往在效率上有很大的不同。这些差异可能比硬件和软件造成的差异要大得多。</p>
<p>As an example, Chapter 2 introduces two algorithms for sorting. The first, known as insertion sort, takes time roughly equal to c1n2 to sort n items, where c1 is a constant that does not depend on n. That is, it takes time roughly proportional to n2. The second, merge sort, takes time roughly equal to c2n lg n, where lg n stands for log2 n and c2 is another constant that also does not depend on n. Insertion sort typically has a smaller constant factor than merge sort, so that c1 &lt; c2. We’ll see that the constant factors can have far less of an impact on the running time than the dependence on the input size n. Let’s write insertion sort’s running time as c1n · n and merge sort’s running time as c2n · lg n. Then we see that where insertion sort has a factor of n in its running time, merge sort has a factor of lg n, which is much smaller. For example, when n is 1000, lg n is approximately 10, and when n is 1,000,000, lg n is approximately only 20. Although insertion sort usually runs faster than merge sort for small input sizes, once the input size n becomes large enough, merge sort’s advantage of lg n versus n more than compensates for the difference in constant factors. No matter how much smaller c1 is than c2, there is always a crossover point beyond which merge sort is faster.</p>
<p>作为一个例子，第二章介绍了两种排序的算法。第一种，被称为插入排序，需要的时间大致等于 c1n2 来排序 n 个项目，其中 c1 是一个不依赖于 n 的常数，也就是说，它需要的时间大致与 n2 成比例。第二种，合并排序，需要的时间大致等于 c2n lg n，其中 lg n 代表 log2 n，c2 是另一个常数，也不取决于 n。插入排序通常比合并排序有一个更小的常数因子，因此 c1 &lt; c2。让我们把插入排序的运行时间写成 c1n *n，把合并排序的运行时间写成 c2n *lg n，那么我们就会发现，在插入排序的运行时间里有一个 n 的系数，而合并排序的系数是 lg n，这个系数要小得多。例如，当 n 为 1000 时，lg n 大约为 10，而当 n 为 1,000,000 时，lg n 大约只有 20。尽管在小的输入规模下，插入排序通常比合并排序运行得更快，但一旦输入规模 n 变得足够大，合并排序的 lg n 相对于 n 的优势就足以补偿常数因素的差异。无论 c1 比 c2 小多少，总有一个交叉点，超过这个交叉点，合并排序就会更快。</p>
<p>For a concrete example, let us pit a faster computer (computer A) running insertion sort against a slower computer (computer B) running merge sort. They each must sort an array of 10 million numbers.(Although 10 million numbers might seem like a lot, if the numbers are eight-byte integers, then the input occupies about 80 megabytes, which fits in the memory of even an inexpensive laptop computer many times over.) Suppose that computer A executes 10 billion instructions per second (faster than any single sequential computer at the time of this writing) and computer B executes only 10 million instructions per second (much slower than most contemporary computers), so that computer A is 1000 times faster than computer B in raw computing power. To make the difference even more dramatic, suppose that the world’s craftiest programmer codes insertion sort in machine language for computer A, and the resulting code requires 2n2 instructions to sort n numbers. Suppose further that just an average programmer implements merge sort, using a high-level language with an inefficient compiler, with the resulting code taking 50 n lg n instructions. To sort 10 million numbers, computer A takes</p>
<p>对于一个具体的例子，让我们让一台运行插入排序的较快的计算机（计算机 A）和一台运行合并排序的较慢的计算机（计算机 B）对决。虽然 1000 万个数字看起来很多，但如果这些数字是 8 字节的整数，那么输入的数字大约占 80 兆字节，即使是一台廉价的笔记本电脑的内存也够用了）。假设计算机 A 每秒执行 100 亿条指令（比本文写作时的任何一台顺序计算机都快），而计算机 B 每秒只执行 1000 万条指令（比大多数当代计算机慢得多），因此，就原始计算能力而言，计算机 A 比计算机 B 快 1000 倍。为了使差异更加显著，假设世界上最狡猾的程序员用机器语言为计算机 A 编码插入式排序，结果代码需要 2n2 条指令来排序 n 个数字。进一步假设，只是一个普通的程序员使用高级语言和低效的编译器来实现合并排序，结果代码需要 50 n lg n 指令。要对 1000 万个数字进行排序，计算机 A 需要</p>
<p><img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220815150137515.png" alt="image-20220815150137515"></p>
<p>while computer B takes</p>
<p>而计算机 B 需要</p>
<p><img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220815150328362.png" alt="image-20220815150328362"></p>
<p>By using an algorithm whose running time grows more slowly, even with a poor compiler, computer B runs more than 17 times faster than computer A! The advantage of merge sort is even more pronounced when sorting 100 million numbers: where insertion sort takes more than 23 days, merge sort takes under four hours. Although 100 million might seem like a large number, there are more than 100 million web searches every half hour, more than 100 million emails sent every minute, and some of the smallest galaxies (known as ultra-compact dwarf galaxies) contain about 100 million stars. In general, as the problem size increases, so does the relative advantage of merge sort.</p>
<p>通过使用一种运行时间增长较慢的算法，即使在编译器较差的情况下，计算机 B 的运行速度也比计算机 A 快 17 倍以上！在对 1 亿个数字进行排序时，合并排序的优势更加明显：插入排序需要 23 天以上的时间，而合并排序只需要不到 4 小时。虽然 1 亿看起来是个大数字，但每半小时就有超过 1 亿次的网络搜索，每分钟就有超过 1 亿封的电子邮件发送，一些最小的星系（被称为超紧凑矮星系）包含大约 1 亿颗恒星。一般来说，随着问题大小的增加，合并排序的相对优势也在增加。</p>
<p>Algorithms and other technologies</p>
<p>You might wonder whether algorithms are truly that important on contemporary computers in light of other advanced technologies, such as</p>
<p>advanced computer architectures and fabrication technologies,</p>
<p>easy-to-use, intuitive, graphical user interfaces (GUIs),</p>
<p>object-oriented systems,</p>
<p>integrated web technologies,</p>
<p>fast networking, both wired and wireless,</p>
<p>machine learning,</p>
<p>and mobile devices.</p>
<p>你可能会想，鉴于其他先进技术，算法在当代计算机上是否真的那么重要，例如</p>
<p>先进的计算机结构和制造技术。</p>
<p>易于使用的、直观的、图形用户界面（GUIs）。</p>
<p>面向对象的系统。</p>
<p>集成的网络技术。</p>
<p>快速联网，包括有线和无线。</p>
<p>机器学习。</p>
<p>和移动设备。</p>
<p>The answer is yes. Although some applications do not explicitly require algorithmic content at the application level (such as some simple, webbased applications), many do. For example, consider a web-based service that determines how to travel from one location to another. Its implementation would rely on fast hardware, a graphical user interface, wide-area networking, and also possibly on object orientation. It would also require algorithms for operations such as finding routes (probably using a shortest-path algorithm), rendering maps, and interpolating addresses.</p>
<p>答案是肯定的。尽管有些应用在应用层面上没有明确要求算法内容（比如一些简单的、基于网络的应用），但许多应用都需要。例如，考虑一个基于网络的服务，决定如何从一个地方到另一个地方。它的实现将依赖于快速的硬件、图形用户界面、广域网络，也可能依赖于面向对象。它还需要寻找路线（可能使用最短路径算法）、渲染地图和插值地址等操作的算法。</p>
<p>Moreover, even an application that does not require algorithmic content at the application level relies heavily upon algorithms. Does the application rely on fast hardware? The hardware design used algorithms. Does the application rely on graphical user interfaces? The design of any GUI relies on algorithms. Does the application rely on networking? Routing in networks relies heavily on algorithms. Was the application written in a language other than machine code? Then it was processed by a compiler, interpreter, or assembler, all of which make extensive use of algorithms. Algorithms are at the core of most technologies used in contemporary computers.</p>
<p>此外，即使是一个在应用层面上不需要算法内容的应用程序，也在很大程度上依赖于算法。该应用是否依赖快速的硬件？硬件设计使用了算法。应用程序依赖于图形用户界面吗？任何图形用户界面的设计都依赖于算法。应用程序依赖网络吗？网络中的路由在很大程度上依赖于算法。应用程序是用机器代码以外的语言编写的吗？那么它是由编译器、解释器或汇编器处理的，所有这些都大量使用了算法。算法是当代计算机中使用的大多数技术的核心。</p>
<p>Machine learning can be thought of as a method for performing algorithmic tasks without explicitly designing an algorithm, but instead inferring patterns from data and thereby automatically learning a solution. At first glance, machine learning, which automates the process of algorithmic design, may seem to make learning about algorithms obsolete. The opposite is true, however. Machine learning is itself a collection of algorithms, just under a different name. Furthermore, it currently seems that the successes of machine learning are mainly for problems for which we, as humans, do not really understand what the right algorithm is. Prominent examples include computer vision and automatic language translation. For algorithmic problems that humans understand well, such as most of the problems in this book, efficient algorithms designed to solve a specific problem are typically more successful than machine-learning approaches.</p>
<p>机器学习可以被认为是一种执行算法任务的方法，不需要明确设计算法，而是从数据中推断出模式，从而自动学习解决方案。乍一看，机器学习使算法设计的过程自动化，似乎使关于算法的学习变得过时。然而，事实恰恰相反。机器学习本身就是一个算法的集合，只是名称不同而已。此外，目前看来，机器学习的成功主要是针对那些我们作为人类并不真正了解什么是正确的算法的问题。突出的例子包括计算机视觉和自动语言翻译。对于人类能够很好理解的算法问题，比如本书中的大多数问题，为解决特定问题而设计的高效算法通常比机器学习方法更成功。</p>
<p>Data science is an interdisciplinary field with the goal of extracting knowledge and insights from structured and unstructured data. Data science uses methods from statistics, computer science, and optimization. The design and analysis of algorithms is fundamental to the field. The core techniques of data science, which overlap significantly with those in machine learning, include many of the algorithms in this book.</p>
<p>数据科学是一个跨学科领域，目标是从结构化和非结构化数据中提取知识和见解。数据科学使用来自统计学、计算机科学和优化的方法。算法的设计和分析是该领域的基础。数据科学的核心技术与机器学习的核心技术有很大重叠，包括本书中的许多算法。</p>
<p>Furthermore, with the ever-increasing capacities of computers, we use them to solve larger problems than ever before. As we saw in the above comparison between insertion sort and merge sort, it is at larger problem sizes that the differences in efficiency between algorithms become particularly prominent.</p>
<p>此外，随着计算机能力的不断提高，我们用它们来解决比以前更大的问题。正如我们在上面的插入排序和合并排序的比较中所看到的，正是在更大的问题规模上，算法之间的效率差异变得尤为突出。</p>
<p>Having a solid base of algorithmic knowledge and technique is one characteristic that defines the truly skilled programmer. With modern computing technology, you can accomplish some tasks without knowing much about algorithms, but with a good background in algorithms, you can do much, much more.</p>
<p>拥有坚实的算法知识和技术基础是定义真正熟练的程序员的一个特征。有了现代计算技术，你可以在不太了解算法的情况下完成一些任务，但有了良好的算法背景，你可以做得更多、更多。</p>
<p>Exercises 1.2-1 Give an example of an application that requires algorithmic content at the application level, and discuss the function of the algorithms involved.</p>
<p>1.2-2 Suppose that for inputs of size n on a particular computer, insertion sort runs in 8n2 steps and merge sort runs in 64 n lg n steps. For which values of n does insertion sort beat merge sort?</p>
<p>1.2-3 What is the smallest value of n such that an algorithm whose running time is 100n2 runs faster than an algorithm whose running time is 2n on the same machine?</p>
<p>练习 1.2-1 给出一个在应用层面需要算法内容的例子，并讨论相关算法的功能。</p>
<p>1.2-2 假设在一台特定的计算机上，对于大小为 n 的输入，插入排序运行 8n2 步，合并排序运行 64 n lg n 步。对于哪些数值的 n，插入排序会战胜合并排序？</p>
<p>1.2-3 在同一台机器上，运行时间为 100n2 的算法比运行时间为 2n 的算法运行得快，那么 n 的最小值是多少？</p>
<p>Problems</p>
<p>1-1     Comparison of running times</p>
<p>For each function f (n) and time t in the following table, determine the largest size n of a problem that can be solved in time t, assuming that the algorithm to solve the problem takes f (n) microseconds.</p>
<p>问题</p>
<p>1-1 运行时间的比较</p>
<p>对于下表中的每个函数 f (n) 和时间 t，假设解决问题的算法需要 f (n) 微秒，请确定在时间 t 内能解决的最大尺寸 n 的问题。</p>
<p><img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220815155147332.png" alt="image-20220815155147332"></p>
<p>Chapter notes There are many excellent texts on the general topic of algorithms, including those by Aho, Hopcroft, and Ullman [5, 6], Dasgupta, Papadimitriou, and Vazirani [107], Edmonds [133], Erickson [135], Goodrich and Tamassia [195, 196], Kleinberg and Tardos [257], Knuth [259, 260, 261, 262, 263], Levitin [298], Louridas [305], Mehlhorn and Sanders [325], Mitzenmacher and Upfal [331], Neapolitan [342], Roughgarden [385, 386, 387, 388], Sanders, Mehlhorn, Dietzfelbinger, and Dementiev [393], Sedgewick and Wayne [402], Skiena [414], SoltysKulinicz [419], Wilf [455], and Williamson and Shmoys [459]. Some of the more practical aspects of algorithm design are discussed by Bentley [49, 50, 51], Bhargava [54], Kochenderfer and Wheeler [268], and McGeoch [321]. Surveys of the field of algorithms can also be found in books by Atallah and Blanton [27, 28] and Mehta and Sahhi [326]. For less technical material, see the books by Christian and Griffiths [92], Cormen [104], Erwig [136], MacCormick [307], and Vöcking et al. [448].Overviews of the algorithms used in computational biology can be found in books by Jones and Pevzner [240], Elloumi and Zomaya [134], and Marchisio [315].</p>
<p>章节注释 关于算法的一般主题有许多优秀的文本，包括 Aho, Hopcroft, and Ullman [5, 6], Dasgupta, Papadimitriou, and Vazirani [107], Edmonds [133], Erickson [135], Goodrich and Tamassia [195, 196], Kleinberg and Tardos [257], Knuth [259, 260, 261, 262, 263] 的作品，Levitin [298], Louridas [305], Mehlhorn and Sanders [325], Mitzenmacher and Upfal [331], Neapolitan [342], Roughgarden [385, 386, 387, 388], Sanders, Mehlhorn, Dietzfelbinger, and Dementiev [393], Sedgewick and Wayne [402], Skiena [414], SoltysKulinicz [419], Wilf [455], and Williamson and Shmoys [459] 。Bentley [49, 50, 51], Bhargava [54], Kochenderfer 和 Wheeler [268], 以及 McGeoch [321] 讨论了算法设计的一些更实际的方面。算法领域的调查也可以在 Atallah 和 Blanton [27, 28] 以及 Mehta 和 Sahhi [326] 的书中找到。关于技术性较低的材料，可参见 Christian 和 Griffiths [92]、Cormen [104]、Erwig [136]、MacCormick [307] 和 Vöcking 等人 [448] 的书。Jones 和 Pevzner [240]、Elloumi 和 Zomaya [134] 以及 Marchisio [315] 的书中可以找到计算生物学中所用算法的概览。</p>
<p>1 Sometimes, when the problem context is known, problem instances are themselves simply called “problems.”</p>
<p>2 To be precise, only decision problems—those with a “yes/no” answer—can be NP-complete.The decision version of the traveling salesperson problem asks whether there exists an order of stops whose distance totals at most a given amount.</p>
<p>1 有时，当问题的背景是已知的，问题实例本身就被简单地称为 "问题"。</p>
<p>2 准确地说，只有决策问题 -- 那些有 "是 / 否" 答案的问题 -- 才是 NP - 完备的。旅行推销员问题的决策版本问的是，是否存在一个总距离最多为给定数额的停车顺序。</p>
<p>2 Getting Started</p>
<p>This chapter will familiarize you with the framework we’ll use throughout the book to think about the design and analysis of algorithms. It is self-contained, but it does include several references to material that will be introduced in Chapters 3 and 4. (It also contains several summations, which Appendix A shows how to solve.)</p>
<p>本章将使你熟悉我们在全书中用来思考算法的设计和分析的框架。它是自成一体的，但它确实包括了对将在第 3 章和第 4 章中介绍的材料的一些参考。（它还包含了一些总结，附录 A 显示了如何解决这些问题）。</p>
<p>We’ll begin by examining the insertion sort algorithm to solve the sorting problem introduced in Chapter 1. We’ll specify algorithms using a pseudocode that should be understandable to you if you have done computer programming. We’ll see why insertion sort correctly sorts and analyze its running time. The analysis introduces a notation that describes how running time increases with the number of items to be sorted. Following a discussion of insertion sort, we’ll use a method called divide-and-conquer to develop a sorting algorithm called merge sort. We’ll end with an analysis of merge sort’s running time.</p>
<p>我们将首先研究插入式排序算法，以解决第 1 章中介绍的排序问题。我们将使用一个伪代码来指定算法，如果你做过计算机编程，应该可以理解。我们将看到插入排序为什么能正确排序，并分析其运行时间。该分析引入了一个符号，描述了运行时间是如何随着要排序的项目数量而增加的。在对插入式排序进行讨论之后，我们将使用一种叫做分而治之的方法来开发一种叫做合并式排序的排序算法。最后，我们将对合并排序的运行时间进行分析。</p>
<p>2.1 Insertion sort</p>
<p>Our first algorithm, insertion sort, solves the sorting problem introduced in Chapter 1</p>
<p>我们的第一个算法，插入排序，解决了第一章中介绍的排序问题</p>
<p>Input: A sequence of n numbers 〈a1, a2, … , an〉.</p>
<p>输入。一串 n 个数字 〈a1, a2, ..., an〉。</p>
<p>Output: A permutation (reordering) <img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220816094234363.png" alt="image-20220816094234363"> of the input sequence such that<img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220816094246841.png" alt="image-20220816094246841"> .</p>
<p>输出：一个输入序列<img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220816094315830.png" alt="image-20220816094315830"> 的排列组合（重新排序) 像这样<img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220816094329360.png" alt="image-20220816094329360"></p>
<p>The numbers to be sorted are also known as the keys. Although the problem is conceptually about sorting a sequence, the input comes in the form of an array with n elements. When we want to sort numbers, it’s often because they are the keys associated with other data, which we call satellite data. Together, a key and satellite data form a record. For example, consider a spreadsheet containing student records with many associated pieces of data such as age, grade-point average, and number of courses taken. Any one of these quantities could be a key, but when the spreadsheet sorts, it moves the associated record (the satellite data) with the key. When describing a sorting algorithm, we focus on the keys, but it is important to remember that there usually is associated satellite data.</p>
<p>需要排序的数字也被称为键。虽然这个问题在概念上是关于序列的排序，但输入的形式是一个有 n 个元素的数组。当我们想对数字进行排序时，往往是因为它们是与其他数据相关的键，我们称之为卫星数据。键和卫星数据一起构成了一条记录。例如，考虑一个包含学生记录的电子表格，其中有许多相关的数据，如年龄、平均成绩和所学课程的数量。这些数量中的任何一个都可能是一个键，但是当电子表格进行排序时，它会将相关的记录（卫星数据）与键一起移动。在描述排序算法时，我们把重点放在键上，但重要的是要记住，通常有相关的卫星数据。</p>
<p>n this book, we’ll typically describe algorithms as procedures written in a pseudocode that is similar in many respects to C, C++, Java, Python,1 or JavaScript. (Apologies if we’ve omitted your favorite programming language. We can’t list them all.) If you have been introduced to any of these languages, you should have little trouble understanding algorithms “coded” in pseudocode. What separates pseudocode from real code is that in pseudocode, we employ whatever expressive method is most clear and concise to specify a given algorithm. Sometimes the clearest method is English, so do not be surprised if you come across an English phrase or sentence embedded within a section that looks more like real code. Another difference between pseudocode and real code is that pseudocode often ignores aspects of software engineering—such as data abstraction, modularity, and error handling—in order to convey the essence of the algorithm more concisely.</p>
<p>在本书中，我们通常将算法描述为用伪代码编写的程序，在许多方面类似于 C、C++、Java、Python1 或 JavaScript。(如果我们遗漏了你最喜欢的编程语言，请原谅。我们不可能把它们都列出来）。如果你已经被介绍过这些语言中的任何一种，你在理解用伪代码 "编码" 的算法方面应该没有什么问题。伪代码与真实代码的区别在于，在伪代码中，我们采用任何最清晰、最简洁的表达方法来指定一个特定的算法。有时，最清晰的方法是英语，因此，如果你遇到一个英语短语或句子嵌入到一个看起来更像真实代码的部分，请不要感到惊讶。伪代码和真实代码之间的另一个区别是，伪代码往往忽略了软件工程的一些方面 -- 例如数据抽象、模块化和错误处理 -- 以便更简洁地传达算法的本质。</p>
<p>We start with insertion sort, which is an efficient algorithm for sorting a small number of elements. Insertion sort works the way you might sort a hand of playing cards. Start with an empty left hand and the cards in a pile on the table. Pick up the first card in the pile and hold it with your left hand. Then, with your right hand, remove one card at a time from the pile, and insert it into the correct position in your left hand. As Figure 2.1 illustrates, you find the correct position for a card by comparing it with each of the cards already in your left hand, starting at the right and moving left. As soon as you see a card in your left hand whose value is less than or equal to the card you’re holding in your right hand, insert the card that you’re holding in your right hand just to the right of this card in your left hand. If all the cards in your left hand have values greater than the card in your right hand, then place this card as the leftmost card in your left hand. At all times, the cards held in your left hand are sorted, and these cards were originally the top cards of the pile on the table.</p>
<p>我们从插入式排序开始，这是一种对少量元素进行排序的有效算法。插入式排序的工作方式与你对一手扑克牌的排序一样。开始时，你的左手是空的，牌堆在桌子上。拿起牌堆中的第一张牌，用你的左手拿着它。然后，用你的右手从牌堆中每次取出一张牌，并将其插入你左手的正确位置。如图 2.1 所示，你通过与已经在你左手中的每一张牌进行比较，找到一张牌的正确位置，从右边开始，向左移动。一旦你看到左手中的一张牌的价值小于或等于你右手中的牌，就把你右手中的牌插到左手中这张牌的右边。如果你左手的所有牌的价值都大于你右手的这张牌，那么就把这张牌作为你左手的最左边的牌。在任何时候，你左手所持的牌都是经过分类的，这些牌本来就是桌上这堆牌的顶层。</p>
<p>The pseudocode for insertion sort is given as the procedure INSERTION-SORT on the facing page. It takes two parameters: an array A containing the values to be sorted and the number n of values of sort. The values occupy positions A[1] through A[n] of the array, which we denote by A[1 : n]. When the INSERTION-SORT procedure is finished, array A[1 : n] contains the original values, but in sorted order.</p>
<p>插入式排序的伪码在面版的 INSERTION-SORT 程序中给出。它需要两个参数：一个包含要排序的值的数组 A 和排序值的数量 n。这些值占据了数组中 A [1] 到 A [n] 的位置，我们用 A [1 : n] 表示。当 INSERTION-SORT 程序完成后，数组 A [1 : n] 包含原来的值，但是是按排序的顺序。</p>
<p><img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220817101227162.png" alt="image-20220817101227162"></p>
<p>Figure 2.1 Sorting a hand of cards using insertion sort.</p>
<pre><code>INSERTION-SORT(A, n)
1 for i = 2 to n
2 key = A[i]
3 // Insert A[i] into the sorted subarray A[1 : i – 1].
4 j = i – 1
5 while j &gt; 0 and A[j] &gt; key
6 A[j + 1] = A[j]
7 j = j – 1
8 A[j + 1] = key
</code></pre>
<p><strong>Loop invariants and the correctness of insertion sort</strong></p>
<p>Figure 2.2 shows how this algorithm works for an array A that starts out with the sequence 〈5, 2, 4, 6, 1, 3〉. The index i indicates the “current card” being inserted into the hand. At the beginning of each iteration of the for loop, which is indexed by i, the subarray (a contiguous portion of the array) consisting of elements A[1 : i – 1] (that is, A[1] through A[i – 1]) constitutes the currently sorted hand, and the remaining subarray A[i + 1 : n] (elements A[i + 1] through A[n]) corresponds to the pile of cards still on the table. In fact, elements A[1 : i – 1] are the elements originally in positions 1 through i – 1, but now in sorted order. We state these properties of A[1 : i – 1] formally as a loop invariant:</p>
<p>图 2.2 显示了这一算法对一个以〈5, 2, 4, 6, 1, 3〉序列开始的数组 A 的作用。索引 i 表示 "当前牌" 被插入手牌中。在 for 循环的每次迭代开始时，以 i 为索引，由元素 A [1 : i - 1]（即 A [1] 到 A [i - 1]）组成的子数组（数组的连续部分）构成了当前排序的手牌，其余的子数组 A [i + 1 : n]（元素 A [i + 1] 到 A [n]）对应的是仍在桌上的一堆牌。事实上，元素 A [1 : i - 1] 是原来在 1 到 i - 1 位置的元素，但现在是按排序顺序排列。我们将 A [1 : i - 1] 的这些属性正式表述为一个循环不变量。</p>
<p><img loading="lazy" src="C:%5CUsers%5Ckongmei%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220820191238802.png" alt="image-20220820191238802"></p>
<p>Figure 2.2 The operation of INSERTION-SORT(A, n), where A initially contains the sequence 〈5, 2, 4, 6, 1, 3〉 and n = 6. Array indices appear above the rectangles, and values stored in the array positions appear within the rectangles. (a)–(e) The iterations of the for loop of lines 1–8. In each iteration, the blue rectangle holds the key taken from A[i], which is compared with the values in tan rectangles to its left in the test of line 5. Orange arrows show array values moved one position to the right in line 6, and blue arrows indicate where the key moves to in line 8. (f) The final sorted array.</p>
<p>图 2.2 INSERTION-SORT (A, n) 的操作，其中 A 最初包含序列〈5, 2, 4, 6, 1, 3〉，n = 6。阵列索引出现在矩形的上方，存储在阵列位置的数值出现在矩形内。(a)-(e) 第 1-8 行的 for 循环的迭代。在每个迭代中，蓝色的矩形持有从 A [i] 中提取的键，在第 5 行的测试中，它与左侧的 tan 矩形中的值进行比较。橙色箭头表示阵列值在第 6 行中向右移动了一个位置，蓝色箭头表示键在第 8 行中移动到哪里。(f) 最后的排序数组。</p>
<figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tbody><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token triple-quoted-string string">"""Sort a list or numpy array.</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>	Argument:</pre></td></tr><tr><td data-num="5"></td><td><pre>	A -- a list or numpy array</pre></td></tr><tr><td data-num="6"></td><td><pre>	n -- length of A</pre></td></tr><tr><td data-num="7"></td><td><pre>	"""</pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment"># Traverse the list or array from index 1 to n-1.</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		key <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token comment"># Insert A[i] into the sorted subarray a[0:i].</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token comment"># Compare stored key with the already sorted values to its left.</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token comment"># Move each item one position to the right until we find the </span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token comment"># position for the key or fall off the left end of the list or array.</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token keyword">while</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token keyword">and</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>			A<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="19"></td><td><pre>			j <span class="token operator">-=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>		<span class="token comment"># Insert key at the correct position in the list or array.</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		A<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key</pre></td></tr></tbody></table></figure><p>At the start of each iteration of the for loop of lines 1–8, the subarray A[1 : i – 1] consists of the elements originally in A[1 : i – 1], but in sorted order.</p>
<p>在第 1-8 行 for 循环的每次迭代开始时，子数组 A [1 : i - 1] 由原来在 A [1 : i - 1] 中的元素组成，但是是按照排序的顺序。</p>
<p>Loop invariants help us understand why an algorithm is correct.When you’re using a loop invariant, you need to show three things:</p>
<p>循环不变量帮助我们理解为什么一个算法是正确的。当你使用一个循环不变量时，你需要明确三件事。</p>
<p>Initialization: It is true prior to the first iteration of the loop.</p>
<p>Maintenance: If it is true before an iteration of the loop, it remains true before the next iteration.</p>
<p>Termination: The loop terminates, and when it terminates, the invariant —usually along with the reason that the loop terminated—gives us a useful property that helps show that the algorithm is correct.</p>
<p>初始化：在循环的第一次迭代之前为真。</p>
<p>循环维持：如果它在循环的一次迭代之前为真，那么在下一次迭代之前它仍然为真。</p>
<p>终止：循环终止，当它终止时，该变量 -- 通常与循环终止的原因一起 -- 为我们提供了一个有用的属性，有助于表明该算法是正确的。</p>
<p>When the first two properties hold, the loop invariant is true prior to every iteration of the loop. (Of course, you are free to use established facts other than the loop invariant itself to prove that the loop invariant remains true before each iteration.) A loop-invariant proof is a form of mathematical induction, where to prove that a property holds, you prove a base case and an inductive step. Here, showing that the invariant holds before the first iteration corresponds to the base case, and showing that the invariant holds from iteration to iteration corresponds to the inductive step.</p>
<p>当前两个属性成立时，循环不变式在循环的每次迭代之前都是真的。(当然，你可以自由地使用循环不变性本身以外的既定事实来证明循环不变性在每次迭代之前都是真的）。循环不变量证明是数学归纳法的一种形式，为了证明一个属性的成立，你要证明一个基本情况和一个归纳步骤。在这里，在第一次迭代前证明不变式成立对应的是基本情况，而在迭代后证明不变式成立对应的是归纳步骤。</p>
<p>The third property is perhaps the most important one, since you are using the loop invariant to show correctness. Typically, you use the loop invariant along with the condition that caused the loop to terminate.Mathematical induction typically applies the inductive step infinitely, but in a loop invariant the “induction” stops when the loop terminates.</p>
<p>Let’s see how these properties hold for insertion sort.</p>
<p>第三个属性也许是最重要的一个，因为你要用循环不变式来证明正确性。通常情况下，你将循环不变量与导致循环终止的条件一起使用。数学归纳法通常无限地应用归纳步骤，但在循环不变量中，"归纳" 在循环终止时停止。</p>
<p>让我们来看看这些属性在插入式排序中是如何成立的。</p>
<p>Initialization: We start by showing that the loop invariant holds before the first loop iteration, when i = 2.2 The subarray A[1 : i – 1] consists of just the single element A[1], which is in fact the original element in A[1]. Moreover, this subarray is sorted (after all, how could a subarray with just one value not be sorted?), which shows that the loop invariant holds prior to the first iteration of the loop.</p>
<p>初始化：我们首先表明，在第一次循环迭代之前，当 i = 2.2 时，循环不变性是成立的。子数组 A [1 : i - 1] 只由单一元素 A [1] 组成，这实际上是 A [1] 的原始元素。此外，这个子数是被排序的（毕竟，只有一个值的子数怎么可能不被排序呢），这表明在循环的第一次迭代之前，循环不变式是成立的。</p>
<p>Maintenance: Next, we tackle the second property: showing that each iteration maintains the loop invariant. Informally, the body of the for loop works by moving the values in A[i – 1], A[i – 2], A[i – 3], and so on by one position to the right until it finds the proper position for A[i] (lines 4–7), at which point it inserts the value of A[i] (line 8). The subarray A[1 : i] then consists of the elements originally in A[1 : i], but in sorted order. Incrementing i (increasing its value by 1) for the next iteration of the for loop then preserves the loop invariant.</p>
<p>A more formal treatment of the second property would require us to state and show a loop invariant for the while loop of lines 5–7. Let’s not get bogged down in such formalism just yet. Instead, we’ll rely on our informal analysis to show that the second property holds for the outer loop.</p>
<p>维持：接下来，我们处理第二个属性：表明每个迭代都能保持循环的不变性。非正式地，for 循环的主体是将 A [i - 1]、A [i - 2]、A [i - 3] 中的值向右移动一个位置，直到找到 A [i] 的适当位置（第 4-7 行），这时它插入 A [i] 的值（第 8 行）。然后，子数组 A [1 : i] 由原来在 A [1 : i] 中的元素组成，但是是按排序的顺序。在 for 循环的下一次迭代中增加 i（将其值增加 1），这样就保留了循环不变性。</p>
<p>对第二个属性进行更正式的处理，需要我们说明并展示第 5-7 行的 while 循环的循环不变性。让我们先不要纠结于这种形式主义。相反，我们将依靠我们的非正式分析来证明第二个属性在外循环中成立。</p>
<p>Termination: Finally, we examine loop termination. The loop variable i starts at 2 and increases by 1 in each iteration. Once i’s value exceeds n in line 1, the loop terminates. That is, the loop terminates once i equals n + 1. Substituting n + 1 for i in the wording of the loop invariant yields that the subarray A[1 : n] consists of the elements originally in A[1 : n], but in sorted order. Hence, the algorithm is correct.</p>
<p>终止：最后，我们检查一下循环的终止。循环变量 i 从 2 开始，在每次迭代中增加 1。一旦 i 的值超过第 1 行的 n，循环就终止了。也就是说，一旦 i 等于 n+1，循环就终止了。在循环不变式中用 n + 1 代替 i，可以得出子数组 A [1 : n] 由原来在 A [1 : n] 中的元素组成，但是是按排序的顺序。因此，该算法是正确的。</p>
<p>This method of loop invariants is used to show correctness in various places throughout this book.</p>
<p>在本书的各个地方，这种循环不变量的方法被用来展示正确性。</p>
<p>Pseudocode conventions</p>
<p>We use the following conventions in our pseudocode.</p>
<p>我们在伪代码中使用以下约定。</p>
<p>Indentation indicates block structure. For example, the body of the for loop that begins on line 1 consists of lines 2–8, and the body of the while loop that begins on line 5 contains lines 6–7 but not line 8. Our indentation style applies to if-else statements as well. Using indentation instead of textual indicators of block structure, such as begin and end statements or curly braces, reduces clutter while preserving, or even enhancing, clarity.</p>
<p>缩进表示块结构。例如，第 1 行开始的 for 循环的主体由第 2-8 行组成，而第 5 行开始的 while 循环的主体包含第 6-7 行，但不包含第 8 行。我们的缩进方式也适用于 if-else 语句。使用缩进而不是块结构的文本指示器，如开始和结束语句或大括号，可以减少混乱，同时保持甚至提高清晰度。</p>
<p>The looping constructs while, for, and repeat-until and the if-else conditional construct have interpretations similar to those in C, C++, Java, Python, and <a target="_blank" rel="noopener" href="http://JavaScript.In">JavaScript.In</a> this book, the loop counter retains its value after the loop is exited, unlike some situations that arise in C++ and Java. Thus, immediately after a for loop, the loop counter’s value is the value that first exceeded the for loop bound.We used this property in our correctness argument for insertion sort. The for loop header in line 1 is for i = 2 to n, and so when this loop terminates, i equals n + 1. We use the keyword to when a for loop increments its loop counter in each iteration, and we use the keyword downto when a for loop decrements its loop counter (reduces its value by 1 in each iteration). When the loop counter changes by an amount greater than 1, the amount of change follows the optional keyword by.</p>
<p>循环结构 while、for 和 repeat-until 以及 if-else 条件结构的解释与 C、C++、Java、Python 和 JavaScript 中的解释相似。在本书中，循环计数器在循环退出后保留其值，与 C++ 和 Java 中出现的一些情况不同。因此，在 for 循环之后，循环计数器的值是第一次超过 for 循环边界的值。我们在插入排序的正确性论证中使用了这个属性。第 1 行的 for 循环头是 for i = 2 to n，因此当这个循环终止时，i 等于 n + 1。当 for 循环在每次迭代中增加其循环计数器时，我们使用关键字 to，而当 for 循环减少其循环计数器时（在每次迭代中减少 1），我们使用关键字 downto。当循环计数器的变化量大于 1 时，变化量跟随可选的关键字 by。</p>
<div class="tags"><a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"><i class="ic i-tag"></i>翻译</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2023/04/30/basic-theory/算法导论第四版（持续）/">ローディング...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2024-03-13 00:01:09" itemprop="dateModified" datetime="2024-03-13T00:01:09+08:00">2024-03-13</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" src="/assets/bitcoin.avif" alt="Sakura 比特币"><p>比特币</p></div><div><img loading="lazy" src="/assets/monero.avif" alt="Sakura monero"><p>monero</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>Sakura<i class="ic i-at"><em>@</em></i>Sakura</li><li class="link"><strong>本文链接：</strong><a href="https://sakurame.eu.org/2023/04/30/basic-theory/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89/" title="算法导论第四版（持续）">https://sakurame.eu.org/2023/04/30/basic-theory/算法导论第四版（持续）/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/04/28/basic-theory/UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="prev" itemprop="url" data-background-image="https://ptpimg.me/gzt9vt.jpg" title="UNIX系统编程：通信，并发和线程"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>计算机基础理论</span><h3>UNIX系统编程：通信，并发和线程</h3></a></div><div class="item right"><a href="/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/" rel="next" itemprop="url" data-background-image="https://ptpimg.me/1rb722.jpg" title="游戏引擎架构（开坑）"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>游戏引擎实践</span><h3>游戏引擎架构（开坑）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/28/basic-theory/UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="UNIX系统编程：通信，并发和线程">UNIX系统编程：通信，并发和线程</a></li><li class="active"><a href="/2023/04/30/basic-theory/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89/" rel="bookmark" title="算法导论第四版（持续）">算法导论第四版（持续）</a></li><li><a href="/2023/05/16/basic-theory/%E9%9D%A2%E5%90%91cloudflare%E7%9A%84%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA-1%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%9C%89ssl%E8%AF%81%E4%B9%A6%E7%9A%84wordpress%E5%8D%9A%E5%AE%A2/" rel="bookmark" title="面向cloudflare的网站搭建,1分钟快速启动一个有ssl证书的wordpress博客">面向cloudflare的网站搭建,1分钟快速启动一个有ssl证书的wordpress博客</a></li><li><a href="/2023/05/22/basic-theory/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/" rel="bookmark" title="动手学深度学习第二版笔记">动手学深度学习第二版笔记</a></li><li><a href="/2023/05/26/basic-theory/Glyphs-for-General-Second-Order-2D-and-3D-Tensors/" rel="bookmark" title="Glyphs_for_General_Second-Order_2D_and_3D_Tensors">Glyphs_for_General_Second-Order_2D_and_3D_Tensors</a></li><li><a href="/2023/05/29/basic-theory/fundamentals-of-reservoir-engineering/" rel="bookmark" title="fundamentals_of_reservoir_engineering">fundamentals_of_reservoir_engineering</a></li><li><a href="/2023/05/31/basic-theory/3D-TSV-The-3D-Trajectory-based-Stress-Visualizer/" rel="bookmark" title="3D-TSV_The_3D_Trajectory-based_Stress_Visualizer">3D-TSV_The_3D_Trajectory-based_Stress_Visualizer</a></li><li><a href="/2023/07/09/basic-theory/%E9%9B%85%E6%80%9D%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%89%88/" rel="bookmark" title="雅思备考笔记整理归纳长期更新版">雅思备考笔记整理归纳长期更新版</a></li><li><a href="/2023/07/11/basic-theory/A-Topologically-Informed-Hyperstreamline/" rel="bookmark" title="A_Topologically-Informed_Hyperstreamline">A_Topologically-Informed_Hyperstreamline</a></li><li><a href="/2023/07/11/basic-theory/Over-Two-Decades-of-Integration-Based-Geometric-Flow-Visualization/" rel="bookmark" title="Over_Two_Decades_of_Integration-Based_Geometric_Flow_Visualization">Over_Two_Decades_of_Integration-Based_Geometric_Flow_Visualization</a></li><li><a href="/2023/08/09/basic-theory/Creating-Evenly-Spaced-Streamlines-of-Arbitrary-Density/" rel="bookmark" title="Creating_Evenly-Spaced_Streamlines_of_Arbitrary_Density">Creating_Evenly-Spaced_Streamlines_of_Arbitrary_Density</a></li><li><a href="/2023/08/10/basic-theory/A-Flow-guided-Streamline-Seeding-Strategy/" rel="bookmark" title="A_Flow-guided_Streamline_Seeding_Strategy">A_Flow-guided_Streamline_Seeding_Strategy</a></li><li><a href="/2023/08/16/basic-theory/Detecting-faults-and-channels-while-enhancing-seismic-structural-and-stratigraphic-features/" rel="bookmark" title="Detecting_faults_and_channels_while_enhancing_seismic_structural_and_stratigraphic_features">Detecting_faults_and_channels_while_enhancing_seismic_structural_and_stratigraphic_features</a></li><li><a href="/2023/08/17/basic-theory/Methods-to-compute-fault-images-extract-fault-surfaces-and-estimate-fault-throws-from-3D-seismic-images/" rel="bookmark" title="Methods_to_compute_fault_images_extract_fault_surfaces_and_estimate_fault_throws_from_3D_seismic_images">Methods_to_compute_fault_images_extract_fault_surfaces_and_estimate_fault_throws_from_3D_seismic_images</a></li><li><a href="/2023/09/08/basic-theory/Water-Injection-Optimization-Using-Historical-Production-and-Seismic-Data/" rel="bookmark" title="Water_Injection_Optimization_Using_Historical_Production_and_Seismic_Data">Water_Injection_Optimization_Using_Historical_Production_and_Seismic_Data</a></li><li><a href="/2024/03/19/basic-theory/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%8C%87%E5%8D%97PMBOK%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%83%E7%89%88%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A0%87%E5%87%86/" rel="bookmark" title="项目管理知识体系指南PMBOK指南第七版项目管理标准(长期持续更新中)">项目管理知识体系指南PMBOK指南第七版项目管理标准(长期持续更新中)</a></li><li><a href="/2024/03/29/computer-graphic/PBRT%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%AA%E4%BA%BA%E7%B2%BE%E6%A0%A1%E7%89%88%E7%BF%BB%E8%AF%91%EF%BC%88%E9%95%BF%E6%9C%9F%E8%AE%A1%E5%88%92%E9%A1%B9%E7%9B%AE%EF%BC%89/" rel="bookmark" title="PBRT第四版个人精校版翻译（长期计划项目）">PBRT第四版个人精校版翻译（长期计划项目）</a></li><li><a href="/2024/05/12/basic-theory/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="bookmark" title="人工智能现代方法（第四版）读书笔记">人工智能现代方法（第四版）读书笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="Sakura" src="/assets/avatar.avif"><p class="name" itemprop="name">Sakura</p><div class="description" itemprop="description">一个专注于技术和思考分享的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">77</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/auveggry" class="item github" title="https://github.com/auveggry"><i class="ic i-github"></i></a><a href="mailto:mail@sakurame.eu.org" class="item email" title="mailto:mail@sakurame.eu.org"><i class="ic i-envelope"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li><li class="item"><a href="/privacy/" rel="section"><i class="ic i-user"></i>隐私政策</a></li></ul></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-sakura"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/04/28/basic-theory/UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%B9%B6%E5%8F%91%E5%92%8C%E7%BA%BF%E7%A8%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div><div id="player"></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/05/01/game-engine/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%EF%BC%88%E5%BC%80%E5%9D%91%EF%BC%89/">游戏引擎架构（开坑）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-graphic/" title="分类于计算机图形学">计算机图形学</a></div><span><a href="/2023/05/13/computer-graphic/3D-Graphics-Rendering-Cookbook/">3D-Graphics-Rendering-Cookbook</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2023/05/18/vcbstudio/%E5%BC%80%E6%BA%90%E4%B8%80%E4%B8%8B%E5%8E%8B%E5%88%B6%E7%BB%84%E8%80%83%E8%AF%95%E7%9A%84%E8%AF%95%E9%A2%98/">开源一下压制组考试的试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/thinking/" title="分类于思考随笔记录">思考随笔记录</a></div><span><a href="/2023/06/06/thinking/%E5%AF%BC%E5%B8%88%E4%B8%8E%E5%AD%A6%E7%94%9F%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%88%E6%95%B4%E7%90%86%E8%87%AA%E9%80%BC%E4%B9%8E%EF%BC%89/">导师与学生的关系（整理自逼乎）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/basic-theory/" title="分类于计算机基础理论">计算机基础理论</a></div><span><a href="/2024/03/19/basic-theory/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%8C%87%E5%8D%97PMBOK%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%83%E7%89%88%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A0%87%E5%87%86/">项目管理知识体系指南PMBOK指南第七版项目管理标准(长期持续更新中)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/game-engine/" title="分类于游戏引擎实践">游戏引擎实践</a></div><span><a href="/2023/06/25/game-engine/games104%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">games104系列笔记（三）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/privacy/" title="分类于隐私保护指北">隐私保护指北</a></div><span><a href="/2023/06/09/privacy/the-pgp-problem/">the-pgp-problem</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/privacy/" title="分类于隐私保护指北">隐私保护指北</a></div><span><a href="/2024/03/14/privacy/Canokey%E4%B8%8D%E5%AE%8C%E5%85%A8%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97-%E6%8C%81%E7%BB%AD%E8%B8%A9%E5%9D%91%E4%B8%AD/">Canokey不完全食用指南--持续踩坑中</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2023/06/11/vcbstudio/VapourSynth%E5%9F%BA%E7%A1%80/">VapourSynth基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vcbstudio/" title="分类于视频压制技术">视频压制技术</a></div><span><a href="/2024/03/16/vcbstudio/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A08-bit%E4%BD%8E%E7%A0%81%E7%8E%87%E5%8E%8B%E5%88%B6/">第十二章8-bit低码率压制</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><!--!= partial('_partials/header.pug', {}, {cache: true})--></div></footer></div><script data-config="" type="text/javascript">var LOCAL = {
    ispost: true,
    path: `2023/04/30/basic-theory/算法导论第四版（持续）/`,
    favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    nocopy: "false",
    copyright: `复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。`,
    copy_tex: true,
    katex: true,
    mermaid: false,
    audio: undefined,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    }
};
</script><script src="/js/siteInit.js?v=0.5.0" type="module" fetchpriority="high" defer=""></script></body></html>